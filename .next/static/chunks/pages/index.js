/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/Hero.module.scss":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/Hero.module.scss ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".Hero_hero__9dTGe {\\n  background: #0a001c;\\n  display: flex;\\n  flex-direction: column;\\n}\\n\\n.Hero_heroContainer__oc1ou {\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  color: white;\\n  background: radial-gradient(circle at 50% 30%, #3a006f 0%, transparent 50%);\\n  padding: 20px;\\n  padding-bottom: 60px;\\n}\\n\\n.Hero_headerContainer__lUWhX {\\n  width: 100%;\\n  align-items: center;\\n  display: flex;\\n  justify-content: center;\\n}\\n\\n.Hero_nameContainer__aIBzz {\\n  width: 1200px;\\n  align-items: center;\\n  display: flex;\\n  justify-content: center;\\n  margin: 1em 0em 2em 0em;\\n}\\n\\n.Hero_nameTextContainer__91Cu2 {\\n  display: flex;\\n  flex-direction: column;\\n  flex: 1 1;\\n}\\n\\n.Hero_profileImage__pXdtR {\\n  width: 6em;\\n  height: 6em;\\n  border-radius: 50%;\\n  object-fit: cover;\\n  margin-right: 20px;\\n}\\n\\n.Hero_title__EyJZO {\\n  color: white;\\n  font-size: 2em;\\n  font-weight: bold;\\n}\\n\\n.Hero_subtitle__Q4zVY {\\n  font-size: 1.8em;\\n  font-weight: bold;\\n  color: var(--color-primary);\\n  margin-bottom: 6px;\\n}\\n\\n.Hero_contactContainer__fIqjJ {\\n  display: flex;\\n  align-items: flex-end;\\n  flex-direction: column;\\n  gap: 6px;\\n  color: white;\\n}\\n\\n.Hero_contactField__OU82P {\\n  display: flex;\\n  align-items: center;\\n  gap: 6px;\\n  font-size: 14px;\\n  color: var(--color-primary);\\n  opacity: 0.8;\\n}\\n\\n.Hero_contactField__OU82P:hover {\\n  opacity: 1;\\n  cursor: pointer;\\n}\\n\\n.Hero_contactIcon__kkUHS {\\n  height: 20px;\\n  width: 20px;\\n  opacity: 0.7;\\n}\\n\\n.Hero_portfolioSection__gdwK_,\\n.Hero_portfolioSectionDark__zy2Fe {\\n  display: flex;\\n  align-items: center;\\n  color: white;\\n  flex-direction: column;\\n  padding: 20px;\\n  padding-top: 40px;\\n  padding-bottom: 60px;\\n  background-color: var(--color-bg-primary);\\n}\\n\\n.Hero_portfolioSectionDark__zy2Fe {\\n  background-color: var(--color-bg-secondary);\\n}\\n\\n.Hero_documentEditorContainer__muWIQ {\\n  display: flex;\\n  min-height: 1060px;\\n  border-radius: 20px;\\n  box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.4);\\n  margin-bottom: 40px;\\n  background-color: rgba(0, 0, 0, 0.3490196078);\\n  height: -moz-fit-content;\\n  height: fit-content;\\n  transition: all 0.7s ease-out;\\n  transform: translateY(50px);\\n}\\n\\n.Hero_documentEditor__JYyBu {\\n  display: flex;\\n  min-height: 600px;\\n  background-color: var(--color-box-primary);\\n  border: 1px solid var(--color-box-border);\\n  border-radius: 20px;\\n  flex-direction: column;\\n  flex: 3 1;\\n}\\n\\n.Hero_slideInHidden__4gxwz {\\n  opacity: 0;\\n  transform: translateY(10px);\\n}\\n\\n.Hero_slideInVisible__Y5kQC {\\n  opacity: 1;\\n  transform: translateY(0);\\n}\\n\\n.Hero_documentToolbar__j2WDx {\\n  display: flex;\\n  align-items: center;\\n  padding-left: 12px;\\n  background-color: #381179;\\n  height: 40px;\\n  border-radius: 20px 20px 0px 0px;\\n}\\n\\n.Hero_treeViewContainer__FT74a {\\n  border-radius: 20px;\\n  text-align: left;\\n  padding: 10px;\\n  padding-right: 20px;\\n  height: 100%;\\n  overflow: hidden;\\n  flex: 1 1;\\n}\\n\\n.Hero_toolbarButton__Ez2nP {\\n  cursor: pointer;\\n  color: white;\\n  opacity: 0.6;\\n  width: 20px;\\n  height: 20px;\\n  padding: 6px;\\n}\\n\\n.Hero_toolbarButton__Ez2nP:hover {\\n  color: var(--color-primary);\\n  opacity: 1;\\n}\\n\\n.Hero_translationEditorContainer__bk0Mn {\\n  display: flex;\\n  border-radius: 20px;\\n  transition: all 0.6s ease-out;\\n}\\n\\n.Hero_translationSection__ZcnMT {\\n  width: 100%;\\n  display: flex;\\n  align-items: center;\\n  color: white;\\n  flex-direction: column;\\n  padding-top: 60px;\\n  padding-bottom: 60px;\\n}\\n\\n.Hero_jobTitle__zqwyN {\\n  margin-bottom: 12px;\\n  background-color: inherit;\\n}\\n\\n.Hero_jobDuration__qmxFH {\\n  color: var(--color-primary);\\n}\\n\\n.Hero_jobDescription__WheHc {\\n  color: var(--color-text-subtle);\\n}\\n\\n.Hero_jobDescription__WheHc:last-child {\\n  margin-bottom: 35px;\\n}\\n\\n.Hero_techCategory__oczYT,\\n.Hero_techCategorySecondary__AugRh {\\n  flex: 1 1;\\n  background-color: var(--color-box-primary);\\n  padding: 25px;\\n  border-radius: 20px;\\n  border: 1px solid var(--color-box-border);\\n}\\n\\n.Hero_techCategory__oczYT {\\n  background: linear-gradient(135deg, #320b73 0%, #120729 100%);\\n}\\n\\n.Hero_techCategorySecondary__AugRh {\\n  background-color: var(--color-box-secondary);\\n  border: none;\\n}\\n\\n.Hero_personalProjectContainer__EKoBa {\\n  margin-bottom: 40px;\\n}\\n\\n.Hero_projectHeader__Z15FM {\\n  display: flex;\\n  align-items: center;\\n}\\n\\n.Hero_projectStatusOnline__dacKG,\\n.Hero_projectStatusDiscontinued__CUEM7 {\\n  border-radius: 1em;\\n  padding: 4px 8px;\\n  border: 2px solid black;\\n  margin-left: 12px;\\n  font-weight: bold;\\n  font-size: smaller;\\n  display: flex;\\n  align-items: center;\\n  gap: 6px;\\n}\\n\\n.Hero_projectStatusOnline__dacKG {\\n  color: var(--color-success);\\n  border-color: var(--color-success);\\n  background-color: var(--color-success-bg);\\n}\\n\\n.Hero_projectStatusOnline__dacKG::before {\\n  content: \\\"\\\";\\n  width: 8px;\\n  height: 8px;\\n  border-radius: 50%;\\n  background-color: var(--color-success);\\n}\\n\\n.Hero_projectStatusDiscontinued__CUEM7 {\\n  color: var(--color-disabled);\\n  border-color: var(--color-disabled);\\n  background-color: var(--color-disabled-bg);\\n}\\n\\n.Hero_projectStatusDiscontinued__CUEM7::before {\\n  content: \\\"\\\";\\n  width: 8px;\\n  height: 8px;\\n  border-radius: 50%;\\n  background-color: grey;\\n}\\n\\n.Hero_projectLinks__XA37c {\\n  color: var(--color-primary);\\n  margin-top: 12px;\\n}\\n\\n.Hero_projectImage__oC2Wx {\\n  width: 100%;\\n  height: auto;\\n  border-radius: 10px;\\n  margin-top: 16px;\\n}\\n\\n.Hero_gameVideo__xYeS_ {\\n  width: 100%;\\n  height: auto;\\n  border-radius: 20px;\\n}\\n\\n.Hero_gameProjectContainer__LEmcc {\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  gap: 16px;\\n  color: var(--color-text-subtle);\\n}\\n\\n.Hero_columnContainer__cfFnz {\\n  display: flex;\\n  flex-direction: column;\\n  width: 100%;\\n  max-width: 1200px;\\n  transition: all 0.6s ease-out;\\n}\\n\\n.Hero_sectionHeader__ZtnGf {\\n  margin-bottom: 20px;\\n  color: #c686ff;\\n  font-weight: bold;\\n}\\n\\n.Hero_sectionHeaderText__VbEOn {\\n  padding-bottom: 6px;\\n}\\n\\n.Hero_contentEditable__oDokZ {\\n  outline: none;\\n  color: white;\\n  height: 100%;\\n  text-align: left;\\n  flex: 1 1;\\n}\\n\\n.Hero_divider__BUsWO {\\n  border-left: 1px solid white;\\n  opacity: 0.1;\\n  margin: 12px;\\n  height: 60%;\\n}\\n\\n.Hero_subtleText__eE6hs {\\n  color: var(--color-text-subtle);\\n}\\n\\n.Hero_signOffContainer__C22yQ {\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n}\\n\\n.Hero_signOffContact__4hdL9 {\\n  display: flex;\\n  align-items: center;\\n  gap: 6px;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://src/styles/Hero.module.scss\"],\"names\":[],\"mappings\":\"AAAA;EACE,mBAAA;EACA,aAAA;EACA,sBAAA;AACF;;AAGA;EACE,aAAA;EACA,sBAAA;EACA,mBAAA;EACA,YAAA;EACA,2EAAA;EACA,aAAA;EACA,oBAAA;AAAF;;AAGA;EACE,WAAA;EACA,mBAAA;EACA,aAAA;EACA,uBAAA;AAAF;;AAGA;EACE,aAAA;EACA,mBAAA;EACA,aAAA;EACA,uBAAA;EACA,uBAAA;AAAF;;AAGA;EACE,aAAA;EACA,sBAAA;EACA,SAAA;AAAF;;AAGA;EACE,UAAA;EACA,WAAA;EACA,kBAAA;EACA,iBAAA;EACA,kBAAA;AAAF;;AAGA;EACE,YAAA;EACA,cAAA;EACA,iBAAA;AAAF;;AAEA;EACE,gBAAA;EACA,iBAAA;EACA,2BAAA;EACA,kBAAA;AACF;;AAEA;EACE,aAAA;EACA,qBAAA;EACA,sBAAA;EACA,QAAA;EACA,YAAA;AACF;;AAEA;EACE,aAAA;EACA,mBAAA;EACA,QAAA;EACA,eAAA;EACA,2BAAA;EACA,YAAA;AACF;;AACA;EACE,UAAA;EACA,eAAA;AAEF;;AACA;EACE,YAAA;EACA,WAAA;EACA,YAAA;AAEF;;AACA;;EAEE,aAAA;EACA,mBAAA;EACA,YAAA;EACA,sBAAA;EACA,aAAA;EACA,iBAAA;EACA,oBAAA;EACA,yCAAA;AAEF;;AACA;EACE,2CAAA;AAEF;;AAGA;EACE,aAAA;EACA,kBAAA;EACA,mBAAA;EACA,2CAAA;EACA,mBAAA;EACA,6CAAA;EACA,wBAAA;EAAA,mBAAA;EACA,6BAAA;EACA,2BAAA;AAAF;;AAGA;EACE,aAAA;EACA,iBAAA;EACA,0CAAA;EACA,yCAAA;EACA,mBAAA;EACA,sBAAA;EACA,SAAA;AAAF;;AAGA;EACE,UAAA;EACA,2BAAA;AAAF;;AAGA;EACE,UAAA;EACA,wBAAA;AAAF;;AAGA;EACE,aAAA;EACA,mBAAA;EACA,kBAAA;EACA,yBAAA;EACA,YAAA;EACA,gCAAA;AAAF;;AAGA;EACE,mBAAA;EACA,gBAAA;EACA,aAAA;EACA,mBAAA;EACA,YAAA;EACA,gBAAA;EACA,SAAA;AAAF;;AAEA;EACE,eAAA;EACA,YAAA;EACA,YAAA;EACA,WAAA;EACA,YAAA;EACA,YAAA;AACF;;AACA;EACE,2BAAA;EACA,UAAA;AAEF;;AACA;EACE,aAAA;EACA,mBAAA;EACA,6BAAA;AAEF;;AACA;EACE,WAAA;EACA,aAAA;EACA,mBAAA;EACA,YAAA;EACA,sBAAA;EACA,iBAAA;EACA,oBAAA;AAEF;;AAGA;EACE,mBAAA;EACA,yBAAA;AAAF;;AAGA;EACE,2BAAA;AAAF;;AAGA;EACE,+BAAA;AAAF;;AAGA;EACE,mBAAA;AAAF;;AAKA;;EAEE,SAAA;EACA,0CAAA;EACA,aAAA;EACA,mBAAA;EACA,yCAAA;AAFF;;AAIA;EACE,6DAAA;AADF;;AAIA;EACE,4CAAA;EACA,YAAA;AADF;;AAMA;EACE,mBAAA;AAHF;;AAKA;EACE,aAAA;EACA,mBAAA;AAFF;;AAKA;;EAEE,kBAAA;EACA,gBAAA;EACA,uBAAA;EACA,iBAAA;EACA,iBAAA;EACA,kBAAA;EACA,aAAA;EACA,mBAAA;EACA,QAAA;AAFF;;AAKA;EACE,2BAAA;EACA,kCAAA;EACA,yCAAA;AAFF;;AAKA;EACE,WAAA;EACA,UAAA;EACA,WAAA;EACA,kBAAA;EACA,sCAAA;AAFF;;AAKA;EACE,4BAAA;EACA,mCAAA;EACA,0CAAA;AAFF;;AAKA;EACE,WAAA;EACA,UAAA;EACA,WAAA;EACA,kBAAA;EACA,sBAAA;AAFF;;AAKA;EACE,2BAAA;EACA,gBAAA;AAFF;;AAKA;EACE,WAAA;EACA,YAAA;EACA,mBAAA;EACA,gBAAA;AAFF;;AAQA;EACE,WAAA;EACA,YAAA;EACA,mBAAA;AALF;;AAQA;EACE,aAAA;EACA,sBAAA;EACA,mBAAA;EACA,SAAA;EACA,+BAAA;AALF;;AAUA;EACE,aAAA;EACA,sBAAA;EACA,WAAA;EACA,iBAAA;EACA,6BAAA;AAPF;;AAUA;EACE,mBAAA;EACA,cAAA;EACA,iBAAA;AAPF;;AAUA;EACE,mBAAA;AAPF;;AAUA;EACE,aAAA;EACA,YAAA;EACA,YAAA;EACA,gBAAA;EACA,SAAA;AAPF;;AAUA;EACE,4BAAA;EACA,YAAA;EACA,YAAA;EACA,WAAA;AAPF;;AAUA;EACE,+BAAA;AAPF;;AAUA;EACE,aAAA;EACA,sBAAA;EACA,mBAAA;AAPF;;AAUA;EACE,aAAA;EACA,mBAAA;EACA,QAAA;AAPF\",\"sourcesContent\":[\".hero {\\n  background: #0a001c;\\n  display: flex;\\n  flex-direction: column;\\n  // background: radial-gradient(circle, var(--color-primary) 0%, transparent 70%);\\n}\\n\\n.heroContainer {\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  color: white;\\n  background: radial-gradient(circle at 50% 30%, #3a006f 0%, transparent 50%);\\n  padding: 20px;\\n  padding-bottom: 60px;\\n}\\n\\n.headerContainer {\\n  width: 100%;\\n  align-items: center;\\n  display: flex;\\n  justify-content: center;\\n}\\n\\n.nameContainer {\\n  width: 1200px;\\n  align-items: center;\\n  display: flex;\\n  justify-content: center;\\n  margin: 1em 0em 2em 0em;\\n}\\n\\n.nameTextContainer {\\n  display: flex;\\n  flex-direction: column;\\n  flex: 1;\\n}\\n\\n.profileImage {\\n  width: 6em;\\n  height: 6em;\\n  border-radius: 50%;\\n  object-fit: cover;\\n  margin-right: 20px;\\n}\\n\\n.title {\\n  color: white;\\n  font-size: 2em;\\n  font-weight: bold;\\n}\\n.subtitle {\\n  font-size: 1.8em;\\n  font-weight: bold;\\n  color: var(--color-primary);\\n  margin-bottom: 6px;\\n}\\n\\n.contactContainer {\\n  display: flex;\\n  align-items: flex-end;\\n  flex-direction: column;\\n  gap: 6px;\\n  color: white;\\n}\\n\\n.contactField {\\n  display: flex;\\n  align-items: center;\\n  gap: 6px;\\n  font-size: 14px;\\n  color: var(--color-primary);\\n  opacity: 0.8;\\n}\\n.contactField:hover {\\n  opacity: 1;\\n  cursor: pointer;\\n}\\n\\n.contactIcon {\\n  height: 20px;\\n  width: 20px;\\n  opacity: 0.7;\\n}\\n\\n.portfolioSection,\\n.portfolioSectionDark {\\n  display: flex;\\n  align-items: center;\\n  color: white;\\n  flex-direction: column;\\n  padding: 20px;\\n  padding-top: 40px;\\n  padding-bottom: 60px;\\n  background-color: var(--color-bg-primary);\\n}\\n\\n.portfolioSectionDark {\\n  background-color: var(--color-bg-secondary);\\n}\\n\\n// Documents\\n\\n.documentEditorContainer {\\n  display: flex;\\n  min-height: 1060px;\\n  border-radius: 20px;\\n  box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.4);\\n  margin-bottom: 40px;\\n  background-color: #00000059;\\n  height: fit-content;\\n  transition: all 0.7s ease-out;\\n  transform: translateY(50px);\\n}\\n\\n.documentEditor {\\n  display: flex;\\n  min-height: 600px;\\n  background-color: var(--color-box-primary);\\n  border: 1px solid var(--color-box-border);\\n  border-radius: 20px;\\n  flex-direction: column;\\n  flex: 3;\\n}\\n\\n.slideInHidden {\\n  opacity: 0;\\n  transform: translateY(10px);\\n}\\n\\n.slideInVisible {\\n  opacity: 1;\\n  transform: translateY(0);\\n}\\n\\n.documentToolbar {\\n  display: flex;\\n  align-items: center;\\n  padding-left: 12px;\\n  background-color: #381179;\\n  height: 40px;\\n  border-radius: 20px 20px 0px 0px;\\n}\\n\\n.treeViewContainer {\\n  border-radius: 20px;\\n  text-align: left;\\n  padding: 10px;\\n  padding-right: 20px;\\n  height: 100%;\\n  overflow: hidden;\\n  flex: 1;\\n}\\n.toolbarButton {\\n  cursor: pointer;\\n  color: white;\\n  opacity: 0.6;\\n  width: 20px;\\n  height: 20px;\\n  padding: 6px;\\n}\\n.toolbarButton:hover {\\n  color: var(--color-primary);\\n  opacity: 1;\\n}\\n\\n.translationEditorContainer {\\n  display: flex;\\n  border-radius: 20px;\\n  transition: all 0.6s ease-out;\\n}\\n\\n.translationSection {\\n  width: 100%;\\n  display: flex;\\n  align-items: center;\\n  color: white;\\n  flex-direction: column;\\n  padding-top: 60px;\\n  padding-bottom: 60px;\\n}\\n\\n// Previous Exp\\n\\n.jobTitle {\\n  margin-bottom: 12px;\\n  background-color: inherit;\\n}\\n\\n.jobDuration {\\n  color: var(--color-primary);\\n}\\n\\n.jobDescription {\\n  color: var(--color-text-subtle);\\n}\\n\\n.jobDescription:last-child {\\n  margin-bottom: 35px;\\n}\\n\\n// Tech\\n\\n.techCategory,\\n.techCategorySecondary {\\n  flex: 1 1 0%;\\n  background-color: var(--color-box-primary);\\n  padding: 25px;\\n  border-radius: 20px;\\n  border: 1px solid var(--color-box-border);\\n}\\n.techCategory {\\n  background: linear-gradient(135deg, #320b73 0%, #120729 100%);\\n}\\n\\n.techCategorySecondary {\\n  background-color: var(--color-box-secondary);\\n  border: none;\\n}\\n\\n// Projects\\n\\n.personalProjectContainer {\\n  margin-bottom: 40px;\\n}\\n.projectHeader {\\n  display: flex;\\n  align-items: center;\\n}\\n\\n.projectStatusOnline,\\n.projectStatusDiscontinued {\\n  border-radius: 1em;\\n  padding: 4px 8px;\\n  border: 2px solid black;\\n  margin-left: 12px;\\n  font-weight: bold;\\n  font-size: smaller;\\n  display: flex;\\n  align-items: center;\\n  gap: 6px;\\n}\\n\\n.projectStatusOnline {\\n  color: var(--color-success);\\n  border-color: var(--color-success);\\n  background-color: var(--color-success-bg);\\n}\\n\\n.projectStatusOnline::before {\\n  content: \\\"\\\";\\n  width: 8px;\\n  height: 8px;\\n  border-radius: 50%;\\n  background-color: var(--color-success);\\n}\\n\\n.projectStatusDiscontinued {\\n  color: var(--color-disabled);\\n  border-color: var(--color-disabled);\\n  background-color: var(--color-disabled-bg);\\n}\\n\\n.projectStatusDiscontinued::before {\\n  content: \\\"\\\";\\n  width: 8px;\\n  height: 8px;\\n  border-radius: 50%;\\n  background-color: grey;\\n}\\n\\n.projectLinks {\\n  color: var(--color-primary);\\n  margin-top: 12px;\\n}\\n\\n.projectImage {\\n  width: 100%;\\n  height: auto;\\n  border-radius: 10px;\\n  margin-top: 16px;\\n  // box-shadow: 0px 4px 80px rgb(38 6 61);\\n}\\n\\n// Game Dev\\n\\n.gameVideo {\\n  width: 100%;\\n  height: auto;\\n  border-radius: 20px;\\n}\\n\\n.gameProjectContainer {\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  gap: 16px;\\n  color: var(--color-text-subtle);\\n}\\n\\n// Common\\n\\n.columnContainer {\\n  display: flex;\\n  flex-direction: column;\\n  width: 100%;\\n  max-width: 1200px;\\n  transition: all 0.6s ease-out;\\n}\\n\\n.sectionHeader {\\n  margin-bottom: 20px;\\n  color: #c686ff;\\n  font-weight: bold;\\n}\\n\\n.sectionHeaderText {\\n  padding-bottom: 6px;\\n}\\n\\n.contentEditable {\\n  outline: none;\\n  color: white;\\n  height: 100%;\\n  text-align: left;\\n  flex: 1;\\n}\\n\\n.divider {\\n  border-left: 1px solid #ffffffff;\\n  opacity: 0.1;\\n  margin: 12px;\\n  height: 60%;\\n}\\n\\n.subtleText {\\n  color: var(--color-text-subtle);\\n}\\n\\n.signOffContainer {\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n}\\n\\n.signOffContact {\\n  display: flex;\\n  align-items: center;\\n  gap: 6px;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"hero\": \"Hero_hero__9dTGe\",\n\t\"heroContainer\": \"Hero_heroContainer__oc1ou\",\n\t\"headerContainer\": \"Hero_headerContainer__lUWhX\",\n\t\"nameContainer\": \"Hero_nameContainer__aIBzz\",\n\t\"nameTextContainer\": \"Hero_nameTextContainer__91Cu2\",\n\t\"profileImage\": \"Hero_profileImage__pXdtR\",\n\t\"title\": \"Hero_title__EyJZO\",\n\t\"subtitle\": \"Hero_subtitle__Q4zVY\",\n\t\"contactContainer\": \"Hero_contactContainer__fIqjJ\",\n\t\"contactField\": \"Hero_contactField__OU82P\",\n\t\"contactIcon\": \"Hero_contactIcon__kkUHS\",\n\t\"portfolioSection\": \"Hero_portfolioSection__gdwK_\",\n\t\"portfolioSectionDark\": \"Hero_portfolioSectionDark__zy2Fe\",\n\t\"documentEditorContainer\": \"Hero_documentEditorContainer__muWIQ\",\n\t\"documentEditor\": \"Hero_documentEditor__JYyBu\",\n\t\"slideInHidden\": \"Hero_slideInHidden__4gxwz\",\n\t\"slideInVisible\": \"Hero_slideInVisible__Y5kQC\",\n\t\"documentToolbar\": \"Hero_documentToolbar__j2WDx\",\n\t\"treeViewContainer\": \"Hero_treeViewContainer__FT74a\",\n\t\"toolbarButton\": \"Hero_toolbarButton__Ez2nP\",\n\t\"translationEditorContainer\": \"Hero_translationEditorContainer__bk0Mn\",\n\t\"translationSection\": \"Hero_translationSection__ZcnMT\",\n\t\"jobTitle\": \"Hero_jobTitle__zqwyN\",\n\t\"jobDuration\": \"Hero_jobDuration__qmxFH\",\n\t\"jobDescription\": \"Hero_jobDescription__WheHc\",\n\t\"techCategory\": \"Hero_techCategory__oczYT\",\n\t\"techCategorySecondary\": \"Hero_techCategorySecondary__AugRh\",\n\t\"personalProjectContainer\": \"Hero_personalProjectContainer__EKoBa\",\n\t\"projectHeader\": \"Hero_projectHeader__Z15FM\",\n\t\"projectStatusOnline\": \"Hero_projectStatusOnline__dacKG\",\n\t\"projectStatusDiscontinued\": \"Hero_projectStatusDiscontinued__CUEM7\",\n\t\"projectLinks\": \"Hero_projectLinks__XA37c\",\n\t\"projectImage\": \"Hero_projectImage__oC2Wx\",\n\t\"gameVideo\": \"Hero_gameVideo__xYeS_\",\n\t\"gameProjectContainer\": \"Hero_gameProjectContainer__LEmcc\",\n\t\"columnContainer\": \"Hero_columnContainer__cfFnz\",\n\t\"sectionHeader\": \"Hero_sectionHeader__ZtnGf\",\n\t\"sectionHeaderText\": \"Hero_sectionHeaderText__VbEOn\",\n\t\"contentEditable\": \"Hero_contentEditable__oDokZ\",\n\t\"divider\": \"Hero_divider__BUsWO\",\n\t\"subtleText\": \"Hero_subtleText__eE6hs\",\n\t\"signOffContainer\": \"Hero_signOffContainer__C22yQ\",\n\t\"signOffContact\": \"Hero_signOffContact__4hdL9\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzFdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbMl0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbMTBdLnVzZVszXSEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbNF0hLi9zcmMvc3R5bGVzL0hlcm8ubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxrQ0FBa0MsbUJBQU8sQ0FBQyxzS0FBa0Y7QUFDNUg7QUFDQTtBQUNBLDZEQUE2RCx3QkFBd0Isa0JBQWtCLDJCQUEyQixHQUFHLGdDQUFnQyxrQkFBa0IsMkJBQTJCLHdCQUF3QixpQkFBaUIsZ0ZBQWdGLGtCQUFrQix5QkFBeUIsR0FBRyxrQ0FBa0MsZ0JBQWdCLHdCQUF3QixrQkFBa0IsNEJBQTRCLEdBQUcsZ0NBQWdDLGtCQUFrQix3QkFBd0Isa0JBQWtCLDRCQUE0Qiw0QkFBNEIsR0FBRyxvQ0FBb0Msa0JBQWtCLDJCQUEyQixjQUFjLEdBQUcsK0JBQStCLGVBQWUsZ0JBQWdCLHVCQUF1QixzQkFBc0IsdUJBQXVCLEdBQUcsd0JBQXdCLGlCQUFpQixtQkFBbUIsc0JBQXNCLEdBQUcsMkJBQTJCLHFCQUFxQixzQkFBc0IsZ0NBQWdDLHVCQUF1QixHQUFHLG1DQUFtQyxrQkFBa0IsMEJBQTBCLDJCQUEyQixhQUFhLGlCQUFpQixHQUFHLCtCQUErQixrQkFBa0Isd0JBQXdCLGFBQWEsb0JBQW9CLGdDQUFnQyxpQkFBaUIsR0FBRyxxQ0FBcUMsZUFBZSxvQkFBb0IsR0FBRyw4QkFBOEIsaUJBQWlCLGdCQUFnQixpQkFBaUIsR0FBRyx1RUFBdUUsa0JBQWtCLHdCQUF3QixpQkFBaUIsMkJBQTJCLGtCQUFrQixzQkFBc0IseUJBQXlCLDhDQUE4QyxHQUFHLHVDQUF1QyxnREFBZ0QsR0FBRywwQ0FBMEMsa0JBQWtCLHVCQUF1Qix3QkFBd0IsZ0RBQWdELHdCQUF3QixrREFBa0QsNkJBQTZCLHdCQUF3QixrQ0FBa0MsZ0NBQWdDLEdBQUcsaUNBQWlDLGtCQUFrQixzQkFBc0IsK0NBQStDLDhDQUE4Qyx3QkFBd0IsMkJBQTJCLGNBQWMsR0FBRyxnQ0FBZ0MsZUFBZSxnQ0FBZ0MsR0FBRyxpQ0FBaUMsZUFBZSw2QkFBNkIsR0FBRyxrQ0FBa0Msa0JBQWtCLHdCQUF3Qix1QkFBdUIsOEJBQThCLGlCQUFpQixxQ0FBcUMsR0FBRyxvQ0FBb0Msd0JBQXdCLHFCQUFxQixrQkFBa0Isd0JBQXdCLGlCQUFpQixxQkFBcUIsY0FBYyxHQUFHLGdDQUFnQyxvQkFBb0IsaUJBQWlCLGlCQUFpQixnQkFBZ0IsaUJBQWlCLGlCQUFpQixHQUFHLHNDQUFzQyxnQ0FBZ0MsZUFBZSxHQUFHLDZDQUE2QyxrQkFBa0Isd0JBQXdCLGtDQUFrQyxHQUFHLHFDQUFxQyxnQkFBZ0Isa0JBQWtCLHdCQUF3QixpQkFBaUIsMkJBQTJCLHNCQUFzQix5QkFBeUIsR0FBRywyQkFBMkIsd0JBQXdCLDhCQUE4QixHQUFHLDhCQUE4QixnQ0FBZ0MsR0FBRyxpQ0FBaUMsb0NBQW9DLEdBQUcsNENBQTRDLHdCQUF3QixHQUFHLG9FQUFvRSxjQUFjLCtDQUErQyxrQkFBa0Isd0JBQXdCLDhDQUE4QyxHQUFHLCtCQUErQixrRUFBa0UsR0FBRyx3Q0FBd0MsaURBQWlELGlCQUFpQixHQUFHLDJDQUEyQyx3QkFBd0IsR0FBRyxnQ0FBZ0Msa0JBQWtCLHdCQUF3QixHQUFHLCtFQUErRSx1QkFBdUIscUJBQXFCLDRCQUE0QixzQkFBc0Isc0JBQXNCLHVCQUF1QixrQkFBa0Isd0JBQXdCLGFBQWEsR0FBRyxzQ0FBc0MsZ0NBQWdDLHVDQUF1Qyw4Q0FBOEMsR0FBRyw4Q0FBOEMsa0JBQWtCLGVBQWUsZ0JBQWdCLHVCQUF1QiwyQ0FBMkMsR0FBRyw0Q0FBNEMsaUNBQWlDLHdDQUF3QywrQ0FBK0MsR0FBRyxvREFBb0Qsa0JBQWtCLGVBQWUsZ0JBQWdCLHVCQUF1QiwyQkFBMkIsR0FBRywrQkFBK0IsZ0NBQWdDLHFCQUFxQixHQUFHLCtCQUErQixnQkFBZ0IsaUJBQWlCLHdCQUF3QixxQkFBcUIsR0FBRyw0QkFBNEIsZ0JBQWdCLGlCQUFpQix3QkFBd0IsR0FBRyx1Q0FBdUMsa0JBQWtCLDJCQUEyQix3QkFBd0IsY0FBYyxvQ0FBb0MsR0FBRyxrQ0FBa0Msa0JBQWtCLDJCQUEyQixnQkFBZ0Isc0JBQXNCLGtDQUFrQyxHQUFHLGdDQUFnQyx3QkFBd0IsbUJBQW1CLHNCQUFzQixHQUFHLG9DQUFvQyx3QkFBd0IsR0FBRyxrQ0FBa0Msa0JBQWtCLGlCQUFpQixpQkFBaUIscUJBQXFCLGNBQWMsR0FBRywwQkFBMEIsaUNBQWlDLGlCQUFpQixpQkFBaUIsZ0JBQWdCLEdBQUcsNkJBQTZCLG9DQUFvQyxHQUFHLG1DQUFtQyxrQkFBa0IsMkJBQTJCLHdCQUF3QixHQUFHLGlDQUFpQyxrQkFBa0Isd0JBQXdCLGFBQWEsR0FBRyxPQUFPLDRGQUE0RixXQUFXLFVBQVUsV0FBVyxNQUFNLEtBQUssVUFBVSxXQUFXLFdBQVcsVUFBVSxXQUFXLFVBQVUsV0FBVyxNQUFNLEtBQUssVUFBVSxXQUFXLFVBQVUsV0FBVyxNQUFNLEtBQUssVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLE1BQU0sS0FBSyxVQUFVLFdBQVcsVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLFdBQVcsV0FBVyxXQUFXLE1BQU0sS0FBSyxVQUFVLFVBQVUsV0FBVyxNQUFNLEtBQUssV0FBVyxXQUFXLFdBQVcsV0FBVyxNQUFNLEtBQUssVUFBVSxXQUFXLFdBQVcsVUFBVSxVQUFVLE1BQU0sS0FBSyxVQUFVLFdBQVcsVUFBVSxVQUFVLFdBQVcsVUFBVSxNQUFNLEtBQUssVUFBVSxVQUFVLE1BQU0sS0FBSyxVQUFVLFVBQVUsVUFBVSxNQUFNLE1BQU0sVUFBVSxXQUFXLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLE1BQU0sS0FBSyxXQUFXLE1BQU0sS0FBSyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLE1BQU0sS0FBSyxVQUFVLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxVQUFVLE1BQU0sS0FBSyxVQUFVLFdBQVcsTUFBTSxLQUFLLFVBQVUsV0FBVyxNQUFNLEtBQUssVUFBVSxXQUFXLFdBQVcsV0FBVyxVQUFVLFdBQVcsTUFBTSxLQUFLLFdBQVcsV0FBVyxVQUFVLFdBQVcsVUFBVSxXQUFXLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxVQUFVLE1BQU0sS0FBSyxXQUFXLFVBQVUsTUFBTSxLQUFLLFVBQVUsV0FBVyxXQUFXLE1BQU0sS0FBSyxVQUFVLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxXQUFXLE1BQU0sS0FBSyxXQUFXLFdBQVcsTUFBTSxLQUFLLFdBQVcsTUFBTSxLQUFLLFdBQVcsTUFBTSxLQUFLLFdBQVcsTUFBTSxNQUFNLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxNQUFNLEtBQUssV0FBVyxNQUFNLEtBQUssV0FBVyxVQUFVLE1BQU0sS0FBSyxXQUFXLE1BQU0sS0FBSyxVQUFVLFdBQVcsTUFBTSxNQUFNLFdBQVcsV0FBVyxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsV0FBVyxVQUFVLE1BQU0sS0FBSyxXQUFXLFdBQVcsV0FBVyxNQUFNLEtBQUssVUFBVSxVQUFVLFVBQVUsV0FBVyxXQUFXLE1BQU0sS0FBSyxXQUFXLFdBQVcsV0FBVyxNQUFNLEtBQUssVUFBVSxVQUFVLFVBQVUsV0FBVyxXQUFXLE1BQU0sS0FBSyxXQUFXLFdBQVcsTUFBTSxLQUFLLFVBQVUsVUFBVSxXQUFXLFdBQVcsTUFBTSxLQUFLLFVBQVUsVUFBVSxXQUFXLE1BQU0sS0FBSyxVQUFVLFdBQVcsV0FBVyxVQUFVLFdBQVcsTUFBTSxLQUFLLFVBQVUsV0FBVyxVQUFVLFdBQVcsV0FBVyxNQUFNLEtBQUssV0FBVyxVQUFVLFdBQVcsTUFBTSxLQUFLLFdBQVcsTUFBTSxLQUFLLFVBQVUsVUFBVSxVQUFVLFdBQVcsVUFBVSxNQUFNLEtBQUssV0FBVyxVQUFVLFVBQVUsVUFBVSxNQUFNLEtBQUssV0FBVyxNQUFNLEtBQUssVUFBVSxXQUFXLFdBQVcsTUFBTSxLQUFLLFVBQVUsV0FBVyxVQUFVLGdDQUFnQyx3QkFBd0Isa0JBQWtCLDJCQUEyQixxRkFBcUYsR0FBRyxvQkFBb0Isa0JBQWtCLDJCQUEyQix3QkFBd0IsaUJBQWlCLGdGQUFnRixrQkFBa0IseUJBQXlCLEdBQUcsc0JBQXNCLGdCQUFnQix3QkFBd0Isa0JBQWtCLDRCQUE0QixHQUFHLG9CQUFvQixrQkFBa0Isd0JBQXdCLGtCQUFrQiw0QkFBNEIsNEJBQTRCLEdBQUcsd0JBQXdCLGtCQUFrQiwyQkFBMkIsWUFBWSxHQUFHLG1CQUFtQixlQUFlLGdCQUFnQix1QkFBdUIsc0JBQXNCLHVCQUF1QixHQUFHLFlBQVksaUJBQWlCLG1CQUFtQixzQkFBc0IsR0FBRyxhQUFhLHFCQUFxQixzQkFBc0IsZ0NBQWdDLHVCQUF1QixHQUFHLHVCQUF1QixrQkFBa0IsMEJBQTBCLDJCQUEyQixhQUFhLGlCQUFpQixHQUFHLG1CQUFtQixrQkFBa0Isd0JBQXdCLGFBQWEsb0JBQW9CLGdDQUFnQyxpQkFBaUIsR0FBRyx1QkFBdUIsZUFBZSxvQkFBb0IsR0FBRyxrQkFBa0IsaUJBQWlCLGdCQUFnQixpQkFBaUIsR0FBRywrQ0FBK0Msa0JBQWtCLHdCQUF3QixpQkFBaUIsMkJBQTJCLGtCQUFrQixzQkFBc0IseUJBQXlCLDhDQUE4QyxHQUFHLDJCQUEyQixnREFBZ0QsR0FBRyw4Q0FBOEMsa0JBQWtCLHVCQUF1Qix3QkFBd0IsZ0RBQWdELHdCQUF3QixnQ0FBZ0Msd0JBQXdCLGtDQUFrQyxnQ0FBZ0MsR0FBRyxxQkFBcUIsa0JBQWtCLHNCQUFzQiwrQ0FBK0MsOENBQThDLHdCQUF3QiwyQkFBMkIsWUFBWSxHQUFHLG9CQUFvQixlQUFlLGdDQUFnQyxHQUFHLHFCQUFxQixlQUFlLDZCQUE2QixHQUFHLHNCQUFzQixrQkFBa0Isd0JBQXdCLHVCQUF1Qiw4QkFBOEIsaUJBQWlCLHFDQUFxQyxHQUFHLHdCQUF3Qix3QkFBd0IscUJBQXFCLGtCQUFrQix3QkFBd0IsaUJBQWlCLHFCQUFxQixZQUFZLEdBQUcsa0JBQWtCLG9CQUFvQixpQkFBaUIsaUJBQWlCLGdCQUFnQixpQkFBaUIsaUJBQWlCLEdBQUcsd0JBQXdCLGdDQUFnQyxlQUFlLEdBQUcsaUNBQWlDLGtCQUFrQix3QkFBd0Isa0NBQWtDLEdBQUcseUJBQXlCLGdCQUFnQixrQkFBa0Isd0JBQXdCLGlCQUFpQiwyQkFBMkIsc0JBQXNCLHlCQUF5QixHQUFHLGtDQUFrQyx3QkFBd0IsOEJBQThCLEdBQUcsa0JBQWtCLGdDQUFnQyxHQUFHLHFCQUFxQixvQ0FBb0MsR0FBRyxnQ0FBZ0Msd0JBQXdCLEdBQUcsdURBQXVELGlCQUFpQiwrQ0FBK0Msa0JBQWtCLHdCQUF3Qiw4Q0FBOEMsR0FBRyxpQkFBaUIsa0VBQWtFLEdBQUcsNEJBQTRCLGlEQUFpRCxpQkFBaUIsR0FBRyw4Q0FBOEMsd0JBQXdCLEdBQUcsa0JBQWtCLGtCQUFrQix3QkFBd0IsR0FBRyx1REFBdUQsdUJBQXVCLHFCQUFxQiw0QkFBNEIsc0JBQXNCLHNCQUFzQix1QkFBdUIsa0JBQWtCLHdCQUF3QixhQUFhLEdBQUcsMEJBQTBCLGdDQUFnQyx1Q0FBdUMsOENBQThDLEdBQUcsa0NBQWtDLGtCQUFrQixlQUFlLGdCQUFnQix1QkFBdUIsMkNBQTJDLEdBQUcsZ0NBQWdDLGlDQUFpQyx3Q0FBd0MsK0NBQStDLEdBQUcsd0NBQXdDLGtCQUFrQixlQUFlLGdCQUFnQix1QkFBdUIsMkJBQTJCLEdBQUcsbUJBQW1CLGdDQUFnQyxxQkFBcUIsR0FBRyxtQkFBbUIsZ0JBQWdCLGlCQUFpQix3QkFBd0IscUJBQXFCLDZDQUE2QyxHQUFHLCtCQUErQixnQkFBZ0IsaUJBQWlCLHdCQUF3QixHQUFHLDJCQUEyQixrQkFBa0IsMkJBQTJCLHdCQUF3QixjQUFjLG9DQUFvQyxHQUFHLG1DQUFtQyxrQkFBa0IsMkJBQTJCLGdCQUFnQixzQkFBc0Isa0NBQWtDLEdBQUcsb0JBQW9CLHdCQUF3QixtQkFBbUIsc0JBQXNCLEdBQUcsd0JBQXdCLHdCQUF3QixHQUFHLHNCQUFzQixrQkFBa0IsaUJBQWlCLGlCQUFpQixxQkFBcUIsWUFBWSxHQUFHLGNBQWMscUNBQXFDLGlCQUFpQixpQkFBaUIsZ0JBQWdCLEdBQUcsaUJBQWlCLG9DQUFvQyxHQUFHLHVCQUF1QixrQkFBa0IsMkJBQTJCLHdCQUF3QixHQUFHLHFCQUFxQixrQkFBa0Isd0JBQXdCLGFBQWEsR0FBRyxxQkFBcUI7QUFDNWplO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3N0eWxlcy9IZXJvLm1vZHVsZS5zY3NzPzJiZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5IZXJvX2hlcm9fXzlkVEdlIHtcXG4gIGJhY2tncm91bmQ6ICMwYTAwMWM7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuLkhlcm9faGVyb0NvbnRhaW5lcl9fb2Mxb3Uge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KGNpcmNsZSBhdCA1MCUgMzAlLCAjM2EwMDZmIDAlLCB0cmFuc3BhcmVudCA1MCUpO1xcbiAgcGFkZGluZzogMjBweDtcXG4gIHBhZGRpbmctYm90dG9tOiA2MHB4O1xcbn1cXG5cXG4uSGVyb19oZWFkZXJDb250YWluZXJfX2xVV2hYIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuXFxuLkhlcm9fbmFtZUNvbnRhaW5lcl9fYUlCenoge1xcbiAgd2lkdGg6IDEyMDBweDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBtYXJnaW46IDFlbSAwZW0gMmVtIDBlbTtcXG59XFxuXFxuLkhlcm9fbmFtZVRleHRDb250YWluZXJfXzkxQ3UyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZmxleDogMSAxO1xcbn1cXG5cXG4uSGVyb19wcm9maWxlSW1hZ2VfX3BYZHRSIHtcXG4gIHdpZHRoOiA2ZW07XFxuICBoZWlnaHQ6IDZlbTtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIG9iamVjdC1maXQ6IGNvdmVyO1xcbiAgbWFyZ2luLXJpZ2h0OiAyMHB4O1xcbn1cXG5cXG4uSGVyb190aXRsZV9fRXlKWk8ge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZm9udC1zaXplOiAyZW07XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuXFxuLkhlcm9fc3VidGl0bGVfX1E0elZZIHtcXG4gIGZvbnQtc2l6ZTogMS44ZW07XFxuICBmb250LXdlaWdodDogYm9sZDtcXG4gIGNvbG9yOiB2YXIoLS1jb2xvci1wcmltYXJ5KTtcXG4gIG1hcmdpbi1ib3R0b206IDZweDtcXG59XFxuXFxuLkhlcm9fY29udGFjdENvbnRhaW5lcl9fZklxakoge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBnYXA6IDZweDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLkhlcm9fY29udGFjdEZpZWxkX19PVTgyUCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGdhcDogNnB4O1xcbiAgZm9udC1zaXplOiAxNHB4O1xcbiAgY29sb3I6IHZhcigtLWNvbG9yLXByaW1hcnkpO1xcbiAgb3BhY2l0eTogMC44O1xcbn1cXG5cXG4uSGVyb19jb250YWN0RmllbGRfX09VODJQOmhvdmVyIHtcXG4gIG9wYWNpdHk6IDE7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5IZXJvX2NvbnRhY3RJY29uX19ra1VIUyB7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICB3aWR0aDogMjBweDtcXG4gIG9wYWNpdHk6IDAuNztcXG59XFxuXFxuLkhlcm9fcG9ydGZvbGlvU2VjdGlvbl9fZ2R3S18sXFxuLkhlcm9fcG9ydGZvbGlvU2VjdGlvbkRhcmtfX3p5MkZlIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHBhZGRpbmc6IDIwcHg7XFxuICBwYWRkaW5nLXRvcDogNDBweDtcXG4gIHBhZGRpbmctYm90dG9tOiA2MHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYmctcHJpbWFyeSk7XFxufVxcblxcbi5IZXJvX3BvcnRmb2xpb1NlY3Rpb25EYXJrX196eTJGZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1iZy1zZWNvbmRhcnkpO1xcbn1cXG5cXG4uSGVyb19kb2N1bWVudEVkaXRvckNvbnRhaW5lcl9fbXVXSVEge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIG1pbi1oZWlnaHQ6IDEwNjBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICBib3gtc2hhZG93OiAwcHggNHB4IDIwcHggcmdiYSgwLCAwLCAwLCAwLjQpO1xcbiAgbWFyZ2luLWJvdHRvbTogNDBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4zNDkwMTk2MDc4KTtcXG4gIGhlaWdodDogLW1vei1maXQtY29udGVudDtcXG4gIGhlaWdodDogZml0LWNvbnRlbnQ7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC43cyBlYXNlLW91dDtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWSg1MHB4KTtcXG59XFxuXFxuLkhlcm9fZG9jdW1lbnRFZGl0b3JfX0pZeUJ1IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBtaW4taGVpZ2h0OiA2MDBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJveC1wcmltYXJ5KTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWNvbG9yLWJveC1ib3JkZXIpO1xcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBmbGV4OiAzIDE7XFxufVxcblxcbi5IZXJvX3NsaWRlSW5IaWRkZW5fXzRneHd6IHtcXG4gIG9wYWNpdHk6IDA7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTBweCk7XFxufVxcblxcbi5IZXJvX3NsaWRlSW5WaXNpYmxlX19ZNWtRQyB7XFxuICBvcGFjaXR5OiAxO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVZKDApO1xcbn1cXG5cXG4uSGVyb19kb2N1bWVudFRvb2xiYXJfX2oyV0R4IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgcGFkZGluZy1sZWZ0OiAxMnB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzM4MTE3OTtcXG4gIGhlaWdodDogNDBweDtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHggMjBweCAwcHggMHB4O1xcbn1cXG5cXG4uSGVyb190cmVlVmlld0NvbnRhaW5lcl9fRlQ3NGEge1xcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcXG4gIHRleHQtYWxpZ246IGxlZnQ7XFxuICBwYWRkaW5nOiAxMHB4O1xcbiAgcGFkZGluZy1yaWdodDogMjBweDtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICBmbGV4OiAxIDE7XFxufVxcblxcbi5IZXJvX3Rvb2xiYXJCdXR0b25fX0V6Mm5QIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIG9wYWNpdHk6IDAuNjtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgcGFkZGluZzogNnB4O1xcbn1cXG5cXG4uSGVyb190b29sYmFyQnV0dG9uX19FejJuUDpob3ZlciB7XFxuICBjb2xvcjogdmFyKC0tY29sb3ItcHJpbWFyeSk7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4uSGVyb190cmFuc2xhdGlvbkVkaXRvckNvbnRhaW5lcl9fYmswTW4ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC42cyBlYXNlLW91dDtcXG59XFxuXFxuLkhlcm9fdHJhbnNsYXRpb25TZWN0aW9uX19aY25NVCB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHBhZGRpbmctdG9wOiA2MHB4O1xcbiAgcGFkZGluZy1ib3R0b206IDYwcHg7XFxufVxcblxcbi5IZXJvX2pvYlRpdGxlX196cXd5TiB7XFxuICBtYXJnaW4tYm90dG9tOiAxMnB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG59XFxuXFxuLkhlcm9fam9iRHVyYXRpb25fX3FteEZIIHtcXG4gIGNvbG9yOiB2YXIoLS1jb2xvci1wcmltYXJ5KTtcXG59XFxuXFxuLkhlcm9fam9iRGVzY3JpcHRpb25fX1doZUhjIHtcXG4gIGNvbG9yOiB2YXIoLS1jb2xvci10ZXh0LXN1YnRsZSk7XFxufVxcblxcbi5IZXJvX2pvYkRlc2NyaXB0aW9uX19XaGVIYzpsYXN0LWNoaWxkIHtcXG4gIG1hcmdpbi1ib3R0b206IDM1cHg7XFxufVxcblxcbi5IZXJvX3RlY2hDYXRlZ29yeV9fb2N6WVQsXFxuLkhlcm9fdGVjaENhdGVnb3J5U2Vjb25kYXJ5X19BdWdSaCB7XFxuICBmbGV4OiAxIDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ib3gtcHJpbWFyeSk7XFxuICBwYWRkaW5nOiAyNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkIHZhcigtLWNvbG9yLWJveC1ib3JkZXIpO1xcbn1cXG5cXG4uSGVyb190ZWNoQ2F0ZWdvcnlfX29jellUIHtcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxMzVkZWcsICMzMjBiNzMgMCUsICMxMjA3MjkgMTAwJSk7XFxufVxcblxcbi5IZXJvX3RlY2hDYXRlZ29yeVNlY29uZGFyeV9fQXVnUmgge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYm94LXNlY29uZGFyeSk7XFxuICBib3JkZXI6IG5vbmU7XFxufVxcblxcbi5IZXJvX3BlcnNvbmFsUHJvamVjdENvbnRhaW5lcl9fRUtvQmEge1xcbiAgbWFyZ2luLWJvdHRvbTogNDBweDtcXG59XFxuXFxuLkhlcm9fcHJvamVjdEhlYWRlcl9fWjE1Rk0ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5IZXJvX3Byb2plY3RTdGF0dXNPbmxpbmVfX2RhY0tHLFxcbi5IZXJvX3Byb2plY3RTdGF0dXNEaXNjb250aW51ZWRfX0NVRU03IHtcXG4gIGJvcmRlci1yYWRpdXM6IDFlbTtcXG4gIHBhZGRpbmc6IDRweCA4cHg7XFxuICBib3JkZXI6IDJweCBzb2xpZCBibGFjaztcXG4gIG1hcmdpbi1sZWZ0OiAxMnB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBmb250LXNpemU6IHNtYWxsZXI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGdhcDogNnB4O1xcbn1cXG5cXG4uSGVyb19wcm9qZWN0U3RhdHVzT25saW5lX19kYWNLRyB7XFxuICBjb2xvcjogdmFyKC0tY29sb3Itc3VjY2Vzcyk7XFxuICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLXN1Y2Nlc3MpO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3Itc3VjY2Vzcy1iZyk7XFxufVxcblxcbi5IZXJvX3Byb2plY3RTdGF0dXNPbmxpbmVfX2RhY0tHOjpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXCI7XFxuICB3aWR0aDogOHB4O1xcbiAgaGVpZ2h0OiA4cHg7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1zdWNjZXNzKTtcXG59XFxuXFxuLkhlcm9fcHJvamVjdFN0YXR1c0Rpc2NvbnRpbnVlZF9fQ1VFTTcge1xcbiAgY29sb3I6IHZhcigtLWNvbG9yLWRpc2FibGVkKTtcXG4gIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItZGlzYWJsZWQpO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItZGlzYWJsZWQtYmcpO1xcbn1cXG5cXG4uSGVyb19wcm9qZWN0U3RhdHVzRGlzY29udGludWVkX19DVUVNNzo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgd2lkdGg6IDhweDtcXG4gIGhlaWdodDogOHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogZ3JleTtcXG59XFxuXFxuLkhlcm9fcHJvamVjdExpbmtzX19YQTM3YyB7XFxuICBjb2xvcjogdmFyKC0tY29sb3ItcHJpbWFyeSk7XFxuICBtYXJnaW4tdG9wOiAxMnB4O1xcbn1cXG5cXG4uSGVyb19wcm9qZWN0SW1hZ2VfX29DMld4IHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gIG1hcmdpbi10b3A6IDE2cHg7XFxufVxcblxcbi5IZXJvX2dhbWVWaWRlb19feFllU18ge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IGF1dG87XFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbn1cXG5cXG4uSGVyb19nYW1lUHJvamVjdENvbnRhaW5lcl9fTEVtY2Mge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZ2FwOiAxNnB4O1xcbiAgY29sb3I6IHZhcigtLWNvbG9yLXRleHQtc3VidGxlKTtcXG59XFxuXFxuLkhlcm9fY29sdW1uQ29udGFpbmVyX19jZkZueiB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LXdpZHRoOiAxMjAwcHg7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC42cyBlYXNlLW91dDtcXG59XFxuXFxuLkhlcm9fc2VjdGlvbkhlYWRlcl9fWnRuR2Yge1xcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG4gIGNvbG9yOiAjYzY4NmZmO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbi5IZXJvX3NlY3Rpb25IZWFkZXJUZXh0X19WYkVPbiB7XFxuICBwYWRkaW5nLWJvdHRvbTogNnB4O1xcbn1cXG5cXG4uSGVyb19jb250ZW50RWRpdGFibGVfX29Eb2taIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBjb2xvcjogd2hpdGU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgZmxleDogMSAxO1xcbn1cXG5cXG4uSGVyb19kaXZpZGVyX19CVXNXTyB7XFxuICBib3JkZXItbGVmdDogMXB4IHNvbGlkIHdoaXRlO1xcbiAgb3BhY2l0eTogMC4xO1xcbiAgbWFyZ2luOiAxMnB4O1xcbiAgaGVpZ2h0OiA2MCU7XFxufVxcblxcbi5IZXJvX3N1YnRsZVRleHRfX2VFNmhzIHtcXG4gIGNvbG9yOiB2YXIoLS1jb2xvci10ZXh0LXN1YnRsZSk7XFxufVxcblxcbi5IZXJvX3NpZ25PZmZDb250YWluZXJfX0MyMnlRIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLkhlcm9fc2lnbk9mZkNvbnRhY3RfXzRoZEw5IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZ2FwOiA2cHg7XFxufVwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9zcmMvc3R5bGVzL0hlcm8ubW9kdWxlLnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxtQkFBQTtFQUNBLGFBQUE7RUFDQSxzQkFBQTtBQUNGOztBQUdBO0VBQ0UsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsbUJBQUE7RUFDQSxZQUFBO0VBQ0EsMkVBQUE7RUFDQSxhQUFBO0VBQ0Esb0JBQUE7QUFBRjs7QUFHQTtFQUNFLFdBQUE7RUFDQSxtQkFBQTtFQUNBLGFBQUE7RUFDQSx1QkFBQTtBQUFGOztBQUdBO0VBQ0UsYUFBQTtFQUNBLG1CQUFBO0VBQ0EsYUFBQTtFQUNBLHVCQUFBO0VBQ0EsdUJBQUE7QUFBRjs7QUFHQTtFQUNFLGFBQUE7RUFDQSxzQkFBQTtFQUNBLFNBQUE7QUFBRjs7QUFHQTtFQUNFLFVBQUE7RUFDQSxXQUFBO0VBQ0Esa0JBQUE7RUFDQSxpQkFBQTtFQUNBLGtCQUFBO0FBQUY7O0FBR0E7RUFDRSxZQUFBO0VBQ0EsY0FBQTtFQUNBLGlCQUFBO0FBQUY7O0FBRUE7RUFDRSxnQkFBQTtFQUNBLGlCQUFBO0VBQ0EsMkJBQUE7RUFDQSxrQkFBQTtBQUNGOztBQUVBO0VBQ0UsYUFBQTtFQUNBLHFCQUFBO0VBQ0Esc0JBQUE7RUFDQSxRQUFBO0VBQ0EsWUFBQTtBQUNGOztBQUVBO0VBQ0UsYUFBQTtFQUNBLG1CQUFBO0VBQ0EsUUFBQTtFQUNBLGVBQUE7RUFDQSwyQkFBQTtFQUNBLFlBQUE7QUFDRjs7QUFDQTtFQUNFLFVBQUE7RUFDQSxlQUFBO0FBRUY7O0FBQ0E7RUFDRSxZQUFBO0VBQ0EsV0FBQTtFQUNBLFlBQUE7QUFFRjs7QUFDQTs7RUFFRSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSxZQUFBO0VBQ0Esc0JBQUE7RUFDQSxhQUFBO0VBQ0EsaUJBQUE7RUFDQSxvQkFBQTtFQUNBLHlDQUFBO0FBRUY7O0FBQ0E7RUFDRSwyQ0FBQTtBQUVGOztBQUdBO0VBQ0UsYUFBQTtFQUNBLGtCQUFBO0VBQ0EsbUJBQUE7RUFDQSwyQ0FBQTtFQUNBLG1CQUFBO0VBQ0EsNkNBQUE7RUFDQSx3QkFBQTtFQUFBLG1CQUFBO0VBQ0EsNkJBQUE7RUFDQSwyQkFBQTtBQUFGOztBQUdBO0VBQ0UsYUFBQTtFQUNBLGlCQUFBO0VBQ0EsMENBQUE7RUFDQSx5Q0FBQTtFQUNBLG1CQUFBO0VBQ0Esc0JBQUE7RUFDQSxTQUFBO0FBQUY7O0FBR0E7RUFDRSxVQUFBO0VBQ0EsMkJBQUE7QUFBRjs7QUFHQTtFQUNFLFVBQUE7RUFDQSx3QkFBQTtBQUFGOztBQUdBO0VBQ0UsYUFBQTtFQUNBLG1CQUFBO0VBQ0Esa0JBQUE7RUFDQSx5QkFBQTtFQUNBLFlBQUE7RUFDQSxnQ0FBQTtBQUFGOztBQUdBO0VBQ0UsbUJBQUE7RUFDQSxnQkFBQTtFQUNBLGFBQUE7RUFDQSxtQkFBQTtFQUNBLFlBQUE7RUFDQSxnQkFBQTtFQUNBLFNBQUE7QUFBRjs7QUFFQTtFQUNFLGVBQUE7RUFDQSxZQUFBO0VBQ0EsWUFBQTtFQUNBLFdBQUE7RUFDQSxZQUFBO0VBQ0EsWUFBQTtBQUNGOztBQUNBO0VBQ0UsMkJBQUE7RUFDQSxVQUFBO0FBRUY7O0FBQ0E7RUFDRSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSw2QkFBQTtBQUVGOztBQUNBO0VBQ0UsV0FBQTtFQUNBLGFBQUE7RUFDQSxtQkFBQTtFQUNBLFlBQUE7RUFDQSxzQkFBQTtFQUNBLGlCQUFBO0VBQ0Esb0JBQUE7QUFFRjs7QUFHQTtFQUNFLG1CQUFBO0VBQ0EseUJBQUE7QUFBRjs7QUFHQTtFQUNFLDJCQUFBO0FBQUY7O0FBR0E7RUFDRSwrQkFBQTtBQUFGOztBQUdBO0VBQ0UsbUJBQUE7QUFBRjs7QUFLQTs7RUFFRSxTQUFBO0VBQ0EsMENBQUE7RUFDQSxhQUFBO0VBQ0EsbUJBQUE7RUFDQSx5Q0FBQTtBQUZGOztBQUlBO0VBQ0UsNkRBQUE7QUFERjs7QUFJQTtFQUNFLDRDQUFBO0VBQ0EsWUFBQTtBQURGOztBQU1BO0VBQ0UsbUJBQUE7QUFIRjs7QUFLQTtFQUNFLGFBQUE7RUFDQSxtQkFBQTtBQUZGOztBQUtBOztFQUVFLGtCQUFBO0VBQ0EsZ0JBQUE7RUFDQSx1QkFBQTtFQUNBLGlCQUFBO0VBQ0EsaUJBQUE7RUFDQSxrQkFBQTtFQUNBLGFBQUE7RUFDQSxtQkFBQTtFQUNBLFFBQUE7QUFGRjs7QUFLQTtFQUNFLDJCQUFBO0VBQ0Esa0NBQUE7RUFDQSx5Q0FBQTtBQUZGOztBQUtBO0VBQ0UsV0FBQTtFQUNBLFVBQUE7RUFDQSxXQUFBO0VBQ0Esa0JBQUE7RUFDQSxzQ0FBQTtBQUZGOztBQUtBO0VBQ0UsNEJBQUE7RUFDQSxtQ0FBQTtFQUNBLDBDQUFBO0FBRkY7O0FBS0E7RUFDRSxXQUFBO0VBQ0EsVUFBQTtFQUNBLFdBQUE7RUFDQSxrQkFBQTtFQUNBLHNCQUFBO0FBRkY7O0FBS0E7RUFDRSwyQkFBQTtFQUNBLGdCQUFBO0FBRkY7O0FBS0E7RUFDRSxXQUFBO0VBQ0EsWUFBQTtFQUNBLG1CQUFBO0VBQ0EsZ0JBQUE7QUFGRjs7QUFRQTtFQUNFLFdBQUE7RUFDQSxZQUFBO0VBQ0EsbUJBQUE7QUFMRjs7QUFRQTtFQUNFLGFBQUE7RUFDQSxzQkFBQTtFQUNBLG1CQUFBO0VBQ0EsU0FBQTtFQUNBLCtCQUFBO0FBTEY7O0FBVUE7RUFDRSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxXQUFBO0VBQ0EsaUJBQUE7RUFDQSw2QkFBQTtBQVBGOztBQVVBO0VBQ0UsbUJBQUE7RUFDQSxjQUFBO0VBQ0EsaUJBQUE7QUFQRjs7QUFVQTtFQUNFLG1CQUFBO0FBUEY7O0FBVUE7RUFDRSxhQUFBO0VBQ0EsWUFBQTtFQUNBLFlBQUE7RUFDQSxnQkFBQTtFQUNBLFNBQUE7QUFQRjs7QUFVQTtFQUNFLDRCQUFBO0VBQ0EsWUFBQTtFQUNBLFlBQUE7RUFDQSxXQUFBO0FBUEY7O0FBVUE7RUFDRSwrQkFBQTtBQVBGOztBQVVBO0VBQ0UsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsbUJBQUE7QUFQRjs7QUFVQTtFQUNFLGFBQUE7RUFDQSxtQkFBQTtFQUNBLFFBQUE7QUFQRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuaGVybyB7XFxuICBiYWNrZ3JvdW5kOiAjMGEwMDFjO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICAvLyBiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoY2lyY2xlLCB2YXIoLS1jb2xvci1wcmltYXJ5KSAwJSwgdHJhbnNwYXJlbnQgNzAlKTtcXG59XFxuXFxuLmhlcm9Db250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZDogcmFkaWFsLWdyYWRpZW50KGNpcmNsZSBhdCA1MCUgMzAlLCAjM2EwMDZmIDAlLCB0cmFuc3BhcmVudCA1MCUpO1xcbiAgcGFkZGluZzogMjBweDtcXG4gIHBhZGRpbmctYm90dG9tOiA2MHB4O1xcbn1cXG5cXG4uaGVhZGVyQ29udGFpbmVyIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG59XFxuXFxuLm5hbWVDb250YWluZXIge1xcbiAgd2lkdGg6IDEyMDBweDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBtYXJnaW46IDFlbSAwZW0gMmVtIDBlbTtcXG59XFxuXFxuLm5hbWVUZXh0Q29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZmxleDogMTtcXG59XFxuXFxuLnByb2ZpbGVJbWFnZSB7XFxuICB3aWR0aDogNmVtO1xcbiAgaGVpZ2h0OiA2ZW07XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBvYmplY3QtZml0OiBjb3ZlcjtcXG4gIG1hcmdpbi1yaWdodDogMjBweDtcXG59XFxuXFxuLnRpdGxlIHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGZvbnQtc2l6ZTogMmVtO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcbi5zdWJ0aXRsZSB7XFxuICBmb250LXNpemU6IDEuOGVtO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBjb2xvcjogdmFyKC0tY29sb3ItcHJpbWFyeSk7XFxuICBtYXJnaW4tYm90dG9tOiA2cHg7XFxufVxcblxcbi5jb250YWN0Q29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZ2FwOiA2cHg7XFxuICBjb2xvcjogd2hpdGU7XFxufVxcblxcbi5jb250YWN0RmllbGQge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBnYXA6IDZweDtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG4gIGNvbG9yOiB2YXIoLS1jb2xvci1wcmltYXJ5KTtcXG4gIG9wYWNpdHk6IDAuODtcXG59XFxuLmNvbnRhY3RGaWVsZDpob3ZlciB7XFxuICBvcGFjaXR5OiAxO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4uY29udGFjdEljb24ge1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgd2lkdGg6IDIwcHg7XFxuICBvcGFjaXR5OiAwLjc7XFxufVxcblxcbi5wb3J0Zm9saW9TZWN0aW9uLFxcbi5wb3J0Zm9saW9TZWN0aW9uRGFyayB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBwYWRkaW5nOiAyMHB4O1xcbiAgcGFkZGluZy10b3A6IDQwcHg7XFxuICBwYWRkaW5nLWJvdHRvbTogNjBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJnLXByaW1hcnkpO1xcbn1cXG5cXG4ucG9ydGZvbGlvU2VjdGlvbkRhcmsge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYmctc2Vjb25kYXJ5KTtcXG59XFxuXFxuLy8gRG9jdW1lbnRzXFxuXFxuLmRvY3VtZW50RWRpdG9yQ29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBtaW4taGVpZ2h0OiAxMDYwcHg7XFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgYm94LXNoYWRvdzogMHB4IDRweCAyMHB4IHJnYmEoMCwgMCwgMCwgMC40KTtcXG4gIG1hcmdpbi1ib3R0b206IDQwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwMDAwNTk7XFxuICBoZWlnaHQ6IGZpdC1jb250ZW50O1xcbiAgdHJhbnNpdGlvbjogYWxsIDAuN3MgZWFzZS1vdXQ7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoNTBweCk7XFxufVxcblxcbi5kb2N1bWVudEVkaXRvciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgbWluLWhlaWdodDogNjAwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1ib3gtcHJpbWFyeSk7XFxuICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1jb2xvci1ib3gtYm9yZGVyKTtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZmxleDogMztcXG59XFxuXFxuLnNsaWRlSW5IaWRkZW4ge1xcbiAgb3BhY2l0eTogMDtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgxMHB4KTtcXG59XFxuXFxuLnNsaWRlSW5WaXNpYmxlIHtcXG4gIG9wYWNpdHk6IDE7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMCk7XFxufVxcblxcbi5kb2N1bWVudFRvb2xiYXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBwYWRkaW5nLWxlZnQ6IDEycHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMzgxMTc5O1xcbiAgaGVpZ2h0OiA0MHB4O1xcbiAgYm9yZGVyLXJhZGl1czogMjBweCAyMHB4IDBweCAwcHg7XFxufVxcblxcbi50cmVlVmlld0NvbnRhaW5lciB7XFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgdGV4dC1hbGlnbjogbGVmdDtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBwYWRkaW5nLXJpZ2h0OiAyMHB4O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIGZsZXg6IDE7XFxufVxcbi50b29sYmFyQnV0dG9uIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIG9wYWNpdHk6IDAuNjtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgcGFkZGluZzogNnB4O1xcbn1cXG4udG9vbGJhckJ1dHRvbjpob3ZlciB7XFxuICBjb2xvcjogdmFyKC0tY29sb3ItcHJpbWFyeSk7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4udHJhbnNsYXRpb25FZGl0b3JDb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC42cyBlYXNlLW91dDtcXG59XFxuXFxuLnRyYW5zbGF0aW9uU2VjdGlvbiB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHBhZGRpbmctdG9wOiA2MHB4O1xcbiAgcGFkZGluZy1ib3R0b206IDYwcHg7XFxufVxcblxcbi8vIFByZXZpb3VzIEV4cFxcblxcbi5qb2JUaXRsZSB7XFxuICBtYXJnaW4tYm90dG9tOiAxMnB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogaW5oZXJpdDtcXG59XFxuXFxuLmpvYkR1cmF0aW9uIHtcXG4gIGNvbG9yOiB2YXIoLS1jb2xvci1wcmltYXJ5KTtcXG59XFxuXFxuLmpvYkRlc2NyaXB0aW9uIHtcXG4gIGNvbG9yOiB2YXIoLS1jb2xvci10ZXh0LXN1YnRsZSk7XFxufVxcblxcbi5qb2JEZXNjcmlwdGlvbjpsYXN0LWNoaWxkIHtcXG4gIG1hcmdpbi1ib3R0b206IDM1cHg7XFxufVxcblxcbi8vIFRlY2hcXG5cXG4udGVjaENhdGVnb3J5LFxcbi50ZWNoQ2F0ZWdvcnlTZWNvbmRhcnkge1xcbiAgZmxleDogMSAxIDAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItYm94LXByaW1hcnkpO1xcbiAgcGFkZGluZzogMjVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1jb2xvci1ib3gtYm9yZGVyKTtcXG59XFxuLnRlY2hDYXRlZ29yeSB7XFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjMzIwYjczIDAlLCAjMTIwNzI5IDEwMCUpO1xcbn1cXG5cXG4udGVjaENhdGVnb3J5U2Vjb25kYXJ5IHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWNvbG9yLWJveC1zZWNvbmRhcnkpO1xcbiAgYm9yZGVyOiBub25lO1xcbn1cXG5cXG4vLyBQcm9qZWN0c1xcblxcbi5wZXJzb25hbFByb2plY3RDb250YWluZXIge1xcbiAgbWFyZ2luLWJvdHRvbTogNDBweDtcXG59XFxuLnByb2plY3RIZWFkZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5wcm9qZWN0U3RhdHVzT25saW5lLFxcbi5wcm9qZWN0U3RhdHVzRGlzY29udGludWVkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDFlbTtcXG4gIHBhZGRpbmc6IDRweCA4cHg7XFxuICBib3JkZXI6IDJweCBzb2xpZCBibGFjaztcXG4gIG1hcmdpbi1sZWZ0OiAxMnB4O1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICBmb250LXNpemU6IHNtYWxsZXI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGdhcDogNnB4O1xcbn1cXG5cXG4ucHJvamVjdFN0YXR1c09ubGluZSB7XFxuICBjb2xvcjogdmFyKC0tY29sb3Itc3VjY2Vzcyk7XFxuICBib3JkZXItY29sb3I6IHZhcigtLWNvbG9yLXN1Y2Nlc3MpO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3Itc3VjY2Vzcy1iZyk7XFxufVxcblxcbi5wcm9qZWN0U3RhdHVzT25saW5lOjpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIlxcXCI7XFxuICB3aWR0aDogOHB4O1xcbiAgaGVpZ2h0OiA4cHg7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1zdWNjZXNzKTtcXG59XFxuXFxuLnByb2plY3RTdGF0dXNEaXNjb250aW51ZWQge1xcbiAgY29sb3I6IHZhcigtLWNvbG9yLWRpc2FibGVkKTtcXG4gIGJvcmRlci1jb2xvcjogdmFyKC0tY29sb3ItZGlzYWJsZWQpO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tY29sb3ItZGlzYWJsZWQtYmcpO1xcbn1cXG5cXG4ucHJvamVjdFN0YXR1c0Rpc2NvbnRpbnVlZDo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6IFxcXCJcXFwiO1xcbiAgd2lkdGg6IDhweDtcXG4gIGhlaWdodDogOHB4O1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogZ3JleTtcXG59XFxuXFxuLnByb2plY3RMaW5rcyB7XFxuICBjb2xvcjogdmFyKC0tY29sb3ItcHJpbWFyeSk7XFxuICBtYXJnaW4tdG9wOiAxMnB4O1xcbn1cXG5cXG4ucHJvamVjdEltYWdlIHtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXG4gIG1hcmdpbi10b3A6IDE2cHg7XFxuICAvLyBib3gtc2hhZG93OiAwcHggNHB4IDgwcHggcmdiKDM4IDYgNjEpO1xcbn1cXG5cXG4vLyBHYW1lIERldlxcblxcbi5nYW1lVmlkZW8ge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IGF1dG87XFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbn1cXG5cXG4uZ2FtZVByb2plY3RDb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZ2FwOiAxNnB4O1xcbiAgY29sb3I6IHZhcigtLWNvbG9yLXRleHQtc3VidGxlKTtcXG59XFxuXFxuLy8gQ29tbW9uXFxuXFxuLmNvbHVtbkNvbnRhaW5lciB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWF4LXdpZHRoOiAxMjAwcHg7XFxuICB0cmFuc2l0aW9uOiBhbGwgMC42cyBlYXNlLW91dDtcXG59XFxuXFxuLnNlY3Rpb25IZWFkZXIge1xcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG4gIGNvbG9yOiAjYzY4NmZmO1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxufVxcblxcbi5zZWN0aW9uSGVhZGVyVGV4dCB7XFxuICBwYWRkaW5nLWJvdHRvbTogNnB4O1xcbn1cXG5cXG4uY29udGVudEVkaXRhYmxlIHtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBjb2xvcjogd2hpdGU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICB0ZXh0LWFsaWduOiBsZWZ0O1xcbiAgZmxleDogMTtcXG59XFxuXFxuLmRpdmlkZXIge1xcbiAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjZmZmZmZmZmY7XFxuICBvcGFjaXR5OiAwLjE7XFxuICBtYXJnaW46IDEycHg7XFxuICBoZWlnaHQ6IDYwJTtcXG59XFxuXFxuLnN1YnRsZVRleHQge1xcbiAgY29sb3I6IHZhcigtLWNvbG9yLXRleHQtc3VidGxlKTtcXG59XFxuXFxuLnNpZ25PZmZDb250YWluZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uc2lnbk9mZkNvbnRhY3Qge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBnYXA6IDZweDtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiaGVyb1wiOiBcIkhlcm9faGVyb19fOWRUR2VcIixcblx0XCJoZXJvQ29udGFpbmVyXCI6IFwiSGVyb19oZXJvQ29udGFpbmVyX19vYzFvdVwiLFxuXHRcImhlYWRlckNvbnRhaW5lclwiOiBcIkhlcm9faGVhZGVyQ29udGFpbmVyX19sVVdoWFwiLFxuXHRcIm5hbWVDb250YWluZXJcIjogXCJIZXJvX25hbWVDb250YWluZXJfX2FJQnp6XCIsXG5cdFwibmFtZVRleHRDb250YWluZXJcIjogXCJIZXJvX25hbWVUZXh0Q29udGFpbmVyX185MUN1MlwiLFxuXHRcInByb2ZpbGVJbWFnZVwiOiBcIkhlcm9fcHJvZmlsZUltYWdlX19wWGR0UlwiLFxuXHRcInRpdGxlXCI6IFwiSGVyb190aXRsZV9fRXlKWk9cIixcblx0XCJzdWJ0aXRsZVwiOiBcIkhlcm9fc3VidGl0bGVfX1E0elZZXCIsXG5cdFwiY29udGFjdENvbnRhaW5lclwiOiBcIkhlcm9fY29udGFjdENvbnRhaW5lcl9fZklxakpcIixcblx0XCJjb250YWN0RmllbGRcIjogXCJIZXJvX2NvbnRhY3RGaWVsZF9fT1U4MlBcIixcblx0XCJjb250YWN0SWNvblwiOiBcIkhlcm9fY29udGFjdEljb25fX2trVUhTXCIsXG5cdFwicG9ydGZvbGlvU2VjdGlvblwiOiBcIkhlcm9fcG9ydGZvbGlvU2VjdGlvbl9fZ2R3S19cIixcblx0XCJwb3J0Zm9saW9TZWN0aW9uRGFya1wiOiBcIkhlcm9fcG9ydGZvbGlvU2VjdGlvbkRhcmtfX3p5MkZlXCIsXG5cdFwiZG9jdW1lbnRFZGl0b3JDb250YWluZXJcIjogXCJIZXJvX2RvY3VtZW50RWRpdG9yQ29udGFpbmVyX19tdVdJUVwiLFxuXHRcImRvY3VtZW50RWRpdG9yXCI6IFwiSGVyb19kb2N1bWVudEVkaXRvcl9fSll5QnVcIixcblx0XCJzbGlkZUluSGlkZGVuXCI6IFwiSGVyb19zbGlkZUluSGlkZGVuX180Z3h3elwiLFxuXHRcInNsaWRlSW5WaXNpYmxlXCI6IFwiSGVyb19zbGlkZUluVmlzaWJsZV9fWTVrUUNcIixcblx0XCJkb2N1bWVudFRvb2xiYXJcIjogXCJIZXJvX2RvY3VtZW50VG9vbGJhcl9fajJXRHhcIixcblx0XCJ0cmVlVmlld0NvbnRhaW5lclwiOiBcIkhlcm9fdHJlZVZpZXdDb250YWluZXJfX0ZUNzRhXCIsXG5cdFwidG9vbGJhckJ1dHRvblwiOiBcIkhlcm9fdG9vbGJhckJ1dHRvbl9fRXoyblBcIixcblx0XCJ0cmFuc2xhdGlvbkVkaXRvckNvbnRhaW5lclwiOiBcIkhlcm9fdHJhbnNsYXRpb25FZGl0b3JDb250YWluZXJfX2JrME1uXCIsXG5cdFwidHJhbnNsYXRpb25TZWN0aW9uXCI6IFwiSGVyb190cmFuc2xhdGlvblNlY3Rpb25fX1pjbk1UXCIsXG5cdFwiam9iVGl0bGVcIjogXCJIZXJvX2pvYlRpdGxlX196cXd5TlwiLFxuXHRcImpvYkR1cmF0aW9uXCI6IFwiSGVyb19qb2JEdXJhdGlvbl9fcW14RkhcIixcblx0XCJqb2JEZXNjcmlwdGlvblwiOiBcIkhlcm9fam9iRGVzY3JpcHRpb25fX1doZUhjXCIsXG5cdFwidGVjaENhdGVnb3J5XCI6IFwiSGVyb190ZWNoQ2F0ZWdvcnlfX29jellUXCIsXG5cdFwidGVjaENhdGVnb3J5U2Vjb25kYXJ5XCI6IFwiSGVyb190ZWNoQ2F0ZWdvcnlTZWNvbmRhcnlfX0F1Z1JoXCIsXG5cdFwicGVyc29uYWxQcm9qZWN0Q29udGFpbmVyXCI6IFwiSGVyb19wZXJzb25hbFByb2plY3RDb250YWluZXJfX0VLb0JhXCIsXG5cdFwicHJvamVjdEhlYWRlclwiOiBcIkhlcm9fcHJvamVjdEhlYWRlcl9fWjE1Rk1cIixcblx0XCJwcm9qZWN0U3RhdHVzT25saW5lXCI6IFwiSGVyb19wcm9qZWN0U3RhdHVzT25saW5lX19kYWNLR1wiLFxuXHRcInByb2plY3RTdGF0dXNEaXNjb250aW51ZWRcIjogXCJIZXJvX3Byb2plY3RTdGF0dXNEaXNjb250aW51ZWRfX0NVRU03XCIsXG5cdFwicHJvamVjdExpbmtzXCI6IFwiSGVyb19wcm9qZWN0TGlua3NfX1hBMzdjXCIsXG5cdFwicHJvamVjdEltYWdlXCI6IFwiSGVyb19wcm9qZWN0SW1hZ2VfX29DMld4XCIsXG5cdFwiZ2FtZVZpZGVvXCI6IFwiSGVyb19nYW1lVmlkZW9fX3hZZVNfXCIsXG5cdFwiZ2FtZVByb2plY3RDb250YWluZXJcIjogXCJIZXJvX2dhbWVQcm9qZWN0Q29udGFpbmVyX19MRW1jY1wiLFxuXHRcImNvbHVtbkNvbnRhaW5lclwiOiBcIkhlcm9fY29sdW1uQ29udGFpbmVyX19jZkZuelwiLFxuXHRcInNlY3Rpb25IZWFkZXJcIjogXCJIZXJvX3NlY3Rpb25IZWFkZXJfX1p0bkdmXCIsXG5cdFwic2VjdGlvbkhlYWRlclRleHRcIjogXCJIZXJvX3NlY3Rpb25IZWFkZXJUZXh0X19WYkVPblwiLFxuXHRcImNvbnRlbnRFZGl0YWJsZVwiOiBcIkhlcm9fY29udGVudEVkaXRhYmxlX19vRG9rWlwiLFxuXHRcImRpdmlkZXJcIjogXCJIZXJvX2RpdmlkZXJfX0JVc1dPXCIsXG5cdFwic3VidGxlVGV4dFwiOiBcIkhlcm9fc3VidGxlVGV4dF9fZUU2aHNcIixcblx0XCJzaWduT2ZmQ29udGFpbmVyXCI6IFwiSGVyb19zaWduT2ZmQ29udGFpbmVyX19DMjJ5UVwiLFxuXHRcInNpZ25PZmZDb250YWN0XCI6IFwiSGVyb19zaWduT2ZmQ29udGFjdF9fNGhkTDlcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/Hero.module.scss\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/TranslationExample.module.scss":
/*!*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/TranslationExample.module.scss ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// Imports\nvar ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".TranslationExample_translationSection__Aw_jE {\\n  width: 100%;\\n  display: flex;\\n  align-items: center;\\n  color: white;\\n  flex-direction: column;\\n  padding-top: 60px;\\n  padding-bottom: 60px;\\n}\\n\\n.TranslationExample_translationInput__A_26A {\\n  background-color: #150037;\\n  border-radius: 20px;\\n  margin-right: 10px;\\n  box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.2);\\n  padding: 25px;\\n  opacity: 0.7;\\n  height: 100%;\\n  flex: 1 1;\\n}\\n\\n.TranslationExample_translationContainer__uOKUa {\\n  display: flex;\\n  flex-direction: column;\\n  border-radius: 20px;\\n  background-color: #1f0845;\\n  box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.2);\\n  padding: 25px;\\n  flex: 1 1;\\n  border: 1px solid var(--color-box-border);\\n  background: linear-gradient(135deg, #320b73 0%, #120729 100%);\\n}\\n\\n.TranslationExample_translationContent__Cc32F {\\n  display: flex;\\n  flex-direction: column;\\n  flex: 1 1;\\n}\\n\\n.TranslationExample_translationCardContainer__bv_xQ {\\n  display: flex;\\n  gap: 20px;\\n  padding-top: 14px;\\n  padding-bottom: 14px;\\n}\\n\\n.TranslationExample_translationCard___ZCYu {\\n  border-radius: 20px;\\n  background-color: #10002d;\\n  padding: 18px;\\n  flex: 1 1;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://src/styles/TranslationExample.module.scss\"],\"names\":[],\"mappings\":\"AAAA;EACE,WAAA;EACA,aAAA;EACA,mBAAA;EACA,YAAA;EACA,sBAAA;EACA,iBAAA;EACA,oBAAA;AACF;;AAEA;EACE,yBAAA;EACA,mBAAA;EACA,kBAAA;EACA,2CAAA;EACA,aAAA;EACA,YAAA;EACA,YAAA;EACA,SAAA;AACF;;AAEA;EACE,aAAA;EACA,sBAAA;EACA,mBAAA;EACA,yBAAA;EACA,2CAAA;EACA,aAAA;EACA,SAAA;EACA,yCAAA;EACA,6DAAA;AACF;;AAEA;EACE,aAAA;EACA,sBAAA;EACA,SAAA;AACF;;AAEA;EACE,aAAA;EACA,SAAA;EACA,iBAAA;EACA,oBAAA;AACF;;AAEA;EACE,mBAAA;EACA,yBAAA;EACA,aAAA;EACA,SAAA;AACF\",\"sourcesContent\":[\".translationSection {\\n  width: 100%;\\n  display: flex;\\n  align-items: center;\\n  color: white;\\n  flex-direction: column;\\n  padding-top: 60px;\\n  padding-bottom: 60px;\\n}\\n\\n.translationInput {\\n  background-color: #150037;\\n  border-radius: 20px;\\n  margin-right: 10px;\\n  box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.2);\\n  padding: 25px;\\n  opacity: 0.7;\\n  height: 100%;\\n  flex: 1;\\n}\\n\\n.translationContainer {\\n  display: flex;\\n  flex-direction: column;\\n  border-radius: 20px;\\n  background-color: #1f0845;\\n  box-shadow: 0px 4px 20px rgba(0, 0, 0, 0.2);\\n  padding: 25px;\\n  flex: 1;\\n  border: 1px solid var(--color-box-border);\\n  background: linear-gradient(135deg, #320b73 0%, #120729 100%);\\n}\\n\\n.translationContent {\\n  display: flex;\\n  flex-direction: column;\\n  flex: 1;\\n}\\n\\n.translationCardContainer {\\n  display: flex;\\n  gap: 20px;\\n  padding-top: 14px;\\n  padding-bottom: 14px;\\n}\\n\\n.translationCard {\\n  border-radius: 20px;\\n  background-color: #10002d;\\n  padding: 18px;\\n  flex: 1;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n___CSS_LOADER_EXPORT___.locals = {\n\t\"translationSection\": \"TranslationExample_translationSection__Aw_jE\",\n\t\"translationInput\": \"TranslationExample_translationInput__A_26A\",\n\t\"translationContainer\": \"TranslationExample_translationContainer__uOKUa\",\n\t\"translationContent\": \"TranslationExample_translationContent__Cc32F\",\n\t\"translationCardContainer\": \"TranslationExample_translationCardContainer__bv_xQ\",\n\t\"translationCard\": \"TranslationExample_translationCard___ZCYu\"\n};\nmodule.exports = ___CSS_LOADER_EXPORT___;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzFdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbMl0hLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbMTBdLnVzZVszXSEuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbNF0hLi9zcmMvc3R5bGVzL1RyYW5zbGF0aW9uRXhhbXBsZS5tb2R1bGUuc2NzcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtDQUFrQyxtQkFBTyxDQUFDLHNLQUFrRjtBQUM1SDtBQUNBO0FBQ0EseUZBQXlGLGdCQUFnQixrQkFBa0Isd0JBQXdCLGlCQUFpQiwyQkFBMkIsc0JBQXNCLHlCQUF5QixHQUFHLGlEQUFpRCw4QkFBOEIsd0JBQXdCLHVCQUF1QixnREFBZ0Qsa0JBQWtCLGlCQUFpQixpQkFBaUIsY0FBYyxHQUFHLHFEQUFxRCxrQkFBa0IsMkJBQTJCLHdCQUF3Qiw4QkFBOEIsZ0RBQWdELGtCQUFrQixjQUFjLDhDQUE4QyxrRUFBa0UsR0FBRyxtREFBbUQsa0JBQWtCLDJCQUEyQixjQUFjLEdBQUcseURBQXlELGtCQUFrQixjQUFjLHNCQUFzQix5QkFBeUIsR0FBRyxnREFBZ0Qsd0JBQXdCLDhCQUE4QixrQkFBa0IsY0FBYyxHQUFHLE9BQU8sMEdBQTBHLFVBQVUsVUFBVSxXQUFXLFVBQVUsV0FBVyxXQUFXLFdBQVcsTUFBTSxLQUFLLFdBQVcsV0FBVyxXQUFXLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxNQUFNLEtBQUssVUFBVSxXQUFXLFdBQVcsV0FBVyxXQUFXLFVBQVUsVUFBVSxXQUFXLFdBQVcsTUFBTSxLQUFLLFVBQVUsV0FBVyxVQUFVLE1BQU0sS0FBSyxVQUFVLFVBQVUsV0FBVyxXQUFXLE1BQU0sS0FBSyxXQUFXLFdBQVcsVUFBVSxVQUFVLDhDQUE4QyxnQkFBZ0Isa0JBQWtCLHdCQUF3QixpQkFBaUIsMkJBQTJCLHNCQUFzQix5QkFBeUIsR0FBRyx1QkFBdUIsOEJBQThCLHdCQUF3Qix1QkFBdUIsZ0RBQWdELGtCQUFrQixpQkFBaUIsaUJBQWlCLFlBQVksR0FBRywyQkFBMkIsa0JBQWtCLDJCQUEyQix3QkFBd0IsOEJBQThCLGdEQUFnRCxrQkFBa0IsWUFBWSw4Q0FBOEMsa0VBQWtFLEdBQUcseUJBQXlCLGtCQUFrQiwyQkFBMkIsWUFBWSxHQUFHLCtCQUErQixrQkFBa0IsY0FBYyxzQkFBc0IseUJBQXlCLEdBQUcsc0JBQXNCLHdCQUF3Qiw4QkFBOEIsa0JBQWtCLFlBQVksR0FBRyxxQkFBcUI7QUFDandGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdHlsZXMvVHJhbnNsYXRpb25FeGFtcGxlLm1vZHVsZS5zY3NzPzVlZTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qc1wiKTtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi5UcmFuc2xhdGlvbkV4YW1wbGVfdHJhbnNsYXRpb25TZWN0aW9uX19Bd19qRSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHBhZGRpbmctdG9wOiA2MHB4O1xcbiAgcGFkZGluZy1ib3R0b206IDYwcHg7XFxufVxcblxcbi5UcmFuc2xhdGlvbkV4YW1wbGVfdHJhbnNsYXRpb25JbnB1dF9fQV8yNkEge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzE1MDAzNztcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICBtYXJnaW4tcmlnaHQ6IDEwcHg7XFxuICBib3gtc2hhZG93OiAwcHggNHB4IDIwcHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgcGFkZGluZzogMjVweDtcXG4gIG9wYWNpdHk6IDAuNztcXG4gIGhlaWdodDogMTAwJTtcXG4gIGZsZXg6IDEgMTtcXG59XFxuXFxuLlRyYW5zbGF0aW9uRXhhbXBsZV90cmFuc2xhdGlvbkNvbnRhaW5lcl9fdU9LVWEge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzFmMDg0NTtcXG4gIGJveC1zaGFkb3c6IDBweCA0cHggMjBweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICBwYWRkaW5nOiAyNXB4O1xcbiAgZmxleDogMSAxO1xcbiAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tY29sb3ItYm94LWJvcmRlcik7XFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjMzIwYjczIDAlLCAjMTIwNzI5IDEwMCUpO1xcbn1cXG5cXG4uVHJhbnNsYXRpb25FeGFtcGxlX3RyYW5zbGF0aW9uQ29udGVudF9fQ2MzMkYge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBmbGV4OiAxIDE7XFxufVxcblxcbi5UcmFuc2xhdGlvbkV4YW1wbGVfdHJhbnNsYXRpb25DYXJkQ29udGFpbmVyX19idl94USB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZ2FwOiAyMHB4O1xcbiAgcGFkZGluZy10b3A6IDE0cHg7XFxuICBwYWRkaW5nLWJvdHRvbTogMTRweDtcXG59XFxuXFxuLlRyYW5zbGF0aW9uRXhhbXBsZV90cmFuc2xhdGlvbkNhcmRfX19aQ1l1IHtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTAwMDJkO1xcbiAgcGFkZGluZzogMThweDtcXG4gIGZsZXg6IDEgMTtcXG59XCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL3NyYy9zdHlsZXMvVHJhbnNsYXRpb25FeGFtcGxlLm1vZHVsZS5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBO0VBQ0UsV0FBQTtFQUNBLGFBQUE7RUFDQSxtQkFBQTtFQUNBLFlBQUE7RUFDQSxzQkFBQTtFQUNBLGlCQUFBO0VBQ0Esb0JBQUE7QUFDRjs7QUFFQTtFQUNFLHlCQUFBO0VBQ0EsbUJBQUE7RUFDQSxrQkFBQTtFQUNBLDJDQUFBO0VBQ0EsYUFBQTtFQUNBLFlBQUE7RUFDQSxZQUFBO0VBQ0EsU0FBQTtBQUNGOztBQUVBO0VBQ0UsYUFBQTtFQUNBLHNCQUFBO0VBQ0EsbUJBQUE7RUFDQSx5QkFBQTtFQUNBLDJDQUFBO0VBQ0EsYUFBQTtFQUNBLFNBQUE7RUFDQSx5Q0FBQTtFQUNBLDZEQUFBO0FBQ0Y7O0FBRUE7RUFDRSxhQUFBO0VBQ0Esc0JBQUE7RUFDQSxTQUFBO0FBQ0Y7O0FBRUE7RUFDRSxhQUFBO0VBQ0EsU0FBQTtFQUNBLGlCQUFBO0VBQ0Esb0JBQUE7QUFDRjs7QUFFQTtFQUNFLG1CQUFBO0VBQ0EseUJBQUE7RUFDQSxhQUFBO0VBQ0EsU0FBQTtBQUNGXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi50cmFuc2xhdGlvblNlY3Rpb24ge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBwYWRkaW5nLXRvcDogNjBweDtcXG4gIHBhZGRpbmctYm90dG9tOiA2MHB4O1xcbn1cXG5cXG4udHJhbnNsYXRpb25JbnB1dCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTUwMDM3O1xcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcXG4gIG1hcmdpbi1yaWdodDogMTBweDtcXG4gIGJveC1zaGFkb3c6IDBweCA0cHggMjBweCByZ2JhKDAsIDAsIDAsIDAuMik7XFxuICBwYWRkaW5nOiAyNXB4O1xcbiAgb3BhY2l0eTogMC43O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgZmxleDogMTtcXG59XFxuXFxuLnRyYW5zbGF0aW9uQ29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMxZjA4NDU7XFxuICBib3gtc2hhZG93OiAwcHggNHB4IDIwcHggcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgcGFkZGluZzogMjVweDtcXG4gIGZsZXg6IDE7XFxuICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1jb2xvci1ib3gtYm9yZGVyKTtcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxMzVkZWcsICMzMjBiNzMgMCUsICMxMjA3MjkgMTAwJSk7XFxufVxcblxcbi50cmFuc2xhdGlvbkNvbnRlbnQge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBmbGV4OiAxO1xcbn1cXG5cXG4udHJhbnNsYXRpb25DYXJkQ29udGFpbmVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBnYXA6IDIwcHg7XFxuICBwYWRkaW5nLXRvcDogMTRweDtcXG4gIHBhZGRpbmctYm90dG9tOiAxNHB4O1xcbn1cXG5cXG4udHJhbnNsYXRpb25DYXJkIHtcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMTAwMDJkO1xcbiAgcGFkZGluZzogMThweDtcXG4gIGZsZXg6IDE7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcInRyYW5zbGF0aW9uU2VjdGlvblwiOiBcIlRyYW5zbGF0aW9uRXhhbXBsZV90cmFuc2xhdGlvblNlY3Rpb25fX0F3X2pFXCIsXG5cdFwidHJhbnNsYXRpb25JbnB1dFwiOiBcIlRyYW5zbGF0aW9uRXhhbXBsZV90cmFuc2xhdGlvbklucHV0X19BXzI2QVwiLFxuXHRcInRyYW5zbGF0aW9uQ29udGFpbmVyXCI6IFwiVHJhbnNsYXRpb25FeGFtcGxlX3RyYW5zbGF0aW9uQ29udGFpbmVyX191T0tVYVwiLFxuXHRcInRyYW5zbGF0aW9uQ29udGVudFwiOiBcIlRyYW5zbGF0aW9uRXhhbXBsZV90cmFuc2xhdGlvbkNvbnRlbnRfX0NjMzJGXCIsXG5cdFwidHJhbnNsYXRpb25DYXJkQ29udGFpbmVyXCI6IFwiVHJhbnNsYXRpb25FeGFtcGxlX3RyYW5zbGF0aW9uQ2FyZENvbnRhaW5lcl9fYnZfeFFcIixcblx0XCJ0cmFuc2xhdGlvbkNhcmRcIjogXCJUcmFuc2xhdGlvbkV4YW1wbGVfdHJhbnNsYXRpb25DYXJkX19fWkNZdVwiXG59O1xubW9kdWxlLmV4cG9ydHMgPSBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/TranslationExample.module.scss\n"));

/***/ }),

/***/ "__barrel_optimize__?names=ArrowRightToLine,Github,Linkedin,Mail,MapPin!=!./node_modules/lucide-react/dist/esm/lucide-react.js":
/*!*************************************************************************************************************************************!*\
  !*** __barrel_optimize__?names=ArrowRightToLine,Github,Linkedin,Mail,MapPin!=!./node_modules/lucide-react/dist/esm/lucide-react.js ***!
  \*************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrowRightToLine: function() { return /* reexport safe */ _icons_arrow_right_to_line_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   Github: function() { return /* reexport safe */ _icons_github_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   Linkedin: function() { return /* reexport safe */ _icons_linkedin_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   Mail: function() { return /* reexport safe */ _icons_mail_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   MapPin: function() { return /* reexport safe */ _icons_map_pin_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _icons_arrow_right_to_line_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icons/arrow-right-to-line.js */ \"./node_modules/lucide-react/dist/esm/icons/arrow-right-to-line.js\");\n/* harmony import */ var _icons_github_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icons/github.js */ \"./node_modules/lucide-react/dist/esm/icons/github.js\");\n/* harmony import */ var _icons_linkedin_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons/linkedin.js */ \"./node_modules/lucide-react/dist/esm/icons/linkedin.js\");\n/* harmony import */ var _icons_mail_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icons/mail.js */ \"./node_modules/lucide-react/dist/esm/icons/mail.js\");\n/* harmony import */ var _icons_map_pin_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./icons/map-pin.js */ \"./node_modules/lucide-react/dist/esm/icons/map-pin.js\");\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX19iYXJyZWxfb3B0aW1pemVfXz9uYW1lcz1BcnJvd1JpZ2h0VG9MaW5lLEdpdGh1YixMaW5rZWRpbixNYWlsLE1hcFBpbiE9IS4vbm9kZV9tb2R1bGVzL2x1Y2lkZS1yZWFjdC9kaXN0L2VzbS9sdWNpZGUtcmVhY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFDNEU7QUFDdkI7QUFDSTtBQUNSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vbHVjaWRlLXJlYWN0LmpzPzNmNDEiXSwic291cmNlc0NvbnRlbnQiOlsiXG5leHBvcnQgeyBkZWZhdWx0IGFzIEFycm93UmlnaHRUb0xpbmUgfSBmcm9tIFwiLi9pY29ucy9hcnJvdy1yaWdodC10by1saW5lLmpzXCJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgR2l0aHViIH0gZnJvbSBcIi4vaWNvbnMvZ2l0aHViLmpzXCJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTGlua2VkaW4gfSBmcm9tIFwiLi9pY29ucy9saW5rZWRpbi5qc1wiXG5leHBvcnQgeyBkZWZhdWx0IGFzIE1haWwgfSBmcm9tIFwiLi9pY29ucy9tYWlsLmpzXCJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTWFwUGluIH0gZnJvbSBcIi4vaWNvbnMvbWFwLXBpbi5qc1wiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///__barrel_optimize__?names=ArrowRightToLine,Github,Linkedin,Mail,MapPin!=!./node_modules/lucide-react/dist/esm/lucide-react.js\n"));

/***/ }),

/***/ "__barrel_optimize__?names=Bold,Download,Highlighter,Italic,Redo,Undo!=!./node_modules/lucide-react/dist/esm/lucide-react.js":
/*!***********************************************************************************************************************************!*\
  !*** __barrel_optimize__?names=Bold,Download,Highlighter,Italic,Redo,Undo!=!./node_modules/lucide-react/dist/esm/lucide-react.js ***!
  \***********************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: function() { return /* reexport safe */ _icons_bold_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   Download: function() { return /* reexport safe */ _icons_download_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   Highlighter: function() { return /* reexport safe */ _icons_highlighter_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   Italic: function() { return /* reexport safe */ _icons_italic_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   Redo: function() { return /* reexport safe */ _icons_redo_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; },\n/* harmony export */   Undo: function() { return /* reexport safe */ _icons_undo_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _icons_bold_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./icons/bold.js */ \"./node_modules/lucide-react/dist/esm/icons/bold.js\");\n/* harmony import */ var _icons_download_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./icons/download.js */ \"./node_modules/lucide-react/dist/esm/icons/download.js\");\n/* harmony import */ var _icons_highlighter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icons/highlighter.js */ \"./node_modules/lucide-react/dist/esm/icons/highlighter.js\");\n/* harmony import */ var _icons_italic_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icons/italic.js */ \"./node_modules/lucide-react/dist/esm/icons/italic.js\");\n/* harmony import */ var _icons_redo_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./icons/redo.js */ \"./node_modules/lucide-react/dist/esm/icons/redo.js\");\n/* harmony import */ var _icons_undo_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./icons/undo.js */ \"./node_modules/lucide-react/dist/esm/icons/undo.js\");\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX19iYXJyZWxfb3B0aW1pemVfXz9uYW1lcz1Cb2xkLERvd25sb2FkLEhpZ2hsaWdodGVyLEl0YWxpYyxSZWRvLFVuZG8hPSEuL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vbHVjaWRlLXJlYWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDaUQ7QUFDUTtBQUNNO0FBQ1Y7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2x1Y2lkZS1yZWFjdC5qcz85ZDY1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuZXhwb3J0IHsgZGVmYXVsdCBhcyBCb2xkIH0gZnJvbSBcIi4vaWNvbnMvYm9sZC5qc1wiXG5leHBvcnQgeyBkZWZhdWx0IGFzIERvd25sb2FkIH0gZnJvbSBcIi4vaWNvbnMvZG93bmxvYWQuanNcIlxuZXhwb3J0IHsgZGVmYXVsdCBhcyBIaWdobGlnaHRlciB9IGZyb20gXCIuL2ljb25zL2hpZ2hsaWdodGVyLmpzXCJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgSXRhbGljIH0gZnJvbSBcIi4vaWNvbnMvaXRhbGljLmpzXCJcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVkbyB9IGZyb20gXCIuL2ljb25zL3JlZG8uanNcIlxuZXhwb3J0IHsgZGVmYXVsdCBhcyBVbmRvIH0gZnJvbSBcIi4vaWNvbnMvdW5kby5qc1wiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///__barrel_optimize__?names=Bold,Download,Highlighter,Italic,Redo,Undo!=!./node_modules/lucide-react/dist/esm/lucide-react.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fnick%2Fprojects%2Fportfolio%2Fsrc%2Fpages%2Findex.tsx&page=%2F!":
/*!*****************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fnick%2Fprojects%2Fportfolio%2Fsrc%2Fpages%2Findex.tsx&page=%2F! ***!
  \*****************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/index.tsx */ \"./src/pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZob21lJTJGbmljayUyRnByb2plY3RzJTJGcG9ydGZvbGlvJTJGc3JjJTJGcGFnZXMlMkZpbmRleC50c3gmcGFnZT0lMkYhIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsb0RBQXVCO0FBQzlDO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz8zN2M4Il0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiLi9zcmMvcGFnZXMvaW5kZXgudHN4XCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9cIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fnick%2Fprojects%2Fportfolio%2Fsrc%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./src/styles/Hero.module.scss":
/*!*************************************!*\
  !*** ./src/styles/Hero.module.scss ***!
  \*************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./Hero.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/Hero.module.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./Hero.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/Hero.module.scss\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./Hero.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/Hero.module.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL0hlcm8ubW9kdWxlLnNjc3MiLCJtYXBwaW5ncyI6IkFBQUEsVUFBVSxtQkFBTyxDQUFDLHVOQUEyRztBQUM3SCwwQkFBMEIsbUJBQU8sQ0FBQywrNUJBQWdkOztBQUVsZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sKzVCQUFnZDtBQUN0ZDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLCs1QkFBZ2Q7O0FBRTFlOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdHlsZXMvSGVyby5tb2R1bGUuc2Nzcz84ODAyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzNdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbNF0hLi9IZXJvLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBzdHlsZS1sb2FkZXIgaW5qZWN0cyBDU1MgaW50byB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mIDxoZWFkPi4gVGhpcyBjYXVzZXMgb3JkZXJpbmcgcHJvYmxlbXMgYmV0d2VlbiBkZXZcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHByb2QuIFRvIGZpeCB0aGlzLCB3ZSByZW5kZXIgYSA8bm9zY3JpcHQ+IHRhZyBhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhbiBhbmNob3IgZm9yIHRoZSBzdHlsZXMgdG8gYmUgcGxhY2VkIGJlZm9yZS4gVGhlc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBfYmVmb3JlXyA8c3R5bGUganN4IGdsb2JhbD4uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIGVsZW1lbnRzIHNob3VsZCBhbHdheXMgZXhpc3QuIElmIHRoZXkgZG8gbm90LFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNfX25leHRfY3NzX19ET19OT1RfVVNFX19cIik7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFjaCBzdHlsZSB0YWcgc2hvdWxkIGJlIHBsYWNlZCByaWdodCBiZWZvcmUgb3VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byB0cmFjayB0aGUgbGFzdCBpbnNlcnRlZCBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50LCBhbmNob3JFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFbcF0gIT09IGJbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IocCBpbiBiKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYVtwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbiAgICB2YXIgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcbiAgICAgIFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzNdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbNF0hLi9IZXJvLm1vZHVsZS5zY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzNdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbNF0hLi9IZXJvLm1vZHVsZS5zY3NzXCIpO1xuXG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWlzRXF1YWxMb2NhbHMob2xkTG9jYWxzLCBjb250ZW50LmxvY2FscykpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGUuaG90LmludmFsaWRhdGUoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgICAgICAgICAgIHVwZGF0ZShjb250ZW50KTtcbiAgICAgIH1cbiAgICApXG4gIH1cblxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG4gICAgdXBkYXRlKCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/styles/Hero.module.scss\n"));

/***/ }),

/***/ "./src/styles/TranslationExample.module.scss":
/*!***************************************************!*\
  !*** ./src/styles/TranslationExample.module.scss ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./TranslationExample.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/TranslationExample.module.scss\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./TranslationExample.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/TranslationExample.module.scss\",\n      function () {\n        content = __webpack_require__(/*! !!../../node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!../../node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!../../node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!../../node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./TranslationExample.module.scss */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[6].oneOf[10].use[2]!./node_modules/next/dist/build/webpack/loaders/resolve-url-loader/index.js??ruleSet[1].rules[6].oneOf[10].use[3]!./node_modules/next/dist/compiled/sass-loader/cjs.js??ruleSet[1].rules[6].oneOf[10].use[4]!./src/styles/TranslationExample.module.scss\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc3R5bGVzL1RyYW5zbGF0aW9uRXhhbXBsZS5tb2R1bGUuc2NzcyIsIm1hcHBpbmdzIjoiQUFBQSxVQUFVLG1CQUFPLENBQUMsdU5BQTJHO0FBQzdILDBCQUEwQixtQkFBTyxDQUFDLDI3QkFBOGQ7O0FBRWhnQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0sMjdCQUE4ZDtBQUNwZTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLDI3QkFBOGQ7O0FBRXhmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixVQUFVOztBQUUxQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUUsVUFBVTtBQUNaO0FBQ0EsR0FBRztBQUNIOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9zdHlsZXMvVHJhbnNsYXRpb25FeGFtcGxlLm1vZHVsZS5zY3NzP2NhYjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcmVzb2x2ZS11cmwtbG9hZGVyL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbM10hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9zYXNzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbMTBdLnVzZVs0XSEuL1RyYW5zbGF0aW9uRXhhbXBsZS5tb2R1bGUuc2Nzc1wiKTtcblxuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgfVxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCwgc3R5bGUtbG9hZGVyIGluamVjdHMgQ1NTIGludG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICAvLyBvZiA8aGVhZD4uIFRoaXMgY2F1c2VzIG9yZGVyaW5nIHByb2JsZW1zIGJldHdlZW4gZGV2XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBwcm9kLiBUbyBmaXggdGhpcywgd2UgcmVuZGVyIGEgPG5vc2NyaXB0PiB0YWcgYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYW5jaG9yIGZvciB0aGUgc3R5bGVzIHRvIGJlIHBsYWNlZCBiZWZvcmUuIFRoZXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgX2JlZm9yZV8gPHN0eWxlIGpzeCBnbG9iYWw+LlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBlbGVtZW50cyBzaG91bGQgYWx3YXlzIGV4aXN0LiBJZiB0aGV5IGRvIG5vdCxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjX19uZXh0X2Nzc19fRE9fTk9UX1VTRV9fXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGFuY2hvckVsZW1lbnQucGFyZW50Tm9kZS8vIE5vcm1hbGx5IDxoZWFkPlxuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgICAgICAvLyBhbmNob3IuIEJ5IGluc2VydGluZyBiZWZvcmUgYW5kIG5vdCBhZnRlciwgd2UgZG8gbm90XG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgaWYgKCFjb250ZW50LmxvY2FscyB8fCBtb2R1bGUuaG90LmludmFsaWRhdGUpIHtcbiAgICB2YXIgaXNFcXVhbExvY2FscyA9IGZ1bmN0aW9uIGlzRXF1YWxMb2NhbHMoYSwgYiwgaXNOYW1lZEV4cG9ydCkge1xuICAgIGlmICghYSAmJiBiIHx8IGEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgcDtcbiAgICBmb3IocCBpbiBhKXtcbiAgICAgICAgaWYgKGlzTmFtZWRFeHBvcnQgJiYgcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFbcF0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbMTBdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbMTBdLnVzZVsyXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9yZXNvbHZlLXVybC1sb2FkZXIvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbNl0ub25lT2ZbMTBdLnVzZVszXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Nhc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzRdIS4vVHJhbnNsYXRpb25FeGFtcGxlLm1vZHVsZS5zY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Jlc29sdmUtdXJsLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1s2XS5vbmVPZlsxMF0udXNlWzNdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvc2Fzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzZdLm9uZU9mWzEwXS51c2VbNF0hLi9UcmFuc2xhdGlvbkV4YW1wbGUubW9kdWxlLnNjc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/styles/TranslationExample.module.scss\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/Icon.js":
/*!****************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/Icon.js ***!
  \****************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Icon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"./node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst Icon = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(_c = (param, ref)=>{\n    let { color = \"currentColor\", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = \"\", children, iconNode, ...rest } = param;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n        ref,\n        ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n        width: size,\n        height: size,\n        stroke: color,\n        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n        className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide\", className),\n        ...!children && !(0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.hasA11yProp)(rest) && {\n            \"aria-hidden\": \"true\"\n        },\n        ...rest\n    }, [\n        ...iconNode.map((param)=>{\n            let [tag, attrs] = param;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs);\n        }),\n        ...Array.isArray(children) ? children : [\n            children\n        ]\n    ]);\n});\n_c1 = Icon;\n //# sourceMappingURL=Icon.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Icon$forwardRef\");\n$RefreshReg$(_c1, \"Icon\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL0ljb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxNQUFNQSxxQkFBT0MsaURBQVVBLE1BQ3JCLFFBV0VDO1FBVkEsRUFDRUMsUUFBUSxnQkFDUkMsT0FBTyxJQUNQQyxjQUFjLEdBQ2RDLG1CQUFBLEVBQ0FDLFlBQVksSUFDWkMsUUFBQSxFQUNBQyxRQUFBLEVBQ0EsR0FBR0MsTUFBQTt5QkFJTEMsb0RBQWFBLENBQ1gsT0FDQTtRQUNFVDtRQUNBLEdBQUdVLDZEQUFBO1FBQ0hDLE9BQU9UO1FBQ1BVLFFBQVFWO1FBQ1JXLFFBQVFaO1FBQ1JFLGFBQWFDLHNCQUF1QlUsT0FBT1gsZUFBZSxLQUFNVyxPQUFPWixRQUFRQztRQUMvRUUsV0FBV1Usa0VBQVlBLENBQUMsVUFBVVY7UUFDbEMsR0FBSSxDQUFDQyxZQUFZLENBQUNVLGlFQUFXQSxDQUFDUixTQUFTO1lBQUUsZUFBZTtRQUFBLENBQU87UUFDL0QsR0FBR0EsSUFBQTtJQUFBLEdBRUw7V0FDS0QsU0FBU1UsR0FBQSxDQUFJO2dCQUFDLENBQUNDLEtBQUtDLE1BQUs7aUNBQU1WLG9EQUFhQSxDQUFDUyxLQUFLQzs7V0FDakRDLE1BQU1DLE9BQUEsQ0FBUWYsWUFBWUEsV0FBVztZQUFDQTtTQUFRO0tBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9JY29uLnRzP2FkYWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBkZWZhdWx0QXR0cmlidXRlcyBmcm9tICcuL2RlZmF1bHRBdHRyaWJ1dGVzJztcbmltcG9ydCB7IEljb25Ob2RlLCBMdWNpZGVQcm9wcyB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzLCBoYXNBMTF5UHJvcCB9IGZyb20gJ0BsdWNpZGUvc2hhcmVkJztcblxuaW50ZXJmYWNlIEljb25Db21wb25lbnRQcm9wcyBleHRlbmRzIEx1Y2lkZVByb3BzIHtcbiAgaWNvbk5vZGU6IEljb25Ob2RlO1xufVxuXG4vKipcbiAqIEx1Y2lkZSBpY29uIGNvbXBvbmVudFxuICpcbiAqIEBjb21wb25lbnQgSWNvblxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMuY29sb3IgLSBUaGUgY29sb3Igb2YgdGhlIGljb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy5zaXplIC0gVGhlIHNpemUgb2YgdGhlIGljb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBwcm9wcy5zdHJva2VXaWR0aCAtIFRoZSBzdHJva2Ugd2lkdGggb2YgdGhlIGljb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJvcHMuYWJzb2x1dGVTdHJva2VXaWR0aCAtIFdoZXRoZXIgdG8gdXNlIGFic29sdXRlIHN0cm9rZSB3aWR0aFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BzLmNsYXNzTmFtZSAtIFRoZSBjbGFzcyBuYW1lIG9mIHRoZSBpY29uXG4gKiBAcGFyYW0ge0ljb25Ob2RlfSBwcm9wcy5jaGlsZHJlbiAtIFRoZSBjaGlsZHJlbiBvZiB0aGUgaWNvblxuICogQHBhcmFtIHtJY29uTm9kZX0gcHJvcHMuaWNvbk5vZGUgLSBUaGUgaWNvbiBub2RlIG9mIHRoZSBpY29uXG4gKlxuICogQHJldHVybnMge0ZvcndhcmRSZWZFeG90aWNDb21wb25lbnR9IEx1Y2lkZUljb25cbiAqL1xuY29uc3QgSWNvbiA9IGZvcndhcmRSZWY8U1ZHU1ZHRWxlbWVudCwgSWNvbkNvbXBvbmVudFByb3BzPihcbiAgKFxuICAgIHtcbiAgICAgIGNvbG9yID0gJ2N1cnJlbnRDb2xvcicsXG4gICAgICBzaXplID0gMjQsXG4gICAgICBzdHJva2VXaWR0aCA9IDIsXG4gICAgICBhYnNvbHV0ZVN0cm9rZVdpZHRoLFxuICAgICAgY2xhc3NOYW1lID0gJycsXG4gICAgICBjaGlsZHJlbixcbiAgICAgIGljb25Ob2RlLFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgcmVmLFxuICApID0+XG4gICAgY3JlYXRlRWxlbWVudChcbiAgICAgICdzdmcnLFxuICAgICAge1xuICAgICAgICByZWYsXG4gICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgICB3aWR0aDogc2l6ZSxcbiAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aDogYWJzb2x1dGVTdHJva2VXaWR0aCA/IChOdW1iZXIoc3Ryb2tlV2lkdGgpICogMjQpIC8gTnVtYmVyKHNpemUpIDogc3Ryb2tlV2lkdGgsXG4gICAgICAgIGNsYXNzTmFtZTogbWVyZ2VDbGFzc2VzKCdsdWNpZGUnLCBjbGFzc05hbWUpLFxuICAgICAgICAuLi4oIWNoaWxkcmVuICYmICFoYXNBMTF5UHJvcChyZXN0KSAmJiB7ICdhcmlhLWhpZGRlbic6ICd0cnVlJyB9KSxcbiAgICAgICAgLi4ucmVzdCxcbiAgICAgIH0sXG4gICAgICBbXG4gICAgICAgIC4uLmljb25Ob2RlLm1hcCgoW3RhZywgYXR0cnNdKSA9PiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpKSxcbiAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dKSxcbiAgICAgIF0sXG4gICAgKSxcbik7XG5cbmV4cG9ydCBkZWZhdWx0IEljb247XG4iXSwibmFtZXMiOlsiSWNvbiIsImZvcndhcmRSZWYiLCJyZWYiLCJjb2xvciIsInNpemUiLCJzdHJva2VXaWR0aCIsImFic29sdXRlU3Ryb2tlV2lkdGgiLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsImljb25Ob2RlIiwicmVzdCIsImNyZWF0ZUVsZW1lbnQiLCJkZWZhdWx0QXR0cmlidXRlcyIsIndpZHRoIiwiaGVpZ2h0Iiwic3Ryb2tlIiwiTnVtYmVyIiwibWVyZ2VDbGFzc2VzIiwiaGFzQTExeVByb3AiLCJtYXAiLCJ0YWciLCJhdHRycyIsIkFycmF5IiwiaXNBcnJheSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/Icon.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createLucideIcon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shared/src/utils.js */ \"./node_modules/lucide-react/dist/esm/shared/src/utils.js\");\n/* harmony import */ var _Icon_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Icon.js */ \"./node_modules/lucide-react/dist/esm/Icon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\n\nconst createLucideIcon = (iconName, iconNode)=>{\n    const Component = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((param, ref)=>{\n        let { className, ...props } = param;\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(_Icon_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n            ref,\n            iconNode,\n            className: (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.mergeClasses)(\"lucide-\".concat((0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toKebabCase)((0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toPascalCase)(iconName))), \"lucide-\".concat(iconName), className),\n            ...props\n        });\n    });\n    Component.displayName = (0,_shared_src_utils_js__WEBPACK_IMPORTED_MODULE_2__.toPascalCase)(iconName);\n    return Component;\n};\n //# sourceMappingURL=createLucideIcon.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2NyZWF0ZUx1Y2lkZUljb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQVdBLE1BQU1BLG1CQUFtQixDQUFDQyxVQUFrQkM7SUFDMUMsTUFBTUMsMEJBQVlDLGlEQUFVQSxDQUE2QixRQUEwQkM7WUFBekIsRUFBRUMsU0FBQSxFQUFXLEdBQUdDLE9BQU07NkJBQzlFQyxvREFBYUEsQ0FBQ0MsZ0RBQUlBLEVBQUU7WUFDbEJKO1lBQ0FIO1lBQ0FJLFdBQVdJLGtFQUFZQSxDQUNyQixVQUE2QyxPQUFuQ0MsaUVBQVdBLENBQUNDLGtFQUFZQSxDQUFDWCxhQUNuQyxVQUFrQixPQUFSQSxXQUNWSztZQUVGLEdBQUdDLEtBQUE7UUFBQTs7SUFJUEosVUFBVVUsV0FBQSxHQUFjRCxrRUFBWUEsQ0FBQ1g7SUFFckMsT0FBT0U7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2NyZWF0ZUx1Y2lkZUljb24udHM/MDQ4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWVyZ2VDbGFzc2VzLCB0b0tlYmFiQ2FzZSwgdG9QYXNjYWxDYXNlIH0gZnJvbSAnQGx1Y2lkZS9zaGFyZWQnO1xuaW1wb3J0IHsgSWNvbk5vZGUsIEx1Y2lkZVByb3BzIH0gZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgSWNvbiBmcm9tICcuL0ljb24nO1xuXG4vKipcbiAqIENyZWF0ZSBhIEx1Y2lkZSBpY29uIGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGljb25OYW1lXG4gKiBAcGFyYW0ge2FycmF5fSBpY29uTm9kZVxuICogQHJldHVybnMge0ZvcndhcmRSZWZFeG90aWNDb21wb25lbnR9IEx1Y2lkZUljb25cbiAqL1xuY29uc3QgY3JlYXRlTHVjaWRlSWNvbiA9IChpY29uTmFtZTogc3RyaW5nLCBpY29uTm9kZTogSWNvbk5vZGUpID0+IHtcbiAgY29uc3QgQ29tcG9uZW50ID0gZm9yd2FyZFJlZjxTVkdTVkdFbGVtZW50LCBMdWNpZGVQcm9wcz4oKHsgY2xhc3NOYW1lLCAuLi5wcm9wcyB9LCByZWYpID0+XG4gICAgY3JlYXRlRWxlbWVudChJY29uLCB7XG4gICAgICByZWYsXG4gICAgICBpY29uTm9kZSxcbiAgICAgIGNsYXNzTmFtZTogbWVyZ2VDbGFzc2VzKFxuICAgICAgICBgbHVjaWRlLSR7dG9LZWJhYkNhc2UodG9QYXNjYWxDYXNlKGljb25OYW1lKSl9YCxcbiAgICAgICAgYGx1Y2lkZS0ke2ljb25OYW1lfWAsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICksXG4gICAgICAuLi5wcm9wcyxcbiAgICB9KSxcbiAgKTtcblxuICBDb21wb25lbnQuZGlzcGxheU5hbWUgPSB0b1Bhc2NhbENhc2UoaWNvbk5hbWUpO1xuXG4gIHJldHVybiBDb21wb25lbnQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVMdWNpZGVJY29uO1xuIl0sIm5hbWVzIjpbImNyZWF0ZUx1Y2lkZUljb24iLCJpY29uTmFtZSIsImljb25Ob2RlIiwiQ29tcG9uZW50IiwiZm9yd2FyZFJlZiIsInJlZiIsImNsYXNzTmFtZSIsInByb3BzIiwiY3JlYXRlRWxlbWVudCIsIkljb24iLCJtZXJnZUNsYXNzZXMiLCJ0b0tlYmFiQ2FzZSIsInRvUGFzY2FsQ2FzZSIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \*****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ defaultAttributes; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ var defaultAttributes = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n};\n //# sourceMappingURL=defaultAttributes.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2RlZmF1bHRBdHRyaWJ1dGVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztJQUFBLElBQUFBLG9CQUFlO0lBQ2JDLE9BQU87SUFDUEMsT0FBTztJQUNQQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLGFBQWE7SUFDYkMsZUFBZTtJQUNmQyxnQkFBZ0I7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9kZWZhdWx0QXR0cmlidXRlcy50cz8zNzBjIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IHtcbiAgeG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG4gIHdpZHRoOiAyNCxcbiAgaGVpZ2h0OiAyNCxcbiAgdmlld0JveDogJzAgMCAyNCAyNCcsXG4gIGZpbGw6ICdub25lJyxcbiAgc3Ryb2tlOiAnY3VycmVudENvbG9yJyxcbiAgc3Ryb2tlV2lkdGg6IDIsXG4gIHN0cm9rZUxpbmVjYXA6ICdyb3VuZCcsXG4gIHN0cm9rZUxpbmVqb2luOiAncm91bmQnLFxufTtcbiJdLCJuYW1lcyI6WyJkZWZhdWx0QXR0cmlidXRlcyIsInhtbG5zIiwid2lkdGgiLCJoZWlnaHQiLCJ2aWV3Qm94IiwiZmlsbCIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZUxpbmVqb2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/arrow-right-to-line.js":
/*!*************************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/arrow-right-to-line.js ***!
  \*************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ ArrowRightToLine; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M17 12H3\",\n            key: \"8awo09\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m11 18 6-6-6-6\",\n            key: \"8c2y43\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M21 5v14\",\n            key: \"nzette\"\n        }\n    ]\n];\nconst ArrowRightToLine = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"arrow-right-to-line\", __iconNode);\n //# sourceMappingURL=arrow-right-to-line.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2Fycm93LXJpZ2h0LXRvLWxpbmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR08sTUFBTUEsYUFBdUI7SUFDbEM7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBWUMsS0FBSztRQUFBO0tBQVU7SUFDekM7UUFBQztRQUFRO1lBQUVELEdBQUc7WUFBa0JDLEtBQUs7UUFBQTtLQUFVO0lBQy9DO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQVlDLEtBQUs7UUFBQTtLQUFVO0NBQzNDO0FBYUEsTUFBTUMsbUJBQW1CQyxnRUFBZ0JBLENBQUMsdUJBQXVCSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL2Fycm93LXJpZ2h0LXRvLWxpbmUudHM/ZDY1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcbmltcG9ydCB7IEljb25Ob2RlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgX19pY29uTm9kZTogSWNvbk5vZGUgPSBbXG4gIFsncGF0aCcsIHsgZDogJ00xNyAxMkgzJywga2V5OiAnOGF3bzA5JyB9XSxcbiAgWydwYXRoJywgeyBkOiAnbTExIDE4IDYtNi02LTYnLCBrZXk6ICc4YzJ5NDMnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNMjEgNXYxNCcsIGtleTogJ256ZXR0ZScgfV0sXG5dO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgQXJyb3dSaWdodFRvTGluZVxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTVRjZ01USklNeUlnTHo0S0lDQThjR0YwYUNCa1BTSnRNVEVnTVRnZ05pMDJMVFl0TmlJZ0x6NEtJQ0E4Y0dGMGFDQmtQU0pOTWpFZ05YWXhOQ0lnTHo0S1BDOXpkbWMrQ2c9PSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvYXJyb3ctcmlnaHQtdG8tbGluZVxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IEFycm93UmlnaHRUb0xpbmUgPSBjcmVhdGVMdWNpZGVJY29uKCdhcnJvdy1yaWdodC10by1saW5lJywgX19pY29uTm9kZSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFycm93UmlnaHRUb0xpbmU7XG4iXSwibmFtZXMiOlsiX19pY29uTm9kZSIsImQiLCJrZXkiLCJBcnJvd1JpZ2h0VG9MaW5lIiwiY3JlYXRlTHVjaWRlSWNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/arrow-right-to-line.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/bold.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/bold.js ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Bold; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M6 12h9a4 4 0 0 1 0 8H7a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h7a4 4 0 0 1 0 8\",\n            key: \"mg9rjx\"\n        }\n    ]\n];\nconst Bold = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"bold\", __iconNode);\n //# sourceMappingURL=bold.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2JvbGQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR08sTUFBTUEsYUFBdUI7SUFDbEM7UUFDRTtRQUNBO1lBQUVDLEdBQUc7WUFBeUVDLEtBQUs7UUFBQTtLQUFTO0NBRWhHO0FBYUEsTUFBTUMsT0FBT0MsZ0VBQWdCQSxDQUFDLFFBQVFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvYm9sZC50cz9mOThjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgW1xuICAgICdwYXRoJyxcbiAgICB7IGQ6ICdNNiAxMmg5YTQgNCAwIDAgMSAwIDhIN2ExIDEgMCAwIDEtMS0xVjVhMSAxIDAgMCAxIDEtMWg3YTQgNCAwIDAgMSAwIDgnLCBrZXk6ICdtZzlyangnIH0sXG4gIF0sXG5dO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgQm9sZFxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTmlBeE1tZzVZVFFnTkNBd0lEQWdNU0F3SURoSU4yRXhJREVnTUNBd0lERXRNUzB4VmpWaE1TQXhJREFnTUNBeElERXRNV2czWVRRZ05DQXdJREFnTVNBd0lEZ2lJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9ib2xkXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgQm9sZCA9IGNyZWF0ZUx1Y2lkZUljb24oJ2JvbGQnLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgQm9sZDtcbiJdLCJuYW1lcyI6WyJfX2ljb25Ob2RlIiwiZCIsImtleSIsIkJvbGQiLCJjcmVhdGVMdWNpZGVJY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/bold.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/download.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/download.js ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Download; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M12 15V3\",\n            key: \"m9g1x1\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4\",\n            key: \"ih7n3h\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m7 10 5 5 5-5\",\n            key: \"brsn70\"\n        }\n    ]\n];\nconst Download = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"download\", __iconNode);\n //# sourceMappingURL=download.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2Rvd25sb2FkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUdPLE1BQU1BLGFBQXVCO0lBQ2xDO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQVlDLEtBQUs7UUFBQTtLQUFVO0lBQ3pDO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQTZDQyxLQUFLO1FBQUE7S0FBVTtJQUMxRTtRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFpQkMsS0FBSztRQUFBO0tBQVU7Q0FDaEQ7QUFhQSxNQUFNQyxXQUFXQyxnRUFBZ0JBLENBQUMsWUFBWUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9pY29ucy9kb3dubG9hZC50cz83YTNlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgWydwYXRoJywgeyBkOiAnTTEyIDE1VjMnLCBrZXk6ICdtOWcxeDEnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNMjEgMTV2NGEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnYtNCcsIGtleTogJ2loN24zaCcgfV0sXG4gIFsncGF0aCcsIHsgZDogJ203IDEwIDUgNSA1LTUnLCBrZXk6ICdicnNuNzAnIH1dLFxuXTtcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIERvd25sb2FkXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NVElnTVRWV015SWdMejRLSUNBOGNHRjBhQ0JrUFNKTk1qRWdNVFYyTkdFeUlESWdNQ0F3SURFdE1pQXlTRFZoTWlBeUlEQWdNQ0F4TFRJdE1uWXROQ0lnTHo0S0lDQThjR0YwYUNCa1BTSnROeUF4TUNBMUlEVWdOUzAxSWlBdlBnbzhMM04yWno0SykgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvZG93bmxvYWRcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBEb3dubG9hZCA9IGNyZWF0ZUx1Y2lkZUljb24oJ2Rvd25sb2FkJywgX19pY29uTm9kZSk7XG5cbmV4cG9ydCBkZWZhdWx0IERvd25sb2FkO1xuIl0sIm5hbWVzIjpbIl9faWNvbk5vZGUiLCJkIiwia2V5IiwiRG93bmxvYWQiLCJjcmVhdGVMdWNpZGVJY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/download.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/github.js":
/*!************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/github.js ***!
  \************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Github; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4\",\n            key: \"tonef\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M9 18c-4.51 2-5-2-7-2\",\n            key: \"9comsn\"\n        }\n    ]\n];\nconst Github = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"github\", __iconNode);\n //# sourceMappingURL=github.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2dpdGh1Yi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFHTyxNQUFNQSxhQUF1QjtJQUNsQztRQUNFO1FBQ0E7WUFDRUMsR0FBRztZQUNIQyxLQUFLO1FBQUE7S0FFVDtJQUNBO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQXlCQyxLQUFLO1FBQUE7S0FBVTtDQUN4RDtBQWFBLE1BQU1DLFNBQVNDLGdFQUFnQkEsQ0FBQyxVQUFVSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL2dpdGh1Yi50cz8yNmJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgW1xuICAgICdwYXRoJyxcbiAgICB7XG4gICAgICBkOiAnTTE1IDIydi00YTQuOCA0LjggMCAwIDAtMS0zLjVjMyAwIDYtMiA2LTUuNS4wOC0xLjI1LS4yNy0yLjQ4LTEtMy41LjI4LTEuMTUuMjgtMi4zNSAwLTMuNSAwIDAtMSAwLTMgMS41LTIuNjQtLjUtNS4zNi0uNS04IDBDNiAyIDUgMiA1IDJjLS4zIDEuMTUtLjMgMi4zNSAwIDMuNUE1LjQwMyA1LjQwMyAwIDAgMCA0IDljMCAzLjUgMyA1LjUgNiA1LjUtLjM5LjQ5LS42OCAxLjA1LS44NSAxLjY1LS4xNy42LS4yMiAxLjIzLS4xNSAxLjg1djQnLFxuICAgICAga2V5OiAndG9uZWYnLFxuICAgIH0sXG4gIF0sXG4gIFsncGF0aCcsIHsgZDogJ005IDE4Yy00LjUxIDItNS0yLTctMicsIGtleTogJzljb21zbicgfV0sXG5dO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgR2l0aHViXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NVFVnTWpKMkxUUmhOQzQ0SURRdU9DQXdJREFnTUMweExUTXVOV016SURBZ05pMHlJRFl0TlM0MUxqQTRMVEV1TWpVdExqSTNMVEl1TkRndE1TMHpMalV1TWpndE1TNHhOUzR5T0MweUxqTTFJREF0TXk0MUlEQWdNQzB4SURBdE15QXhMalV0TWk0Mk5DMHVOUzAxTGpNMkxTNDFMVGdnTUVNMklESWdOU0F5SURVZ01tTXRMak1nTVM0eE5TMHVNeUF5TGpNMUlEQWdNeTQxUVRVdU5EQXpJRFV1TkRBeklEQWdNQ0F3SURRZ09XTXdJRE11TlNBeklEVXVOU0EySURVdU5TMHVNemt1TkRrdExqWTRJREV1TURVdExqZzFJREV1TmpVdExqRTNMall0TGpJeUlERXVNak10TGpFMUlERXVPRFYyTkNJZ0x6NEtJQ0E4Y0dGMGFDQmtQU0pOT1NBeE9HTXROQzQxTVNBeUxUVXRNaTAzTFRJaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2dpdGh1YlxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqIEBkZXByZWNhdGVkIEJyYW5kIGljb25zIGhhdmUgYmVlbiBkZXByZWNhdGVkIGFuZCBhcmUgZHVlIHRvIGJlIHJlbW92ZWQsIHBsZWFzZSByZWZlciB0byBodHRwczovL2dpdGh1Yi5jb20vbHVjaWRlLWljb25zL2x1Y2lkZS9pc3N1ZXMvNjcwLiBXZSByZWNvbW1lbmQgdXNpbmcgaHR0cHM6Ly9zaW1wbGVpY29ucy5vcmcvP3E9Z2l0aHViIGluc3RlYWQuIFRoaXMgaWNvbiB3aWxsIGJlIHJlbW92ZWQgaW4gdjEuMFxuICovXG5jb25zdCBHaXRodWIgPSBjcmVhdGVMdWNpZGVJY29uKCdnaXRodWInLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgR2l0aHViO1xuIl0sIm5hbWVzIjpbIl9faWNvbk5vZGUiLCJkIiwia2V5IiwiR2l0aHViIiwiY3JlYXRlTHVjaWRlSWNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/github.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/highlighter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/highlighter.js ***!
  \*****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Highlighter; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"m9 11-6 6v3h9l3-3\",\n            key: \"1a3l36\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m22 12-4.6 4.6a2 2 0 0 1-2.8 0l-5.2-5.2a2 2 0 0 1 0-2.8L14 4\",\n            key: \"14a9rk\"\n        }\n    ]\n];\nconst Highlighter = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"highlighter\", __iconNode);\n //# sourceMappingURL=highlighter.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2hpZ2hsaWdodGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUdPLE1BQU1BLGFBQXVCO0lBQ2xDO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQXFCQyxLQUFLO1FBQUE7S0FBVTtJQUNsRDtRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFnRUMsS0FBSztRQUFBO0tBQVU7Q0FDL0Y7QUFhQSxNQUFNQyxjQUFjQyxnRUFBZ0JBLENBQUMsZUFBZUoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9pY29ucy9oaWdobGlnaHRlci50cz9lN2Y2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgWydwYXRoJywgeyBkOiAnbTkgMTEtNiA2djNoOWwzLTMnLCBrZXk6ICcxYTNsMzYnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdtMjIgMTItNC42IDQuNmEyIDIgMCAwIDEtMi44IDBsLTUuMi01LjJhMiAyIDAgMCAxIDAtMi44TDE0IDQnLCBrZXk6ICcxNGE5cmsnIH1dLFxuXTtcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIEhpZ2hsaWdodGVyXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSnRPU0F4TVMwMklEWjJNMmc1YkRNdE15SWdMejRLSUNBOGNHRjBhQ0JrUFNKdE1qSWdNVEl0TkM0MklEUXVObUV5SURJZ01DQXdJREV0TWk0NElEQnNMVFV1TWkwMUxqSmhNaUF5SURBZ01DQXhJREF0TWk0NFRERTBJRFFpSUM4K0Nqd3ZjM1puUGdvPSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvaGlnaGxpZ2h0ZXJcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBIaWdobGlnaHRlciA9IGNyZWF0ZUx1Y2lkZUljb24oJ2hpZ2hsaWdodGVyJywgX19pY29uTm9kZSk7XG5cbmV4cG9ydCBkZWZhdWx0IEhpZ2hsaWdodGVyO1xuIl0sIm5hbWVzIjpbIl9faWNvbk5vZGUiLCJkIiwia2V5IiwiSGlnaGxpZ2h0ZXIiLCJjcmVhdGVMdWNpZGVJY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/highlighter.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/italic.js":
/*!************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/italic.js ***!
  \************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Italic; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"line\",\n        {\n            x1: \"19\",\n            x2: \"10\",\n            y1: \"4\",\n            y2: \"4\",\n            key: \"15jd3p\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"14\",\n            x2: \"5\",\n            y1: \"20\",\n            y2: \"20\",\n            key: \"bu0au3\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"15\",\n            x2: \"9\",\n            y1: \"4\",\n            y2: \"20\",\n            key: \"uljnxc\"\n        }\n    ]\n];\nconst Italic = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"italic\", __iconNode);\n //# sourceMappingURL=italic.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2l0YWxpYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFHTyxNQUFNQSxhQUF1QjtJQUNsQztRQUFDO1FBQVE7WUFBRUMsSUFBSTtZQUFNQyxJQUFJO1lBQU1DLElBQUk7WUFBS0MsSUFBSTtZQUFLQyxLQUFLO1FBQUE7S0FBVTtJQUNoRTtRQUFDO1FBQVE7WUFBRUosSUFBSTtZQUFNQyxJQUFJO1lBQUtDLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxLQUFLO1FBQUE7S0FBVTtJQUNqRTtRQUFDO1FBQVE7WUFBRUosSUFBSTtZQUFNQyxJQUFJO1lBQUtDLElBQUk7WUFBS0MsSUFBSTtZQUFNQyxLQUFLO1FBQUE7S0FBVTtDQUNsRTtBQWFBLE1BQU1DLFNBQVNDLGdFQUFnQkEsQ0FBQyxVQUFVUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL2l0YWxpYy50cz9jODI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgWydsaW5lJywgeyB4MTogJzE5JywgeDI6ICcxMCcsIHkxOiAnNCcsIHkyOiAnNCcsIGtleTogJzE1amQzcCcgfV0sXG4gIFsnbGluZScsIHsgeDE6ICcxNCcsIHgyOiAnNScsIHkxOiAnMjAnLCB5MjogJzIwJywga2V5OiAnYnUwYXUzJyB9XSxcbiAgWydsaW5lJywgeyB4MTogJzE1JywgeDI6ICc5JywgeTE6ICc0JywgeTI6ICcyMCcsIGtleTogJ3Vsam54YycgfV0sXG5dO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgSXRhbGljXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThiR2x1WlNCNE1UMGlNVGtpSUhneVBTSXhNQ0lnZVRFOUlqUWlJSGt5UFNJMElpQXZQZ29nSUR4c2FXNWxJSGd4UFNJeE5DSWdlREk5SWpVaUlIa3hQU0l5TUNJZ2VUSTlJakl3SWlBdlBnb2dJRHhzYVc1bElIZ3hQU0l4TlNJZ2VESTlJamtpSUhreFBTSTBJaUI1TWowaU1qQWlJQzgrQ2p3dmMzWm5QZ289KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9pdGFsaWNcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBJdGFsaWMgPSBjcmVhdGVMdWNpZGVJY29uKCdpdGFsaWMnLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgSXRhbGljO1xuIl0sIm5hbWVzIjpbIl9faWNvbk5vZGUiLCJ4MSIsIngyIiwieTEiLCJ5MiIsImtleSIsIkl0YWxpYyIsImNyZWF0ZUx1Y2lkZUljb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/italic.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/linkedin.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/linkedin.js ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Linkedin; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z\",\n            key: \"c2jq9f\"\n        }\n    ],\n    [\n        \"rect\",\n        {\n            width: \"4\",\n            height: \"12\",\n            x: \"2\",\n            y: \"9\",\n            key: \"mk3on5\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"4\",\n            cy: \"4\",\n            r: \"2\",\n            key: \"bt5ra8\"\n        }\n    ]\n];\nconst Linkedin = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"linkedin\", __iconNode);\n //# sourceMappingURL=linkedin.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL2xpbmtlZGluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUdPLE1BQU1BLGFBQXVCO0lBQ2xDO1FBQ0U7UUFDQTtZQUNFQyxHQUFHO1lBQ0hDLEtBQUs7UUFBQTtLQUVUO0lBQ0E7UUFBQztRQUFRO1lBQUVDLE9BQU87WUFBS0MsUUFBUTtZQUFNQyxHQUFHO1lBQUtDLEdBQUc7WUFBS0osS0FBSztRQUFBO0tBQVU7SUFDcEU7UUFBQztRQUFVO1lBQUVLLElBQUk7WUFBS0MsSUFBSTtZQUFLQyxHQUFHO1lBQUtQLEtBQUs7UUFBQTtLQUFVO0NBQ3hEO0FBYUEsTUFBTVEsV0FBV0MsZ0VBQWdCQSxDQUFDLFlBQVlYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvbGlua2VkaW4udHM/ODdiZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlTHVjaWRlSWNvbiBmcm9tICcuLi9jcmVhdGVMdWNpZGVJY29uJztcbmltcG9ydCB7IEljb25Ob2RlIH0gZnJvbSAnLi4vdHlwZXMnO1xuXG5leHBvcnQgY29uc3QgX19pY29uTm9kZTogSWNvbk5vZGUgPSBbXG4gIFtcbiAgICAncGF0aCcsXG4gICAge1xuICAgICAgZDogJ00xNiA4YTYgNiAwIDAgMSA2IDZ2N2gtNHYtN2EyIDIgMCAwIDAtMi0yIDIgMiAwIDAgMC0yIDJ2N2gtNHYtN2E2IDYgMCAwIDEgNi02eicsXG4gICAgICBrZXk6ICdjMmpxOWYnLFxuICAgIH0sXG4gIF0sXG4gIFsncmVjdCcsIHsgd2lkdGg6ICc0JywgaGVpZ2h0OiAnMTInLCB4OiAnMicsIHk6ICc5Jywga2V5OiAnbWszb241JyB9XSxcbiAgWydjaXJjbGUnLCB7IGN4OiAnNCcsIGN5OiAnNCcsIHI6ICcyJywga2V5OiAnYnQ1cmE4JyB9XSxcbl07XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBMaW5rZWRpblxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTVRZZ09HRTJJRFlnTUNBd0lERWdOaUEyZGpkb0xUUjJMVGRoTWlBeUlEQWdNQ0F3TFRJdE1pQXlJRElnTUNBd0lEQXRNaUF5ZGpkb0xUUjJMVGRoTmlBMklEQWdNQ0F4SURZdE5ub2lJQzgrQ2lBZ1BISmxZM1FnZDJsa2RHZzlJalFpSUdobGFXZG9kRDBpTVRJaUlIZzlJaklpSUhrOUlqa2lJQzgrQ2lBZ1BHTnBjbU5zWlNCamVEMGlOQ0lnWTNrOUlqUWlJSEk5SWpJaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2xpbmtlZGluXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICogQGRlcHJlY2F0ZWQgQnJhbmQgaWNvbnMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIGFyZSBkdWUgdG8gYmUgcmVtb3ZlZCwgcGxlYXNlIHJlZmVyIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9sdWNpZGUtaWNvbnMvbHVjaWRlL2lzc3Vlcy82NzAuIFdlIHJlY29tbWVuZCB1c2luZyBodHRwczovL3NpbXBsZWljb25zLm9yZy8/cT1saW5rZWRpbiBpbnN0ZWFkLiBUaGlzIGljb24gd2lsbCBiZSByZW1vdmVkIGluIHYxLjBcbiAqL1xuY29uc3QgTGlua2VkaW4gPSBjcmVhdGVMdWNpZGVJY29uKCdsaW5rZWRpbicsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgZGVmYXVsdCBMaW5rZWRpbjtcbiJdLCJuYW1lcyI6WyJfX2ljb25Ob2RlIiwiZCIsImtleSIsIndpZHRoIiwiaGVpZ2h0IiwieCIsInkiLCJjeCIsImN5IiwiciIsIkxpbmtlZGluIiwiY3JlYXRlTHVjaWRlSWNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/linkedin.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/mail.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/mail.js ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Mail; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7\",\n            key: \"132q7q\"\n        }\n    ],\n    [\n        \"rect\",\n        {\n            x: \"2\",\n            y: \"4\",\n            width: \"20\",\n            height: \"16\",\n            rx: \"2\",\n            key: \"izxlao\"\n        }\n    ]\n];\nconst Mail = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"mail\", __iconNode);\n //# sourceMappingURL=mail.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL21haWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR08sTUFBTUEsYUFBdUI7SUFDbEM7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBMkNDLEtBQUs7UUFBQTtLQUFVO0lBQ3hFO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQUtDLEdBQUc7WUFBS0MsT0FBTztZQUFNQyxRQUFRO1lBQU1DLElBQUk7WUFBS0wsS0FBSztRQUFBO0tBQVU7Q0FDaEY7QUFhQSxNQUFNTSxPQUFPQyxnRUFBZ0JBLENBQUMsUUFBUVQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9pY29ucy9tYWlsLnRzPzZmMTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5pbXBvcnQgeyBJY29uTm9kZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IF9faWNvbk5vZGU6IEljb25Ob2RlID0gW1xuICBbJ3BhdGgnLCB7IGQ6ICdtMjIgNy04Ljk5MSA1LjcyN2EyIDIgMCAwIDEtMi4wMDkgMEwyIDcnLCBrZXk6ICcxMzJxN3EnIH1dLFxuICBbJ3JlY3QnLCB7IHg6ICcyJywgeTogJzQnLCB3aWR0aDogJzIwJywgaGVpZ2h0OiAnMTYnLCByeDogJzInLCBrZXk6ICdpenhsYW8nIH1dLFxuXTtcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIE1haWxcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKdE1qSWdOeTA0TGprNU1TQTFMamN5TjJFeUlESWdNQ0F3SURFdE1pNHdNRGtnTUV3eUlEY2lJQzgrQ2lBZ1BISmxZM1FnZUQwaU1pSWdlVDBpTkNJZ2QybGtkR2c5SWpJd0lpQm9aV2xuYUhROUlqRTJJaUJ5ZUQwaU1pSWdMejRLUEM5emRtYytDZz09KSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9tYWlsXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgTWFpbCA9IGNyZWF0ZUx1Y2lkZUljb24oJ21haWwnLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFpbDtcbiJdLCJuYW1lcyI6WyJfX2ljb25Ob2RlIiwiZCIsImtleSIsIngiLCJ5Iiwid2lkdGgiLCJoZWlnaHQiLCJyeCIsIk1haWwiLCJjcmVhdGVMdWNpZGVJY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/mail.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/map-pin.js":
/*!*************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/map-pin.js ***!
  \*************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ MapPin; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M20 10c0 4.993-5.539 10.193-7.399 11.799a1 1 0 0 1-1.202 0C9.539 20.193 4 14.993 4 10a8 8 0 0 1 16 0\",\n            key: \"1r0f0z\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"10\",\n            r: \"3\",\n            key: \"ilqhr7\"\n        }\n    ]\n];\nconst MapPin = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"map-pin\", __iconNode);\n //# sourceMappingURL=map-pin.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL21hcC1waW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR08sTUFBTUEsYUFBdUI7SUFDbEM7UUFDRTtRQUNBO1lBQ0VDLEdBQUc7WUFDSEMsS0FBSztRQUFBO0tBRVQ7SUFDQTtRQUFDO1FBQVU7WUFBRUMsSUFBSTtZQUFNQyxJQUFJO1lBQU1DLEdBQUc7WUFBS0gsS0FBSztRQUFBO0tBQVU7Q0FDMUQ7QUFhQSxNQUFNSSxTQUFTQyxnRUFBZ0JBLENBQUMsV0FBV1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9pY29ucy9tYXAtcGluLnRzPzZkZWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5pbXBvcnQgeyBJY29uTm9kZSB9IGZyb20gJy4uL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IF9faWNvbk5vZGU6IEljb25Ob2RlID0gW1xuICBbXG4gICAgJ3BhdGgnLFxuICAgIHtcbiAgICAgIGQ6ICdNMjAgMTBjMCA0Ljk5My01LjUzOSAxMC4xOTMtNy4zOTkgMTEuNzk5YTEgMSAwIDAgMS0xLjIwMiAwQzkuNTM5IDIwLjE5MyA0IDE0Ljk5MyA0IDEwYTggOCAwIDAgMSAxNiAwJyxcbiAgICAgIGtleTogJzFyMGYweicsXG4gICAgfSxcbiAgXSxcbiAgWydjaXJjbGUnLCB7IGN4OiAnMTInLCBjeTogJzEwJywgcjogJzMnLCBrZXk6ICdpbHFocjcnIH1dLFxuXTtcblxuLyoqXG4gKiBAY29tcG9uZW50IEBuYW1lIE1hcFBpblxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTWpBZ01UQmpNQ0EwTGprNU15MDFMalV6T1NBeE1DNHhPVE10Tnk0ek9Ua2dNVEV1TnprNVlURWdNU0F3SURBZ01TMHhMakl3TWlBd1F6a3VOVE01SURJd0xqRTVNeUEwSURFMExqazVNeUEwSURFd1lUZ2dPQ0F3SURBZ01TQXhOaUF3SWlBdlBnb2dJRHhqYVhKamJHVWdZM2c5SWpFeUlpQmplVDBpTVRBaUlISTlJak1pSUM4K0Nqd3ZjM1puUGdvPSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvbWFwLXBpblxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IE1hcFBpbiA9IGNyZWF0ZUx1Y2lkZUljb24oJ21hcC1waW4nLCBfX2ljb25Ob2RlKTtcblxuZXhwb3J0IGRlZmF1bHQgTWFwUGluO1xuIl0sIm5hbWVzIjpbIl9faWNvbk5vZGUiLCJkIiwia2V5IiwiY3giLCJjeSIsInIiLCJNYXBQaW4iLCJjcmVhdGVMdWNpZGVJY29uIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/map-pin.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/redo.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/redo.js ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Redo; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M21 7v6h-6\",\n            key: \"3ptur4\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7\",\n            key: \"1kgawr\"\n        }\n    ]\n];\nconst Redo = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"redo\", __iconNode);\n //# sourceMappingURL=redo.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL3JlZG8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR08sTUFBTUEsYUFBdUI7SUFDbEM7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBY0MsS0FBSztRQUFBO0tBQVU7SUFDM0M7UUFBQztRQUFRO1lBQUVELEdBQUc7WUFBNkNDLEtBQUs7UUFBQTtLQUFVO0NBQzVFO0FBYUEsTUFBTUMsT0FBT0MsZ0VBQWdCQSxDQUFDLFFBQVFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvcmVkby50cz82ODFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgWydwYXRoJywgeyBkOiAnTTIxIDd2NmgtNicsIGtleTogJzNwdHVyNCcgfV0sXG4gIFsncGF0aCcsIHsgZDogJ00zIDE3YTkgOSAwIDAgMSA5LTkgOSA5IDAgMCAxIDYgMi4zbDMgMi43Jywga2V5OiAnMWtnYXdyJyB9XSxcbl07XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBSZWRvXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NakVnTjNZMmFDMDJJaUF2UGdvZ0lEeHdZWFJvSUdROUlrMHpJREUzWVRrZ09TQXdJREFnTVNBNUxUa2dPU0E1SURBZ01DQXhJRFlnTWk0emJETWdNaTQzSWlBdlBnbzhMM04yWno0SykgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvcmVkb1xuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IFJlZG8gPSBjcmVhdGVMdWNpZGVJY29uKCdyZWRvJywgX19pY29uTm9kZSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJlZG87XG4iXSwibmFtZXMiOlsiX19pY29uTm9kZSIsImQiLCJrZXkiLCJSZWRvIiwiY3JlYXRlTHVjaWRlSWNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/redo.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/icons/undo.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/undo.js ***!
  \**********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __iconNode: function() { return /* binding */ __iconNode; },\n/* harmony export */   \"default\": function() { return /* binding */ Undo; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst __iconNode = [\n    [\n        \"path\",\n        {\n            d: \"M3 7v6h6\",\n            key: \"1v2h90\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13\",\n            key: \"1r6uu6\"\n        }\n    ]\n];\nconst Undo = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"undo\", __iconNode);\n //# sourceMappingURL=undo.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL2ljb25zL3VuZG8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBR08sTUFBTUEsYUFBdUI7SUFDbEM7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBWUMsS0FBSztRQUFBO0tBQVU7SUFDekM7UUFBQztRQUFRO1lBQUVELEdBQUc7WUFBNkNDLEtBQUs7UUFBQTtLQUFVO0NBQzVFO0FBYUEsTUFBTUMsT0FBT0MsZ0VBQWdCQSxDQUFDLFFBQVFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvdW5kby50cz9kOTljIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuaW1wb3J0IHsgSWNvbk5vZGUgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBfX2ljb25Ob2RlOiBJY29uTm9kZSA9IFtcbiAgWydwYXRoJywgeyBkOiAnTTMgN3Y2aDYnLCBrZXk6ICcxdjJoOTAnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdNMjEgMTdhOSA5IDAgMCAwLTktOSA5IDkgMCAwIDAtNiAyLjNMMyAxMycsIGtleTogJzFyNnV1NicgfV0sXG5dO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgVW5kb1xuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTXlBM2RqWm9OaUlnTHo0S0lDQThjR0YwYUNCa1BTSk5NakVnTVRkaE9TQTVJREFnTUNBd0xUa3RPU0E1SURrZ01DQXdJREF0TmlBeUxqTk1NeUF4TXlJZ0x6NEtQQzl6ZG1jK0NnPT0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL3VuZG9cbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBVbmRvID0gY3JlYXRlTHVjaWRlSWNvbigndW5kbycsIF9faWNvbk5vZGUpO1xuXG5leHBvcnQgZGVmYXVsdCBVbmRvO1xuIl0sIm5hbWVzIjpbIl9faWNvbk5vZGUiLCJkIiwia2V5IiwiVW5kbyIsImNyZWF0ZUx1Y2lkZUljb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/icons/undo.js\n"));

/***/ }),

/***/ "./node_modules/lucide-react/dist/esm/shared/src/utils.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/shared/src/utils.js ***!
  \****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasA11yProp: function() { return /* binding */ hasA11yProp; },\n/* harmony export */   mergeClasses: function() { return /* binding */ mergeClasses; },\n/* harmony export */   toCamelCase: function() { return /* binding */ toCamelCase; },\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; },\n/* harmony export */   toPascalCase: function() { return /* binding */ toPascalCase; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.539.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ const toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase();\nconst toCamelCase = (string)=>string.replace(/^([A-Z])|[\\s-_]+(\\w)/g, (match, p1, p2)=>p2 ? p2.toUpperCase() : p1.toLowerCase());\nconst toPascalCase = (string)=>{\n    const camelCase = toCamelCase(string);\n    return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);\n};\nconst mergeClasses = function() {\n    for(var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++){\n        classes[_key] = arguments[_key];\n    }\n    return classes.filter((className, index, array)=>{\n        return Boolean(className) && className.trim() !== \"\" && array.indexOf(className) === index;\n    }).join(\" \").trim();\n};\nconst hasA11yProp = (props)=>{\n    for(const prop in props){\n        if (prop.startsWith(\"aria-\") || prop === \"role\" || prop === \"title\") {\n            return true;\n        }\n    }\n};\n //# sourceMappingURL=utils.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbHVjaWRlLXJlYWN0L2Rpc3QvZXNtL3NoYXJlZC9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztJQVFPLE1BQU1BLGNBQWMsQ0FBQ0MsU0FDMUJBLE9BQU9DLE9BQUEsQ0FBUSxzQkFBc0IsU0FBU0MsV0FBQTtBQVF6QyxNQUFNQyxjQUFjLENBQW1CSCxTQUM1Q0EsT0FBT0MsT0FBQSxDQUFRLHlCQUF5QixDQUFDRyxPQUFPQyxJQUFJQyxLQUNsREEsS0FBS0EsR0FBR0MsV0FBQSxLQUFnQkYsR0FBR0gsV0FBQTtBQVN4QixNQUFNTSxlQUFlLENBQW1CUjtJQUM3QyxNQUFNUyxZQUFZTixZQUFZSDtJQUU5QixPQUFRUyxVQUFVQyxNQUFBLENBQU8sR0FBR0gsV0FBQSxLQUFnQkUsVUFBVUUsS0FBQSxDQUFNO0FBQzlEO0FBUU8sTUFBTUMsZUFBZTtxQ0FBMkNDO1FBQUFBOztXQUNyRUEsUUFDR0MsTUFBQSxDQUFPLENBQUNDLFdBQVdDLE9BQU9DO1FBQ3pCLE9BQ0VDLFFBQVFILGNBQ1BBLFVBQXFCSSxJQUFBLE9BQVcsTUFDakNGLE1BQU1HLE9BQUEsQ0FBUUwsZUFBZUM7SUFFakMsR0FDQ0ssSUFBQSxDQUFLLEtBQ0xGLElBQUE7O0FBZ0JFLE1BQU1HLGNBQWMsQ0FBQ0M7SUFDMUIsVUFBV0MsUUFBUUQsTUFBTztRQUN4QixJQUFJQyxLQUFLQyxVQUFBLENBQVcsWUFBWUQsU0FBUyxVQUFVQSxTQUFTLFNBQVM7WUFDbkUsT0FBTztRQUNUO0lBQ0Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vLi4vc2hhcmVkL3NyYy91dGlscy50cz9kODFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENhbWVsVG9QYXNjYWwgfSBmcm9tICcuL3V0aWxpdHktdHlwZXMnO1xuXG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBrZWJhYiBjYXNlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gQSBrZWJhYml6ZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB0b0tlYmFiQ2FzZSA9IChzdHJpbmc6IHN0cmluZykgPT5cbiAgc3RyaW5nLnJlcGxhY2UoLyhbYS16MC05XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIGNhbWVsIGNhc2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIGNhbWVsaXplZCBzdHJpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IHRvQ2FtZWxDYXNlID0gPFQgZXh0ZW5kcyBzdHJpbmc+KHN0cmluZzogVCkgPT5cbiAgc3RyaW5nLnJlcGxhY2UoL14oW0EtWl0pfFtcXHMtX10rKFxcdykvZywgKG1hdGNoLCBwMSwgcDIpID0+XG4gICAgcDIgPyBwMi50b1VwcGVyQ2FzZSgpIDogcDEudG9Mb3dlckNhc2UoKSxcbiAgKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gcGFzY2FsIGNhc2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHBhc2NhbGl6ZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB0b1Bhc2NhbENhc2UgPSA8VCBleHRlbmRzIHN0cmluZz4oc3RyaW5nOiBUKTogQ2FtZWxUb1Bhc2NhbDxUPiA9PiB7XG4gIGNvbnN0IGNhbWVsQ2FzZSA9IHRvQ2FtZWxDYXNlKHN0cmluZyk7XG5cbiAgcmV0dXJuIChjYW1lbENhc2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBjYW1lbENhc2Uuc2xpY2UoMSkpIGFzIENhbWVsVG9QYXNjYWw8VD47XG59O1xuXG4vKipcbiAqIE1lcmdlcyBjbGFzc2VzIGludG8gYSBzaW5nbGUgc3RyaW5nXG4gKlxuICogQHBhcmFtIHthcnJheX0gY2xhc3Nlc1xuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgb2YgY2xhc3Nlc1xuICovXG5leHBvcnQgY29uc3QgbWVyZ2VDbGFzc2VzID0gPENsYXNzVHlwZSA9IHN0cmluZyB8IHVuZGVmaW5lZCB8IG51bGw+KC4uLmNsYXNzZXM6IENsYXNzVHlwZVtdKSA9PlxuICBjbGFzc2VzXG4gICAgLmZpbHRlcigoY2xhc3NOYW1lLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIEJvb2xlYW4oY2xhc3NOYW1lKSAmJlxuICAgICAgICAoY2xhc3NOYW1lIGFzIHN0cmluZykudHJpbSgpICE9PSAnJyAmJlxuICAgICAgICBhcnJheS5pbmRleE9mKGNsYXNzTmFtZSkgPT09IGluZGV4XG4gICAgICApO1xuICAgIH0pXG4gICAgLmpvaW4oJyAnKVxuICAgIC50cmltKCk7XG5cbi8qKlxuICogSXMgZW1wdHkgc3RyaW5nXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHZhbHVlIGlzIGFuIGVtcHR5IHN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgaXNFbXB0eVN0cmluZyA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gPT4gdmFsdWUgPT09ICcnO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9uZW50IGhhcyBhbiBhY2Nlc3NpYmlsaXR5IHByb3BcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBjb21wb25lbnQgaGFzIGFuIGFjY2Vzc2liaWxpdHkgcHJvcFxuICovXG5leHBvcnQgY29uc3QgaGFzQTExeVByb3AgPSAocHJvcHM6IFJlY29yZDxzdHJpbmcsIGFueT4pID0+IHtcbiAgZm9yIChjb25zdCBwcm9wIGluIHByb3BzKSB7XG4gICAgaWYgKHByb3Auc3RhcnRzV2l0aCgnYXJpYS0nKSB8fCBwcm9wID09PSAncm9sZScgfHwgcHJvcCA9PT0gJ3RpdGxlJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59O1xuIl0sIm5hbWVzIjpbInRvS2ViYWJDYXNlIiwic3RyaW5nIiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwidG9DYW1lbENhc2UiLCJtYXRjaCIsInAxIiwicDIiLCJ0b1VwcGVyQ2FzZSIsInRvUGFzY2FsQ2FzZSIsImNhbWVsQ2FzZSIsImNoYXJBdCIsInNsaWNlIiwibWVyZ2VDbGFzc2VzIiwiY2xhc3NlcyIsImZpbHRlciIsImNsYXNzTmFtZSIsImluZGV4IiwiYXJyYXkiLCJCb29sZWFuIiwidHJpbSIsImluZGV4T2YiLCJqb2luIiwiaGFzQTExeVByb3AiLCJwcm9wcyIsInByb3AiLCJzdGFydHNXaXRoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/lucide-react/dist/esm/shared/src/utils.js\n"));

/***/ }),

/***/ "./src/components/Hero.tsx":
/*!*********************************!*\
  !*** ./src/components/Hero.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lexical/list */ \"./node_modules/@lexical/list/LexicalList.dev.mjs\");\n/* harmony import */ var _lexical_mark__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @lexical/mark */ \"./node_modules/@lexical/mark/LexicalMark.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @lexical/react/LexicalComposer */ \"./node_modules/@lexical/react/LexicalComposer.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @lexical/react/LexicalContentEditable */ \"./node_modules/@lexical/react/LexicalContentEditable.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalErrorBoundary__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @lexical/react/LexicalErrorBoundary */ \"./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @lexical/react/LexicalHistoryPlugin */ \"./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalOnChangePlugin__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @lexical/react/LexicalOnChangePlugin */ \"./node_modules/@lexical/react/LexicalOnChangePlugin.dev.mjs\");\n/* harmony import */ var _lexical_react_LexicalRichTextPlugin__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @lexical/react/LexicalRichTextPlugin */ \"./node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/rich-text */ \"./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _barrel_optimize_names_ArrowRightToLine_Github_Linkedin_Mail_MapPin_lucide_react__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=ArrowRightToLine,Github,Linkedin,Mail,MapPin!=!lucide-react */ \"__barrel_optimize__?names=ArrowRightToLine,Github,Linkedin,Mail,MapPin!=!./node_modules/lucide-react/dist/esm/lucide-react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/Hero.module.scss */ \"./src/styles/Hero.module.scss\");\n/* harmony import */ var _styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _StateLoaderPlugin__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StateLoaderPlugin */ \"./src/components/StateLoaderPlugin.tsx\");\n/* harmony import */ var _ToolbarPlugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ToolbarPlugin */ \"./src/components/ToolbarPlugin.tsx\");\n/* harmony import */ var _TranslationExample__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TranslationExample */ \"./src/components/TranslationExample.tsx\");\n/* harmony import */ var _TreeViewPlugin__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TreeViewPlugin */ \"./src/components/TreeViewPlugin.tsx\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Hero = ()=>{\n    _s();\n    const [isMobile, setIsMobile] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [pageInitialized, setPageInitialized] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [isTranslationSectionVisible, setIsTranslationSectionVisible] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const translationSectionRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const observer = new IntersectionObserver((param)=>{\n            let [entry] = param;\n            if (entry.isIntersecting) {\n                setIsTranslationSectionVisible(true);\n                console.log(\"Translation section is visible\");\n            }\n        }, {\n            threshold: 0.1\n        });\n        if (translationSectionRef.current) {\n            observer.observe(translationSectionRef.current);\n        }\n        return ()=>observer.disconnect();\n    }, []);\n    const [isTechSectionVisible, setIsTechSectionVisible] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const techSectionRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const observer = new IntersectionObserver((param)=>{\n            let [entry] = param;\n            if (entry.isIntersecting) {\n                setIsTechSectionVisible(true);\n            }\n        }, {\n            threshold: 0.1\n        });\n        if (techSectionRef.current) {\n            observer.observe(techSectionRef.current);\n        }\n        return ()=>observer.disconnect();\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        setIsMobile(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent));\n        setPageInitialized(true);\n    }, []);\n    const nodeList = [\n        _lexical_rich_text__WEBPACK_IMPORTED_MODULE_7__.HeadingNode,\n        lexical__WEBPACK_IMPORTED_MODULE_8__.ParagraphNode,\n        lexical__WEBPACK_IMPORTED_MODULE_8__.TextNode,\n        _lexical_list__WEBPACK_IMPORTED_MODULE_9__.ListNode,\n        _lexical_list__WEBPACK_IMPORTED_MODULE_9__.ListItemNode,\n        _lexical_mark__WEBPACK_IMPORTED_MODULE_10__.MarkNode\n    ];\n    const initialConfig = {\n        namespace: \"MyEditor\",\n        theme: {},\n        nodes: nodeList,\n        initialEditorState: null,\n        onError: (error)=>console.error(error)\n    };\n    const getExperienceString = ()=>{\n        const startDate = new Date(2018, 4);\n        const currentDate = new Date();\n        const years = currentDate.getFullYear() - startDate.getFullYear();\n        const months = currentDate.getMonth() - startDate.getMonth();\n        const totalMonths = years * 12 + months;\n        const experienceYears = Math.floor(totalMonths / 12);\n        const experienceMonths = Math.ceil(totalMonths % 12);\n        return \"\".concat(experienceYears, \" years, \").concat(experienceMonths, \" months\");\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n        className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().hero),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().heroContainer),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().headerContainer),\n                        style: {\n                            fontSize: isMobile ? \"14px\" : \"16px\"\n                        },\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().nameContainer),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                    src: \"/profile.png\",\n                                    alt: \"Nick Morrissey\",\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().profileImage)\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 113,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().nameTextContainer),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().title),\n                                            children: \"Nick Morrissey\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 119,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().subtitle),\n                                            children: \"Frontend Developer\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 120,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            style: {\n                                                display: \"flex\",\n                                                alignItems: \"center\"\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowRightToLine_Github_Linkedin_Mail_MapPin_lucide_react__WEBPACK_IMPORTED_MODULE_11__.MapPin, {\n                                                    fill: \"#770000\",\n                                                    style: {\n                                                        color: \"red\",\n                                                        marginRight: \"6px\",\n                                                        fontSize: \"1.5em\"\n                                                    }\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 122,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                                    style: {\n                                                        color: \"white\",\n                                                        fontSize: isMobile ? \"0.8em\" : \"1em\"\n                                                    },\n                                                    children: \"Canberra, Australia\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 130,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h4\", {\n                                                    style: {\n                                                        color: \"white\",\n                                                        marginLeft: \"12px\",\n                                                        fontSize: isMobile ? \"0.8em\" : \"1em\"\n                                                    },\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                                            style: {\n                                                                color: \"var(--color-primary)\",\n                                                                marginRight: \"8px\"\n                                                            },\n                                                            children: \"EXP\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 145,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        getExperienceString()\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 138,\n                                                    columnNumber: 17\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 121,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 118,\n                                    columnNumber: 13\n                                }, undefined),\n                                !isMobile && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().contactContainer),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                            href: \"https://www.linkedin.com/in/nicholas-morrissey-60b7042aa/\",\n                                            target: \"_blank\",\n                                            rel: \"noopener noreferrer\",\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().contactField),\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    children: \"LinkedIn\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 165,\n                                                    columnNumber: 19\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowRightToLine_Github_Linkedin_Mail_MapPin_lucide_react__WEBPACK_IMPORTED_MODULE_11__.Linkedin, {\n                                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().contactIcon)\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 166,\n                                                    columnNumber: 19\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 159,\n                                            columnNumber: 17\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                            href: \"https://github.com/nicholasmorrissey\",\n                                            target: \"_blank\",\n                                            rel: \"noopener noreferrer\",\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().contactField),\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    children: \"Github\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 174,\n                                                    columnNumber: 19\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowRightToLine_Github_Linkedin_Mail_MapPin_lucide_react__WEBPACK_IMPORTED_MODULE_11__.Github, {\n                                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().contactIcon)\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 175,\n                                                    columnNumber: 19\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 168,\n                                            columnNumber: 17\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                            href: \"mailto:morrissey.nicholas@gmail.com\",\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().contactField),\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                    children: \"morrissey.nicholas@gmail.com\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 181,\n                                                    columnNumber: 19\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowRightToLine_Github_Linkedin_Mail_MapPin_lucide_react__WEBPACK_IMPORTED_MODULE_11__.Mail, {\n                                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().contactIcon)\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 182,\n                                                    columnNumber: 19\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 177,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 158,\n                                    columnNumber: 15\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 112,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                        lineNumber: 108,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().columnContainer),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalComposer__WEBPACK_IMPORTED_MODULE_12__.LexicalComposer, {\n                            initialConfig: initialConfig,\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"\".concat((_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().documentEditorContainer), \" \").concat(pageInitialized ? (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().slideInVisible) : (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().slideInHidden)),\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().documentEditor),\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_ToolbarPlugin__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                lineNumber: 197,\n                                                columnNumber: 17\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                style: {\n                                                    flex: 1,\n                                                    padding: \"20px\",\n                                                    background: \"linear-gradient(180deg, #280d55 0%, #15072f 100%)\",\n                                                    borderRadius: \"0px 0px 20px 20px\"\n                                                },\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalRichTextPlugin__WEBPACK_IMPORTED_MODULE_13__.RichTextPlugin, {\n                                                        contentEditable: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalContentEditable__WEBPACK_IMPORTED_MODULE_14__.ContentEditable, {\n                                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().contentEditable)\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 209,\n                                                            columnNumber: 23\n                                                        }, void 0),\n                                                        ErrorBoundary: _lexical_react_LexicalErrorBoundary__WEBPACK_IMPORTED_MODULE_15__.LexicalErrorBoundary\n                                                    }, void 0, false, {\n                                                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                        lineNumber: 207,\n                                                        columnNumber: 19\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_StateLoaderPlugin__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                                        delay: 1\n                                                    }, void 0, false, {\n                                                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                        lineNumber: 213,\n                                                        columnNumber: 19\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalHistoryPlugin__WEBPACK_IMPORTED_MODULE_16__.HistoryPlugin, {}, void 0, false, {\n                                                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                        lineNumber: 214,\n                                                        columnNumber: 19\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_react_LexicalOnChangePlugin__WEBPACK_IMPORTED_MODULE_17__.OnChangePlugin, {\n                                                        onChange: ()=>{}\n                                                    }, void 0, false, {\n                                                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                        lineNumber: 215,\n                                                        columnNumber: 19\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                lineNumber: 198,\n                                                columnNumber: 17\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                        lineNumber: 196,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    !isMobile && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().treeViewContainer),\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TreeViewPlugin__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {}, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 220,\n                                            columnNumber: 19\n                                        }, undefined)\n                                    }, void 0, false, {\n                                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                        lineNumber: 219,\n                                        columnNumber: 17\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                lineNumber: 191,\n                                columnNumber: 13\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 190,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                        lineNumber: 189,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        style: {\n                            marginBottom: \"30px\"\n                        },\n                        children: \"Powered by...\"\n                    }, void 0, false, {\n                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                        lineNumber: 227,\n                        columnNumber: 9\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().columnContainer),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            ref: translationSectionRef,\n                            className: \"\".concat((_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().translationEditorContainer), \" \").concat(isTranslationSectionVisible ? (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().slideInVisible) : (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().slideInHidden)),\n                            children: [\n                                !isMobile && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TranslationExample__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                            langIndex: 1,\n                                            isInput: true\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 239,\n                                            columnNumber: 17\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowRightToLine_Github_Linkedin_Mail_MapPin_lucide_react__WEBPACK_IMPORTED_MODULE_11__.ArrowRightToLine, {\n                                            style: {\n                                                color: \"var(--color-primary)\",\n                                                margin: \"12px\",\n                                                alignSelf: \"center\"\n                                            }\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 240,\n                                            columnNumber: 17\n                                        }, undefined)\n                                    ]\n                                }, void 0, true),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TranslationExample__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                                    langIndex: 0\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 249,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 229,\n                            columnNumber: 11\n                        }, undefined)\n                    }, void 0, false, {\n                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                        lineNumber: 228,\n                        columnNumber: 9\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                lineNumber: 107,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().portfolioSection),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().columnContainer),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().sectionHeader),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().sectionHeaderText),\n                                children: \"Before that...\"\n                            }, void 0, false, {\n                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                lineNumber: 258,\n                                columnNumber: 13\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 257,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().experienceContainer),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().experienceItem),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobTitle),\n                                            children: \"Full-stack Developer\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 262,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobDuration),\n                                            children: [\n                                                \"Jan 2021 - Aug 2023 \\xb7 \",\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                                    children: \"2 yrs 8 mos\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 264,\n                                                    columnNumber: 39\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 263,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobDescription),\n                                            children: \"Developed a modern web task management application built with Typescript, React, Java, Go, and Material UI, which supported critical organisational functions in a classified and high stakes environment. I led the implementation of UI/UX and collaborated closely with business analysts, designers, and stakeholders to iteratively improve solutions and bridge the gap between engineering and design.\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 266,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobDescription),\n                                            children: \"Through greenfield development I planned software architecture, built out reusable component libraries, wrote unit tests, and maintained a growing code base through releases. I am grateful for this role, as it gave me a strong fullstack skillset and allowed me to research and implement industry best practices.\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 275,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 261,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().experienceItem),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobTitle),\n                                            children: \"Web Services Developer\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 285,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobDuration),\n                                            children: [\n                                                \"Jan 2019 - Jan 2021 \\xb7 \",\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                                    children: \"2 yrs 1 mo\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 287,\n                                                    columnNumber: 39\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 286,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobDescription),\n                                            children: \"Worked as a fullstack web developer, leading the development and deployment of a comprehensive learning management system. I collaborated closely with learning and development teams to gather requirements, integrate identity systems for seamless onboarding, and automate key data imports.\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 289,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobDescription),\n                                            children: \"I also set up and configured web servers and databases, developed custom audit tools, maintained deployments across development and production instances, and led user interface overhauls of legacy applications.\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 296,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 284,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().experienceItem),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobTitle),\n                                            children: \"ICT Cadet\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 305,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobDuration),\n                                            children: [\n                                                \"May 2018 - Jan 2019 \\xb7 \",\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                                    children: \"9 mos\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 307,\n                                                    columnNumber: 39\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 306,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobDescription),\n                                            children: \"While completing my university studies, I worked part-time as an ICT Cadet supporting internal software development projects. I contributed to user interface design, assisted with requirements gathering, and participated in agile team workflows. The role provided hands-on experience within a secure government environment and included structured training and professional development.\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 309,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 304,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().experienceItem),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobTitle),\n                                            children: \"Bachelor of Software Engineering\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 320,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobDuration),\n                                            children: [\n                                                \"Jan 2016 - Jan 2020 \\xb7 \",\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                                                    children: \"4 yrs\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 324,\n                                                    columnNumber: 39\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 323,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().jobDescription),\n                                            children: \"I completed a Bachelor of Software Engineering at the University of Canberra, where I gained a solid foundation in software development principles, algorithms, and data structures. My studies included hands-on projects that enhanced my coding skills and understanding of software design patterns. I did minors in Networking, Design, and Web and Game Development.\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 326,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 319,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 260,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                    lineNumber: 256,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                lineNumber: 255,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().portfolioSectionDark),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    ref: techSectionRef,\n                    className: \"\".concat((_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().columnContainer), \" \").concat(isTechSectionVisible ? (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().slideInVisible) : (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().slideInHidden)),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().sectionHeader),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().sectionHeaderText),\n                                children: \"Technologies and Languages\"\n                            }, void 0, false, {\n                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                lineNumber: 347,\n                                columnNumber: 13\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 346,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            style: {\n                                display: \"flex\",\n                                gap: \"20px\",\n                                flexDirection: isMobile ? \"column\" : \"row\"\n                            },\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().techCategory),\n                                    style: {\n                                        flex: 1,\n                                        fontSize: \"20px\"\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                            children: \"Frontend\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 362,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"JavaScript\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 364,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"TypeScript\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 365,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"React\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 366,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"Lexical.js\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 367,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"Next.js\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 368,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"Node.js\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 369,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"Websockets\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 370,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"Redux\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 371,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"RTK Query\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 372,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"HTML5\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 373,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"CSS3\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 374,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"Sass\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 375,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"Material UI\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 376,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                    children: \"Tailwind\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 377,\n                                                    columnNumber: 17\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 363,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 358,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    style: {\n                                        display: \"flex\",\n                                        flexDirection: \"column\",\n                                        flex: 1,\n                                        gap: \"20px\"\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().techCategorySecondary),\n                                            style: {\n                                                flex: 1,\n                                                backgroundColor: \"var(--color-box-secondary)\"\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                                    children: \"Backend & DevOps\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 395,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Java\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 397,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"GoLang\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 398,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"MySQL\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 399,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Git\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 400,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Docker\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 401,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Kubernetes\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 402,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"AWS\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 403,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Github & GitLab\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 404,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Vercel\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 405,\n                                                            columnNumber: 19\n                                                        }, undefined)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 396,\n                                                    columnNumber: 17\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 388,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().techCategorySecondary),\n                                            style: {\n                                                flex: 1,\n                                                backgroundColor: \"var(--color-box-secondary)\"\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                                    children: \"Testing\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 415,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Jest\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 417,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"React Testing Library\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 418,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Puppeteer\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 419,\n                                                            columnNumber: 19\n                                                        }, undefined)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 416,\n                                                    columnNumber: 17\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 408,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 380,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    style: {\n                                        display: \"flex\",\n                                        flexDirection: \"column\",\n                                        flex: 1,\n                                        gap: \"20px\"\n                                    },\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().techCategorySecondary),\n                                            style: {\n                                                flex: 1,\n                                                backgroundColor: \"var(--color-box-secondary)\"\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                                    children: \"Design\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 438,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Photoshop\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 440,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Figma\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 441,\n                                                            columnNumber: 19\n                                                        }, undefined)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 439,\n                                                    columnNumber: 17\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 431,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().techCategorySecondary),\n                                            style: {\n                                                flex: 1,\n                                                backgroundColor: \"var(--color-box-secondary)\"\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                                    children: \"Game Dev\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 451,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"C#\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 453,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Unity\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 454,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Blender\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 455,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Cascaduer \"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 456,\n                                                            columnNumber: 19\n                                                        }, undefined)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 452,\n                                                    columnNumber: 17\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 444,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().techCategorySecondary),\n                                            style: {\n                                                flex: 1,\n                                                backgroundColor: \"var(--color-box-secondary)\"\n                                            },\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                                    children: \"Other\"\n                                                }, void 0, false, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 466,\n                                                    columnNumber: 17\n                                                }, undefined),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Linux\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 468,\n                                                            columnNumber: 19\n                                                        }, undefined),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            children: \"Adobe Premiere\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                            lineNumber: 469,\n                                                            columnNumber: 19\n                                                        }, undefined)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                    lineNumber: 467,\n                                                    columnNumber: 17\n                                                }, undefined)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 459,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 423,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 351,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                    lineNumber: 340,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                lineNumber: 339,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().portfolioSection),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().columnContainer),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().sectionHeader),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().sectionHeaderText),\n                                children: \"Personal Projects\"\n                            }, void 0, false, {\n                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                lineNumber: 479,\n                                columnNumber: 13\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 478,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().personalProjectContainer),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().projectHeader),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                            children: \"When Games? (2024)\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 483,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().projectStatusOnline),\n                                            children: \"Online\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 484,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 482,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().projectLinks),\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"a\", {\n                                        href: \"https://whengames.vercel.app/\",\n                                        target: \"_blank\",\n                                        rel: \"noopener noreferrer\",\n                                        children: \"https://whengames.vercel.app/\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                        lineNumber: 487,\n                                        columnNumber: 15\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 486,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().subtleText),\n                                    children: \"Daily game to sort 10 random video games by their release date. Compare game screenshots and use clues to guess the correct order. Inspired by my love for daily games like Wordle, Connections, Gamedle, and others.\"\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 495,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                    src: \"/when-games-screenshot.png\",\n                                    alt: \"When Games project\",\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().projectImage)\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 501,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 481,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().personalProjectContainer),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().projectHeader),\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                            children: \"Savvy (2023)\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 509,\n                                            columnNumber: 15\n                                        }, undefined),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().projectStatusDiscontinued),\n                                            children: \"Offline\"\n                                        }, void 0, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                            lineNumber: 510,\n                                            columnNumber: 15\n                                        }, undefined)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 508,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().subtleText),\n                                    children: \"A marketplace tool for discovering rare and undervalued Counter Strike 2 weapon skins.\"\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 512,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                    src: \"/savvy-screenshot.png\",\n                                    alt: \"Savvy project\",\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().projectImage)\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 516,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 507,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                    lineNumber: 477,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                lineNumber: 476,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().portfolioSectionDark),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().columnContainer),\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().sectionHeader),\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().sectionHeaderText),\n                                children: \"Game Development\"\n                            }, void 0, false, {\n                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                lineNumber: 528,\n                                columnNumber: 13\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 527,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().gameProjectContainer),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().subtleText),\n                                    children: \"In my free time, I work on game development projects using Unity and C#. I'm passionate about video games and game design, and developing them is a rewarding application of my professional skills.\"\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 531,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().subtleText),\n                                    children: \"Game development has many similarities to fullstack web development, you often have to wear many different hats and be able to piece it all together. It has given me valuable experience in building complex systems while maintaining performance and upholding good visual design principles.\"\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 537,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"video\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().gameVideo),\n                                    autoPlay: true,\n                                    loop: true,\n                                    muted: true,\n                                    playsInline: true,\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"source\", {\n                                        src: \"/gameDemo.webm\",\n                                        type: \"video/webm\"\n                                    }, void 0, false, {\n                                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                        lineNumber: 545,\n                                        columnNumber: 15\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 544,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                            lineNumber: 530,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                    lineNumber: 526,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                lineNumber: 525,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().portfolioSection),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().columnContainer),\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().signOffContainer),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().sectionHeader),\n                                style: {\n                                    marginBottom: \"6px\"\n                                },\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                    className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().sectionHeaderText),\n                                    children: \"Thanks for visiting!\"\n                                }, void 0, false, {\n                                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                    lineNumber: 558,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                lineNumber: 554,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().subtleText),\n                                children: \"Feel free to reach out via LinkedIn or email.\"\n                            }, void 0, false, {\n                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                lineNumber: 562,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                style: {\n                                    display: \"flex\",\n                                    alignItems: \"center\",\n                                    gap: \"10px\",\n                                    marginTop: \"12px\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().signOffContact),\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowRightToLine_Github_Linkedin_Mail_MapPin_lucide_react__WEBPACK_IMPORTED_MODULE_11__.Linkedin, {\n                                                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().contactIcon)\n                                            }, void 0, false, {\n                                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                lineNumber: 574,\n                                                columnNumber: 17\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                children: \"LinkedIn\"\n                                            }, void 0, false, {\n                                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                lineNumber: 575,\n                                                columnNumber: 17\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                        lineNumber: 573,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().signOffContact),\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_ArrowRightToLine_Github_Linkedin_Mail_MapPin_lucide_react__WEBPACK_IMPORTED_MODULE_11__.Mail, {\n                                                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().contactIcon)\n                                            }, void 0, false, {\n                                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                lineNumber: 578,\n                                                columnNumber: 17\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                children: \"morrissey.nicholas@gmail.com\"\n                                            }, void 0, false, {\n                                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                                lineNumber: 579,\n                                                columnNumber: 17\n                                            }, undefined)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                        lineNumber: 577,\n                                        columnNumber: 15\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                                lineNumber: 565,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                        lineNumber: 553,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                    lineNumber: 552,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n                lineNumber: 551,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/nick/projects/portfolio/src/components/Hero.tsx\",\n        lineNumber: 106,\n        columnNumber: 5\n    }, undefined);\n};\n_s(Hero, \"34BMJ5OrwDupvZpPbCQkUmMe4/A=\");\n_c = Hero;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Hero);\nvar _c;\n$RefreshReg$(_c, \"Hero\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9IZXJvLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDZDtBQUN3QjtBQUNPO0FBQ0c7QUFDUDtBQUNFO0FBQ0E7QUFDckI7QUFDQztBQUM4QjtBQUNqRDtBQUNpQjtBQUNJO0FBQ1I7QUFDVTtBQUNSO0FBRTlDLE1BQU11QixPQUFpQjs7SUFDckIsTUFBTSxDQUFDQyxVQUFVQyxZQUFZLEdBQUdSLDJDQUFjLENBQUM7SUFDL0MsTUFBTSxDQUFDVSxpQkFBaUJDLG1CQUFtQixHQUFHWCwyQ0FBYyxDQUFDO0lBRTdELE1BQU0sQ0FBQ1ksNkJBQTZCQywrQkFBK0IsR0FDakViLDJDQUFjLENBQUM7SUFDakIsTUFBTWMsd0JBQXdCZCx5Q0FBWSxDQUFpQjtJQUUzREEsNENBQWUsQ0FBQztRQUNkLE1BQU1pQixXQUFXLElBQUlDLHFCQUNuQjtnQkFBQyxDQUFDQyxNQUFNO1lBQ04sSUFBSUEsTUFBTUMsY0FBYyxFQUFFO2dCQUN4QlAsK0JBQStCO2dCQUMvQlEsUUFBUUMsR0FBRyxDQUFDO1lBQ2Q7UUFDRixHQUNBO1lBQUVDLFdBQVc7UUFBSTtRQUduQixJQUFJVCxzQkFBc0JVLE9BQU8sRUFBRTtZQUNqQ1AsU0FBU1EsT0FBTyxDQUFDWCxzQkFBc0JVLE9BQU87UUFDaEQ7UUFFQSxPQUFPLElBQU1QLFNBQVNTLFVBQVU7SUFDbEMsR0FBRyxFQUFFO0lBRUwsTUFBTSxDQUFDQyxzQkFBc0JDLHdCQUF3QixHQUFHNUIsMkNBQWMsQ0FBQztJQUN2RSxNQUFNNkIsaUJBQWlCN0IseUNBQVksQ0FBaUI7SUFFcERBLDRDQUFlLENBQUM7UUFDZCxNQUFNaUIsV0FBVyxJQUFJQyxxQkFDbkI7Z0JBQUMsQ0FBQ0MsTUFBTTtZQUNOLElBQUlBLE1BQU1DLGNBQWMsRUFBRTtnQkFDeEJRLHdCQUF3QjtZQUMxQjtRQUNGLEdBQ0E7WUFBRUwsV0FBVztRQUFJO1FBR25CLElBQUlNLGVBQWVMLE9BQU8sRUFBRTtZQUMxQlAsU0FBU1EsT0FBTyxDQUFDSSxlQUFlTCxPQUFPO1FBQ3pDO1FBRUEsT0FBTyxJQUFNUCxTQUFTUyxVQUFVO0lBQ2xDLEdBQUcsRUFBRTtJQUVMMUIsNENBQWUsQ0FBQztRQUNkUSxZQUNFLGlFQUFpRXNCLElBQUksQ0FDbkVDLFVBQVVDLFNBQVM7UUFHdkJyQixtQkFBbUI7SUFDckIsR0FBRyxFQUFFO0lBRUwsTUFBTXNCLFdBQVc7UUFDZnpDLDJEQUFXQTtRQUNYQyxrREFBYUE7UUFDYkMsNkNBQVFBO1FBQ1JWLG1EQUFRQTtRQUNSRCx1REFBWUE7UUFDWkUsb0RBQVFBO0tBQ1Q7SUFFRCxNQUFNaUQsZ0JBQWdCO1FBQ3BCQyxXQUFXO1FBQ1hDLE9BQU8sQ0FBQztRQUNSQyxPQUFPSjtRQUNQSyxvQkFBb0I7UUFDcEJDLFNBQVMsQ0FBQ0MsUUFBaUJuQixRQUFRbUIsS0FBSyxDQUFDQTtJQUMzQztJQUVBLE1BQU1DLHNCQUFzQjtRQUMxQixNQUFNQyxZQUFZLElBQUlDLEtBQUssTUFBTTtRQUNqQyxNQUFNQyxjQUFjLElBQUlEO1FBRXhCLE1BQU1FLFFBQVFELFlBQVlFLFdBQVcsS0FBS0osVUFBVUksV0FBVztRQUMvRCxNQUFNQyxTQUFTSCxZQUFZSSxRQUFRLEtBQUtOLFVBQVVNLFFBQVE7UUFFMUQsTUFBTUMsY0FBY0osUUFBUSxLQUFLRTtRQUNqQyxNQUFNRyxrQkFBa0JDLEtBQUtDLEtBQUssQ0FBQ0gsY0FBYztRQUNqRCxNQUFNSSxtQkFBbUJGLEtBQUtHLElBQUksQ0FBQ0wsY0FBYztRQUVqRCxPQUFPLEdBQTZCSSxPQUExQkgsaUJBQWdCLFlBQTJCLE9BQWpCRyxrQkFBaUI7SUFDdkQ7SUFFQSxxQkFDRSw4REFBQ0U7UUFBUUMsV0FBV3ZELHNFQUFXOzswQkFDN0IsOERBQUN5RDtnQkFBSUYsV0FBV3ZELCtFQUFvQjs7a0NBQ2xDLDhEQUFDeUQ7d0JBQ0NGLFdBQVd2RCxpRkFBc0I7d0JBQ2pDNEQsT0FBTzs0QkFBRUMsVUFBVXZELFdBQVcsU0FBUzt3QkFBTztrQ0FFOUMsNEVBQUNtRDs0QkFBSUYsV0FBV3ZELCtFQUFvQjs7OENBQ2xDLDhEQUFDK0Q7b0NBQ0NDLEtBQUk7b0NBQ0pDLEtBQUk7b0NBQ0pWLFdBQVd2RCw4RUFBbUI7Ozs7Ozs4Q0FFaEMsOERBQUN5RDtvQ0FBSUYsV0FBV3ZELG1GQUF3Qjs7c0RBQ3RDLDhEQUFDb0U7NENBQUdiLFdBQVd2RCx1RUFBWTtzREFBRTs7Ozs7O3NEQUM3Qiw4REFBQ3NFOzRDQUFHZixXQUFXdkQsMEVBQWU7c0RBQUU7Ozs7OztzREFDaEMsOERBQUN5RDs0Q0FBSUcsT0FBTztnREFBRVksU0FBUztnREFBUUMsWUFBWTs0Q0FBUzs7OERBQ2xELDhEQUFDM0UscUhBQU1BO29EQUNMNEUsTUFBSztvREFDTGQsT0FBTzt3REFDTGUsT0FBTzt3REFDUEMsYUFBYTt3REFDYmYsVUFBVTtvREFDWjs7Ozs7OzhEQUVGLDhEQUFDZ0I7b0RBQ0NqQixPQUFPO3dEQUNMZSxPQUFPO3dEQUNQZCxVQUFVdkQsV0FBVyxVQUFVO29EQUNqQzs4REFDRDs7Ozs7OzhEQUdELDhEQUFDdUU7b0RBQ0NqQixPQUFPO3dEQUNMZSxPQUFPO3dEQUNQRyxZQUFZO3dEQUNaakIsVUFBVXZELFdBQVcsVUFBVTtvREFDakM7O3NFQUVBLDhEQUFDeUU7NERBQ0NuQixPQUFPO2dFQUNMZSxPQUFPO2dFQUNQQyxhQUFhOzREQUNmO3NFQUNEOzs7Ozs7d0RBR0FwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQ0FJTixDQUFDbEMsMEJBQ0EsOERBQUNtRDtvQ0FBSUYsV0FBV3ZELGtGQUF1Qjs7c0RBQ3JDLDhEQUFDaUY7NENBQ0NDLE1BQUs7NENBQ0xDLFFBQU87NENBQ1BDLEtBQUk7NENBQ0o3QixXQUFXdkQsOEVBQW1COzs4REFFOUIsOERBQUNzRjs4REFBSzs7Ozs7OzhEQUNOLDhEQUFDMUYsdUhBQVFBO29EQUFDMkQsV0FBV3ZELDZFQUFrQjs7Ozs7Ozs7Ozs7O3NEQUV6Qyw4REFBQ2lGOzRDQUNDQyxNQUFLOzRDQUNMQyxRQUFPOzRDQUNQQyxLQUFJOzRDQUNKN0IsV0FBV3ZELDhFQUFtQjs7OERBRTlCLDhEQUFDc0Y7OERBQUs7Ozs7Ozs4REFDTiw4REFBQzNGLHFIQUFNQTtvREFBQzRELFdBQVd2RCw2RUFBa0I7Ozs7Ozs7Ozs7OztzREFFdkMsOERBQUNpRjs0Q0FDQ0MsTUFBSzs0Q0FDTDNCLFdBQVd2RCw4RUFBbUI7OzhEQUU5Qiw4REFBQ3NGOzhEQUFLOzs7Ozs7OERBQ04sOERBQUN6RixtSEFBSUE7b0RBQUMwRCxXQUFXdkQsNkVBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQ0FPN0MsOERBQUN5RDt3QkFBSUYsV0FBV3ZELGlGQUFzQjtrQ0FDcEMsNEVBQUNmLDRFQUFlQTs0QkFBQ2dELGVBQWVBO3NDQUM5Qiw0RUFBQ3dCO2dDQUNDRixXQUFXLEdBQ1Q5QyxPQURZVCx5RkFBOEIsRUFBQyxLQUU1QyxPQURDUyxrQkFBa0JULGdGQUFxQixHQUFHQSwrRUFBb0I7O2tEQUdoRSw4REFBQ3lEO3dDQUFJRixXQUFXdkQsZ0ZBQXFCOzswREFDbkMsOERBQUNFLHNEQUFhQTs7Ozs7MERBQ2QsOERBQUN1RDtnREFDQ0csT0FBTztvREFDTGlDLE1BQU07b0RBQ05DLFNBQVM7b0RBQ1RDLFlBQ0U7b0RBQ0ZDLGNBQWM7Z0RBQ2hCOztrRUFFQSw4REFBQzFHLGlGQUFjQTt3REFDYjJHLCtCQUNFLDhEQUFDL0csbUZBQWVBOzREQUFDcUUsV0FBV3ZELGlGQUFzQjs7Ozs7O3dEQUVwRGtHLGVBQWUvRyxzRkFBb0JBOzs7Ozs7a0VBRXJDLDhEQUFDYywwREFBaUJBO3dEQUFDa0csT0FBTzs7Ozs7O2tFQUMxQiw4REFBQy9HLCtFQUFhQTs7Ozs7a0VBQ2QsOERBQUNDLGlGQUFjQTt3REFBQytHLFVBQVUsS0FBTzs7Ozs7Ozs7Ozs7Ozs7Ozs7O29DQUdwQyxDQUFDOUYsMEJBQ0EsOERBQUNtRDt3Q0FBSUYsV0FBV3ZELG1GQUF3QjtrREFDdEMsNEVBQUNJLHVEQUFjQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0NBT3pCLDhEQUFDa0U7d0JBQUdWLE9BQU87NEJBQUUwQyxjQUFjO3dCQUFPO2tDQUFHOzs7Ozs7a0NBQ3JDLDhEQUFDN0M7d0JBQUlGLFdBQVd2RCxpRkFBc0I7a0NBQ3BDLDRFQUFDeUQ7NEJBQ0M4QyxLQUFLMUY7NEJBQ0wwQyxXQUFXLEdBQ1Q1QyxPQURZWCw0RkFBaUMsRUFBQyxLQUkvQyxPQUhDVyw4QkFDSVgsZ0ZBQXFCLEdBQ3JCQSwrRUFBb0I7O2dDQUd6QixDQUFDTSwwQkFDQTs7c0RBQ0UsOERBQUNILDJEQUFrQkE7NENBQUNzRyxXQUFXOzRDQUFHQyxTQUFTOzs7Ozs7c0RBQzNDLDhEQUFDaEgsK0hBQWdCQTs0Q0FDZmtFLE9BQU87Z0RBQ0xlLE9BQU87Z0RBQ1BnQyxRQUFRO2dEQUNSQyxXQUFXOzRDQUNiOzs7Ozs7Ozs4Q0FJTiw4REFBQ3pHLDJEQUFrQkE7b0NBQUNzRyxXQUFXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFNckMsOERBQUNoRDtnQkFBSUYsV0FBV3ZELGtGQUF1QjswQkFDckMsNEVBQUN5RDtvQkFBSUYsV0FBV3ZELGlGQUFzQjs7c0NBQ3BDLDhEQUFDb0U7NEJBQUdiLFdBQVd2RCwrRUFBb0I7c0NBQ2pDLDRFQUFDc0Y7Z0NBQUsvQixXQUFXdkQsbUZBQXdCOzBDQUFFOzs7Ozs7Ozs7OztzQ0FFN0MsOERBQUN5RDs0QkFBSUYsV0FBV3ZELHFGQUEwQjs7OENBQ3hDLDhEQUFDeUQ7b0NBQUlGLFdBQVd2RCxnRkFBcUI7O3NEQUNuQyw4REFBQ2tIOzRDQUFHM0QsV0FBV3ZELDBFQUFlO3NEQUFFOzs7Ozs7c0RBQ2hDLDhEQUFDc0Y7NENBQUsvQixXQUFXdkQsNkVBQWtCOztnREFBRTs4REFDYiw4REFBQytFOzhEQUFFOzs7Ozs7Ozs7Ozs7c0RBRTNCLDhEQUFDc0M7NENBQUU5RCxXQUFXdkQsZ0ZBQXFCO3NEQUFFOzs7Ozs7c0RBU3JDLDhEQUFDcUg7NENBQUU5RCxXQUFXdkQsZ0ZBQXFCO3NEQUFFOzs7Ozs7Ozs7Ozs7OENBU3ZDLDhEQUFDeUQ7b0NBQUlGLFdBQVd2RCxnRkFBcUI7O3NEQUNuQyw4REFBQ2tIOzRDQUFHM0QsV0FBV3ZELDBFQUFlO3NEQUFFOzs7Ozs7c0RBQ2hDLDhEQUFDc0Y7NENBQUsvQixXQUFXdkQsNkVBQWtCOztnREFBRTs4REFDYiw4REFBQytFOzhEQUFFOzs7Ozs7Ozs7Ozs7c0RBRTNCLDhEQUFDc0M7NENBQUU5RCxXQUFXdkQsZ0ZBQXFCO3NEQUFFOzs7Ozs7c0RBT3JDLDhEQUFDcUg7NENBQUU5RCxXQUFXdkQsZ0ZBQXFCO3NEQUFFOzs7Ozs7Ozs7Ozs7OENBUXZDLDhEQUFDeUQ7b0NBQUlGLFdBQVd2RCxnRkFBcUI7O3NEQUNuQyw4REFBQ2tIOzRDQUFHM0QsV0FBV3ZELDBFQUFlO3NEQUFFOzs7Ozs7c0RBQ2hDLDhEQUFDc0Y7NENBQUsvQixXQUFXdkQsNkVBQWtCOztnREFBRTs4REFDYiw4REFBQytFOzhEQUFFOzs7Ozs7Ozs7Ozs7c0RBRTNCLDhEQUFDc0M7NENBQUU5RCxXQUFXdkQsZ0ZBQXFCO3NEQUFFOzs7Ozs7Ozs7Ozs7OENBVXZDLDhEQUFDeUQ7b0NBQUlGLFdBQVd2RCxnRkFBcUI7O3NEQUNuQyw4REFBQ2tIOzRDQUFHM0QsV0FBV3ZELDBFQUFlO3NEQUFFOzs7Ozs7c0RBR2hDLDhEQUFDc0Y7NENBQUsvQixXQUFXdkQsNkVBQWtCOztnREFBRTs4REFDYiw4REFBQytFOzhEQUFFOzs7Ozs7Ozs7Ozs7c0RBRTNCLDhEQUFDc0M7NENBQUU5RCxXQUFXdkQsZ0ZBQXFCO3NEQUFFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQkFhN0MsOERBQUN5RDtnQkFBSUYsV0FBV3ZELHNGQUEyQjswQkFDekMsNEVBQUN5RDtvQkFDQzhDLEtBQUszRTtvQkFDTDJCLFdBQVcsR0FDVDdCLE9BRFkxQixpRkFBc0IsRUFBQyxLQUVwQyxPQURDMEIsdUJBQXVCMUIsZ0ZBQXFCLEdBQUdBLCtFQUFvQjs7c0NBR3JFLDhEQUFDb0U7NEJBQUdiLFdBQVd2RCwrRUFBb0I7c0NBQ2pDLDRFQUFDc0Y7Z0NBQUsvQixXQUFXdkQsbUZBQXdCOzBDQUFFOzs7Ozs7Ozs7OztzQ0FJN0MsOERBQUN5RDs0QkFDQ0csT0FBTztnQ0FDTFksU0FBUztnQ0FDVGdELEtBQUs7Z0NBQ0xDLGVBQWVuSCxXQUFXLFdBQVc7NEJBQ3ZDOzs4Q0FFQSw4REFBQ21EO29DQUNDRixXQUFXdkQsOEVBQW1CO29DQUM5QjRELE9BQU87d0NBQUVpQyxNQUFNO3dDQUFHaEMsVUFBVTtvQ0FBTzs7c0RBRW5DLDhEQUFDTztzREFBRzs7Ozs7O3NEQUNKLDhEQUFDdUQ7OzhEQUNDLDhEQUFDQzs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDQTs4REFBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7OzhDQUdSLDhEQUFDbkU7b0NBQ0NHLE9BQU87d0NBQ0xZLFNBQVM7d0NBQ1RpRCxlQUFlO3dDQUNmNUIsTUFBTTt3Q0FDTjJCLEtBQUs7b0NBQ1A7O3NEQUVBLDhEQUFDL0Q7NENBQ0NGLFdBQVd2RCx1RkFBNEI7NENBQ3ZDNEQsT0FBTztnREFDTGlDLE1BQU07Z0RBQ05pQyxpQkFBaUI7NENBQ25COzs4REFFQSw4REFBQzFEOzhEQUFHOzs7Ozs7OERBQ0osOERBQUN1RDs7c0VBQ0MsOERBQUNDO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7c0RBR1IsOERBQUNuRTs0Q0FDQ0YsV0FBV3ZELHVGQUE0Qjs0Q0FDdkM0RCxPQUFPO2dEQUNMaUMsTUFBTTtnREFDTmlDLGlCQUFpQjs0Q0FDbkI7OzhEQUVBLDhEQUFDMUQ7OERBQUc7Ozs7Ozs4REFDSiw4REFBQ3VEOztzRUFDQyw4REFBQ0M7c0VBQUc7Ozs7OztzRUFDSiw4REFBQ0E7c0VBQUc7Ozs7OztzRUFDSiw4REFBQ0E7c0VBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs4Q0FJViw4REFBQ25FO29DQUNDRyxPQUFPO3dDQUNMWSxTQUFTO3dDQUNUaUQsZUFBZTt3Q0FDZjVCLE1BQU07d0NBQ04yQixLQUFLO29DQUNQOztzREFFQSw4REFBQy9EOzRDQUNDRixXQUFXdkQsdUZBQTRCOzRDQUN2QzRELE9BQU87Z0RBQ0xpQyxNQUFNO2dEQUNOaUMsaUJBQWlCOzRDQUNuQjs7OERBRUEsOERBQUMxRDs4REFBRzs7Ozs7OzhEQUNKLDhEQUFDdUQ7O3NFQUNDLDhEQUFDQztzRUFBRzs7Ozs7O3NFQUNKLDhEQUFDQTtzRUFBRzs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NEQUdSLDhEQUFDbkU7NENBQ0NGLFdBQVd2RCx1RkFBNEI7NENBQ3ZDNEQsT0FBTztnREFDTGlDLE1BQU07Z0RBQ05pQyxpQkFBaUI7NENBQ25COzs4REFFQSw4REFBQzFEOzhEQUFHOzs7Ozs7OERBQ0osOERBQUN1RDs7c0VBQ0MsOERBQUNDO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7c0VBQ0osOERBQUNBO3NFQUFHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7c0RBR1IsOERBQUNuRTs0Q0FDQ0YsV0FBV3ZELHVGQUE0Qjs0Q0FDdkM0RCxPQUFPO2dEQUNMaUMsTUFBTTtnREFDTmlDLGlCQUFpQjs0Q0FDbkI7OzhEQUVBLDhEQUFDMUQ7OERBQUc7Ozs7Ozs4REFDSiw4REFBQ3VEOztzRUFDQyw4REFBQ0M7c0VBQUc7Ozs7OztzRUFDSiw4REFBQ0E7c0VBQUc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU9oQiw4REFBQ25FO2dCQUFJRixXQUFXdkQsa0ZBQXVCOzBCQUNyQyw0RUFBQ3lEO29CQUFJRixXQUFXdkQsaUZBQXNCOztzQ0FDcEMsOERBQUNvRTs0QkFBR2IsV0FBV3ZELCtFQUFvQjtzQ0FDakMsNEVBQUNzRjtnQ0FBSy9CLFdBQVd2RCxtRkFBd0I7MENBQUU7Ozs7Ozs7Ozs7O3NDQUU3Qyw4REFBQ3lEOzRCQUFJRixXQUFXdkQsMEZBQStCOzs4Q0FDN0MsOERBQUN5RDtvQ0FBSUYsV0FBV3ZELCtFQUFvQjs7c0RBQ2xDLDhEQUFDa0g7c0RBQUc7Ozs7OztzREFDSiw4REFBQzVCOzRDQUFLL0IsV0FBV3ZELHFGQUEwQjtzREFBRTs7Ozs7Ozs7Ozs7OzhDQUUvQyw4REFBQ3lEO29DQUFJRixXQUFXdkQsOEVBQW1COzhDQUNqQyw0RUFBQ2lGO3dDQUNDQyxNQUFLO3dDQUNMQyxRQUFPO3dDQUNQQyxLQUFJO2tEQUNMOzs7Ozs7Ozs7Ozs4Q0FJSCw4REFBQ2lDO29DQUFFOUQsV0FBV3ZELDRFQUFpQjs4Q0FBRTs7Ozs7OzhDQU1qQyw4REFBQytEO29DQUNDQyxLQUFJO29DQUNKQyxLQUFJO29DQUNKVixXQUFXdkQsOEVBQW1COzs7Ozs7Ozs7Ozs7c0NBR2xDLDhEQUFDeUQ7NEJBQUlGLFdBQVd2RCwwRkFBK0I7OzhDQUM3Qyw4REFBQ3lEO29DQUFJRixXQUFXdkQsK0VBQW9COztzREFDbEMsOERBQUNrSDtzREFBRzs7Ozs7O3NEQUNKLDhEQUFDNUI7NENBQUsvQixXQUFXdkQsMkZBQWdDO3NEQUFFOzs7Ozs7Ozs7Ozs7OENBRXJELDhEQUFDcUg7b0NBQUU5RCxXQUFXdkQsNEVBQWlCOzhDQUFFOzs7Ozs7OENBSWpDLDhEQUFDK0Q7b0NBQ0NDLEtBQUk7b0NBQ0pDLEtBQUk7b0NBQ0pWLFdBQVd2RCw4RUFBbUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzBCQU10Qyw4REFBQ3lEO2dCQUFJRixXQUFXdkQsc0ZBQTJCOzBCQUN6Qyw0RUFBQ3lEO29CQUFJRixXQUFXdkQsaUZBQXNCOztzQ0FDcEMsOERBQUNvRTs0QkFBR2IsV0FBV3ZELCtFQUFvQjtzQ0FDakMsNEVBQUNzRjtnQ0FBSy9CLFdBQVd2RCxtRkFBd0I7MENBQUU7Ozs7Ozs7Ozs7O3NDQUU3Qyw4REFBQ3lEOzRCQUFJRixXQUFXdkQsc0ZBQTJCOzs4Q0FDekMsOERBQUNzRjtvQ0FBSy9CLFdBQVd2RCw0RUFBaUI7OENBQUU7Ozs7Ozs4Q0FNcEMsOERBQUNzRjtvQ0FBSy9CLFdBQVd2RCw0RUFBaUI7OENBQUU7Ozs7Ozs4Q0FPcEMsOERBQUN1STtvQ0FBTWhGLFdBQVd2RCwyRUFBZ0I7b0NBQUV5SSxRQUFRO29DQUFDQyxJQUFJO29DQUFDQyxLQUFLO29DQUFDQyxXQUFXOzhDQUNqRSw0RUFBQ0M7d0NBQU83RSxLQUFJO3dDQUFpQjhFLE1BQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MEJBTTFDLDhEQUFDckY7Z0JBQUlGLFdBQVd2RCxrRkFBdUI7MEJBQ3JDLDRFQUFDeUQ7b0JBQUlGLFdBQVd2RCxpRkFBc0I7OEJBQ3BDLDRFQUFDeUQ7d0JBQUlGLFdBQVd2RCxrRkFBdUI7OzBDQUNyQyw4REFBQ29FO2dDQUNDYixXQUFXdkQsK0VBQW9CO2dDQUMvQjRELE9BQU87b0NBQUUwQyxjQUFjO2dDQUFNOzBDQUU3Qiw0RUFBQ2hCO29DQUFLL0IsV0FBV3ZELG1GQUF3Qjs4Q0FBRTs7Ozs7Ozs7Ozs7MENBSTdDLDhEQUFDc0Y7Z0NBQUsvQixXQUFXdkQsNEVBQWlCOzBDQUFFOzs7Ozs7MENBR3BDLDhEQUFDeUQ7Z0NBQ0NHLE9BQU87b0NBQ0xZLFNBQVM7b0NBQ1RDLFlBQVk7b0NBQ1orQyxLQUFLO29DQUNMd0IsV0FBVztnQ0FDYjs7a0RBRUEsOERBQUN2Rjt3Q0FBSUYsV0FBV3ZELGdGQUFxQjs7MERBQ25DLDhEQUFDSix1SEFBUUE7Z0RBQUMyRCxXQUFXdkQsNkVBQWtCOzs7Ozs7MERBQ3ZDLDhEQUFDc0Y7MERBQUs7Ozs7Ozs7Ozs7OztrREFFUiw4REFBQzdCO3dDQUFJRixXQUFXdkQsZ0ZBQXFCOzswREFDbkMsOERBQUNILG1IQUFJQTtnREFBQzBELFdBQVd2RCw2RUFBa0I7Ozs7OzswREFDbkMsOERBQUNzRjswREFBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVF0QjtHQXhqQk1qRjtLQUFBQTtBQTBqQk4sK0RBQWVBLElBQUlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvSGVyby50c3g/NjY5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMaXN0SXRlbU5vZGUsIExpc3ROb2RlIH0gZnJvbSBcIkBsZXhpY2FsL2xpc3RcIjtcbmltcG9ydCB7IE1hcmtOb2RlIH0gZnJvbSBcIkBsZXhpY2FsL21hcmtcIjtcbmltcG9ydCB7IExleGljYWxDb21wb3NlciB9IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJcIjtcbmltcG9ydCB7IENvbnRlbnRFZGl0YWJsZSB9IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29udGVudEVkaXRhYmxlXCI7XG5pbXBvcnQgeyBMZXhpY2FsRXJyb3JCb3VuZGFyeSB9IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsRXJyb3JCb3VuZGFyeVwiO1xuaW1wb3J0IHsgSGlzdG9yeVBsdWdpbiB9IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsSGlzdG9yeVBsdWdpblwiO1xuaW1wb3J0IHsgT25DaGFuZ2VQbHVnaW4gfSBmcm9tIFwiQGxleGljYWwvcmVhY3QvTGV4aWNhbE9uQ2hhbmdlUGx1Z2luXCI7XG5pbXBvcnQgeyBSaWNoVGV4dFBsdWdpbiB9IGZyb20gXCJAbGV4aWNhbC9yZWFjdC9MZXhpY2FsUmljaFRleHRQbHVnaW5cIjtcbmltcG9ydCB7IEhlYWRpbmdOb2RlIH0gZnJvbSBcIkBsZXhpY2FsL3JpY2gtdGV4dFwiO1xuaW1wb3J0IHsgUGFyYWdyYXBoTm9kZSwgVGV4dE5vZGUgfSBmcm9tIFwibGV4aWNhbFwiO1xuaW1wb3J0IHsgQXJyb3dSaWdodFRvTGluZSwgR2l0aHViLCBMaW5rZWRpbiwgTWFpbCwgTWFwUGluIH0gZnJvbSBcImx1Y2lkZS1yZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgc3R5bGVzIGZyb20gXCIuLi9zdHlsZXMvSGVyby5tb2R1bGUuc2Nzc1wiO1xuaW1wb3J0IFN0YXRlTG9hZGVyUGx1Z2luIGZyb20gXCIuL1N0YXRlTG9hZGVyUGx1Z2luXCI7XG5pbXBvcnQgVG9vbGJhclBsdWdpbiBmcm9tIFwiLi9Ub29sYmFyUGx1Z2luXCI7XG5pbXBvcnQgVHJhbnNsYXRpb25FeGFtcGxlIGZyb20gXCIuL1RyYW5zbGF0aW9uRXhhbXBsZVwiO1xuaW1wb3J0IFRyZWVWaWV3UGx1Z2luIGZyb20gXCIuL1RyZWVWaWV3UGx1Z2luXCI7XG5cbmNvbnN0IEhlcm86IFJlYWN0LkZDID0gKCkgPT4ge1xuICBjb25zdCBbaXNNb2JpbGUsIHNldElzTW9iaWxlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3BhZ2VJbml0aWFsaXplZCwgc2V0UGFnZUluaXRpYWxpemVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcblxuICBjb25zdCBbaXNUcmFuc2xhdGlvblNlY3Rpb25WaXNpYmxlLCBzZXRJc1RyYW5zbGF0aW9uU2VjdGlvblZpc2libGVdID1cbiAgICBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHRyYW5zbGF0aW9uU2VjdGlvblJlZiA9IFJlYWN0LnVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAgIChbZW50cnldKSA9PiB7XG4gICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgIHNldElzVHJhbnNsYXRpb25TZWN0aW9uVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRyYW5zbGF0aW9uIHNlY3Rpb24gaXMgdmlzaWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgdGhyZXNob2xkOiAwLjEgfVxuICAgICk7XG5cbiAgICBpZiAodHJhbnNsYXRpb25TZWN0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUodHJhbnNsYXRpb25TZWN0aW9uUmVmLmN1cnJlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBbaXNUZWNoU2VjdGlvblZpc2libGUsIHNldElzVGVjaFNlY3Rpb25WaXNpYmxlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgdGVjaFNlY3Rpb25SZWYgPSBSZWFjdC51c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAoW2VudHJ5XSkgPT4ge1xuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcbiAgICAgICAgICBzZXRJc1RlY2hTZWN0aW9uVmlzaWJsZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgdGhyZXNob2xkOiAwLjEgfVxuICAgICk7XG5cbiAgICBpZiAodGVjaFNlY3Rpb25SZWYuY3VycmVudCkge1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0ZWNoU2VjdGlvblJlZi5jdXJyZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRJc01vYmlsZShcbiAgICAgIC9BbmRyb2lkfHdlYk9TfGlQaG9uZXxpUGFkfGlQb2R8QmxhY2tCZXJyeXxJRU1vYmlsZXxPcGVyYSBNaW5pL2kudGVzdChcbiAgICAgICAgbmF2aWdhdG9yLnVzZXJBZ2VudFxuICAgICAgKVxuICAgICk7XG4gICAgc2V0UGFnZUluaXRpYWxpemVkKHRydWUpO1xuICB9LCBbXSk7XG5cbiAgY29uc3Qgbm9kZUxpc3QgPSBbXG4gICAgSGVhZGluZ05vZGUsXG4gICAgUGFyYWdyYXBoTm9kZSxcbiAgICBUZXh0Tm9kZSxcbiAgICBMaXN0Tm9kZSxcbiAgICBMaXN0SXRlbU5vZGUsXG4gICAgTWFya05vZGUsXG4gIF07XG5cbiAgY29uc3QgaW5pdGlhbENvbmZpZyA9IHtcbiAgICBuYW1lc3BhY2U6IFwiTXlFZGl0b3JcIixcbiAgICB0aGVtZToge30sXG4gICAgbm9kZXM6IG5vZGVMaXN0LFxuICAgIGluaXRpYWxFZGl0b3JTdGF0ZTogbnVsbCxcbiAgICBvbkVycm9yOiAoZXJyb3I6IEVycm9yKSA9PiBjb25zb2xlLmVycm9yKGVycm9yKSxcbiAgfTtcblxuICBjb25zdCBnZXRFeHBlcmllbmNlU3RyaW5nID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9IG5ldyBEYXRlKDIwMTgsIDQpO1xuICAgIGNvbnN0IGN1cnJlbnREYXRlID0gbmV3IERhdGUoKTtcblxuICAgIGNvbnN0IHllYXJzID0gY3VycmVudERhdGUuZ2V0RnVsbFllYXIoKSAtIHN0YXJ0RGF0ZS5nZXRGdWxsWWVhcigpO1xuICAgIGNvbnN0IG1vbnRocyA9IGN1cnJlbnREYXRlLmdldE1vbnRoKCkgLSBzdGFydERhdGUuZ2V0TW9udGgoKTtcblxuICAgIGNvbnN0IHRvdGFsTW9udGhzID0geWVhcnMgKiAxMiArIG1vbnRocztcbiAgICBjb25zdCBleHBlcmllbmNlWWVhcnMgPSBNYXRoLmZsb29yKHRvdGFsTW9udGhzIC8gMTIpO1xuICAgIGNvbnN0IGV4cGVyaWVuY2VNb250aHMgPSBNYXRoLmNlaWwodG90YWxNb250aHMgJSAxMik7XG5cbiAgICByZXR1cm4gYCR7ZXhwZXJpZW5jZVllYXJzfSB5ZWFycywgJHtleHBlcmllbmNlTW9udGhzfSBtb250aHNgO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPHNlY3Rpb24gY2xhc3NOYW1lPXtzdHlsZXMuaGVyb30+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmhlcm9Db250YWluZXJ9PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuaGVhZGVyQ29udGFpbmVyfVxuICAgICAgICAgIHN0eWxlPXt7IGZvbnRTaXplOiBpc01vYmlsZSA/IFwiMTRweFwiIDogXCIxNnB4XCIgfX1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubmFtZUNvbnRhaW5lcn0+XG4gICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgIHNyYz1cIi9wcm9maWxlLnBuZ1wiXG4gICAgICAgICAgICAgIGFsdD1cIk5pY2sgTW9ycmlzc2V5XCJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMucHJvZmlsZUltYWdlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMubmFtZVRleHRDb250YWluZXJ9PlxuICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPXtzdHlsZXMudGl0bGV9Pk5pY2sgTW9ycmlzc2V5PC9oMj5cbiAgICAgICAgICAgICAgPGgzIGNsYXNzTmFtZT17c3R5bGVzLnN1YnRpdGxlfT5Gcm9udGVuZCBEZXZlbG9wZXI8L2gzPlxuICAgICAgICAgICAgICA8ZGl2IHN0eWxlPXt7IGRpc3BsYXk6IFwiZmxleFwiLCBhbGlnbkl0ZW1zOiBcImNlbnRlclwiIH19PlxuICAgICAgICAgICAgICAgIDxNYXBQaW5cbiAgICAgICAgICAgICAgICAgIGZpbGw9XCIjNzcwMDAwXCJcbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcInJlZFwiLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogXCI2cHhcIixcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMS41ZW1cIixcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICA8aDRcbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIndoaXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBpc01vYmlsZSA/IFwiMC44ZW1cIiA6IFwiMWVtXCIsXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIENhbmJlcnJhLCBBdXN0cmFsaWFcbiAgICAgICAgICAgICAgICA8L2g0PlxuICAgICAgICAgICAgICAgIDxoNFxuICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwid2hpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogXCIxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBpc01vYmlsZSA/IFwiMC44ZW1cIiA6IFwiMWVtXCIsXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxiXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwidmFyKC0tY29sb3ItcHJpbWFyeSlcIixcbiAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5SaWdodDogXCI4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgRVhQXG4gICAgICAgICAgICAgICAgICA8L2I+XG4gICAgICAgICAgICAgICAgICB7Z2V0RXhwZXJpZW5jZVN0cmluZygpfVxuICAgICAgICAgICAgICAgIDwvaDQ+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7IWlzTW9iaWxlICYmIChcbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb250YWN0Q29udGFpbmVyfT5cbiAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9uaWNob2xhcy1tb3JyaXNzZXktNjBiNzA0MmFhL1wiXG4gICAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5jb250YWN0RmllbGR9XG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPHNwYW4+TGlua2VkSW48L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8TGlua2VkaW4gY2xhc3NOYW1lPXtzdHlsZXMuY29udGFjdEljb259IC8+XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgICBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL25pY2hvbGFzbW9ycmlzc2V5XCJcbiAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgICAgICByZWw9XCJub29wZW5lciBub3JlZmVycmVyXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhY3RGaWVsZH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8c3Bhbj5HaXRodWI8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8R2l0aHViIGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhY3RJY29ufSAvPlxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICA8YVxuICAgICAgICAgICAgICAgICAgaHJlZj1cIm1haWx0bzptb3JyaXNzZXkubmljaG9sYXNAZ21haWwuY29tXCJcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhY3RGaWVsZH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8c3Bhbj5tb3JyaXNzZXkubmljaG9sYXNAZ21haWwuY29tPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgPE1haWwgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFjdEljb259IC8+XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29sdW1uQ29udGFpbmVyfT5cbiAgICAgICAgICA8TGV4aWNhbENvbXBvc2VyIGluaXRpYWxDb25maWc9e2luaXRpYWxDb25maWd9PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy5kb2N1bWVudEVkaXRvckNvbnRhaW5lcn0gJHtcbiAgICAgICAgICAgICAgICBwYWdlSW5pdGlhbGl6ZWQgPyBzdHlsZXMuc2xpZGVJblZpc2libGUgOiBzdHlsZXMuc2xpZGVJbkhpZGRlblxuICAgICAgICAgICAgICB9YH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kb2N1bWVudEVkaXRvcn0+XG4gICAgICAgICAgICAgICAgPFRvb2xiYXJQbHVnaW4gLz5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICBmbGV4OiAxLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjIwcHhcIixcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZDpcbiAgICAgICAgICAgICAgICAgICAgICBcImxpbmVhci1ncmFkaWVudCgxODBkZWcsICMyODBkNTUgMCUsICMxNTA3MmYgMTAwJSlcIixcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBcIjBweCAwcHggMjBweCAyMHB4XCIsXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxSaWNoVGV4dFBsdWdpblxuICAgICAgICAgICAgICAgICAgICBjb250ZW50RWRpdGFibGU9e1xuICAgICAgICAgICAgICAgICAgICAgIDxDb250ZW50RWRpdGFibGUgY2xhc3NOYW1lPXtzdHlsZXMuY29udGVudEVkaXRhYmxlfSAvPlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEVycm9yQm91bmRhcnk9e0xleGljYWxFcnJvckJvdW5kYXJ5fVxuICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgIDxTdGF0ZUxvYWRlclBsdWdpbiBkZWxheT17MX0gLz5cbiAgICAgICAgICAgICAgICAgIDxIaXN0b3J5UGx1Z2luIC8+XG4gICAgICAgICAgICAgICAgICA8T25DaGFuZ2VQbHVnaW4gb25DaGFuZ2U9eygpID0+IHt9fSAvPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgeyFpc01vYmlsZSAmJiAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy50cmVlVmlld0NvbnRhaW5lcn0+XG4gICAgICAgICAgICAgICAgICA8VHJlZVZpZXdQbHVnaW4gLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvTGV4aWNhbENvbXBvc2VyPlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8aDMgc3R5bGU9e3sgbWFyZ2luQm90dG9tOiBcIjMwcHhcIiB9fT5Qb3dlcmVkIGJ5Li4uPC9oMz5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb2x1bW5Db250YWluZXJ9PlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIHJlZj17dHJhbnNsYXRpb25TZWN0aW9uUmVmfVxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtzdHlsZXMudHJhbnNsYXRpb25FZGl0b3JDb250YWluZXJ9ICR7XG4gICAgICAgICAgICAgIGlzVHJhbnNsYXRpb25TZWN0aW9uVmlzaWJsZVxuICAgICAgICAgICAgICAgID8gc3R5bGVzLnNsaWRlSW5WaXNpYmxlXG4gICAgICAgICAgICAgICAgOiBzdHlsZXMuc2xpZGVJbkhpZGRlblxuICAgICAgICAgICAgfWB9XG4gICAgICAgICAgPlxuICAgICAgICAgICAgeyFpc01vYmlsZSAmJiAoXG4gICAgICAgICAgICAgIDw+XG4gICAgICAgICAgICAgICAgPFRyYW5zbGF0aW9uRXhhbXBsZSBsYW5nSW5kZXg9ezF9IGlzSW5wdXQ9e3RydWV9IC8+XG4gICAgICAgICAgICAgICAgPEFycm93UmlnaHRUb0xpbmVcbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcInZhcigtLWNvbG9yLXByaW1hcnkpXCIsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbjogXCIxMnB4XCIsXG4gICAgICAgICAgICAgICAgICAgIGFsaWduU2VsZjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgPC8+XG4gICAgICAgICAgICApfVxuICAgICAgICAgICAgPFRyYW5zbGF0aW9uRXhhbXBsZSBsYW5nSW5kZXg9ezB9IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7LyogPC9kaXY+ICovfVxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucG9ydGZvbGlvU2VjdGlvbn0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29sdW1uQ29udGFpbmVyfT5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPXtzdHlsZXMuc2VjdGlvbkhlYWRlcn0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9uSGVhZGVyVGV4dH0+QmVmb3JlIHRoYXQuLi48L3NwYW4+XG4gICAgICAgICAgPC9oMj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmV4cGVyaWVuY2VDb250YWluZXJ9PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5leHBlcmllbmNlSXRlbX0+XG4gICAgICAgICAgICAgIDxoMSBjbGFzc05hbWU9e3N0eWxlcy5qb2JUaXRsZX0+RnVsbC1zdGFjayBEZXZlbG9wZXI8L2gxPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5qb2JEdXJhdGlvbn0+XG4gICAgICAgICAgICAgICAgSmFuIDIwMjEgLSBBdWcgMjAyMyDCtyA8Yj4yIHlycyA4IG1vczwvYj5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5qb2JEZXNjcmlwdGlvbn0+XG4gICAgICAgICAgICAgICAgRGV2ZWxvcGVkIGEgbW9kZXJuIHdlYiB0YXNrIG1hbmFnZW1lbnQgYXBwbGljYXRpb24gYnVpbHQgd2l0aFxuICAgICAgICAgICAgICAgIFR5cGVzY3JpcHQsIFJlYWN0LCBKYXZhLCBHbywgYW5kIE1hdGVyaWFsIFVJLCB3aGljaCBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICBjcml0aWNhbCBvcmdhbmlzYXRpb25hbCBmdW5jdGlvbnMgaW4gYSBjbGFzc2lmaWVkIGFuZCBoaWdoXG4gICAgICAgICAgICAgICAgc3Rha2VzIGVudmlyb25tZW50LiBJIGxlZCB0aGUgaW1wbGVtZW50YXRpb24gb2YgVUkvVVggYW5kXG4gICAgICAgICAgICAgICAgY29sbGFib3JhdGVkIGNsb3NlbHkgd2l0aCBidXNpbmVzcyBhbmFseXN0cywgZGVzaWduZXJzLCBhbmRcbiAgICAgICAgICAgICAgICBzdGFrZWhvbGRlcnMgdG8gaXRlcmF0aXZlbHkgaW1wcm92ZSBzb2x1dGlvbnMgYW5kIGJyaWRnZSB0aGUgZ2FwXG4gICAgICAgICAgICAgICAgYmV0d2VlbiBlbmdpbmVlcmluZyBhbmQgZGVzaWduLlxuICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT17c3R5bGVzLmpvYkRlc2NyaXB0aW9ufT5cbiAgICAgICAgICAgICAgICBUaHJvdWdoIGdyZWVuZmllbGQgZGV2ZWxvcG1lbnQgSSBwbGFubmVkIHNvZnR3YXJlIGFyY2hpdGVjdHVyZSxcbiAgICAgICAgICAgICAgICBidWlsdCBvdXQgcmV1c2FibGUgY29tcG9uZW50IGxpYnJhcmllcywgd3JvdGUgdW5pdCB0ZXN0cywgYW5kXG4gICAgICAgICAgICAgICAgbWFpbnRhaW5lZCBhIGdyb3dpbmcgY29kZSBiYXNlIHRocm91Z2ggcmVsZWFzZXMuIEkgYW0gZ3JhdGVmdWxcbiAgICAgICAgICAgICAgICBmb3IgdGhpcyByb2xlLCBhcyBpdCBnYXZlIG1lIGEgc3Ryb25nIGZ1bGxzdGFjayBza2lsbHNldCBhbmRcbiAgICAgICAgICAgICAgICBhbGxvd2VkIG1lIHRvIHJlc2VhcmNoIGFuZCBpbXBsZW1lbnQgaW5kdXN0cnkgYmVzdCBwcmFjdGljZXMuXG4gICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmV4cGVyaWVuY2VJdGVtfT5cbiAgICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT17c3R5bGVzLmpvYlRpdGxlfT5XZWIgU2VydmljZXMgRGV2ZWxvcGVyPC9oMT5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMuam9iRHVyYXRpb259PlxuICAgICAgICAgICAgICAgIEphbiAyMDE5IC0gSmFuIDIwMjEgwrcgPGI+MiB5cnMgMSBtbzwvYj5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5qb2JEZXNjcmlwdGlvbn0+XG4gICAgICAgICAgICAgICAgV29ya2VkIGFzIGEgZnVsbHN0YWNrIHdlYiBkZXZlbG9wZXIsIGxlYWRpbmcgdGhlIGRldmVsb3BtZW50IGFuZFxuICAgICAgICAgICAgICAgIGRlcGxveW1lbnQgb2YgYSBjb21wcmVoZW5zaXZlIGxlYXJuaW5nIG1hbmFnZW1lbnQgc3lzdGVtLiBJXG4gICAgICAgICAgICAgICAgY29sbGFib3JhdGVkIGNsb3NlbHkgd2l0aCBsZWFybmluZyBhbmQgZGV2ZWxvcG1lbnQgdGVhbXMgdG9cbiAgICAgICAgICAgICAgICBnYXRoZXIgcmVxdWlyZW1lbnRzLCBpbnRlZ3JhdGUgaWRlbnRpdHkgc3lzdGVtcyBmb3Igc2VhbWxlc3NcbiAgICAgICAgICAgICAgICBvbmJvYXJkaW5nLCBhbmQgYXV0b21hdGUga2V5IGRhdGEgaW1wb3J0cy5cbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5qb2JEZXNjcmlwdGlvbn0+XG4gICAgICAgICAgICAgICAgSSBhbHNvIHNldCB1cCBhbmQgY29uZmlndXJlZCB3ZWIgc2VydmVycyBhbmQgZGF0YWJhc2VzLFxuICAgICAgICAgICAgICAgIGRldmVsb3BlZCBjdXN0b20gYXVkaXQgdG9vbHMsIG1haW50YWluZWQgZGVwbG95bWVudHMgYWNyb3NzXG4gICAgICAgICAgICAgICAgZGV2ZWxvcG1lbnQgYW5kIHByb2R1Y3Rpb24gaW5zdGFuY2VzLCBhbmQgbGVkIHVzZXIgaW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgb3ZlcmhhdWxzIG9mIGxlZ2FjeSBhcHBsaWNhdGlvbnMuXG4gICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmV4cGVyaWVuY2VJdGVtfT5cbiAgICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT17c3R5bGVzLmpvYlRpdGxlfT5JQ1QgQ2FkZXQ8L2gxPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5qb2JEdXJhdGlvbn0+XG4gICAgICAgICAgICAgICAgTWF5IDIwMTggLSBKYW4gMjAxOSDCtyA8Yj45IG1vczwvYj5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5qb2JEZXNjcmlwdGlvbn0+XG4gICAgICAgICAgICAgICAgV2hpbGUgY29tcGxldGluZyBteSB1bml2ZXJzaXR5IHN0dWRpZXMsIEkgd29ya2VkIHBhcnQtdGltZSBhcyBhblxuICAgICAgICAgICAgICAgIElDVCBDYWRldCBzdXBwb3J0aW5nIGludGVybmFsIHNvZnR3YXJlIGRldmVsb3BtZW50IHByb2plY3RzLiBJXG4gICAgICAgICAgICAgICAgY29udHJpYnV0ZWQgdG8gdXNlciBpbnRlcmZhY2UgZGVzaWduLCBhc3Npc3RlZCB3aXRoIHJlcXVpcmVtZW50c1xuICAgICAgICAgICAgICAgIGdhdGhlcmluZywgYW5kIHBhcnRpY2lwYXRlZCBpbiBhZ2lsZSB0ZWFtIHdvcmtmbG93cy4gVGhlIHJvbGVcbiAgICAgICAgICAgICAgICBwcm92aWRlZCBoYW5kcy1vbiBleHBlcmllbmNlIHdpdGhpbiBhIHNlY3VyZSBnb3Zlcm5tZW50XG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnQgYW5kIGluY2x1ZGVkIHN0cnVjdHVyZWQgdHJhaW5pbmcgYW5kIHByb2Zlc3Npb25hbFxuICAgICAgICAgICAgICAgIGRldmVsb3BtZW50LlxuICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuZXhwZXJpZW5jZUl0ZW19PlxuICAgICAgICAgICAgICA8aDEgY2xhc3NOYW1lPXtzdHlsZXMuam9iVGl0bGV9PlxuICAgICAgICAgICAgICAgIEJhY2hlbG9yIG9mIFNvZnR3YXJlIEVuZ2luZWVyaW5nXG4gICAgICAgICAgICAgIDwvaDE+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLmpvYkR1cmF0aW9ufT5cbiAgICAgICAgICAgICAgICBKYW4gMjAxNiAtIEphbiAyMDIwIMK3IDxiPjQgeXJzPC9iPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT17c3R5bGVzLmpvYkRlc2NyaXB0aW9ufT5cbiAgICAgICAgICAgICAgICBJIGNvbXBsZXRlZCBhIEJhY2hlbG9yIG9mIFNvZnR3YXJlIEVuZ2luZWVyaW5nIGF0IHRoZSBVbml2ZXJzaXR5XG4gICAgICAgICAgICAgICAgb2YgQ2FuYmVycmEsIHdoZXJlIEkgZ2FpbmVkIGEgc29saWQgZm91bmRhdGlvbiBpbiBzb2Z0d2FyZVxuICAgICAgICAgICAgICAgIGRldmVsb3BtZW50IHByaW5jaXBsZXMsIGFsZ29yaXRobXMsIGFuZCBkYXRhIHN0cnVjdHVyZXMuIE15XG4gICAgICAgICAgICAgICAgc3R1ZGllcyBpbmNsdWRlZCBoYW5kcy1vbiBwcm9qZWN0cyB0aGF0IGVuaGFuY2VkIG15IGNvZGluZ1xuICAgICAgICAgICAgICAgIHNraWxscyBhbmQgdW5kZXJzdGFuZGluZyBvZiBzb2Z0d2FyZSBkZXNpZ24gcGF0dGVybnMuIEkgZGlkXG4gICAgICAgICAgICAgICAgbWlub3JzIGluIE5ldHdvcmtpbmcsIERlc2lnbiwgYW5kIFdlYiBhbmQgR2FtZSBEZXZlbG9wbWVudC5cbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucG9ydGZvbGlvU2VjdGlvbkRhcmt9PlxuICAgICAgICA8ZGl2XG4gICAgICAgICAgcmVmPXt0ZWNoU2VjdGlvblJlZn1cbiAgICAgICAgICBjbGFzc05hbWU9e2Ake3N0eWxlcy5jb2x1bW5Db250YWluZXJ9ICR7XG4gICAgICAgICAgICBpc1RlY2hTZWN0aW9uVmlzaWJsZSA/IHN0eWxlcy5zbGlkZUluVmlzaWJsZSA6IHN0eWxlcy5zbGlkZUluSGlkZGVuXG4gICAgICAgICAgfWB9XG4gICAgICAgID5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPXtzdHlsZXMuc2VjdGlvbkhlYWRlcn0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9uSGVhZGVyVGV4dH0+XG4gICAgICAgICAgICAgIFRlY2hub2xvZ2llcyBhbmQgTGFuZ3VhZ2VzXG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPC9oMj5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgZ2FwOiBcIjIwcHhcIixcbiAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogaXNNb2JpbGUgPyBcImNvbHVtblwiIDogXCJyb3dcIixcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy50ZWNoQ2F0ZWdvcnl9XG4gICAgICAgICAgICAgIHN0eWxlPXt7IGZsZXg6IDEsIGZvbnRTaXplOiBcIjIwcHhcIiB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8aDI+RnJvbnRlbmQ8L2gyPlxuICAgICAgICAgICAgICA8dWw+XG4gICAgICAgICAgICAgICAgPGxpPkphdmFTY3JpcHQ8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UeXBlU2NyaXB0PC9saT5cbiAgICAgICAgICAgICAgICA8bGk+UmVhY3Q8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5MZXhpY2FsLmpzPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+TmV4dC5qczwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPk5vZGUuanM8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5XZWJzb2NrZXRzPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+UmVkdXg8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5SVEsgUXVlcnk8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5IVE1MNTwvbGk+XG4gICAgICAgICAgICAgICAgPGxpPkNTUzM8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5TYXNzPC9saT5cbiAgICAgICAgICAgICAgICA8bGk+TWF0ZXJpYWwgVUk8L2xpPlxuICAgICAgICAgICAgICAgIDxsaT5UYWlsd2luZDwvbGk+XG4gICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICAgICAgICAgIGZsZXg6IDEsXG4gICAgICAgICAgICAgICAgZ2FwOiBcIjIwcHhcIixcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRlY2hDYXRlZ29yeVNlY29uZGFyeX1cbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgZmxleDogMSxcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ2YXIoLS1jb2xvci1ib3gtc2Vjb25kYXJ5KVwiLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8aDI+QmFja2VuZCAmIERldk9wczwvaDI+XG4gICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgPGxpPkphdmE8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPkdvTGFuZzwvbGk+XG4gICAgICAgICAgICAgICAgICA8bGk+TXlTUUw8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPkdpdDwvbGk+XG4gICAgICAgICAgICAgICAgICA8bGk+RG9ja2VyPC9saT5cbiAgICAgICAgICAgICAgICAgIDxsaT5LdWJlcm5ldGVzPC9saT5cbiAgICAgICAgICAgICAgICAgIDxsaT5BV1M8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPkdpdGh1YiAmIEdpdExhYjwvbGk+XG4gICAgICAgICAgICAgICAgICA8bGk+VmVyY2VsPC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRlY2hDYXRlZ29yeVNlY29uZGFyeX1cbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgZmxleDogMSxcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ2YXIoLS1jb2xvci1ib3gtc2Vjb25kYXJ5KVwiLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8aDI+VGVzdGluZzwvaDI+XG4gICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgPGxpPkplc3Q8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPlJlYWN0IFRlc3RpbmcgTGlicmFyeTwvbGk+XG4gICAgICAgICAgICAgICAgICA8bGk+UHVwcGV0ZWVyPC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICAgICAgICAgICAgZmxleDogMSxcbiAgICAgICAgICAgICAgICBnYXA6IFwiMjBweFwiLFxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudGVjaENhdGVnb3J5U2Vjb25kYXJ5fVxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBmbGV4OiAxLFxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInZhcigtLWNvbG9yLWJveC1zZWNvbmRhcnkpXCIsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxoMj5EZXNpZ248L2gyPlxuICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgIDxsaT5QaG90b3Nob3A8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPkZpZ21hPC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRlY2hDYXRlZ29yeVNlY29uZGFyeX1cbiAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgZmxleDogMSxcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJ2YXIoLS1jb2xvci1ib3gtc2Vjb25kYXJ5KVwiLFxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8aDI+R2FtZSBEZXY8L2gyPlxuICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgIDxsaT5DIzwvbGk+XG4gICAgICAgICAgICAgICAgICA8bGk+VW5pdHk8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPkJsZW5kZXI8L2xpPlxuICAgICAgICAgICAgICAgICAgPGxpPkNhc2NhZHVlciA8L2xpPlxuICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudGVjaENhdGVnb3J5U2Vjb25kYXJ5fVxuICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICBmbGV4OiAxLFxuICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcInZhcigtLWNvbG9yLWJveC1zZWNvbmRhcnkpXCIsXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxoMj5PdGhlcjwvaDI+XG4gICAgICAgICAgICAgICAgPHVsPlxuICAgICAgICAgICAgICAgICAgPGxpPkxpbnV4PC9saT5cbiAgICAgICAgICAgICAgICAgIDxsaT5BZG9iZSBQcmVtaWVyZTwvbGk+XG4gICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucG9ydGZvbGlvU2VjdGlvbn0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29sdW1uQ29udGFpbmVyfT5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPXtzdHlsZXMuc2VjdGlvbkhlYWRlcn0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9uSGVhZGVyVGV4dH0+UGVyc29uYWwgUHJvamVjdHM8L3NwYW4+XG4gICAgICAgICAgPC9oMj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBlcnNvbmFsUHJvamVjdENvbnRhaW5lcn0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnByb2plY3RIZWFkZXJ9PlxuICAgICAgICAgICAgICA8aDE+V2hlbiBHYW1lcz8gKDIwMjQpPC9oMT5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMucHJvamVjdFN0YXR1c09ubGluZX0+T25saW5lPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnByb2plY3RMaW5rc30+XG4gICAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgICAgaHJlZj1cImh0dHBzOi8vd2hlbmdhbWVzLnZlcmNlbC5hcHAvXCJcbiAgICAgICAgICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIlxuICAgICAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vcmVmZXJyZXJcIlxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgaHR0cHM6Ly93aGVuZ2FtZXMudmVyY2VsLmFwcC9cbiAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8cCBjbGFzc05hbWU9e3N0eWxlcy5zdWJ0bGVUZXh0fT5cbiAgICAgICAgICAgICAgRGFpbHkgZ2FtZSB0byBzb3J0IDEwIHJhbmRvbSB2aWRlbyBnYW1lcyBieSB0aGVpciByZWxlYXNlIGRhdGUuXG4gICAgICAgICAgICAgIENvbXBhcmUgZ2FtZSBzY3JlZW5zaG90cyBhbmQgdXNlIGNsdWVzIHRvIGd1ZXNzIHRoZSBjb3JyZWN0IG9yZGVyLlxuICAgICAgICAgICAgICBJbnNwaXJlZCBieSBteSBsb3ZlIGZvciBkYWlseSBnYW1lcyBsaWtlIFdvcmRsZSwgQ29ubmVjdGlvbnMsXG4gICAgICAgICAgICAgIEdhbWVkbGUsIGFuZCBvdGhlcnMuXG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgIHNyYz1cIi93aGVuLWdhbWVzLXNjcmVlbnNob3QucG5nXCJcbiAgICAgICAgICAgICAgYWx0PVwiV2hlbiBHYW1lcyBwcm9qZWN0XCJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMucHJvamVjdEltYWdlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBlcnNvbmFsUHJvamVjdENvbnRhaW5lcn0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnByb2plY3RIZWFkZXJ9PlxuICAgICAgICAgICAgICA8aDE+U2F2dnkgKDIwMjMpPC9oMT5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMucHJvamVjdFN0YXR1c0Rpc2NvbnRpbnVlZH0+T2ZmbGluZTwvc3Bhbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPXtzdHlsZXMuc3VidGxlVGV4dH0+XG4gICAgICAgICAgICAgIEEgbWFya2V0cGxhY2UgdG9vbCBmb3IgZGlzY292ZXJpbmcgcmFyZSBhbmQgdW5kZXJ2YWx1ZWQgQ291bnRlclxuICAgICAgICAgICAgICBTdHJpa2UgMiB3ZWFwb24gc2tpbnMuXG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8aW1nXG4gICAgICAgICAgICAgIHNyYz1cIi9zYXZ2eS1zY3JlZW5zaG90LnBuZ1wiXG4gICAgICAgICAgICAgIGFsdD1cIlNhdnZ5IHByb2plY3RcIlxuICAgICAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5wcm9qZWN0SW1hZ2V9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnBvcnRmb2xpb1NlY3Rpb25EYXJrfT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb2x1bW5Db250YWluZXJ9PlxuICAgICAgICAgIDxoMiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9uSGVhZGVyfT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLnNlY3Rpb25IZWFkZXJUZXh0fT5HYW1lIERldmVsb3BtZW50PC9zcGFuPlxuICAgICAgICAgIDwvaDI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5nYW1lUHJvamVjdENvbnRhaW5lcn0+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5zdWJ0bGVUZXh0fT5cbiAgICAgICAgICAgICAgSW4gbXkgZnJlZSB0aW1lLCBJIHdvcmsgb24gZ2FtZSBkZXZlbG9wbWVudCBwcm9qZWN0cyB1c2luZyBVbml0eVxuICAgICAgICAgICAgICBhbmQgQyMuIEknbSBwYXNzaW9uYXRlIGFib3V0IHZpZGVvIGdhbWVzIGFuZCBnYW1lIGRlc2lnbiwgYW5kXG4gICAgICAgICAgICAgIGRldmVsb3BpbmcgdGhlbSBpcyBhIHJld2FyZGluZyBhcHBsaWNhdGlvbiBvZiBteSBwcm9mZXNzaW9uYWxcbiAgICAgICAgICAgICAgc2tpbGxzLlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPXtzdHlsZXMuc3VidGxlVGV4dH0+XG4gICAgICAgICAgICAgIEdhbWUgZGV2ZWxvcG1lbnQgaGFzIG1hbnkgc2ltaWxhcml0aWVzIHRvIGZ1bGxzdGFjayB3ZWJcbiAgICAgICAgICAgICAgZGV2ZWxvcG1lbnQsIHlvdSBvZnRlbiBoYXZlIHRvIHdlYXIgbWFueSBkaWZmZXJlbnQgaGF0cyBhbmQgYmVcbiAgICAgICAgICAgICAgYWJsZSB0byBwaWVjZSBpdCBhbGwgdG9nZXRoZXIuIEl0IGhhcyBnaXZlbiBtZSB2YWx1YWJsZSBleHBlcmllbmNlXG4gICAgICAgICAgICAgIGluIGJ1aWxkaW5nIGNvbXBsZXggc3lzdGVtcyB3aGlsZSBtYWludGFpbmluZyBwZXJmb3JtYW5jZSBhbmRcbiAgICAgICAgICAgICAgdXBob2xkaW5nIGdvb2QgdmlzdWFsIGRlc2lnbiBwcmluY2lwbGVzLlxuICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPHZpZGVvIGNsYXNzTmFtZT17c3R5bGVzLmdhbWVWaWRlb30gYXV0b1BsYXkgbG9vcCBtdXRlZCBwbGF5c0lubGluZT5cbiAgICAgICAgICAgICAgPHNvdXJjZSBzcmM9XCIvZ2FtZURlbW8ud2VibVwiIHR5cGU9XCJ2aWRlby93ZWJtXCIgLz5cbiAgICAgICAgICAgIDwvdmlkZW8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMucG9ydGZvbGlvU2VjdGlvbn0+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY29sdW1uQ29udGFpbmVyfT5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnNpZ25PZmZDb250YWluZXJ9PlxuICAgICAgICAgICAgPGgyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnNlY3Rpb25IZWFkZXJ9XG4gICAgICAgICAgICAgIHN0eWxlPXt7IG1hcmdpbkJvdHRvbTogXCI2cHhcIiB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5zZWN0aW9uSGVhZGVyVGV4dH0+XG4gICAgICAgICAgICAgICAgVGhhbmtzIGZvciB2aXNpdGluZyFcbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9oMj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLnN1YnRsZVRleHR9PlxuICAgICAgICAgICAgICBGZWVsIGZyZWUgdG8gcmVhY2ggb3V0IHZpYSBMaW5rZWRJbiBvciBlbWFpbC5cbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICAgIGdhcDogXCIxMHB4XCIsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBcIjEycHhcIixcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zaWduT2ZmQ29udGFjdH0+XG4gICAgICAgICAgICAgICAgPExpbmtlZGluIGNsYXNzTmFtZT17c3R5bGVzLmNvbnRhY3RJY29ufSAvPlxuICAgICAgICAgICAgICAgIDxzcGFuPkxpbmtlZEluPC9zcGFuPlxuICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5zaWduT2ZmQ29udGFjdH0+XG4gICAgICAgICAgICAgICAgPE1haWwgY2xhc3NOYW1lPXtzdHlsZXMuY29udGFjdEljb259IC8+XG4gICAgICAgICAgICAgICAgPHNwYW4+bW9ycmlzc2V5Lm5pY2hvbGFzQGdtYWlsLmNvbTwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBIZXJvO1xuIl0sIm5hbWVzIjpbIkxpc3RJdGVtTm9kZSIsIkxpc3ROb2RlIiwiTWFya05vZGUiLCJMZXhpY2FsQ29tcG9zZXIiLCJDb250ZW50RWRpdGFibGUiLCJMZXhpY2FsRXJyb3JCb3VuZGFyeSIsIkhpc3RvcnlQbHVnaW4iLCJPbkNoYW5nZVBsdWdpbiIsIlJpY2hUZXh0UGx1Z2luIiwiSGVhZGluZ05vZGUiLCJQYXJhZ3JhcGhOb2RlIiwiVGV4dE5vZGUiLCJBcnJvd1JpZ2h0VG9MaW5lIiwiR2l0aHViIiwiTGlua2VkaW4iLCJNYWlsIiwiTWFwUGluIiwiUmVhY3QiLCJzdHlsZXMiLCJTdGF0ZUxvYWRlclBsdWdpbiIsIlRvb2xiYXJQbHVnaW4iLCJUcmFuc2xhdGlvbkV4YW1wbGUiLCJUcmVlVmlld1BsdWdpbiIsIkhlcm8iLCJpc01vYmlsZSIsInNldElzTW9iaWxlIiwidXNlU3RhdGUiLCJwYWdlSW5pdGlhbGl6ZWQiLCJzZXRQYWdlSW5pdGlhbGl6ZWQiLCJpc1RyYW5zbGF0aW9uU2VjdGlvblZpc2libGUiLCJzZXRJc1RyYW5zbGF0aW9uU2VjdGlvblZpc2libGUiLCJ0cmFuc2xhdGlvblNlY3Rpb25SZWYiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJvYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiZW50cnkiLCJpc0ludGVyc2VjdGluZyIsImNvbnNvbGUiLCJsb2ciLCJ0aHJlc2hvbGQiLCJjdXJyZW50Iiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJpc1RlY2hTZWN0aW9uVmlzaWJsZSIsInNldElzVGVjaFNlY3Rpb25WaXNpYmxlIiwidGVjaFNlY3Rpb25SZWYiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwibm9kZUxpc3QiLCJpbml0aWFsQ29uZmlnIiwibmFtZXNwYWNlIiwidGhlbWUiLCJub2RlcyIsImluaXRpYWxFZGl0b3JTdGF0ZSIsIm9uRXJyb3IiLCJlcnJvciIsImdldEV4cGVyaWVuY2VTdHJpbmciLCJzdGFydERhdGUiLCJEYXRlIiwiY3VycmVudERhdGUiLCJ5ZWFycyIsImdldEZ1bGxZZWFyIiwibW9udGhzIiwiZ2V0TW9udGgiLCJ0b3RhbE1vbnRocyIsImV4cGVyaWVuY2VZZWFycyIsIk1hdGgiLCJmbG9vciIsImV4cGVyaWVuY2VNb250aHMiLCJjZWlsIiwic2VjdGlvbiIsImNsYXNzTmFtZSIsImhlcm8iLCJkaXYiLCJoZXJvQ29udGFpbmVyIiwiaGVhZGVyQ29udGFpbmVyIiwic3R5bGUiLCJmb250U2l6ZSIsIm5hbWVDb250YWluZXIiLCJpbWciLCJzcmMiLCJhbHQiLCJwcm9maWxlSW1hZ2UiLCJuYW1lVGV4dENvbnRhaW5lciIsImgyIiwidGl0bGUiLCJoMyIsInN1YnRpdGxlIiwiZGlzcGxheSIsImFsaWduSXRlbXMiLCJmaWxsIiwiY29sb3IiLCJtYXJnaW5SaWdodCIsImg0IiwibWFyZ2luTGVmdCIsImIiLCJjb250YWN0Q29udGFpbmVyIiwiYSIsImhyZWYiLCJ0YXJnZXQiLCJyZWwiLCJjb250YWN0RmllbGQiLCJzcGFuIiwiY29udGFjdEljb24iLCJjb2x1bW5Db250YWluZXIiLCJkb2N1bWVudEVkaXRvckNvbnRhaW5lciIsInNsaWRlSW5WaXNpYmxlIiwic2xpZGVJbkhpZGRlbiIsImRvY3VtZW50RWRpdG9yIiwiZmxleCIsInBhZGRpbmciLCJiYWNrZ3JvdW5kIiwiYm9yZGVyUmFkaXVzIiwiY29udGVudEVkaXRhYmxlIiwiRXJyb3JCb3VuZGFyeSIsImRlbGF5Iiwib25DaGFuZ2UiLCJ0cmVlVmlld0NvbnRhaW5lciIsIm1hcmdpbkJvdHRvbSIsInJlZiIsInRyYW5zbGF0aW9uRWRpdG9yQ29udGFpbmVyIiwibGFuZ0luZGV4IiwiaXNJbnB1dCIsIm1hcmdpbiIsImFsaWduU2VsZiIsInBvcnRmb2xpb1NlY3Rpb24iLCJzZWN0aW9uSGVhZGVyIiwic2VjdGlvbkhlYWRlclRleHQiLCJleHBlcmllbmNlQ29udGFpbmVyIiwiZXhwZXJpZW5jZUl0ZW0iLCJoMSIsImpvYlRpdGxlIiwiam9iRHVyYXRpb24iLCJwIiwiam9iRGVzY3JpcHRpb24iLCJwb3J0Zm9saW9TZWN0aW9uRGFyayIsImdhcCIsImZsZXhEaXJlY3Rpb24iLCJ0ZWNoQ2F0ZWdvcnkiLCJ1bCIsImxpIiwidGVjaENhdGVnb3J5U2Vjb25kYXJ5IiwiYmFja2dyb3VuZENvbG9yIiwicGVyc29uYWxQcm9qZWN0Q29udGFpbmVyIiwicHJvamVjdEhlYWRlciIsInByb2plY3RTdGF0dXNPbmxpbmUiLCJwcm9qZWN0TGlua3MiLCJzdWJ0bGVUZXh0IiwicHJvamVjdEltYWdlIiwicHJvamVjdFN0YXR1c0Rpc2NvbnRpbnVlZCIsImdhbWVQcm9qZWN0Q29udGFpbmVyIiwidmlkZW8iLCJnYW1lVmlkZW8iLCJhdXRvUGxheSIsImxvb3AiLCJtdXRlZCIsInBsYXlzSW5saW5lIiwic291cmNlIiwidHlwZSIsInNpZ25PZmZDb250YWluZXIiLCJtYXJnaW5Ub3AiLCJzaWduT2ZmQ29udGFjdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/Hero.tsx\n"));

/***/ }),

/***/ "./src/components/StateLoaderPlugin.tsx":
/*!**********************************************!*\
  !*** ./src/components/StateLoaderPlugin.tsx ***!
  \**********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/rich-text */ \"./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\");\n/* harmony import */ var _lexical_list__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/list */ \"./node_modules/@lexical/list/LexicalList.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lexical_headless__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/headless */ \"./node_modules/@lexical/headless/LexicalHeadless.dev.mjs\");\n/* harmony import */ var _lexical_mark__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lexical/mark */ \"./node_modules/@lexical/mark/LexicalMark.dev.mjs\");\n/* harmony import */ var _utils_editorStates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/editorStates */ \"./src/utils/editorStates.tsx\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\nconst StateLoaderPlugin = (param)=>{\n    let { delay = 10 } = param;\n    _s();\n    const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext)();\n    const [isInitialized, setIsInitialized] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [currentNodeIndex, setCurrentNodeIndex] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);\n    const [currentCharIndex, setCurrentCharIndex] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);\n    const [isFinished, setIsFinished] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const [nodeList, setNodeList] = react__WEBPACK_IMPORTED_MODULE_1__.useState([]);\n    const [currentElementNode, setCurrentElementNode] = react__WEBPACK_IMPORTED_MODULE_1__.useState();\n    const [markCharacterCount, setMarkCharacterCount] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);\n    const [markNodeLength, setMarkNodeLength] = react__WEBPACK_IMPORTED_MODULE_1__.useState(10000);\n    const [markNodeLengths, setMarkNodeLengths] = react__WEBPACK_IMPORTED_MODULE_1__.useState([]);\n    const [currentMarkNodeIndex, setCurrentMarkNodeIndex] = react__WEBPACK_IMPORTED_MODULE_1__.useState(0);\n    const headlessEditor = (0,_lexical_headless__WEBPACK_IMPORTED_MODULE_4__.createHeadlessEditor)({\n        namespace: \"MyEditor\",\n        theme: {},\n        nodes: [\n            _lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__.HeadingNode,\n            lexical__WEBPACK_IMPORTED_MODULE_6__.ParagraphNode,\n            lexical__WEBPACK_IMPORTED_MODULE_6__.TextNode,\n            _lexical_list__WEBPACK_IMPORTED_MODULE_7__.ListNode,\n            _lexical_list__WEBPACK_IMPORTED_MODULE_7__.ListItemNode,\n            _lexical_mark__WEBPACK_IMPORTED_MODULE_8__.MarkNode\n        ],\n        onError: (error)=>console.error(error)\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        headlessEditor.update(()=>{\n            (0,lexical__WEBPACK_IMPORTED_MODULE_6__.$getEditor)().setEditorState((0,lexical__WEBPACK_IMPORTED_MODULE_6__.$getEditor)().parseEditorState(JSON.stringify(_utils_editorStates__WEBPACK_IMPORTED_MODULE_2__.mainEditorState)));\n        }, {\n            onUpdate: ()=>{\n                headlessEditor.update(()=>{\n                    const nodes = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_9__.$dfs)((0,lexical__WEBPACK_IMPORTED_MODULE_6__.$getRoot)()).map((i)=>{\n                        if ((0,_lexical_mark__WEBPACK_IMPORTED_MODULE_8__.$isMarkNode)(i.node)) {\n                            const size = i.node.getTextContentSize();\n                            setMarkNodeLengths((prev)=>[\n                                    ...prev,\n                                    size\n                                ]);\n                        }\n                        return i.node.exportJSON();\n                    });\n                    setNodeList(nodes);\n                });\n            }\n        });\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (!isInitialized && nodeList.length > 0) {\n            editor.update(()=>{\n                const root = (0,lexical__WEBPACK_IMPORTED_MODULE_6__.$getRoot)();\n                root.clear();\n            });\n            setIsInitialized(true);\n        }\n    }, [\n        editor,\n        isInitialized,\n        nodeList\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (isFinished) {\n            editor.update(()=>{\n            // $getEditor().focus();\n            });\n        }\n    }, [\n        isFinished\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (!isInitialized || isFinished || currentNodeIndex >= nodeList.length) return;\n        const interval = setInterval(()=>{\n            editor.update(()=>{\n                const currentItem = nodeList[currentNodeIndex];\n                const currentNode = currentItem;\n                if (!currentNode) return;\n                if (currentNode.type !== \"text\") {\n                    if (currentCharIndex === 0) {\n                        const root = (0,lexical__WEBPACK_IMPORTED_MODULE_6__.$getRoot)();\n                        if (currentNode.type === \"heading\") {\n                            const newHeadingNode = (0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__.$createHeadingNode)(currentNode.tag);\n                            root.append(newHeadingNode);\n                            setCurrentElementNode(newHeadingNode);\n                        } else if (currentNode.type === \"paragraph\") {\n                            const newParagraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_6__.$createParagraphNode)();\n                            root.append(newParagraphNode);\n                            setCurrentElementNode(newParagraphNode);\n                        } else if (currentNode.type === \"mark\") {\n                            const newMarkNode = (0,_lexical_mark__WEBPACK_IMPORTED_MODULE_8__.$createMarkNode)(currentNode.ids);\n                            currentElementNode.append(newMarkNode);\n                            setCurrentElementNode(newMarkNode);\n                            setMarkCharacterCount(0);\n                            setMarkNodeLength(markNodeLengths[currentMarkNodeIndex] || 0);\n                            const newMarkNodeIndex = currentMarkNodeIndex + 1;\n                            setCurrentMarkNodeIndex(newMarkNodeIndex);\n                        } else if (currentNode.type === \"list\") {\n                            const newListNode = (0,_lexical_list__WEBPACK_IMPORTED_MODULE_7__.$createListNode)(\"bullet\");\n                            root.append(newListNode);\n                            setCurrentElementNode(newListNode);\n                        } else if (currentNode.type === \"listitem\") {\n                            const newListItemNode = (0,_lexical_list__WEBPACK_IMPORTED_MODULE_7__.$createListItemNode)();\n                            const children = root.getChildren();\n                            const lastNode = children[children.length - 1];\n                            if ((0,lexical__WEBPACK_IMPORTED_MODULE_6__.$isElementNode)(lastNode)) {\n                                lastNode.append(newListItemNode);\n                                setCurrentElementNode(newListItemNode);\n                            }\n                        }\n                    }\n                    setCurrentNodeIndex((prev)=>prev + 1);\n                } else {\n                    const text = currentNode.text;\n                    const character = text[currentCharIndex];\n                    if (character && currentElementNode) {\n                        if (markCharacterCount >= markNodeLength && ((0,lexical__WEBPACK_IMPORTED_MODULE_6__.$isElementNode)(currentElementNode) || (0,_lexical_mark__WEBPACK_IMPORTED_MODULE_8__.$isMarkNode)(currentElementNode))) {\n                            currentElementNode.insertAfter((0,lexical__WEBPACK_IMPORTED_MODULE_6__.$createTextNode)(character));\n                            setCurrentElementNode(currentElementNode.getParent());\n                            setMarkNodeLength(10000000);\n                        } else {\n                            currentElementNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_6__.$createTextNode)(character));\n                            setMarkCharacterCount((prev)=>prev + 1);\n                        }\n                    }\n                    setCurrentCharIndex((prev)=>{\n                        if (prev + 1 >= text.length) {\n                            const nextIndex = currentNodeIndex + 1;\n                            if (nextIndex >= nodeList.length) {\n                                setIsFinished(true);\n                            }\n                            setCurrentNodeIndex(nextIndex);\n                            return 0;\n                        }\n                        return prev + 1;\n                    });\n                }\n            });\n        }, delay);\n        return ()=>clearInterval(interval);\n    }, [\n        editor,\n        isInitialized,\n        currentNodeIndex,\n        currentCharIndex,\n        isFinished,\n        nodeList,\n        delay,\n        currentElementNode,\n        markNodeLength,\n        headlessEditor\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, void 0, false);\n};\n_s(StateLoaderPlugin, \"BLocdxmBFmJeaCo4NytLYEBHGks=\", false, function() {\n    return [\n        _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext\n    ];\n});\n_c = StateLoaderPlugin;\n/* harmony default export */ __webpack_exports__[\"default\"] = (StateLoaderPlugin);\nvar _c;\n$RefreshReg$(_c, \"StateLoaderPlugin\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9TdGF0ZUxvYWRlclBsdWdpbi50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQWtGO0FBQ2I7QUFPOUM7QUFXTjtBQUNjO0FBQzBCO0FBQ2M7QUFDZjtBQUNsQjtBQU10QyxNQUFNcUIsb0JBQXNEO1FBQUMsRUFDM0RDLFFBQVEsRUFBRSxFQUNYOztJQUNDLE1BQU0sQ0FBQ0MsT0FBTyxHQUFHdkIsZ0dBQXlCQTtJQUMxQyxNQUFNLENBQUN3QixlQUFlQyxpQkFBaUIsR0FBR1gsMkNBQWMsQ0FBQztJQUN6RCxNQUFNLENBQUNhLGtCQUFrQkMsb0JBQW9CLEdBQUdkLDJDQUFjLENBQUM7SUFDL0QsTUFBTSxDQUFDZSxrQkFBa0JDLG9CQUFvQixHQUFHaEIsMkNBQWMsQ0FBQztJQUMvRCxNQUFNLENBQUNpQixZQUFZQyxjQUFjLEdBQUdsQiwyQ0FBYyxDQUFDO0lBQ25ELE1BQU0sQ0FBQ21CLFVBQVVDLFlBQVksR0FBR3BCLDJDQUFjLENBQTBCLEVBQUU7SUFDMUUsTUFBTSxDQUFDcUIsb0JBQW9CQyxzQkFBc0IsR0FBR3RCLDJDQUFjO0lBR2xFLE1BQU0sQ0FBQ3VCLG9CQUFvQkMsc0JBQXNCLEdBQUd4QiwyQ0FBYyxDQUFDO0lBQ25FLE1BQU0sQ0FBQ3lCLGdCQUFnQkMsa0JBQWtCLEdBQUcxQiwyQ0FBYyxDQUFDO0lBQzNELE1BQU0sQ0FBQzJCLGlCQUFpQkMsbUJBQW1CLEdBQUc1QiwyQ0FBYyxDQUFXLEVBQUU7SUFDekUsTUFBTSxDQUFDNkIsc0JBQXNCQyx3QkFBd0IsR0FBRzlCLDJDQUFjLENBQUM7SUFFdkUsTUFBTStCLGlCQUFpQjlCLHVFQUFvQkEsQ0FBQztRQUMxQytCLFdBQVc7UUFDWEMsT0FBTyxDQUFDO1FBQ1JDLE9BQU87WUFDTDlDLDJEQUFXQTtZQUNYVSxrREFBYUE7WUFDYkMsNkNBQVFBO1lBQ1JSLG1EQUFRQTtZQUNSQyx1REFBWUE7WUFDWlksbURBQVFBO1NBQ1Q7UUFDRCtCLFNBQVMsQ0FBQ0MsUUFBaUJDLFFBQVFELEtBQUssQ0FBQ0E7SUFDM0M7SUFFQXBDLDRDQUFlLENBQUM7UUFDZCtCLGVBQWVRLE1BQU0sQ0FDbkI7WUFDRTVDLG1EQUFVQSxHQUFHNkMsY0FBYyxDQUN6QjdDLG1EQUFVQSxHQUFHOEMsZ0JBQWdCLENBQUNDLEtBQUtDLFNBQVMsQ0FBQ3RDLGdFQUFlQTtRQUVoRSxHQUNBO1lBQ0V1QyxVQUFVO2dCQUNSYixlQUFlUSxNQUFNLENBQUM7b0JBQ3BCLE1BQU1MLFFBQVE1QixvREFBSUEsQ0FBQ1YsaURBQVFBLElBQUlpRCxHQUFHLENBQUMsQ0FBQ0M7d0JBQ2xDLElBQUkzQywwREFBV0EsQ0FBQzJDLEVBQUVDLElBQUksR0FBRzs0QkFDdkIsTUFBTUMsT0FBT0YsRUFBRUMsSUFBSSxDQUFDRSxrQkFBa0I7NEJBQ3RDckIsbUJBQW1CLENBQUNzQixPQUFTO3VDQUFJQTtvQ0FBTUY7aUNBQUs7d0JBQzlDO3dCQUNBLE9BQU9GLEVBQUVDLElBQUksQ0FBQ0ksVUFBVTtvQkFDMUI7b0JBQ0EvQixZQUFZYztnQkFDZDtZQUNGO1FBQ0Y7SUFFSixHQUFHLEVBQUU7SUFFTGxDLDRDQUFlLENBQUM7UUFDZCxJQUFJLENBQUNVLGlCQUFpQlMsU0FBU2lDLE1BQU0sR0FBRyxHQUFHO1lBQ3pDM0MsT0FBTzhCLE1BQU0sQ0FBQztnQkFDWixNQUFNYyxPQUFPekQsaURBQVFBO2dCQUNyQnlELEtBQUtDLEtBQUs7WUFDWjtZQUNBM0MsaUJBQWlCO1FBQ25CO0lBQ0YsR0FBRztRQUFDRjtRQUFRQztRQUFlUztLQUFTO0lBRXBDbkIsNENBQWUsQ0FBQztRQUNkLElBQUlpQixZQUFZO1lBQ2RSLE9BQU84QixNQUFNLENBQUM7WUFDWix3QkFBd0I7WUFDMUI7UUFDRjtJQUNGLEdBQUc7UUFBQ3RCO0tBQVc7SUFFZmpCLDRDQUFlLENBQUM7UUFDZCxJQUFJLENBQUNVLGlCQUFpQk8sY0FBY0osb0JBQW9CTSxTQUFTaUMsTUFBTSxFQUNyRTtRQUVGLE1BQU1HLFdBQVdDLFlBQVk7WUFDM0IvQyxPQUFPOEIsTUFBTSxDQUFDO2dCQUNaLE1BQU1rQixjQUFjdEMsUUFBUSxDQUFDTixpQkFBaUI7Z0JBQzlDLE1BQU02QyxjQUFjRDtnQkFDcEIsSUFBSSxDQUFDQyxhQUFhO2dCQUVsQixJQUFJQSxZQUFZQyxJQUFJLEtBQUssUUFBUTtvQkFDL0IsSUFBSTVDLHFCQUFxQixHQUFHO3dCQUMxQixNQUFNc0MsT0FBT3pELGlEQUFRQTt3QkFFckIsSUFBSThELFlBQVlDLElBQUksS0FBSyxXQUFXOzRCQUNsQyxNQUFNQyxpQkFBaUJ6RSxzRUFBa0JBLENBQUN1RSxZQUFZRyxHQUFHOzRCQUN6RFIsS0FBS1MsTUFBTSxDQUFDRjs0QkFDWnRDLHNCQUFzQnNDO3dCQUN4QixPQUFPLElBQUlGLFlBQVlDLElBQUksS0FBSyxhQUFhOzRCQUMzQyxNQUFNSSxtQkFBbUJ0RSw2REFBb0JBOzRCQUM3QzRELEtBQUtTLE1BQU0sQ0FBQ0M7NEJBQ1p6QyxzQkFBc0J5Qzt3QkFDeEIsT0FBTyxJQUFJTCxZQUFZQyxJQUFJLEtBQUssUUFBUTs0QkFDdEMsTUFBTUssY0FBYzlELDhEQUFlQSxDQUFDd0QsWUFBWU8sR0FBRzs0QkFDbkQ1QyxtQkFBb0J5QyxNQUFNLENBQUNFOzRCQUMzQjFDLHNCQUFzQjBDOzRCQUN0QnhDLHNCQUFzQjs0QkFDdEJFLGtCQUFrQkMsZUFBZSxDQUFDRSxxQkFBcUIsSUFBSTs0QkFDM0QsTUFBTXFDLG1CQUFtQnJDLHVCQUF1Qjs0QkFDaERDLHdCQUF3Qm9DO3dCQUMxQixPQUFPLElBQUlSLFlBQVlDLElBQUksS0FBSyxRQUFROzRCQUN0QyxNQUFNUSxjQUFjOUUsOERBQWVBLENBQUM7NEJBQ3BDZ0UsS0FBS1MsTUFBTSxDQUFDSzs0QkFDWjdDLHNCQUFzQjZDO3dCQUN4QixPQUFPLElBQUlULFlBQVlDLElBQUksS0FBSyxZQUFZOzRCQUMxQyxNQUFNUyxrQkFBa0I5RSxrRUFBbUJBOzRCQUMzQyxNQUFNK0UsV0FBV2hCLEtBQUtpQixXQUFXOzRCQUNqQyxNQUFNQyxXQUFXRixRQUFRLENBQUNBLFNBQVNqQixNQUFNLEdBQUcsRUFBRTs0QkFDOUMsSUFBSXZELHVEQUFjQSxDQUFDMEUsV0FBVztnQ0FDNUJBLFNBQVNULE1BQU0sQ0FBQ007Z0NBQ2hCOUMsc0JBQXNCOEM7NEJBQ3hCO3dCQUNGO29CQUNGO29CQUVBdEQsb0JBQW9CLENBQUNvQyxPQUFTQSxPQUFPO2dCQUN2QyxPQUFPO29CQUNMLE1BQU1zQixPQUFPZCxZQUFZYyxJQUFJO29CQUM3QixNQUFNQyxZQUFZRCxJQUFJLENBQUN6RCxpQkFBaUI7b0JBQ3hDLElBQUkwRCxhQUFhcEQsb0JBQW9CO3dCQUNuQyxJQUNFRSxzQkFBc0JFLGtCQUNyQjVCLENBQUFBLHVEQUFjQSxDQUFDd0IsdUJBQ2RsQiwwREFBV0EsQ0FBQ2tCLG1CQUFrQixHQUNoQzs0QkFDQUEsbUJBQW1CcUQsV0FBVyxDQUFDaEYsd0RBQWVBLENBQUMrRTs0QkFDL0NuRCxzQkFBc0JELG1CQUFtQnNELFNBQVM7NEJBQ2xEakQsa0JBQWtCO3dCQUNwQixPQUFPOzRCQUNMTCxtQkFBbUJ5QyxNQUFNLENBQUNwRSx3REFBZUEsQ0FBQytFOzRCQUMxQ2pELHNCQUFzQixDQUFDMEIsT0FBU0EsT0FBTzt3QkFDekM7b0JBQ0Y7b0JBRUFsQyxvQkFBb0IsQ0FBQ2tDO3dCQUNuQixJQUFJQSxPQUFPLEtBQUtzQixLQUFLcEIsTUFBTSxFQUFFOzRCQUMzQixNQUFNd0IsWUFBWS9ELG1CQUFtQjs0QkFDckMsSUFBSStELGFBQWF6RCxTQUFTaUMsTUFBTSxFQUFFO2dDQUNoQ2xDLGNBQWM7NEJBQ2hCOzRCQUNBSixvQkFBb0I4RDs0QkFDcEIsT0FBTzt3QkFDVDt3QkFDQSxPQUFPMUIsT0FBTztvQkFDaEI7Z0JBQ0Y7WUFDRjtRQUNGLEdBQUcxQztRQUVILE9BQU8sSUFBTXFFLGNBQWN0QjtJQUM3QixHQUFHO1FBQ0Q5QztRQUNBQztRQUNBRztRQUNBRTtRQUNBRTtRQUNBRTtRQUNBWDtRQUNBYTtRQUNBSTtRQUNBTTtLQUNEO0lBRUQscUJBQU87QUFDVDtHQXZLTXhCOztRQUdhckIsNEZBQXlCQTs7O0tBSHRDcUI7QUF5S04sK0RBQWVBLGlCQUFpQkEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9TdGF0ZUxvYWRlclBsdWdpbi50c3g/ZmU1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSBcIkBsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3NlckNvbnRleHRcIjtcbmltcG9ydCB7ICRjcmVhdGVIZWFkaW5nTm9kZSwgSGVhZGluZ05vZGUgfSBmcm9tIFwiQGxleGljYWwvcmljaC10ZXh0XCI7XG5pbXBvcnQge1xuICAkY3JlYXRlTGlzdE5vZGUsXG4gICRjcmVhdGVMaXN0SXRlbU5vZGUsXG4gIExpc3ROb2RlLFxuICBMaXN0SXRlbU5vZGUsXG4gICRpc0xpc3RJdGVtTm9kZSxcbn0gZnJvbSBcIkBsZXhpY2FsL2xpc3RcIjtcbmltcG9ydCB7XG4gICRjcmVhdGVQYXJhZ3JhcGhOb2RlLFxuICAkY3JlYXRlVGV4dE5vZGUsXG4gICRnZXRFZGl0b3IsXG4gICRnZXRSb290LFxuICAkaXNFbGVtZW50Tm9kZSxcbiAgRWxlbWVudE5vZGUsXG4gIFBhcmFncmFwaE5vZGUsXG4gIFRleHROb2RlLFxuICB0eXBlIFNlcmlhbGl6ZWRMZXhpY2FsTm9kZSxcbn0gZnJvbSBcImxleGljYWxcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgY3JlYXRlSGVhZGxlc3NFZGl0b3IgfSBmcm9tIFwiQGxleGljYWwvaGVhZGxlc3NcIjtcbmltcG9ydCB7ICRjcmVhdGVNYXJrTm9kZSwgJGlzTWFya05vZGUsIE1hcmtOb2RlIH0gZnJvbSBcIkBsZXhpY2FsL21hcmtcIjtcbmltcG9ydCB7IG1haW5FZGl0b3JTdGF0ZSB9IGZyb20gXCIuLi91dGlscy9lZGl0b3JTdGF0ZXNcIjtcbmltcG9ydCB7ICRkZnMgfSBmcm9tIFwiQGxleGljYWwvdXRpbHNcIjtcblxuaW50ZXJmYWNlIFN0YXRlTG9hZGVyUGx1Z2luUHJvcHMge1xuICBkZWxheT86IG51bWJlcjtcbn1cblxuY29uc3QgU3RhdGVMb2FkZXJQbHVnaW46IFJlYWN0LkZDPFN0YXRlTG9hZGVyUGx1Z2luUHJvcHM+ID0gKHtcbiAgZGVsYXkgPSAxMCxcbn0pID0+IHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIGNvbnN0IFtpc0luaXRpYWxpemVkLCBzZXRJc0luaXRpYWxpemVkXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW2N1cnJlbnROb2RlSW5kZXgsIHNldEN1cnJlbnROb2RlSW5kZXhdID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtjdXJyZW50Q2hhckluZGV4LCBzZXRDdXJyZW50Q2hhckluZGV4XSA9IFJlYWN0LnVzZVN0YXRlKDApO1xuICBjb25zdCBbaXNGaW5pc2hlZCwgc2V0SXNGaW5pc2hlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtub2RlTGlzdCwgc2V0Tm9kZUxpc3RdID0gUmVhY3QudXNlU3RhdGU8U2VyaWFsaXplZExleGljYWxOb2RlW10+KFtdKTtcbiAgY29uc3QgW2N1cnJlbnRFbGVtZW50Tm9kZSwgc2V0Q3VycmVudEVsZW1lbnROb2RlXSA9IFJlYWN0LnVzZVN0YXRlPFxuICAgIEVsZW1lbnROb2RlIHwgTWFya05vZGUgfCBMaXN0SXRlbU5vZGUgfCB1bmRlZmluZWRcbiAgPigpO1xuICBjb25zdCBbbWFya0NoYXJhY3RlckNvdW50LCBzZXRNYXJrQ2hhcmFjdGVyQ291bnRdID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gIGNvbnN0IFttYXJrTm9kZUxlbmd0aCwgc2V0TWFya05vZGVMZW5ndGhdID0gUmVhY3QudXNlU3RhdGUoMTAwMDApO1xuICBjb25zdCBbbWFya05vZGVMZW5ndGhzLCBzZXRNYXJrTm9kZUxlbmd0aHNdID0gUmVhY3QudXNlU3RhdGU8bnVtYmVyW10+KFtdKTtcbiAgY29uc3QgW2N1cnJlbnRNYXJrTm9kZUluZGV4LCBzZXRDdXJyZW50TWFya05vZGVJbmRleF0gPSBSZWFjdC51c2VTdGF0ZSgwKTtcblxuICBjb25zdCBoZWFkbGVzc0VkaXRvciA9IGNyZWF0ZUhlYWRsZXNzRWRpdG9yKHtcbiAgICBuYW1lc3BhY2U6IFwiTXlFZGl0b3JcIixcbiAgICB0aGVtZToge30sXG4gICAgbm9kZXM6IFtcbiAgICAgIEhlYWRpbmdOb2RlLFxuICAgICAgUGFyYWdyYXBoTm9kZSxcbiAgICAgIFRleHROb2RlLFxuICAgICAgTGlzdE5vZGUsXG4gICAgICBMaXN0SXRlbU5vZGUsXG4gICAgICBNYXJrTm9kZSxcbiAgICBdLFxuICAgIG9uRXJyb3I6IChlcnJvcjogRXJyb3IpID0+IGNvbnNvbGUuZXJyb3IoZXJyb3IpLFxuICB9KTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGhlYWRsZXNzRWRpdG9yLnVwZGF0ZShcbiAgICAgICgpID0+IHtcbiAgICAgICAgJGdldEVkaXRvcigpLnNldEVkaXRvclN0YXRlKFxuICAgICAgICAgICRnZXRFZGl0b3IoKS5wYXJzZUVkaXRvclN0YXRlKEpTT04uc3RyaW5naWZ5KG1haW5FZGl0b3JTdGF0ZSkpXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBvblVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGhlYWRsZXNzRWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9ICRkZnMoJGdldFJvb3QoKSkubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgIGlmICgkaXNNYXJrTm9kZShpLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGkubm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgICAgICAgICAgICBzZXRNYXJrTm9kZUxlbmd0aHMoKHByZXYpID0+IFsuLi5wcmV2LCBzaXplXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGkubm9kZS5leHBvcnRKU09OKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldE5vZGVMaXN0KG5vZGVzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgIH1cbiAgICApO1xuICB9LCBbXSk7XG5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzSW5pdGlhbGl6ZWQgJiYgbm9kZUxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICAgICAgICByb290LmNsZWFyKCk7XG4gICAgICB9KTtcbiAgICAgIHNldElzSW5pdGlhbGl6ZWQodHJ1ZSk7XG4gICAgfVxuICB9LCBbZWRpdG9yLCBpc0luaXRpYWxpemVkLCBub2RlTGlzdF0pO1xuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlzRmluaXNoZWQpIHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAvLyAkZ2V0RWRpdG9yKCkuZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2lzRmluaXNoZWRdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNJbml0aWFsaXplZCB8fCBpc0ZpbmlzaGVkIHx8IGN1cnJlbnROb2RlSW5kZXggPj0gbm9kZUxpc3QubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudEl0ZW0gPSBub2RlTGlzdFtjdXJyZW50Tm9kZUluZGV4XTtcbiAgICAgICAgY29uc3QgY3VycmVudE5vZGUgPSBjdXJyZW50SXRlbTtcbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZSkgcmV0dXJuO1xuXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS50eXBlICE9PSBcInRleHRcIikge1xuICAgICAgICAgIGlmIChjdXJyZW50Q2hhckluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnR5cGUgPT09IFwiaGVhZGluZ1wiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0hlYWRpbmdOb2RlID0gJGNyZWF0ZUhlYWRpbmdOb2RlKGN1cnJlbnROb2RlLnRhZyEpO1xuICAgICAgICAgICAgICByb290LmFwcGVuZChuZXdIZWFkaW5nTm9kZSk7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRFbGVtZW50Tm9kZShuZXdIZWFkaW5nTm9kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLnR5cGUgPT09IFwicGFyYWdyYXBoXCIpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV3UGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgICAgICAgIHJvb3QuYXBwZW5kKG5ld1BhcmFncmFwaE5vZGUpO1xuICAgICAgICAgICAgICBzZXRDdXJyZW50RWxlbWVudE5vZGUobmV3UGFyYWdyYXBoTm9kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLnR5cGUgPT09IFwibWFya1wiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld01hcmtOb2RlID0gJGNyZWF0ZU1hcmtOb2RlKGN1cnJlbnROb2RlLmlkcyEpO1xuICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudE5vZGUhLmFwcGVuZChuZXdNYXJrTm9kZSk7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRFbGVtZW50Tm9kZShuZXdNYXJrTm9kZSk7XG4gICAgICAgICAgICAgIHNldE1hcmtDaGFyYWN0ZXJDb3VudCgwKTtcbiAgICAgICAgICAgICAgc2V0TWFya05vZGVMZW5ndGgobWFya05vZGVMZW5ndGhzW2N1cnJlbnRNYXJrTm9kZUluZGV4XSB8fCAwKTtcbiAgICAgICAgICAgICAgY29uc3QgbmV3TWFya05vZGVJbmRleCA9IGN1cnJlbnRNYXJrTm9kZUluZGV4ICsgMTtcbiAgICAgICAgICAgICAgc2V0Q3VycmVudE1hcmtOb2RlSW5kZXgobmV3TWFya05vZGVJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLnR5cGUgPT09IFwibGlzdFwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5ld0xpc3ROb2RlID0gJGNyZWF0ZUxpc3ROb2RlKFwiYnVsbGV0XCIpO1xuICAgICAgICAgICAgICByb290LmFwcGVuZChuZXdMaXN0Tm9kZSk7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRFbGVtZW50Tm9kZShuZXdMaXN0Tm9kZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLnR5cGUgPT09IFwibGlzdGl0ZW1cIikge1xuICAgICAgICAgICAgICBjb25zdCBuZXdMaXN0SXRlbU5vZGUgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0Tm9kZSA9IGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgbGFzdE5vZGUuYXBwZW5kKG5ld0xpc3RJdGVtTm9kZSk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEVsZW1lbnROb2RlKG5ld0xpc3RJdGVtTm9kZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRDdXJyZW50Tm9kZUluZGV4KChwcmV2KSA9PiBwcmV2ICsgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgdGV4dCA9IGN1cnJlbnROb2RlLnRleHQhO1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlciA9IHRleHRbY3VycmVudENoYXJJbmRleF07XG4gICAgICAgICAgaWYgKGNoYXJhY3RlciAmJiBjdXJyZW50RWxlbWVudE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgbWFya0NoYXJhY3RlckNvdW50ID49IG1hcmtOb2RlTGVuZ3RoICYmXG4gICAgICAgICAgICAgICgkaXNFbGVtZW50Tm9kZShjdXJyZW50RWxlbWVudE5vZGUpIHx8XG4gICAgICAgICAgICAgICAgJGlzTWFya05vZGUoY3VycmVudEVsZW1lbnROb2RlKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjdXJyZW50RWxlbWVudE5vZGUuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZVRleHROb2RlKGNoYXJhY3RlcikpO1xuICAgICAgICAgICAgICBzZXRDdXJyZW50RWxlbWVudE5vZGUoY3VycmVudEVsZW1lbnROb2RlLmdldFBhcmVudCgpISk7XG4gICAgICAgICAgICAgIHNldE1hcmtOb2RlTGVuZ3RoKDEwMDAwMDAwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRFbGVtZW50Tm9kZS5hcHBlbmQoJGNyZWF0ZVRleHROb2RlKGNoYXJhY3RlcikpO1xuICAgICAgICAgICAgICBzZXRNYXJrQ2hhcmFjdGVyQ291bnQoKHByZXYpID0+IHByZXYgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRDdXJyZW50Q2hhckluZGV4KChwcmV2KSA9PiB7XG4gICAgICAgICAgICBpZiAocHJldiArIDEgPj0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gY3VycmVudE5vZGVJbmRleCArIDE7XG4gICAgICAgICAgICAgIGlmIChuZXh0SW5kZXggPj0gbm9kZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2V0SXNGaW5pc2hlZCh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzZXRDdXJyZW50Tm9kZUluZGV4KG5leHRJbmRleCk7XG4gICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXYgKyAxO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0sIFtcbiAgICBlZGl0b3IsXG4gICAgaXNJbml0aWFsaXplZCxcbiAgICBjdXJyZW50Tm9kZUluZGV4LFxuICAgIGN1cnJlbnRDaGFySW5kZXgsXG4gICAgaXNGaW5pc2hlZCxcbiAgICBub2RlTGlzdCxcbiAgICBkZWxheSxcbiAgICBjdXJyZW50RWxlbWVudE5vZGUsXG4gICAgbWFya05vZGVMZW5ndGgsXG4gICAgaGVhZGxlc3NFZGl0b3IsXG4gIF0pO1xuXG4gIHJldHVybiA8PjwvPjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFN0YXRlTG9hZGVyUGx1Z2luO1xuIl0sIm5hbWVzIjpbInVzZUxleGljYWxDb21wb3NlckNvbnRleHQiLCIkY3JlYXRlSGVhZGluZ05vZGUiLCJIZWFkaW5nTm9kZSIsIiRjcmVhdGVMaXN0Tm9kZSIsIiRjcmVhdGVMaXN0SXRlbU5vZGUiLCJMaXN0Tm9kZSIsIkxpc3RJdGVtTm9kZSIsIiRjcmVhdGVQYXJhZ3JhcGhOb2RlIiwiJGNyZWF0ZVRleHROb2RlIiwiJGdldEVkaXRvciIsIiRnZXRSb290IiwiJGlzRWxlbWVudE5vZGUiLCJQYXJhZ3JhcGhOb2RlIiwiVGV4dE5vZGUiLCJSZWFjdCIsImNyZWF0ZUhlYWRsZXNzRWRpdG9yIiwiJGNyZWF0ZU1hcmtOb2RlIiwiJGlzTWFya05vZGUiLCJNYXJrTm9kZSIsIm1haW5FZGl0b3JTdGF0ZSIsIiRkZnMiLCJTdGF0ZUxvYWRlclBsdWdpbiIsImRlbGF5IiwiZWRpdG9yIiwiaXNJbml0aWFsaXplZCIsInNldElzSW5pdGlhbGl6ZWQiLCJ1c2VTdGF0ZSIsImN1cnJlbnROb2RlSW5kZXgiLCJzZXRDdXJyZW50Tm9kZUluZGV4IiwiY3VycmVudENoYXJJbmRleCIsInNldEN1cnJlbnRDaGFySW5kZXgiLCJpc0ZpbmlzaGVkIiwic2V0SXNGaW5pc2hlZCIsIm5vZGVMaXN0Iiwic2V0Tm9kZUxpc3QiLCJjdXJyZW50RWxlbWVudE5vZGUiLCJzZXRDdXJyZW50RWxlbWVudE5vZGUiLCJtYXJrQ2hhcmFjdGVyQ291bnQiLCJzZXRNYXJrQ2hhcmFjdGVyQ291bnQiLCJtYXJrTm9kZUxlbmd0aCIsInNldE1hcmtOb2RlTGVuZ3RoIiwibWFya05vZGVMZW5ndGhzIiwic2V0TWFya05vZGVMZW5ndGhzIiwiY3VycmVudE1hcmtOb2RlSW5kZXgiLCJzZXRDdXJyZW50TWFya05vZGVJbmRleCIsImhlYWRsZXNzRWRpdG9yIiwibmFtZXNwYWNlIiwidGhlbWUiLCJub2RlcyIsIm9uRXJyb3IiLCJlcnJvciIsImNvbnNvbGUiLCJ1c2VFZmZlY3QiLCJ1cGRhdGUiLCJzZXRFZGl0b3JTdGF0ZSIsInBhcnNlRWRpdG9yU3RhdGUiLCJKU09OIiwic3RyaW5naWZ5Iiwib25VcGRhdGUiLCJtYXAiLCJpIiwibm9kZSIsInNpemUiLCJnZXRUZXh0Q29udGVudFNpemUiLCJwcmV2IiwiZXhwb3J0SlNPTiIsImxlbmd0aCIsInJvb3QiLCJjbGVhciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJjdXJyZW50SXRlbSIsImN1cnJlbnROb2RlIiwidHlwZSIsIm5ld0hlYWRpbmdOb2RlIiwidGFnIiwiYXBwZW5kIiwibmV3UGFyYWdyYXBoTm9kZSIsIm5ld01hcmtOb2RlIiwiaWRzIiwibmV3TWFya05vZGVJbmRleCIsIm5ld0xpc3ROb2RlIiwibmV3TGlzdEl0ZW1Ob2RlIiwiY2hpbGRyZW4iLCJnZXRDaGlsZHJlbiIsImxhc3ROb2RlIiwidGV4dCIsImNoYXJhY3RlciIsImluc2VydEFmdGVyIiwiZ2V0UGFyZW50IiwibmV4dEluZGV4IiwiY2xlYXJJbnRlcnZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/StateLoaderPlugin.tsx\n"));

/***/ }),

/***/ "./src/components/ToolbarPlugin.tsx":
/*!******************************************!*\
  !*** ./src/components/ToolbarPlugin.tsx ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _barrel_optimize_names_Bold_Download_Highlighter_Italic_Redo_Undo_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=Bold,Download,Highlighter,Italic,Redo,Undo!=!lucide-react */ \"__barrel_optimize__?names=Bold,Download,Highlighter,Italic,Redo,Undo!=!./node_modules/lucide-react/dist/esm/lucide-react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../styles/Hero.module.scss */ \"./src/styles/Hero.module.scss\");\n/* harmony import */ var _styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_mark__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/mark */ \"./node_modules/@lexical/mark/LexicalMark.dev.mjs\");\n\nvar _s = $RefreshSig$();\n\n\n\n\n\n\nconst ToolbarPlugin = ()=>{\n    _s();\n    const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext)();\n    const handleUndo = ()=>{\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_4__.UNDO_COMMAND, undefined);\n    };\n    const handleRedo = ()=>{\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_4__.REDO_COMMAND, undefined);\n    };\n    const handleBold = ()=>{\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_4__.FORMAT_TEXT_COMMAND, \"bold\");\n    };\n    const handleItalic = ()=>{\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_4__.FORMAT_TEXT_COMMAND, \"italic\");\n    };\n    const handleHighlight = ()=>{\n        editor.update(()=>{\n            const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_4__.$getSelection)();\n            if (!(0,lexical__WEBPACK_IMPORTED_MODULE_4__.$isRangeSelection)(selection)) {\n                return;\n            }\n            const randomId = Math.random().toString(36).substr(2, 9);\n            (0,_lexical_mark__WEBPACK_IMPORTED_MODULE_5__.$wrapSelectionInMarkNode)(selection, selection.isBackward(), randomId);\n        });\n    };\n    const handleDownload = ()=>{\n        editor.read(()=>{\n            navigator.clipboard.writeText(JSON.stringify(editor.getEditorState().toJSON()));\n        });\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().documentToolbar),\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Bold_Download_Highlighter_Italic_Redo_Undo_lucide_react__WEBPACK_IMPORTED_MODULE_6__.Undo, {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().toolbarButton),\n                onClick: handleUndo\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/ToolbarPlugin.tsx\",\n                lineNumber: 62,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Bold_Download_Highlighter_Italic_Redo_Undo_lucide_react__WEBPACK_IMPORTED_MODULE_6__.Redo, {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().toolbarButton),\n                onClick: handleRedo\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/ToolbarPlugin.tsx\",\n                lineNumber: 63,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().divider)\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/ToolbarPlugin.tsx\",\n                lineNumber: 64,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Bold_Download_Highlighter_Italic_Redo_Undo_lucide_react__WEBPACK_IMPORTED_MODULE_6__.Bold, {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().toolbarButton),\n                onClick: handleBold\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/ToolbarPlugin.tsx\",\n                lineNumber: 65,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Bold_Download_Highlighter_Italic_Redo_Undo_lucide_react__WEBPACK_IMPORTED_MODULE_6__.Italic, {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().toolbarButton),\n                onClick: handleItalic\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/ToolbarPlugin.tsx\",\n                lineNumber: 66,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Bold_Download_Highlighter_Italic_Redo_Undo_lucide_react__WEBPACK_IMPORTED_MODULE_6__.Highlighter, {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().toolbarButton),\n                onClick: handleHighlight\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/ToolbarPlugin.tsx\",\n                lineNumber: 67,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_Bold_Download_Highlighter_Italic_Redo_Undo_lucide_react__WEBPACK_IMPORTED_MODULE_6__.Download, {\n                className: (_styles_Hero_module_scss__WEBPACK_IMPORTED_MODULE_2___default().toolbarButton),\n                onClick: handleDownload\n            }, void 0, false, {\n                fileName: \"/home/nick/projects/portfolio/src/components/ToolbarPlugin.tsx\",\n                lineNumber: 68,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/nick/projects/portfolio/src/components/ToolbarPlugin.tsx\",\n        lineNumber: 61,\n        columnNumber: 5\n    }, undefined);\n};\n_s(ToolbarPlugin, \"MUJTZ3t3NKyXWeKoJUbyWHO70Z4=\", false, function() {\n    return [\n        _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext\n    ];\n});\n_c = ToolbarPlugin;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ToolbarPlugin);\nvar _c;\n$RefreshReg$(_c, \"ToolbarPlugin\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyUGx1Z2luLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQWtGO0FBUzVEO0FBQ1M7QUFDaUI7QUFPL0I7QUFDd0M7QUFFekQsTUFBTWUsZ0JBQTBCOztJQUM5QixNQUFNLENBQUNDLE9BQU8sR0FBR2hCLGdHQUF5QkE7SUFFMUMsTUFBTWlCLGFBQWE7UUFDakJELE9BQU9FLGVBQWUsQ0FBQ0wsaURBQVlBLEVBQUVNO0lBQ3ZDO0lBRUEsTUFBTUMsYUFBYTtRQUNqQkosT0FBT0UsZUFBZSxDQUFDTixpREFBWUEsRUFBRU87SUFDdkM7SUFFQSxNQUFNRSxhQUFhO1FBQ2pCTCxPQUFPRSxlQUFlLENBQUNQLHdEQUFtQkEsRUFBRTtJQUM5QztJQUVBLE1BQU1XLGVBQWU7UUFDbkJOLE9BQU9FLGVBQWUsQ0FBQ1Asd0RBQW1CQSxFQUFFO0lBQzlDO0lBRUEsTUFBTVksa0JBQWtCO1FBQ3RCUCxPQUFPUSxNQUFNLENBQUM7WUFDWixNQUFNQyxZQUFZaEIsc0RBQWFBO1lBQy9CLElBQUksQ0FBQ0MsMERBQWlCQSxDQUFDZSxZQUFZO2dCQUNqQztZQUNGO1lBQ0EsTUFBTUMsV0FBV0MsS0FBS0MsTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsTUFBTSxDQUFDLEdBQUc7WUFDdERoQix1RUFBd0JBLENBQUNXLFdBQVdBLFVBQVVNLFVBQVUsSUFBSUw7UUFDOUQ7SUFDRjtJQUVBLE1BQU1NLGlCQUFpQjtRQUNyQmhCLE9BQU9pQixJQUFJLENBQUM7WUFDVkMsVUFBVUMsU0FBUyxDQUFDQyxTQUFTLENBQzNCQyxLQUFLQyxTQUFTLENBQUN0QixPQUFPdUIsY0FBYyxHQUFHQyxNQUFNO1FBRWpEO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ0M7UUFBSUMsV0FBV2xDLGlGQUFzQjs7MEJBQ3BDLDhEQUFDRixnSEFBSUE7Z0JBQUNvQyxXQUFXbEMsK0VBQW9CO2dCQUFFcUMsU0FBUzVCOzs7Ozs7MEJBQ2hELDhEQUFDWixnSEFBSUE7Z0JBQUNxQyxXQUFXbEMsK0VBQW9CO2dCQUFFcUMsU0FBU3pCOzs7Ozs7MEJBQ2hELDhEQUFDcUI7Z0JBQUlDLFdBQVdsQyx5RUFBYzs7Ozs7OzBCQUM5Qiw4REFBQ1AsZ0hBQUlBO2dCQUFDeUMsV0FBV2xDLCtFQUFvQjtnQkFBRXFDLFNBQVN4Qjs7Ozs7OzBCQUNoRCw4REFBQ2pCLGtIQUFNQTtnQkFBQ3NDLFdBQVdsQywrRUFBb0I7Z0JBQUVxQyxTQUFTdkI7Ozs7OzswQkFDbEQsOERBQUNuQix1SEFBV0E7Z0JBQUN1QyxXQUFXbEMsK0VBQW9CO2dCQUFFcUMsU0FBU3RCOzs7Ozs7MEJBQ3ZELDhEQUFDckIsb0hBQVFBO2dCQUFDd0MsV0FBV2xDLCtFQUFvQjtnQkFBRXFDLFNBQVNiOzs7Ozs7Ozs7Ozs7QUFHMUQ7R0FqRE1qQjs7UUFDYWYsNEZBQXlCQTs7O0tBRHRDZTtBQW1ETiwrREFBZUEsYUFBYUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Ub29sYmFyUGx1Z2luLnRzeD8yNzEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tIFwiQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dFwiO1xuaW1wb3J0IHtcbiAgQm9sZCxcbiAgRG93bmxvYWQsXG4gIEhpZ2hsaWdodGVyLFxuICBJdGFsaWMsXG4gIFJlZG8sXG4gIFVuZGVybGluZSxcbiAgVW5kbyxcbn0gZnJvbSBcImx1Y2lkZS1yZWFjdFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgc3R5bGVzIGZyb20gXCIuLi9zdHlsZXMvSGVyby5tb2R1bGUuc2Nzc1wiO1xuaW1wb3J0IHtcbiAgJGdldFNlbGVjdGlvbixcbiAgJGlzUmFuZ2VTZWxlY3Rpb24sXG4gIEZPUk1BVF9URVhUX0NPTU1BTkQsXG4gIFJFRE9fQ09NTUFORCxcbiAgVU5ET19DT01NQU5ELFxufSBmcm9tIFwibGV4aWNhbFwiO1xuaW1wb3J0IHsgJHdyYXBTZWxlY3Rpb25Jbk1hcmtOb2RlIH0gZnJvbSBcIkBsZXhpY2FsL21hcmtcIjtcblxuY29uc3QgVG9vbGJhclBsdWdpbjogUmVhY3QuRkMgPSAoKSA9PiB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuXG4gIGNvbnN0IGhhbmRsZVVuZG8gPSAoKSA9PiB7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChVTkRPX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlUmVkbyA9ICgpID0+IHtcbiAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFJFRE9fQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVCb2xkID0gKCkgPT4ge1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRk9STUFUX1RFWFRfQ09NTUFORCwgXCJib2xkXCIpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUl0YWxpYyA9ICgpID0+IHtcbiAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKEZPUk1BVF9URVhUX0NPTU1BTkQsIFwiaXRhbGljXCIpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUhpZ2hsaWdodCA9ICgpID0+IHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByYW5kb21JZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KTtcbiAgICAgICR3cmFwU2VsZWN0aW9uSW5NYXJrTm9kZShzZWxlY3Rpb24sIHNlbGVjdGlvbi5pc0JhY2t3YXJkKCksIHJhbmRvbUlkKTtcbiAgICB9KTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVEb3dubG9hZCA9ICgpID0+IHtcbiAgICBlZGl0b3IucmVhZCgoKSA9PiB7XG4gICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkudG9KU09OKCkpXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5kb2N1bWVudFRvb2xiYXJ9PlxuICAgICAgPFVuZG8gY2xhc3NOYW1lPXtzdHlsZXMudG9vbGJhckJ1dHRvbn0gb25DbGljaz17aGFuZGxlVW5kb30gLz5cbiAgICAgIDxSZWRvIGNsYXNzTmFtZT17c3R5bGVzLnRvb2xiYXJCdXR0b259IG9uQ2xpY2s9e2hhbmRsZVJlZG99IC8+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmRpdmlkZXJ9IC8+XG4gICAgICA8Qm9sZCBjbGFzc05hbWU9e3N0eWxlcy50b29sYmFyQnV0dG9ufSBvbkNsaWNrPXtoYW5kbGVCb2xkfSAvPlxuICAgICAgPEl0YWxpYyBjbGFzc05hbWU9e3N0eWxlcy50b29sYmFyQnV0dG9ufSBvbkNsaWNrPXtoYW5kbGVJdGFsaWN9IC8+XG4gICAgICA8SGlnaGxpZ2h0ZXIgY2xhc3NOYW1lPXtzdHlsZXMudG9vbGJhckJ1dHRvbn0gb25DbGljaz17aGFuZGxlSGlnaGxpZ2h0fSAvPlxuICAgICAgPERvd25sb2FkIGNsYXNzTmFtZT17c3R5bGVzLnRvb2xiYXJCdXR0b259IG9uQ2xpY2s9e2hhbmRsZURvd25sb2FkfSAvPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgVG9vbGJhclBsdWdpbjtcbiJdLCJuYW1lcyI6WyJ1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IiwiQm9sZCIsIkRvd25sb2FkIiwiSGlnaGxpZ2h0ZXIiLCJJdGFsaWMiLCJSZWRvIiwiVW5kbyIsIlJlYWN0Iiwic3R5bGVzIiwiJGdldFNlbGVjdGlvbiIsIiRpc1JhbmdlU2VsZWN0aW9uIiwiRk9STUFUX1RFWFRfQ09NTUFORCIsIlJFRE9fQ09NTUFORCIsIlVORE9fQ09NTUFORCIsIiR3cmFwU2VsZWN0aW9uSW5NYXJrTm9kZSIsIlRvb2xiYXJQbHVnaW4iLCJlZGl0b3IiLCJoYW5kbGVVbmRvIiwiZGlzcGF0Y2hDb21tYW5kIiwidW5kZWZpbmVkIiwiaGFuZGxlUmVkbyIsImhhbmRsZUJvbGQiLCJoYW5kbGVJdGFsaWMiLCJoYW5kbGVIaWdobGlnaHQiLCJ1cGRhdGUiLCJzZWxlY3Rpb24iLCJyYW5kb21JZCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImlzQmFja3dhcmQiLCJoYW5kbGVEb3dubG9hZCIsInJlYWQiLCJuYXZpZ2F0b3IiLCJjbGlwYm9hcmQiLCJ3cml0ZVRleHQiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0RWRpdG9yU3RhdGUiLCJ0b0pTT04iLCJkaXYiLCJjbGFzc05hbWUiLCJkb2N1bWVudFRvb2xiYXIiLCJ0b29sYmFyQnV0dG9uIiwib25DbGljayIsImRpdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/ToolbarPlugin.tsx\n"));

/***/ }),

/***/ "./src/components/TranslationExample.tsx":
/*!***********************************************!*\
  !*** ./src/components/TranslationExample.tsx ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _styles_TranslationExample_module_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../styles/TranslationExample.module.scss */ \"./src/styles/TranslationExample.module.scss\");\n/* harmony import */ var _styles_TranslationExample_module_scss__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_styles_TranslationExample_module_scss__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst TranslationExample = (param)=>{\n    let { langIndex = 0, isInput = false } = param;\n    const presets = [\n        {\n            fontSize: \"16px\",\n            title: \"Rich AI Translation Tools\",\n            description: \"I identified gaps in analyst workflows when trying to translate mixed media content, and developed a tool that translated text in place while preserving:\",\n            listItems: [\n                \"Tables\",\n                \"Images\",\n                \"Lists\",\n                \"Formatting\",\n                \"Links\",\n                \"And more\"\n            ],\n            conclusion: \"It was quickly adopted agency wide and highly praised by users for its impact, particularly due to its speed and ease of use.\",\n            beforeStats: {\n                title: \"Before\",\n                items: [\n                    \"8-12 seconds per table <b>cell</b>\",\n                    \"slow to reformat results\",\n                    \"outdated open source models\",\n                    \"impossible to scan large content\"\n                ]\n            },\n            afterStats: {\n                title: \"After\",\n                items: [\n                    \"3 seconds per <b>table</b>\",\n                    \"results formatted instantly\",\n                    \"latest in-house models\",\n                    \"content can be scanned in orignal formatting\"\n                ]\n            },\n            finalParagraph: \"This tool inspired the creation of the more comprehensive document editing platform mentioned above, but remains as the standalone core component of the system, and is integral to the workflow of hundreds of daily users.\"\n        },\n        {\n            fontSize: \"13px\",\n            title: \"AI\",\n            description: \"\",\n            listItems: [\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\",\n                \"\"\n            ],\n            conclusion: \"\",\n            beforeStats: {\n                title: \"\",\n                items: [\n                    \"<b></b>8-12\",\n                    \"\",\n                    \"\",\n                    \"\"\n                ]\n            },\n            afterStats: {\n                title: \"\",\n                items: [\n                    \"<b></b>3\",\n                    \"\",\n                    \"\",\n                    \"\"\n                ]\n            },\n            finalParagraph: \"\"\n        }\n    ];\n    const preset = presets[langIndex] || presets[0];\n    if (!preset) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, void 0, false);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_TranslationExample_module_scss__WEBPACK_IMPORTED_MODULE_1___default().translationContainer),\n        style: {\n            opacity: isInput ? 0.7 : 1,\n            fontSize: preset.fontSize\n        },\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: (_styles_TranslationExample_module_scss__WEBPACK_IMPORTED_MODULE_1___default().translationContent),\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                    children: preset.title\n                }, void 0, false, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                    lineNumber: 97,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    children: preset.description\n                }, void 0, false, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                    lineNumber: 98,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                    children: preset.listItems.map((item, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            children: item\n                        }, index, false, {\n                            fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                            lineNumber: 101,\n                            columnNumber: 13\n                        }, undefined))\n                }, void 0, false, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                    lineNumber: 99,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    children: preset.conclusion\n                }, void 0, false, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                    lineNumber: 104,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_TranslationExample_module_scss__WEBPACK_IMPORTED_MODULE_1___default().translationCardContainer),\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_TranslationExample_module_scss__WEBPACK_IMPORTED_MODULE_1___default().translationCard),\n                                style: {\n                                    backgroundColor: \"var(--color-error-bg)\",\n                                    border: \"1px solid var(--color-error)\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            color: \"var(--color-error)\",\n                                            fontWeight: \"bold\"\n                                        },\n                                        children: preset.beforeStats.title\n                                    }, void 0, false, {\n                                        fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                                        lineNumber: 114,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    preset.beforeStats.items.map((item, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            dangerouslySetInnerHTML: {\n                                                __html: item\n                                            }\n                                        }, index, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                                            lineNumber: 118,\n                                            columnNumber: 17\n                                        }, undefined))\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                                lineNumber: 107,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: (_styles_TranslationExample_module_scss__WEBPACK_IMPORTED_MODULE_1___default().translationCard),\n                                style: {\n                                    backgroundColor: \"var(--color-success-bg)\",\n                                    border: \"1px solid var(--color-success)\"\n                                },\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        style: {\n                                            color: \"var(--color-success)\",\n                                            fontWeight: \"bold\"\n                                        },\n                                        children: preset.afterStats.title\n                                    }, void 0, false, {\n                                        fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                                        lineNumber: 128,\n                                        columnNumber: 15\n                                    }, undefined),\n                                    preset.afterStats.items.map((item, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                            dangerouslySetInnerHTML: {\n                                                __html: item\n                                            }\n                                        }, index, false, {\n                                            fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                                            lineNumber: 134,\n                                            columnNumber: 17\n                                        }, undefined))\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                                lineNumber: 121,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                        lineNumber: 106,\n                        columnNumber: 11\n                    }, undefined)\n                }, void 0, false, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                    lineNumber: 105,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    children: preset.finalParagraph\n                }, void 0, false, {\n                    fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n                    lineNumber: 139,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n            lineNumber: 96,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/home/nick/projects/portfolio/src/components/TranslationExample.tsx\",\n        lineNumber: 92,\n        columnNumber: 5\n    }, undefined);\n};\n_c = TranslationExample;\n/* harmony default export */ __webpack_exports__[\"default\"] = (TranslationExample);\nvar _c;\n$RefreshReg$(_c, \"TranslationExample\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9UcmFuc2xhdGlvbkV4YW1wbGUudHN4IiwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RDtBQU85RCxNQUFNQyxxQkFBd0Q7UUFBQyxFQUM3REMsWUFBWSxDQUFDLEVBQ2JDLFVBQVUsS0FBSyxFQUNoQjtJQUNDLE1BQU1DLFVBQVU7UUFDZDtZQUNFQyxVQUFVO1lBQ1ZDLE9BQU87WUFDUEMsYUFDRTtZQUNGQyxXQUFXO2dCQUNUO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0Q7WUFDREMsWUFDRTtZQUNGQyxhQUFhO2dCQUNYSixPQUFPO2dCQUNQSyxPQUFPO29CQUNMO29CQUNBO29CQUNBO29CQUNBO2lCQUNEO1lBQ0g7WUFDQUMsWUFBWTtnQkFDVk4sT0FBTztnQkFDUEssT0FBTztvQkFDTDtvQkFDQTtvQkFDQTtvQkFDQTtpQkFDRDtZQUNIO1lBQ0FFLGdCQUNFO1FBQ0o7UUFDQTtZQUNFUixVQUFVO1lBQ1ZDLE9BQU87WUFDUEMsYUFDRTtZQUNGQyxXQUFXO2dCQUNUO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2dCQUNBO2FBQ0Q7WUFDREMsWUFDRTtZQUNGQyxhQUFhO2dCQUNYSixPQUFPO2dCQUNQSyxPQUFPO29CQUNMO29CQUNBO29CQUNBO29CQUNBO2lCQUNEO1lBQ0g7WUFDQUMsWUFBWTtnQkFDVk4sT0FBTztnQkFDUEssT0FBTztvQkFDTDtvQkFDQTtvQkFDQTtvQkFDQTtpQkFDRDtZQUNIO1lBQ0FFLGdCQUNFO1FBQ0o7S0FDRDtJQUVELE1BQU1DLFNBQVNWLE9BQU8sQ0FBQ0YsVUFBVSxJQUFJRSxPQUFPLENBQUMsRUFBRTtJQUUvQyxJQUFJLENBQUNVLFFBQVEscUJBQU87SUFFcEIscUJBQ0UsOERBQUNDO1FBQ0NDLFdBQVdoQixvR0FBMkI7UUFDdENrQixPQUFPO1lBQUVDLFNBQVNoQixVQUFVLE1BQU07WUFBR0UsVUFBVVMsT0FBT1QsUUFBUTtRQUFDO2tCQUUvRCw0RUFBQ1U7WUFBSUMsV0FBV2hCLGtHQUF5Qjs7OEJBQ3ZDLDhEQUFDcUI7OEJBQUlQLE9BQU9SLEtBQUs7Ozs7Ozs4QkFDakIsOERBQUNnQjs4QkFBR1IsT0FBT1AsV0FBVzs7Ozs7OzhCQUN0Qiw4REFBQ2dCOzhCQUNFVCxPQUFPTixTQUFTLENBQUNnQixHQUFHLENBQUMsQ0FBQ0MsTUFBTUMsc0JBQzNCLDhEQUFDQztzQ0FBZ0JGOzJCQUFSQzs7Ozs7Ozs7Ozs4QkFHYiw4REFBQ0o7OEJBQUdSLE9BQU9MLFVBQVU7Ozs7Ozs4QkFDckIsOERBQUNNOzhCQUNDLDRFQUFDQTt3QkFBSUMsV0FBV2hCLHdHQUErQjs7MENBQzdDLDhEQUFDZTtnQ0FDQ0MsV0FBV2hCLCtGQUFzQjtnQ0FDakNrQixPQUFPO29DQUNMWSxpQkFBaUI7b0NBQ2pCQyxRQUFRO2dDQUNWOztrREFFQSw4REFBQ0M7d0NBQUtkLE9BQU87NENBQUVlLE9BQU87NENBQXNCQyxZQUFZO3dDQUFPO2tEQUM1RHBCLE9BQU9KLFdBQVcsQ0FBQ0osS0FBSzs7Ozs7O29DQUUxQlEsT0FBT0osV0FBVyxDQUFDQyxLQUFLLENBQUNhLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQyxzQkFDbkMsOERBQUNKOzRDQUFjYSx5QkFBeUI7Z0RBQUVDLFFBQVFYOzRDQUFLOzJDQUEvQ0M7Ozs7Ozs7Ozs7OzBDQUdaLDhEQUFDWDtnQ0FDQ0MsV0FBV2hCLCtGQUFzQjtnQ0FDakNrQixPQUFPO29DQUNMWSxpQkFBaUI7b0NBQ2pCQyxRQUFRO2dDQUNWOztrREFFQSw4REFBQ0M7d0NBQ0NkLE9BQU87NENBQUVlLE9BQU87NENBQXdCQyxZQUFZO3dDQUFPO2tEQUUxRHBCLE9BQU9GLFVBQVUsQ0FBQ04sS0FBSzs7Ozs7O29DQUV6QlEsT0FBT0YsVUFBVSxDQUFDRCxLQUFLLENBQUNhLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQyxzQkFDbEMsOERBQUNKOzRDQUFjYSx5QkFBeUI7Z0RBQUVDLFFBQVFYOzRDQUFLOzJDQUEvQ0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OEJBS2hCLDhEQUFDSjs4QkFBR1IsT0FBT0QsY0FBYzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJakM7S0F2SU1aO0FBeUlOLCtEQUFlQSxrQkFBa0JBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvVHJhbnNsYXRpb25FeGFtcGxlLnRzeD8wZTI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZXMgZnJvbSBcIi4uL3N0eWxlcy9UcmFuc2xhdGlvbkV4YW1wbGUubW9kdWxlLnNjc3NcIjtcblxuaW50ZXJmYWNlIFRyYW5zbGF0aW9uRXhhbXBsZVByb3BzIHtcbiAgbGFuZ0luZGV4PzogbnVtYmVyO1xuICBpc0lucHV0PzogYm9vbGVhbjtcbn1cblxuY29uc3QgVHJhbnNsYXRpb25FeGFtcGxlOiBSZWFjdC5GQzxUcmFuc2xhdGlvbkV4YW1wbGVQcm9wcz4gPSAoe1xuICBsYW5nSW5kZXggPSAwLFxuICBpc0lucHV0ID0gZmFsc2UsXG59KSA9PiB7XG4gIGNvbnN0IHByZXNldHMgPSBbXG4gICAge1xuICAgICAgZm9udFNpemU6IFwiMTZweFwiLFxuICAgICAgdGl0bGU6IFwiUmljaCBBSSBUcmFuc2xhdGlvbiBUb29sc1wiLFxuICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgIFwiSSBpZGVudGlmaWVkIGdhcHMgaW4gYW5hbHlzdCB3b3JrZmxvd3Mgd2hlbiB0cnlpbmcgdG8gdHJhbnNsYXRlIG1peGVkIG1lZGlhIGNvbnRlbnQsIGFuZCBkZXZlbG9wZWQgYSB0b29sIHRoYXQgdHJhbnNsYXRlZCB0ZXh0IGluIHBsYWNlIHdoaWxlIHByZXNlcnZpbmc6XCIsXG4gICAgICBsaXN0SXRlbXM6IFtcbiAgICAgICAgXCJUYWJsZXNcIixcbiAgICAgICAgXCJJbWFnZXNcIixcbiAgICAgICAgXCJMaXN0c1wiLFxuICAgICAgICBcIkZvcm1hdHRpbmdcIixcbiAgICAgICAgXCJMaW5rc1wiLFxuICAgICAgICBcIkFuZCBtb3JlXCIsXG4gICAgICBdLFxuICAgICAgY29uY2x1c2lvbjpcbiAgICAgICAgXCJJdCB3YXMgcXVpY2tseSBhZG9wdGVkIGFnZW5jeSB3aWRlIGFuZCBoaWdobHkgcHJhaXNlZCBieSB1c2VycyBmb3IgaXRzIGltcGFjdCwgcGFydGljdWxhcmx5IGR1ZSB0byBpdHMgc3BlZWQgYW5kIGVhc2Ugb2YgdXNlLlwiLFxuICAgICAgYmVmb3JlU3RhdHM6IHtcbiAgICAgICAgdGl0bGU6IFwiQmVmb3JlXCIsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgXCI4LTEyIHNlY29uZHMgcGVyIHRhYmxlIDxiPmNlbGw8L2I+XCIsXG4gICAgICAgICAgXCJzbG93IHRvIHJlZm9ybWF0IHJlc3VsdHNcIixcbiAgICAgICAgICBcIm91dGRhdGVkIG9wZW4gc291cmNlIG1vZGVsc1wiLFxuICAgICAgICAgIFwiaW1wb3NzaWJsZSB0byBzY2FuIGxhcmdlIGNvbnRlbnRcIixcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICBhZnRlclN0YXRzOiB7XG4gICAgICAgIHRpdGxlOiBcIkFmdGVyXCIsXG4gICAgICAgIGl0ZW1zOiBbXG4gICAgICAgICAgXCIzIHNlY29uZHMgcGVyIDxiPnRhYmxlPC9iPlwiLFxuICAgICAgICAgIFwicmVzdWx0cyBmb3JtYXR0ZWQgaW5zdGFudGx5XCIsXG4gICAgICAgICAgXCJsYXRlc3QgaW4taG91c2UgbW9kZWxzXCIsXG4gICAgICAgICAgXCJjb250ZW50IGNhbiBiZSBzY2FubmVkIGluIG9yaWduYWwgZm9ybWF0dGluZ1wiLFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIGZpbmFsUGFyYWdyYXBoOlxuICAgICAgICBcIlRoaXMgdG9vbCBpbnNwaXJlZCB0aGUgY3JlYXRpb24gb2YgdGhlIG1vcmUgY29tcHJlaGVuc2l2ZSBkb2N1bWVudCBlZGl0aW5nIHBsYXRmb3JtIG1lbnRpb25lZCBhYm92ZSwgYnV0IHJlbWFpbnMgYXMgdGhlIHN0YW5kYWxvbmUgY29yZSBjb21wb25lbnQgb2YgdGhlIHN5c3RlbSwgYW5kIGlzIGludGVncmFsIHRvIHRoZSB3b3JrZmxvdyBvZiBodW5kcmVkcyBvZiBkYWlseSB1c2Vycy5cIixcbiAgICB9LFxuICAgIHtcbiAgICAgIGZvbnRTaXplOiBcIjEzcHhcIixcbiAgICAgIHRpdGxlOiBcIumrmOW6puOBqkFJ57+76Kiz44OE44O844Or44Gu6ZaL55m6XCIsXG4gICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgXCLnp4Hjga/mt7flkIjjg6Hjg4fjgqPjgqLjgrPjg7Pjg4bjg7Pjg4TjgpLnv7voqLPjgZnjgovpmpvjga7jgqLjg4rjg6rjgrnjg4jjg6/jg7zjgq/jg5Xjg63jg7zjga7jgq7jg6Pjg4Pjg5fjgpLnqY3mpbXnmoTjgavnibnlrprjgZfjgIHjgZ3jga7loLTjgafjg4bjgq3jgrnjg4jjgpLnv7voqLPjgZfjgarjgYzjgonku6XkuIvjgpLkv53mjIHjgZnjgovjg4Tjg7zjg6vjgpLni6zoh6rjgavplovnmbrjgZfjgb7jgZfjgZ/vvJpcIixcbiAgICAgIGxpc3RJdGVtczogW1xuICAgICAgICBcIuODhuODvOODluODq1wiLFxuICAgICAgICBcIueUu+WDj1wiLFxuICAgICAgICBcIuODquOCueODiFwiLFxuICAgICAgICBcIuODleOCqeODvOODnuODg+ODiFwiLFxuICAgICAgICBcIuODquODs+OCr1wiLFxuICAgICAgICBcIuOBneOBruS7llwiLFxuICAgICAgXSxcbiAgICAgIGNvbmNsdXNpb246XG4gICAgICAgIFwi44GT44Gu44OE44O844Or44Gv5qmf6Zai5YWo5L2T44Gn6L+F6YCf44Gr5o6h55So44GV44KM44CB44Gd44Gu6YCf5bqm44Go5L2/44GE44KE44GZ44GV44Gr44KI44KL5b2x6Z+/5Yqb44Gn44Om44O844K244O844GL44KJ6auY44GP6KmV5L6h44GV44KM44G+44GX44Gf44CCXCIsXG4gICAgICBiZWZvcmVTdGF0czoge1xuICAgICAgICB0aXRsZTogXCLku6XliY1cIixcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICBcIuODhuODvOODluODqzxiPuOCu+ODqzwvYj7jgYLjgZ/jgoo4LTEy56eSXCIsXG4gICAgICAgICAgXCLntZDmnpzjga7lho3jg5Xjgqnjg7zjg57jg4Pjg4jjgYzpgYXjgYRcIixcbiAgICAgICAgICBcIuWPpOOBhOOCquODvOODl+ODs+OCveODvOOCueODouODh+ODq1wiLFxuICAgICAgICAgIFwi5aSn44GN44Gq44Kz44Oz44OG44Oz44OE44Gu44K544Kt44Oj44Oz44GM5LiN5Y+v6IO9XCIsXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAgYWZ0ZXJTdGF0czoge1xuICAgICAgICB0aXRsZTogXCLku6XlvoxcIixcbiAgICAgICAgaXRlbXM6IFtcbiAgICAgICAgICBcIjxiPuODhuODvOODluODqzwvYj7jgYLjgZ/jgooz56eSXCIsXG4gICAgICAgICAgXCLntZDmnpzjgYzljbPluqfjgavjg5Xjgqnjg7zjg57jg4Pjg4hcIixcbiAgICAgICAgICBcIuacgOaWsOOBruekvuWGheODouODh+ODq1wiLFxuICAgICAgICAgIFwi5YWD44Gu44OV44Kp44O844Oe44OD44OI44Gn44Kz44Oz44OG44Oz44OE44KS44K544Kt44Oj44Oz5Y+v6IO9XCIsXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAgZmluYWxQYXJhZ3JhcGg6XG4gICAgICAgIFwi44GT44Gu44OE44O844Or44GM5LiK6L+w44Gu44KI44KK5YyF5ous55qE44Gq44OJ44Kt44Ol44Oh44Oz44OI57eo6ZuG44OX44Op44OD44OI44OV44Kp44O844Og44Gu5Ym16Kit44Gr44Kk44Oz44K544OU44Os44O844K344On44Oz44KS5LiO44GI44G+44GX44Gf44GM44CB44K344K544OG44Og44Gu54us56uL44GX44Gf44Kz44Ki6KaB57Sg44Go44GX44Gm5q6L44Gj44Gm44GK44KK44CB5L2V55m+5Lq644KC44Gu5pel5bi444Om44O844K244O844Gu44Ov44O844Kv44OV44Ot44O844Gr5LiN5Y+v5qyg44Gn44GZ44CCXCIsXG4gICAgfSxcbiAgXTtcblxuICBjb25zdCBwcmVzZXQgPSBwcmVzZXRzW2xhbmdJbmRleF0gfHwgcHJlc2V0c1swXTtcblxuICBpZiAoIXByZXNldCkgcmV0dXJuIDw+PC8+O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudHJhbnNsYXRpb25Db250YWluZXJ9XG4gICAgICBzdHlsZT17eyBvcGFjaXR5OiBpc0lucHV0ID8gMC43IDogMSwgZm9udFNpemU6IHByZXNldC5mb250U2l6ZSB9fVxuICAgID5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMudHJhbnNsYXRpb25Db250ZW50fT5cbiAgICAgICAgPGgxPntwcmVzZXQudGl0bGV9PC9oMT5cbiAgICAgICAgPHA+e3ByZXNldC5kZXNjcmlwdGlvbn08L3A+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICB7cHJlc2V0Lmxpc3RJdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXG4gICAgICAgICAgICA8bGkga2V5PXtpbmRleH0+e2l0ZW19PC9saT5cbiAgICAgICAgICApKX1cbiAgICAgICAgPC91bD5cbiAgICAgICAgPHA+e3ByZXNldC5jb25jbHVzaW9ufTwvcD5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLnRyYW5zbGF0aW9uQ2FyZENvbnRhaW5lcn0+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRyYW5zbGF0aW9uQ2FyZH1cbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidmFyKC0tY29sb3ItZXJyb3ItYmcpXCIsXG4gICAgICAgICAgICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCB2YXIoLS1jb2xvci1lcnJvcilcIixcbiAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHNwYW4gc3R5bGU9e3sgY29sb3I6IFwidmFyKC0tY29sb3ItZXJyb3IpXCIsIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH19PlxuICAgICAgICAgICAgICAgIHtwcmVzZXQuYmVmb3JlU3RhdHMudGl0bGV9XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAge3ByZXNldC5iZWZvcmVTdGF0cy5pdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgPHAga2V5PXtpbmRleH0gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw9e3sgX19odG1sOiBpdGVtIH19IC8+XG4gICAgICAgICAgICAgICkpfVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLnRyYW5zbGF0aW9uQ2FyZH1cbiAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidmFyKC0tY29sb3Itc3VjY2Vzcy1iZylcIixcbiAgICAgICAgICAgICAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHZhcigtLWNvbG9yLXN1Y2Nlc3MpXCIsXG4gICAgICAgICAgICAgIH19XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgc3R5bGU9e3sgY29sb3I6IFwidmFyKC0tY29sb3Itc3VjY2VzcylcIiwgZm9udFdlaWdodDogXCJib2xkXCIgfX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtwcmVzZXQuYWZ0ZXJTdGF0cy50aXRsZX1cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICB7cHJlc2V0LmFmdGVyU3RhdHMuaXRlbXMubWFwKChpdGVtLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgIDxwIGtleT17aW5kZXh9IGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MPXt7IF9faHRtbDogaXRlbSB9fSAvPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPHA+e3ByZXNldC5maW5hbFBhcmFncmFwaH08L3A+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFRyYW5zbGF0aW9uRXhhbXBsZTtcbiJdLCJuYW1lcyI6WyJzdHlsZXMiLCJUcmFuc2xhdGlvbkV4YW1wbGUiLCJsYW5nSW5kZXgiLCJpc0lucHV0IiwicHJlc2V0cyIsImZvbnRTaXplIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImxpc3RJdGVtcyIsImNvbmNsdXNpb24iLCJiZWZvcmVTdGF0cyIsIml0ZW1zIiwiYWZ0ZXJTdGF0cyIsImZpbmFsUGFyYWdyYXBoIiwicHJlc2V0IiwiZGl2IiwiY2xhc3NOYW1lIiwidHJhbnNsYXRpb25Db250YWluZXIiLCJzdHlsZSIsIm9wYWNpdHkiLCJ0cmFuc2xhdGlvbkNvbnRlbnQiLCJoMSIsInAiLCJ1bCIsIm1hcCIsIml0ZW0iLCJpbmRleCIsImxpIiwidHJhbnNsYXRpb25DYXJkQ29udGFpbmVyIiwidHJhbnNsYXRpb25DYXJkIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwic3BhbiIsImNvbG9yIiwiZm9udFdlaWdodCIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiX19odG1sIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/TranslationExample.tsx\n"));

/***/ }),

/***/ "./src/components/TreeViewPlugin.tsx":
/*!*******************************************!*\
  !*** ./src/components/TreeViewPlugin.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ TreeViewPlugin; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _TreeViewWrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TreeViewWrapper */ \"./src/components/TreeViewWrapper.tsx\");\n// render on client\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \nvar _s = $RefreshSig$();\n\n\n\nfunction TreeViewPlugin() {\n    _s();\n    const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext)();\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_TreeViewWrapper__WEBPACK_IMPORTED_MODULE_2__.TreeViewWrapper, {\n        viewClassName: \"tree-view-output\",\n        treeTypeButtonClassName: \"hide\",\n        timeTravelPanelClassName: \"hide\",\n        timeTravelButtonClassName: \"hide\",\n        timeTravelPanelSliderClassName: \"hide\",\n        timeTravelPanelButtonClassName: \"hide\",\n        editor: editor\n    }, void 0, false, {\n        fileName: \"/home/nick/projects/portfolio/src/components/TreeViewPlugin.tsx\",\n        lineNumber: 20,\n        columnNumber: 5\n    }, this);\n}\n_s(TreeViewPlugin, \"MUJTZ3t3NKyXWeKoJUbyWHO70Z4=\", false, function() {\n    return [\n        _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.useLexicalComposerContext\n    ];\n});\n_c = TreeViewPlugin;\nvar _c;\n$RefreshReg$(_c, \"TreeViewPlugin\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9UcmVlVmlld1BsdWdpbi50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBLG1CQUFtQjtBQUVuQjs7Ozs7O0NBTUM7O0FBSWlGO0FBQ25EO0FBQ3FCO0FBRXJDLFNBQVNHOztJQUN0QixNQUFNLENBQUNDLE9BQU8sR0FBR0osZ0dBQXlCQTtJQUMxQyxxQkFDRSw4REFBQ0UsNkRBQWVBO1FBQ2RHLGVBQWM7UUFDZEMseUJBQXdCO1FBQ3hCQywwQkFBeUI7UUFDekJDLDJCQUEwQjtRQUMxQkMsZ0NBQStCO1FBQy9CQyxnQ0FBK0I7UUFDL0JOLFFBQVFBOzs7Ozs7QUFHZDtHQWJ3QkQ7O1FBQ0xILDRGQUF5QkE7OztLQURwQkciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvVHJlZVZpZXdQbHVnaW4udHN4PzA5ZTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gcmVuZGVyIG9uIGNsaWVudFxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB0eXBlIHsgSlNYIH0gZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tIFwiQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBUcmVlVmlld1dyYXBwZXIgfSBmcm9tIFwiLi9UcmVlVmlld1dyYXBwZXJcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVHJlZVZpZXdQbHVnaW4oKTogSlNYLkVsZW1lbnQge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmV0dXJuIChcbiAgICA8VHJlZVZpZXdXcmFwcGVyXG4gICAgICB2aWV3Q2xhc3NOYW1lPVwidHJlZS12aWV3LW91dHB1dFwiXG4gICAgICB0cmVlVHlwZUJ1dHRvbkNsYXNzTmFtZT1cImhpZGVcIlxuICAgICAgdGltZVRyYXZlbFBhbmVsQ2xhc3NOYW1lPVwiaGlkZVwiXG4gICAgICB0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lPVwiaGlkZVwiXG4gICAgICB0aW1lVHJhdmVsUGFuZWxTbGlkZXJDbGFzc05hbWU9XCJoaWRlXCJcbiAgICAgIHRpbWVUcmF2ZWxQYW5lbEJ1dHRvbkNsYXNzTmFtZT1cImhpZGVcIlxuICAgICAgZWRpdG9yPXtlZGl0b3J9XG4gICAgLz5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJ1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IiwiUmVhY3QiLCJUcmVlVmlld1dyYXBwZXIiLCJUcmVlVmlld1BsdWdpbiIsImVkaXRvciIsInZpZXdDbGFzc05hbWUiLCJ0cmVlVHlwZUJ1dHRvbkNsYXNzTmFtZSIsInRpbWVUcmF2ZWxQYW5lbENsYXNzTmFtZSIsInRpbWVUcmF2ZWxCdXR0b25DbGFzc05hbWUiLCJ0aW1lVHJhdmVsUGFuZWxTbGlkZXJDbGFzc05hbWUiLCJ0aW1lVHJhdmVsUGFuZWxCdXR0b25DbGFzc05hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/TreeViewPlugin.tsx\n"));

/***/ }),

/***/ "./src/components/TreeViewWrapper.tsx":
/*!********************************************!*\
  !*** ./src/components/TreeViewWrapper.tsx ***!
  \********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeViewWrapper: function() { return /* binding */ TreeViewWrapper; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lexical_devtools_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/devtools-core */ \"./node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _generateContent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./generateContent */ \"./src/components/generateContent.ts\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n/**\n * TreeView is a React component that provides a visual representation of\n * the Lexical editor's state and enables debugging features like time travel\n * and custom tree node rendering.\n *\n * @param {Object} props - The properties passed to the TreeView component.\n * @param {LexicalEditor} props.editor - The Lexical editor instance to be visualized and debugged.\n * @param {string} [props.treeTypeButtonClassName] - Custom class name for the tree type toggle button.\n * @param {string} [props.timeTravelButtonClassName] - Custom class name for the time travel toggle button.\n * @param {string} [props.timeTravelPanelButtonClassName] - Custom class name for buttons inside the time travel panel.\n * @param {string} [props.timeTravelPanelClassName] - Custom class name for the overall time travel panel container.\n * @param {string} [props.timeTravelPanelSliderClassName] - Custom class name for the time travel slider in the panel.\n * @param {string} [props.viewClassName] - Custom class name for the tree view container.\n * @param {CustomPrintNodeFn} [props.customPrintNode] - A function for customizing the display of nodes in the tree.\n *\n * @returns {JSX.Element} - A React element that visualizes the editor's state and supports debugging interactions.\n */ function TreeViewWrapper(param) {\n    let { treeTypeButtonClassName, timeTravelButtonClassName, timeTravelPanelSliderClassName, timeTravelPanelButtonClassName, timeTravelPanelClassName, viewClassName, editor } = param;\n    _s();\n    const treeElementRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createRef();\n    const [editorCurrentState, setEditorCurrentState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(editor.getEditorState());\n    const commandsLog = (0,_lexical_devtools_core__WEBPACK_IMPORTED_MODULE_3__.useLexicalCommandsLog)(editor);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Registers listeners to update the tree view when the editor state changes\n        return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)(editor.registerUpdateListener((param)=>{\n            let { editorState } = param;\n            setEditorCurrentState(editorState);\n        }), editor.registerEditableListener(()=>{\n            setEditorCurrentState(editor.getEditorState());\n        }));\n    }, [\n        editor\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const element = treeElementRef.current;\n        if (element !== null) {\n            // Assigns the editor instance to the tree view DOM element for internal tracking\n            // @ts-ignore Internal field used by Lexical\n            element.__lexicalEditor = editor;\n            return ()=>{\n                // Cleans up the reference when the component is unmounted\n                // @ts-ignore Internal field used by Lexical\n                element.__lexicalEditor = null;\n            };\n        }\n    }, [\n        editor,\n        treeElementRef\n    ]);\n    /**\n   * Handles toggling the readonly state of the editor.\n   *\n   * @param {boolean} isReadonly - Whether the editor should be set to readonly.\n   */ const handleEditorReadOnly = (isReadonly)=>{\n        const rootElement = editor.getRootElement();\n        if (rootElement == null) {\n            return;\n        }\n        rootElement.contentEditable = isReadonly ? \"false\" : \"true\";\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_lexical_devtools_core__WEBPACK_IMPORTED_MODULE_3__.TreeView, {\n        treeTypeButtonClassName: treeTypeButtonClassName,\n        timeTravelButtonClassName: timeTravelButtonClassName,\n        timeTravelPanelSliderClassName: timeTravelPanelSliderClassName,\n        timeTravelPanelButtonClassName: timeTravelPanelButtonClassName,\n        viewClassName: viewClassName,\n        timeTravelPanelClassName: timeTravelPanelClassName,\n        setEditorReadOnly: handleEditorReadOnly,\n        editorState: editorCurrentState,\n        setEditorState: (state)=>editor.setEditorState(state),\n        generateContent: async function(exportDOM) {\n            // Generates the content for the tree view, allowing customization with exportDOM and customPrintNode\n            return (0,_generateContent__WEBPACK_IMPORTED_MODULE_2__.generateContent)(editor, exportDOM);\n        },\n        ref: treeElementRef,\n        commandsLog: commandsLog\n    }, void 0, false, {\n        fileName: \"/home/nick/projects/portfolio/src/components/TreeViewWrapper.tsx\",\n        lineNumber: 107,\n        columnNumber: 5\n    }, this);\n}\n_s(TreeViewWrapper, \"SwfL/NafiuEgyR7zpCYYZC0uNzQ=\", false, function() {\n    return [\n        _lexical_devtools_core__WEBPACK_IMPORTED_MODULE_3__.useLexicalCommandsLog\n    ];\n});\n_c = TreeViewWrapper;\nvar _c;\n$RefreshReg$(_c, \"TreeViewWrapper\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9UcmVlVmlld1dyYXBwZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7OztDQU1DOztBQVErQjtBQUNlO0FBQ2hCO0FBQ2E7QUFDUTtBQUVwRDs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUVNLFNBQVNRLGdCQUFnQixLQWdCL0I7UUFoQitCLEVBQzlCQyx1QkFBdUIsRUFDdkJDLHlCQUF5QixFQUN6QkMsOEJBQThCLEVBQzlCQyw4QkFBOEIsRUFDOUJDLHdCQUF3QixFQUN4QkMsYUFBYSxFQUNiQyxNQUFNLEVBU1AsR0FoQitCOztJQWlCOUIsTUFBTUMsK0JBQWlCWiw0Q0FBZTtJQUV0QyxNQUFNLENBQUNjLG9CQUFvQkMsc0JBQXNCLEdBQUdiLCtDQUFRQSxDQUMxRFMsT0FBT0ssY0FBYztJQUd2QixNQUFNQyxjQUFjbkIsNkVBQXFCQSxDQUFDYTtJQUUxQ1YsZ0RBQVNBLENBQUM7UUFDUiw0RUFBNEU7UUFDNUUsT0FBT0YsNkRBQWFBLENBQ2xCWSxPQUFPTyxzQkFBc0IsQ0FBQztnQkFBQyxFQUFFQyxXQUFXLEVBQUU7WUFDNUNKLHNCQUFzQkk7UUFDeEIsSUFDQVIsT0FBT1Msd0JBQXdCLENBQUM7WUFDOUJMLHNCQUFzQkosT0FBT0ssY0FBYztRQUM3QztJQUVKLEdBQUc7UUFBQ0w7S0FBTztJQUVYVixnREFBU0EsQ0FBQztRQUNSLE1BQU1vQixVQUFVVCxlQUFlVSxPQUFPO1FBRXRDLElBQUlELFlBQVksTUFBTTtZQUNwQixpRkFBaUY7WUFDakYsNENBQTRDO1lBQzVDQSxRQUFRRSxlQUFlLEdBQUdaO1lBRTFCLE9BQU87Z0JBQ0wsMERBQTBEO2dCQUMxRCw0Q0FBNEM7Z0JBQzVDVSxRQUFRRSxlQUFlLEdBQUc7WUFDNUI7UUFDRjtJQUNGLEdBQUc7UUFBQ1o7UUFBUUM7S0FBZTtJQUUzQjs7OztHQUlDLEdBQ0QsTUFBTVksdUJBQXVCLENBQUNDO1FBQzVCLE1BQU1DLGNBQWNmLE9BQU9nQixjQUFjO1FBQ3pDLElBQUlELGVBQWUsTUFBTTtZQUN2QjtRQUNGO1FBRUFBLFlBQVlFLGVBQWUsR0FBR0gsYUFBYSxVQUFVO0lBQ3ZEO0lBRUEscUJBQ0UsOERBQUM1Qiw0REFBWUE7UUFDWFEseUJBQXlCQTtRQUN6QkMsMkJBQTJCQTtRQUMzQkMsZ0NBQWdDQTtRQUNoQ0MsZ0NBQWdDQTtRQUNoQ0UsZUFBZUE7UUFDZkQsMEJBQTBCQTtRQUMxQm9CLG1CQUFtQkw7UUFDbkJMLGFBQWFMO1FBQ2JnQixnQkFBZ0IsQ0FBQ0MsUUFBVXBCLE9BQU9tQixjQUFjLENBQUNDO1FBQ2pENUIsaUJBQWlCLGVBQWdCNkIsU0FBUztZQUN4QyxxR0FBcUc7WUFDckcsT0FBTzdCLGlFQUFlQSxDQUFDUSxRQUFRcUI7UUFDakM7UUFDQUMsS0FBS3JCO1FBQ0xLLGFBQWFBOzs7Ozs7QUFHbkI7R0F0RmdCYjs7UUF1Qk1OLHlFQUFxQkE7OztLQXZCM0JNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb21wb25lbnRzL1RyZWVWaWV3V3JhcHBlci50c3g/ZmE3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB0eXBlIHsgRWRpdG9yU3RhdGUsIExleGljYWxFZGl0b3IgfSBmcm9tIFwibGV4aWNhbFwiO1xuaW1wb3J0IHR5cGUgeyBKU1ggfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IHtcbiAgVHJlZVZpZXcgYXMgVHJlZVZpZXdDb3JlLFxuICB1c2VMZXhpY2FsQ29tbWFuZHNMb2csXG59IGZyb20gXCJAbGV4aWNhbC9kZXZ0b29scy1jb3JlXCI7XG5pbXBvcnQgeyBtZXJnZVJlZ2lzdGVyIH0gZnJvbSBcIkBsZXhpY2FsL3V0aWxzXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGdlbmVyYXRlQ29udGVudCB9IGZyb20gXCIuL2dlbmVyYXRlQ29udGVudFwiO1xuXG4vKipcbiAqIFRyZWVWaWV3IGlzIGEgUmVhY3QgY29tcG9uZW50IHRoYXQgcHJvdmlkZXMgYSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2ZcbiAqIHRoZSBMZXhpY2FsIGVkaXRvcidzIHN0YXRlIGFuZCBlbmFibGVzIGRlYnVnZ2luZyBmZWF0dXJlcyBsaWtlIHRpbWUgdHJhdmVsXG4gKiBhbmQgY3VzdG9tIHRyZWUgbm9kZSByZW5kZXJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gVGhlIHByb3BlcnRpZXMgcGFzc2VkIHRvIHRoZSBUcmVlVmlldyBjb21wb25lbnQuXG4gKiBAcGFyYW0ge0xleGljYWxFZGl0b3J9IHByb3BzLmVkaXRvciAtIFRoZSBMZXhpY2FsIGVkaXRvciBpbnN0YW5jZSB0byBiZSB2aXN1YWxpemVkIGFuZCBkZWJ1Z2dlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMudHJlZVR5cGVCdXR0b25DbGFzc05hbWVdIC0gQ3VzdG9tIGNsYXNzIG5hbWUgZm9yIHRoZSB0cmVlIHR5cGUgdG9nZ2xlIGJ1dHRvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMudGltZVRyYXZlbEJ1dHRvbkNsYXNzTmFtZV0gLSBDdXN0b20gY2xhc3MgbmFtZSBmb3IgdGhlIHRpbWUgdHJhdmVsIHRvZ2dsZSBidXR0b24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BzLnRpbWVUcmF2ZWxQYW5lbEJ1dHRvbkNsYXNzTmFtZV0gLSBDdXN0b20gY2xhc3MgbmFtZSBmb3IgYnV0dG9ucyBpbnNpZGUgdGhlIHRpbWUgdHJhdmVsIHBhbmVsLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wcy50aW1lVHJhdmVsUGFuZWxDbGFzc05hbWVdIC0gQ3VzdG9tIGNsYXNzIG5hbWUgZm9yIHRoZSBvdmVyYWxsIHRpbWUgdHJhdmVsIHBhbmVsIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMudGltZVRyYXZlbFBhbmVsU2xpZGVyQ2xhc3NOYW1lXSAtIEN1c3RvbSBjbGFzcyBuYW1lIGZvciB0aGUgdGltZSB0cmF2ZWwgc2xpZGVyIGluIHRoZSBwYW5lbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcHMudmlld0NsYXNzTmFtZV0gLSBDdXN0b20gY2xhc3MgbmFtZSBmb3IgdGhlIHRyZWUgdmlldyBjb250YWluZXIuXG4gKiBAcGFyYW0ge0N1c3RvbVByaW50Tm9kZUZufSBbcHJvcHMuY3VzdG9tUHJpbnROb2RlXSAtIEEgZnVuY3Rpb24gZm9yIGN1c3RvbWl6aW5nIHRoZSBkaXNwbGF5IG9mIG5vZGVzIGluIHRoZSB0cmVlLlxuICpcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gLSBBIFJlYWN0IGVsZW1lbnQgdGhhdCB2aXN1YWxpemVzIHRoZSBlZGl0b3IncyBzdGF0ZSBhbmQgc3VwcG9ydHMgZGVidWdnaW5nIGludGVyYWN0aW9ucy5cbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gVHJlZVZpZXdXcmFwcGVyKHtcbiAgdHJlZVR5cGVCdXR0b25DbGFzc05hbWUsXG4gIHRpbWVUcmF2ZWxCdXR0b25DbGFzc05hbWUsXG4gIHRpbWVUcmF2ZWxQYW5lbFNsaWRlckNsYXNzTmFtZSxcbiAgdGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lLFxuICB0aW1lVHJhdmVsUGFuZWxDbGFzc05hbWUsXG4gIHZpZXdDbGFzc05hbWUsXG4gIGVkaXRvcixcbn06IHtcbiAgZWRpdG9yOiBMZXhpY2FsRWRpdG9yO1xuICB0cmVlVHlwZUJ1dHRvbkNsYXNzTmFtZT86IHN0cmluZztcbiAgdGltZVRyYXZlbEJ1dHRvbkNsYXNzTmFtZT86IHN0cmluZztcbiAgdGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lPzogc3RyaW5nO1xuICB0aW1lVHJhdmVsUGFuZWxDbGFzc05hbWU/OiBzdHJpbmc7XG4gIHRpbWVUcmF2ZWxQYW5lbFNsaWRlckNsYXNzTmFtZT86IHN0cmluZztcbiAgdmlld0NsYXNzTmFtZT86IHN0cmluZztcbn0pOiBKU1guRWxlbWVudCB7XG4gIGNvbnN0IHRyZWVFbGVtZW50UmVmID0gUmVhY3QuY3JlYXRlUmVmPEhUTUxQcmVFbGVtZW50PigpO1xuXG4gIGNvbnN0IFtlZGl0b3JDdXJyZW50U3RhdGUsIHNldEVkaXRvckN1cnJlbnRTdGF0ZV0gPSB1c2VTdGF0ZTxFZGl0b3JTdGF0ZT4oXG4gICAgZWRpdG9yLmdldEVkaXRvclN0YXRlKClcbiAgKTtcblxuICBjb25zdCBjb21tYW5kc0xvZyA9IHVzZUxleGljYWxDb21tYW5kc0xvZyhlZGl0b3IpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUmVnaXN0ZXJzIGxpc3RlbmVycyB0byB1cGRhdGUgdGhlIHRyZWUgdmlldyB3aGVuIHRoZSBlZGl0b3Igc3RhdGUgY2hhbmdlc1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICAgICAgZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHsgZWRpdG9yU3RhdGUgfSkgPT4ge1xuICAgICAgICBzZXRFZGl0b3JDdXJyZW50U3RhdGUoZWRpdG9yU3RhdGUpO1xuICAgICAgfSksXG4gICAgICBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgICAgc2V0RWRpdG9yQ3VycmVudFN0YXRlKGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfSwgW2VkaXRvcl0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRyZWVFbGVtZW50UmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoZWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gQXNzaWducyB0aGUgZWRpdG9yIGluc3RhbmNlIHRvIHRoZSB0cmVlIHZpZXcgRE9NIGVsZW1lbnQgZm9yIGludGVybmFsIHRyYWNraW5nXG4gICAgICAvLyBAdHMtaWdub3JlIEludGVybmFsIGZpZWxkIHVzZWQgYnkgTGV4aWNhbFxuICAgICAgZWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBlZGl0b3I7XG5cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIC8vIENsZWFucyB1cCB0aGUgcmVmZXJlbmNlIHdoZW4gdGhlIGNvbXBvbmVudCBpcyB1bm1vdW50ZWRcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBJbnRlcm5hbCBmaWVsZCB1c2VkIGJ5IExleGljYWxcbiAgICAgICAgZWxlbWVudC5fX2xleGljYWxFZGl0b3IgPSBudWxsO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtlZGl0b3IsIHRyZWVFbGVtZW50UmVmXSk7XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdG9nZ2xpbmcgdGhlIHJlYWRvbmx5IHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSZWFkb25seSAtIFdoZXRoZXIgdGhlIGVkaXRvciBzaG91bGQgYmUgc2V0IHRvIHJlYWRvbmx5LlxuICAgKi9cbiAgY29uc3QgaGFuZGxlRWRpdG9yUmVhZE9ubHkgPSAoaXNSZWFkb25seTogYm9vbGVhbikgPT4ge1xuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgaWYgKHJvb3RFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByb290RWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBpc1JlYWRvbmx5ID8gXCJmYWxzZVwiIDogXCJ0cnVlXCI7XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8VHJlZVZpZXdDb3JlXG4gICAgICB0cmVlVHlwZUJ1dHRvbkNsYXNzTmFtZT17dHJlZVR5cGVCdXR0b25DbGFzc05hbWV9XG4gICAgICB0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lPXt0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lfVxuICAgICAgdGltZVRyYXZlbFBhbmVsU2xpZGVyQ2xhc3NOYW1lPXt0aW1lVHJhdmVsUGFuZWxTbGlkZXJDbGFzc05hbWV9XG4gICAgICB0aW1lVHJhdmVsUGFuZWxCdXR0b25DbGFzc05hbWU9e3RpbWVUcmF2ZWxQYW5lbEJ1dHRvbkNsYXNzTmFtZX1cbiAgICAgIHZpZXdDbGFzc05hbWU9e3ZpZXdDbGFzc05hbWV9XG4gICAgICB0aW1lVHJhdmVsUGFuZWxDbGFzc05hbWU9e3RpbWVUcmF2ZWxQYW5lbENsYXNzTmFtZX1cbiAgICAgIHNldEVkaXRvclJlYWRPbmx5PXtoYW5kbGVFZGl0b3JSZWFkT25seX1cbiAgICAgIGVkaXRvclN0YXRlPXtlZGl0b3JDdXJyZW50U3RhdGV9XG4gICAgICBzZXRFZGl0b3JTdGF0ZT17KHN0YXRlKSA9PiBlZGl0b3Iuc2V0RWRpdG9yU3RhdGUoc3RhdGUpfVxuICAgICAgZ2VuZXJhdGVDb250ZW50PXthc3luYyBmdW5jdGlvbiAoZXhwb3J0RE9NKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgY29udGVudCBmb3IgdGhlIHRyZWUgdmlldywgYWxsb3dpbmcgY3VzdG9taXphdGlvbiB3aXRoIGV4cG9ydERPTSBhbmQgY3VzdG9tUHJpbnROb2RlXG4gICAgICAgIHJldHVybiBnZW5lcmF0ZUNvbnRlbnQoZWRpdG9yLCBleHBvcnRET00pO1xuICAgICAgfX1cbiAgICAgIHJlZj17dHJlZUVsZW1lbnRSZWZ9XG4gICAgICBjb21tYW5kc0xvZz17Y29tbWFuZHNMb2d9XG4gICAgLz5cbiAgKTtcbn1cbiJdLCJuYW1lcyI6WyJUcmVlVmlldyIsIlRyZWVWaWV3Q29yZSIsInVzZUxleGljYWxDb21tYW5kc0xvZyIsIm1lcmdlUmVnaXN0ZXIiLCJSZWFjdCIsInVzZUVmZmVjdCIsInVzZVN0YXRlIiwiZ2VuZXJhdGVDb250ZW50IiwiVHJlZVZpZXdXcmFwcGVyIiwidHJlZVR5cGVCdXR0b25DbGFzc05hbWUiLCJ0aW1lVHJhdmVsQnV0dG9uQ2xhc3NOYW1lIiwidGltZVRyYXZlbFBhbmVsU2xpZGVyQ2xhc3NOYW1lIiwidGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lIiwidGltZVRyYXZlbFBhbmVsQ2xhc3NOYW1lIiwidmlld0NsYXNzTmFtZSIsImVkaXRvciIsInRyZWVFbGVtZW50UmVmIiwiY3JlYXRlUmVmIiwiZWRpdG9yQ3VycmVudFN0YXRlIiwic2V0RWRpdG9yQ3VycmVudFN0YXRlIiwiZ2V0RWRpdG9yU3RhdGUiLCJjb21tYW5kc0xvZyIsInJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIiLCJlZGl0b3JTdGF0ZSIsInJlZ2lzdGVyRWRpdGFibGVMaXN0ZW5lciIsImVsZW1lbnQiLCJjdXJyZW50IiwiX19sZXhpY2FsRWRpdG9yIiwiaGFuZGxlRWRpdG9yUmVhZE9ubHkiLCJpc1JlYWRvbmx5Iiwicm9vdEVsZW1lbnQiLCJnZXRSb290RWxlbWVudCIsImNvbnRlbnRFZGl0YWJsZSIsInNldEVkaXRvclJlYWRPbmx5Iiwic2V0RWRpdG9yU3RhdGUiLCJzdGF0ZSIsImV4cG9ydERPTSIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/TreeViewWrapper.tsx\n"));

/***/ }),

/***/ "./src/components/generateContent.ts":
/*!*******************************************!*\
  !*** ./src/components/generateContent.ts ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateContent: function() { return /* binding */ generateContent; }\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/html */ \"./node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/link */ \"./node_modules/@lexical/link/LexicalLink.dev.mjs\");\n/* harmony import */ var _lexical_mark__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/mark */ \"./node_modules/@lexical/mark/LexicalMark.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */ \n\n\n\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n    \"\t\": \"\\\\t\",\n    \"\\n\": \"\\\\n\"\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join(\"|\"), \"g\");\nconst SYMBOLS = Object.freeze({\n    ancestorHasNextSibling: \"|\",\n    ancestorIsLastChild: \" \",\n    hasNextSibling: \"\",\n    isLastChild: \"\",\n    selectedChar: \"^\",\n    selectedLine: \">\"\n});\nconst FORMAT_PREDICATES = [\n    (node)=>node.hasFormat(\"bold\") && \"Bold\",\n    (node)=>node.hasFormat(\"code\") && \"Code\",\n    (node)=>node.hasFormat(\"italic\") && \"Italic\",\n    (node)=>node.hasFormat(\"strikethrough\") && \"Strikethrough\",\n    (node)=>node.hasFormat(\"subscript\") && \"Subscript\",\n    (node)=>node.hasFormat(\"superscript\") && \"Superscript\",\n    (node)=>node.hasFormat(\"underline\") && \"Underline\",\n    (node)=>node.hasFormat(\"highlight\") && \"Highlight\"\n];\nconst FORMAT_PREDICATES_PARAGRAPH = [\n    (node)=>node.hasTextFormat(\"bold\") && \"Bold\",\n    (node)=>node.hasTextFormat(\"code\") && \"Code\",\n    (node)=>node.hasTextFormat(\"italic\") && \"Italic\",\n    (node)=>node.hasTextFormat(\"strikethrough\") && \"Strikethrough\",\n    (node)=>node.hasTextFormat(\"subscript\") && \"Subscript\",\n    (node)=>node.hasTextFormat(\"superscript\") && \"Superscript\",\n    (node)=>node.hasTextFormat(\"underline\") && \"Underline\",\n    (node)=>node.hasTextFormat(\"highlight\") && \"Highlight\"\n];\nconst DETAIL_PREDICATES = [\n    (node)=>node.isDirectionless() && \"Directionless\",\n    (node)=>node.isUnmergeable() && \"Unmergeable\"\n];\nconst MODE_PREDICATES = [\n    (node)=>node.isToken() && \"Token\",\n    (node)=>node.isSegmented() && \"Segmented\"\n];\nfunction generateContent(editor, exportDOM, customPrintNode) {\n    let obfuscateText = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    const editorState = editor.getEditorState();\n    const editorConfig = editor._config;\n    const compositionKey = editor._compositionKey;\n    const editable = editor._editable;\n    if (exportDOM) {\n        let htmlString = \"\";\n        editorState.read(()=>{\n            htmlString = printPrettyHTML((0,_lexical_html__WEBPACK_IMPORTED_MODULE_0__.$generateHtmlFromNodes)(editor));\n        });\n        return htmlString;\n    }\n    let res = \" root\\n\";\n    const selectionString = editorState.read(()=>{\n        const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getSelection)();\n        visitTree((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$getRoot)(), (node, indent)=>{\n            const nodeKey = node.getKey();\n            const nodeKeyDisplay = \"\";\n            const typeDisplay = node.getType() || \"\";\n            const isSelected = node.isSelected();\n            res += \"\".concat(isSelected ? SYMBOLS.selectedLine : \" \", \" \").concat(indent.join(\" \"), \" \").concat(nodeKeyDisplay, \" \").concat(typeDisplay, \" \").concat(printNode(node, customPrintNode, obfuscateText), \"\\n\");\n            res += $printSelectedCharsLine({\n                indent,\n                isSelected,\n                node,\n                nodeKeyDisplay,\n                selection,\n                typeDisplay\n            });\n        });\n        return selection === null ? \": null\" : (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection) ? printRangeSelection(selection) : null;\n    });\n    res += \"\\n selection\" + selectionString;\n    return res;\n}\nfunction printRangeSelection(selection) {\n    let res = \"\";\n    const formatText = printFormatProperties(selection);\n    res += \": range \".concat(formatText !== \"\" ? \"{ \".concat(formatText, \" }\") : \"\", \" \").concat(selection.style !== \"\" ? \"{ style: \".concat(selection.style, \" } \") : \"\");\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    res += \"\\n   anchor { key: \".concat(anchor.key, \", offset: \").concat(anchorOffset === null ? \"null\" : anchorOffset, \", type: \").concat(anchor.type, \" }\");\n    res += \"\\n   focus { key: \".concat(focus.key, \", offset: \").concat(focusOffset === null ? \"null\" : focusOffset, \", type: \").concat(focus.type, \" }\");\n    return res;\n}\nfunction printNodeSelection(selection) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isNodeSelection)(selection)) {\n        return \"\";\n    }\n    return \": node\\n   [\".concat(Array.from(selection._nodes).join(\", \"), \"]\");\n}\nfunction visitTree(currentNode, visitor) {\n    let indent = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    const childNodes = currentNode.getChildren();\n    const childNodesLength = childNodes.length;\n    childNodes.forEach((childNode, i)=>{\n        const value = i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling;\n        visitor(childNode, indent.concat(value));\n        const value2 = i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling;\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isElementNode)(childNode)) {\n            visitTree(childNode, visitor, indent.concat(value2));\n        }\n    });\n}\nfunction normalize(text) {\n    let obfuscateText = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const textToPrint = Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, param)=>{\n        let [key, value] = param;\n        return acc.replace(new RegExp(key, \"g\"), String(value));\n    }, text);\n    if (obfuscateText) {\n        return textToPrint.replace(/[^\\s]/g, \"*\");\n    }\n    return textToPrint;\n}\nfunction printNode(node, customPrintNode) {\n    let obfuscateText = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n    const customPrint = customPrintNode ? customPrintNode(node, obfuscateText) : undefined;\n    if (customPrint !== undefined && customPrint.length > 0) {\n        return customPrint;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(node)) {\n        const text = node.getTextContent();\n        const title = text.length === 0 ? \"(empty)\" : '\"'.concat(normalize(text, obfuscateText), '\"');\n        const properties = printAllTextNodeProperties(node);\n        return [\n            title,\n            properties.length !== 0 ? \"{ \".concat(properties, \" }\") : null\n        ].filter(Boolean).join(\" \").trim();\n    } else if ((0,_lexical_link__WEBPACK_IMPORTED_MODULE_2__.$isLinkNode)(node)) {\n        const link = node.getURL();\n        const title = link.length === 0 ? \"(empty)\" : '\"'.concat(normalize(link, obfuscateText), '\"');\n        const properties = printAllLinkNodeProperties(node);\n        return [\n            title,\n            properties.length !== 0 ? \"{ \".concat(properties, \" }\") : null\n        ].filter(Boolean).join(\" \").trim();\n    } else if ((0,_lexical_mark__WEBPACK_IMPORTED_MODULE_3__.$isMarkNode)(node)) {\n        return \"ids: [ \".concat(node.getIDs().join(\", \"), \" ]\");\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isParagraphNode)(node)) {\n        const formatText = printTextFormatProperties(node);\n        let paragraphData = formatText !== \"\" ? \"{ \".concat(formatText, \" }\") : \"\";\n        paragraphData += node.__style ? \"(\".concat(node.__style, \")\") : \"\";\n        return paragraphData;\n    } else {\n        return \"\";\n    }\n}\nfunction printTextFormatProperties(nodeOrSelection) {\n    let str = FORMAT_PREDICATES_PARAGRAPH.map((predicate)=>predicate(nodeOrSelection)).filter(Boolean).join(\", \").toLocaleLowerCase();\n    if (str !== \"\") {\n        str = \"format: \" + str;\n    }\n    return str;\n}\nfunction printAllTextNodeProperties(node) {\n    return [\n        printFormatProperties(node),\n        printDetailProperties(node),\n        printModeProperties(node),\n        printStateProperties(node)\n    ].filter(Boolean).join(\", \");\n}\nfunction printAllLinkNodeProperties(node) {\n    return [\n        printTargetProperties(node),\n        printRelProperties(node),\n        printTitleProperties(node),\n        printStateProperties(node)\n    ].filter(Boolean).join(\", \");\n}\nfunction printDetailProperties(nodeOrSelection) {\n    let str = DETAIL_PREDICATES.map((predicate)=>predicate(nodeOrSelection)).filter(Boolean).join(\", \").toLocaleLowerCase();\n    if (str !== \"\") {\n        str = \"detail: \" + str;\n    }\n    return str;\n}\nfunction printModeProperties(nodeOrSelection) {\n    let str = MODE_PREDICATES.map((predicate)=>predicate(nodeOrSelection)).filter(Boolean).join(\", \").toLocaleLowerCase();\n    if (str !== \"\") {\n        str = \"mode: \" + str;\n    }\n    return str;\n}\nfunction printFormatProperties(nodeOrSelection) {\n    let str = FORMAT_PREDICATES.map((predicate)=>predicate(nodeOrSelection)).filter(Boolean).join(\", \").toLocaleLowerCase();\n    if (str !== \"\") {\n        str = \"format: \" + str;\n    }\n    return str;\n}\nfunction printTargetProperties(node) {\n    let str = node.getTarget();\n    // TODO Fix nullish on LinkNode\n    if (str != null) {\n        str = \"target: \" + str;\n    }\n    return str;\n}\nfunction printRelProperties(node) {\n    let str = node.getRel();\n    // TODO Fix nullish on LinkNode\n    if (str != null) {\n        str = \"rel: \" + str;\n    }\n    return str;\n}\nfunction printTitleProperties(node) {\n    let str = node.getTitle();\n    // TODO Fix nullish on LinkNode\n    if (str != null) {\n        str = \"title: \" + str;\n    }\n    return str;\n}\nfunction printStateProperties(node) {\n    if (!node.__state) {\n        return false;\n    }\n    const states = [];\n    for (const [stateType, value] of node.__state.knownState.entries()){\n        if (stateType.isEqual(value, stateType.defaultValue)) {\n            continue;\n        }\n        const textValue = JSON.stringify(stateType.unparse(value));\n        states.push(\"[\".concat(stateType.key, \": \").concat(textValue, \"]\"));\n    }\n    let str = states.join(\",\");\n    if (str !== \"\") {\n        str = \"state: \" + str;\n    }\n    return str;\n}\nfunction $printSelectedCharsLine(param) {\n    let { indent, isSelected, node, nodeKeyDisplay, selection, typeDisplay } = param;\n    // No selection or node is not selected.\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isTextNode)(node) || !(0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isRangeSelection)(selection) || !isSelected || (0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isElementNode)(node)) {\n        return \"\";\n    }\n    // No selected characters.\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (node.getTextContent() === \"\" || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n        return \"\";\n    }\n    const [start, end] = $getSelectionStartEnd(node, selection);\n    if (start === end) {\n        return \"\";\n    }\n    const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n    const indentionChars = [\n        ...indent.slice(0, indent.length - 1),\n        selectionLastIndent\n    ];\n    const unselectedChars = Array(start + 1).fill(\" \");\n    const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n    const paddingLength = typeDisplay.length + 2; // 1 for the space after + 1 for the double quote.\n    const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(\" \");\n    return [\n        SYMBOLS.selectedLine,\n        indentionChars.join(\" \"),\n        [\n            ...nodePrintSpaces,\n            ...unselectedChars,\n            ...selectedChars\n        ].join(\"\")\n    ].join(\" \") + \"\\n\";\n}\nfunction printPrettyHTML(str) {\n    const div = document.createElement(\"div\");\n    div.innerHTML = str.trim();\n    return prettifyHTML(div, 0).innerHTML;\n}\nfunction prettifyHTML(node, level) {\n    const indentBefore = new Array(level++ + 1).join(\"  \");\n    const indentAfter = new Array(level - 1).join(\"  \");\n    let textNode;\n    for(let i = 0; i < node.children.length; i++){\n        textNode = document.createTextNode(\"\\n\" + indentBefore);\n        node.insertBefore(textNode, node.children[i]);\n        prettifyHTML(node.children[i], level);\n        if (node.lastElementChild === node.children[i]) {\n            textNode = document.createTextNode(\"\\n\" + indentAfter);\n            node.appendChild(textNode);\n        }\n    }\n    return node;\n}\nfunction $getSelectionStartEnd(node, selection) {\n    const anchorAndFocus = selection.getStartEndPoints();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_1__.$isNodeSelection)(selection) || anchorAndFocus === null) {\n        return [\n            -1,\n            -1\n        ];\n    }\n    const [anchor, focus] = anchorAndFocus;\n    const textContent = node.getTextContent();\n    const textLength = textContent.length;\n    let start = -1;\n    let end = -1;\n    // Only one node is being selected.\n    if (anchor.type === \"text\" && focus.type === \"text\") {\n        const anchorNode = anchor.getNode();\n        const focusNode = focus.getNode();\n        if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n            [start, end] = anchor.offset < focus.offset ? [\n                anchor.offset,\n                focus.offset\n            ] : [\n                focus.offset,\n                anchor.offset\n            ];\n        } else if (node === anchorNode) {\n            [start, end] = anchorNode.isBefore(focusNode) ? [\n                anchor.offset,\n                textLength\n            ] : [\n                0,\n                anchor.offset\n            ];\n        } else if (node === focusNode) {\n            [start, end] = focusNode.isBefore(anchorNode) ? [\n                focus.offset,\n                textLength\n            ] : [\n                0,\n                focus.offset\n            ];\n        } else {\n            // Node is within selection but not the anchor nor focus.\n            [start, end] = [\n                0,\n                textLength\n            ];\n        }\n    }\n    // Account for non-single width characters.\n    const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n    const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n    return [\n        start + numNonSingleWidthCharBeforeSelection,\n        end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection\n    ];\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9nZW5lcmF0ZUNvbnRlbnQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FZc0Q7QUFDRDtBQUNWO0FBUzNCO0FBT2pCLE1BQU1VLHFDQUNKQyxPQUFPQyxNQUFNLENBQUM7SUFDWixLQUFNO0lBQ04sTUFBTTtBQUNSO0FBQ0YsTUFBTUMsK0JBQStCLElBQUlDLE9BQ3ZDSCxPQUFPSSxJQUFJLENBQUNMLG9DQUFvQ00sSUFBSSxDQUFDLE1BQ3JEO0FBRUYsTUFBTUMsVUFBa0NOLE9BQU9DLE1BQU0sQ0FBQztJQUNwRE0sd0JBQXdCO0lBQ3hCQyxxQkFBcUI7SUFDckJDLGdCQUFnQjtJQUNoQkMsYUFBYTtJQUNiQyxjQUFjO0lBQ2RDLGNBQWM7QUFDaEI7QUFFQSxNQUFNQyxvQkFBb0I7SUFDeEIsQ0FBQ0MsT0FBb0NBLEtBQUtDLFNBQVMsQ0FBQyxXQUFXO0lBQy9ELENBQUNELE9BQW9DQSxLQUFLQyxTQUFTLENBQUMsV0FBVztJQUMvRCxDQUFDRCxPQUFvQ0EsS0FBS0MsU0FBUyxDQUFDLGFBQWE7SUFDakUsQ0FBQ0QsT0FDQ0EsS0FBS0MsU0FBUyxDQUFDLG9CQUFvQjtJQUNyQyxDQUFDRCxPQUNDQSxLQUFLQyxTQUFTLENBQUMsZ0JBQWdCO0lBQ2pDLENBQUNELE9BQ0NBLEtBQUtDLFNBQVMsQ0FBQyxrQkFBa0I7SUFDbkMsQ0FBQ0QsT0FDQ0EsS0FBS0MsU0FBUyxDQUFDLGdCQUFnQjtJQUNqQyxDQUFDRCxPQUNDQSxLQUFLQyxTQUFTLENBQUMsZ0JBQWdCO0NBQ2xDO0FBRUQsTUFBTUMsOEJBQThCO0lBQ2xDLENBQUNGLE9BQXdCQSxLQUFLRyxhQUFhLENBQUMsV0FBVztJQUN2RCxDQUFDSCxPQUF3QkEsS0FBS0csYUFBYSxDQUFDLFdBQVc7SUFDdkQsQ0FBQ0gsT0FBd0JBLEtBQUtHLGFBQWEsQ0FBQyxhQUFhO0lBQ3pELENBQUNILE9BQ0NBLEtBQUtHLGFBQWEsQ0FBQyxvQkFBb0I7SUFDekMsQ0FBQ0gsT0FBd0JBLEtBQUtHLGFBQWEsQ0FBQyxnQkFBZ0I7SUFDNUQsQ0FBQ0gsT0FBd0JBLEtBQUtHLGFBQWEsQ0FBQyxrQkFBa0I7SUFDOUQsQ0FBQ0gsT0FBd0JBLEtBQUtHLGFBQWEsQ0FBQyxnQkFBZ0I7SUFDNUQsQ0FBQ0gsT0FBd0JBLEtBQUtHLGFBQWEsQ0FBQyxnQkFBZ0I7Q0FDN0Q7QUFFRCxNQUFNQyxvQkFBb0I7SUFDeEIsQ0FBQ0osT0FBbUJBLEtBQUtLLGVBQWUsTUFBTTtJQUM5QyxDQUFDTCxPQUFtQkEsS0FBS00sYUFBYSxNQUFNO0NBQzdDO0FBRUQsTUFBTUMsa0JBQWtCO0lBQ3RCLENBQUNQLE9BQW1CQSxLQUFLUSxPQUFPLE1BQU07SUFDdEMsQ0FBQ1IsT0FBbUJBLEtBQUtTLFdBQVcsTUFBTTtDQUMzQztBQUVNLFNBQVNDLGdCQUNkQyxNQUFxQixFQUNyQkMsU0FBa0IsRUFDbEJDLGVBQW1DO1FBQ25DQyxnQkFBQUEsaUVBQXlCO0lBRXpCLE1BQU1DLGNBQWNKLE9BQU9LLGNBQWM7SUFDekMsTUFBTUMsZUFBZU4sT0FBT08sT0FBTztJQUNuQyxNQUFNQyxpQkFBaUJSLE9BQU9TLGVBQWU7SUFDN0MsTUFBTUMsV0FBV1YsT0FBT1csU0FBUztJQUVqQyxJQUFJVixXQUFXO1FBQ2IsSUFBSVcsYUFBYTtRQUNqQlIsWUFBWVMsSUFBSSxDQUFDO1lBQ2ZELGFBQWFFLGdCQUFnQmxELHFFQUFzQkEsQ0FBQ29DO1FBQ3REO1FBQ0EsT0FBT1k7SUFDVDtJQUVBLElBQUlHLE1BQU07SUFFVixNQUFNQyxrQkFBa0JaLFlBQVlTLElBQUksQ0FBQztRQUN2QyxNQUFNSSxZQUFZakQsc0RBQWFBO1FBRS9Ca0QsVUFBVW5ELGlEQUFRQSxJQUFJLENBQUNzQixNQUFtQjhCO1lBQ3hDLE1BQU1DLFVBQVUvQixLQUFLZ0MsTUFBTTtZQUMzQixNQUFNQyxpQkFBa0I7WUFDeEIsTUFBTUMsY0FBY2xDLEtBQUttQyxPQUFPLE1BQU07WUFDdEMsTUFBTUMsYUFBYXBDLEtBQUtvQyxVQUFVO1lBRWxDVixPQUFPLEdBQThDSSxPQUEzQ00sYUFBYTVDLFFBQVFNLFlBQVksR0FBRyxLQUFJLEtBRTdDbUMsT0FGZ0RILE9BQU92QyxJQUFJLENBQzlELE1BQ0EsS0FBcUIyQyxPQUFsQkQsZ0JBQWUsS0FBa0JJLE9BQWZILGFBQVksS0FJakMsT0FKb0NHLFVBQ3BDckMsTUFDQWEsaUJBQ0FDLGdCQUNBO1lBRUZZLE9BQU9ZLHdCQUF3QjtnQkFDN0JSO2dCQUNBTTtnQkFDQXBDO2dCQUNBaUM7Z0JBQ0FMO2dCQUNBTTtZQUNGO1FBQ0Y7UUFFQSxPQUFPTixjQUFjLE9BQ2pCLFdBQ0E3QywwREFBaUJBLENBQUM2QyxhQUNsQlcsb0JBQW9CWCxhQUNwQjtJQUNOO0lBRUFGLE9BQU8saUJBQWlCQztJQUV4QixPQUFPRDtBQUNUO0FBRUEsU0FBU2Esb0JBQW9CWCxTQUF5QjtJQUNwRCxJQUFJRixNQUFNO0lBRVYsTUFBTWMsYUFBYUMsc0JBQXNCYjtJQUV6Q0YsT0FBTyxXQUNMRSxPQURnQlksZUFBZSxLQUFLLEtBQWdCLE9BQVhBLFlBQVcsUUFBTSxJQUFHLEtBRTlELE9BRENaLFVBQVVjLEtBQUssS0FBSyxLQUFLLFlBQTRCLE9BQWhCZCxVQUFVYyxLQUFLLEVBQUMsU0FBTztJQUc5RCxNQUFNQyxTQUFTZixVQUFVZSxNQUFNO0lBQy9CLE1BQU1DLFFBQVFoQixVQUFVZ0IsS0FBSztJQUM3QixNQUFNQyxlQUFlRixPQUFPRyxNQUFNO0lBQ2xDLE1BQU1DLGNBQWNILE1BQU1FLE1BQU07SUFFaENwQixPQUFPLHVCQUNMbUIsT0FENEJGLE9BQU9LLEdBQUcsRUFBQyxjQUU5QkwsT0FEVEUsaUJBQWlCLE9BQU8sU0FBU0EsY0FDbEMsWUFBc0IsT0FBWkYsT0FBT00sSUFBSSxFQUFDO0lBQ3ZCdkIsT0FBTyxzQkFDTHFCLE9BRDJCSCxNQUFNSSxHQUFHLEVBQUMsY0FFNUJKLE9BRFRHLGdCQUFnQixPQUFPLFNBQVNBLGFBQ2pDLFlBQXFCLE9BQVhILE1BQU1LLElBQUksRUFBQztJQUV0QixPQUFPdkI7QUFDVDtBQUVBLFNBQVN3QixtQkFBbUJ0QixTQUF3QjtJQUNsRCxJQUFJLENBQUMvQyx5REFBZ0JBLENBQUMrQyxZQUFZO1FBQ2hDLE9BQU87SUFDVDtJQUNBLE9BQU8sZ0JBQXdELE9BQXhDdUIsTUFBTUMsSUFBSSxDQUFDeEIsVUFBVXlCLE1BQU0sRUFBRTlELElBQUksQ0FBQyxPQUFNO0FBQ2pFO0FBRUEsU0FBU3NDLFVBQ1B5QixXQUF3QixFQUN4QkMsT0FBOEQ7UUFDOUR6QixTQUFBQSxpRUFBd0IsRUFBRTtJQUUxQixNQUFNMEIsYUFBYUYsWUFBWUcsV0FBVztJQUMxQyxNQUFNQyxtQkFBbUJGLFdBQVdHLE1BQU07SUFFMUNILFdBQVdJLE9BQU8sQ0FBQyxDQUFDQyxXQUFXQztRQUM3QixNQUFNQyxRQUNKRCxNQUFNSixtQkFBbUIsSUFBSWxFLFFBQVFJLFdBQVcsR0FBR0osUUFBUUcsY0FBYztRQUMzRTRELFFBQVFNLFdBQVcvQixPQUFPa0MsTUFBTSxDQUFDRDtRQUVqQyxNQUFNRSxTQUNKSCxNQUFNSixtQkFBbUIsSUFDckJsRSxRQUFRRSxtQkFBbUIsR0FDM0JGLFFBQVFDLHNCQUFzQjtRQUVwQyxJQUFJYix1REFBY0EsQ0FBQ2lGLFlBQVk7WUFDN0JoQyxVQUFVZ0MsV0FBV04sU0FBU3pCLE9BQU9rQyxNQUFNLENBQUNDO1FBQzlDO0lBQ0Y7QUFDRjtBQUVBLFNBQVNDLFVBQVVDLElBQVk7UUFBRXJELGdCQUFBQSxpRUFBeUI7SUFDeEQsTUFBTXNELGNBQWNsRixPQUFPbUYsT0FBTyxDQUFDcEYsb0NBQW9DcUYsTUFBTSxDQUMzRSxDQUFDQztZQUFLLENBQUN2QixLQUFLZSxNQUFNO2VBQUtRLElBQUlDLE9BQU8sQ0FBQyxJQUFJbkYsT0FBTzJELEtBQUssTUFBTXlCLE9BQU9WO09BQ2hFSTtJQUVGLElBQUlyRCxlQUFlO1FBQ2pCLE9BQU9zRCxZQUFZSSxPQUFPLENBQUMsVUFBVTtJQUN2QztJQUNBLE9BQU9KO0FBQ1Q7QUFFQSxTQUFTL0IsVUFDUHJDLElBQWlCLEVBQ2pCYSxlQUFtQztRQUNuQ0MsZ0JBQUFBLGlFQUF5QjtJQUV6QixNQUFNNEQsY0FBa0M3RCxrQkFDcENBLGdCQUFnQmIsTUFBTWMsaUJBQ3RCNkQ7SUFDSixJQUFJRCxnQkFBZ0JDLGFBQWFELFlBQVlmLE1BQU0sR0FBRyxHQUFHO1FBQ3ZELE9BQU9lO0lBQ1Q7SUFFQSxJQUFJMUYsb0RBQVdBLENBQUNnQixPQUFPO1FBQ3JCLE1BQU1tRSxPQUFPbkUsS0FBSzRFLGNBQWM7UUFDaEMsTUFBTUMsUUFDSlYsS0FBS1IsTUFBTSxLQUFLLElBQUksWUFBWSxJQUFtQyxPQUEvQk8sVUFBVUMsTUFBTXJELGdCQUFlO1FBQ3JFLE1BQU1nRSxhQUFhQywyQkFBMkIvRTtRQUM5QyxPQUFPO1lBQUM2RTtZQUFPQyxXQUFXbkIsTUFBTSxLQUFLLElBQUksS0FBZ0IsT0FBWG1CLFlBQVcsUUFBTTtTQUFLLENBQ2pFRSxNQUFNLENBQUNDLFNBQ1AxRixJQUFJLENBQUMsS0FDTDJGLElBQUk7SUFDVCxPQUFPLElBQUkxRywwREFBV0EsQ0FBQ3dCLE9BQU87UUFDNUIsTUFBTW1GLE9BQU9uRixLQUFLb0YsTUFBTTtRQUN4QixNQUFNUCxRQUNKTSxLQUFLeEIsTUFBTSxLQUFLLElBQUksWUFBWSxJQUFtQyxPQUEvQk8sVUFBVWlCLE1BQU1yRSxnQkFBZTtRQUNyRSxNQUFNZ0UsYUFBYU8sMkJBQTJCckY7UUFDOUMsT0FBTztZQUFDNkU7WUFBT0MsV0FBV25CLE1BQU0sS0FBSyxJQUFJLEtBQWdCLE9BQVhtQixZQUFXLFFBQU07U0FBSyxDQUNqRUUsTUFBTSxDQUFDQyxTQUNQMUYsSUFBSSxDQUFDLEtBQ0wyRixJQUFJO0lBQ1QsT0FBTyxJQUFJekcsMERBQVdBLENBQUN1QixPQUFPO1FBQzVCLE9BQU8sVUFBbUMsT0FBekJBLEtBQUtzRixNQUFNLEdBQUcvRixJQUFJLENBQUMsT0FBTTtJQUM1QyxPQUFPLElBQUlULHlEQUFnQkEsQ0FBQ2tCLE9BQU87UUFDakMsTUFBTXdDLGFBQWErQywwQkFBMEJ2RjtRQUM3QyxJQUFJd0YsZ0JBQWdCaEQsZUFBZSxLQUFLLEtBQWdCLE9BQVhBLFlBQVcsUUFBTTtRQUM5RGdELGlCQUFpQnhGLEtBQUt5RixPQUFPLEdBQUcsSUFBaUIsT0FBYnpGLEtBQUt5RixPQUFPLEVBQUMsT0FBSztRQUN0RCxPQUFPRDtJQUNULE9BQU87UUFDTCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLFNBQVNELDBCQUEwQkcsZUFBOEI7SUFDL0QsSUFBSUMsTUFBTXpGLDRCQUE0QjBGLEdBQUcsQ0FBQyxDQUFDQyxZQUN6Q0EsVUFBVUgsa0JBRVRWLE1BQU0sQ0FBQ0MsU0FDUDFGLElBQUksQ0FBQyxNQUNMdUcsaUJBQWlCO0lBRXBCLElBQUlILFFBQVEsSUFBSTtRQUNkQSxNQUFNLGFBQWFBO0lBQ3JCO0lBRUEsT0FBT0E7QUFDVDtBQUVBLFNBQVNaLDJCQUEyQi9FLElBQWM7SUFDaEQsT0FBTztRQUNMeUMsc0JBQXNCekM7UUFDdEIrRixzQkFBc0IvRjtRQUN0QmdHLG9CQUFvQmhHO1FBQ3BCaUcscUJBQXFCakc7S0FDdEIsQ0FDRWdGLE1BQU0sQ0FBQ0MsU0FDUDFGLElBQUksQ0FBQztBQUNWO0FBRUEsU0FBUzhGLDJCQUEyQnJGLElBQWM7SUFDaEQsT0FBTztRQUNMa0csc0JBQXNCbEc7UUFDdEJtRyxtQkFBbUJuRztRQUNuQm9HLHFCQUFxQnBHO1FBQ3JCaUcscUJBQXFCakc7S0FDdEIsQ0FDRWdGLE1BQU0sQ0FBQ0MsU0FDUDFGLElBQUksQ0FBQztBQUNWO0FBRUEsU0FBU3dHLHNCQUFzQkwsZUFBeUI7SUFDdEQsSUFBSUMsTUFBTXZGLGtCQUFrQndGLEdBQUcsQ0FBQyxDQUFDQyxZQUFjQSxVQUFVSCxrQkFDdERWLE1BQU0sQ0FBQ0MsU0FDUDFGLElBQUksQ0FBQyxNQUNMdUcsaUJBQWlCO0lBRXBCLElBQUlILFFBQVEsSUFBSTtRQUNkQSxNQUFNLGFBQWFBO0lBQ3JCO0lBRUEsT0FBT0E7QUFDVDtBQUVBLFNBQVNLLG9CQUFvQk4sZUFBeUI7SUFDcEQsSUFBSUMsTUFBTXBGLGdCQUFnQnFGLEdBQUcsQ0FBQyxDQUFDQyxZQUFjQSxVQUFVSCxrQkFDcERWLE1BQU0sQ0FBQ0MsU0FDUDFGLElBQUksQ0FBQyxNQUNMdUcsaUJBQWlCO0lBRXBCLElBQUlILFFBQVEsSUFBSTtRQUNkQSxNQUFNLFdBQVdBO0lBQ25CO0lBRUEsT0FBT0E7QUFDVDtBQUVBLFNBQVNsRCxzQkFBc0JpRCxlQUEwQztJQUN2RSxJQUFJQyxNQUFNNUYsa0JBQWtCNkYsR0FBRyxDQUFDLENBQUNDLFlBQWNBLFVBQVVILGtCQUN0RFYsTUFBTSxDQUFDQyxTQUNQMUYsSUFBSSxDQUFDLE1BQ0x1RyxpQkFBaUI7SUFFcEIsSUFBSUgsUUFBUSxJQUFJO1FBQ2RBLE1BQU0sYUFBYUE7SUFDckI7SUFFQSxPQUFPQTtBQUNUO0FBRUEsU0FBU08sc0JBQXNCbEcsSUFBYztJQUMzQyxJQUFJMkYsTUFBTTNGLEtBQUtxRyxTQUFTO0lBQ3hCLCtCQUErQjtJQUMvQixJQUFJVixPQUFPLE1BQU07UUFDZkEsTUFBTSxhQUFhQTtJQUNyQjtJQUNBLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTUSxtQkFBbUJuRyxJQUFjO0lBQ3hDLElBQUkyRixNQUFNM0YsS0FBS3NHLE1BQU07SUFDckIsK0JBQStCO0lBQy9CLElBQUlYLE9BQU8sTUFBTTtRQUNmQSxNQUFNLFVBQVVBO0lBQ2xCO0lBQ0EsT0FBT0E7QUFDVDtBQUVBLFNBQVNTLHFCQUFxQnBHLElBQWM7SUFDMUMsSUFBSTJGLE1BQU0zRixLQUFLdUcsUUFBUTtJQUN2QiwrQkFBK0I7SUFDL0IsSUFBSVosT0FBTyxNQUFNO1FBQ2ZBLE1BQU0sWUFBWUE7SUFDcEI7SUFDQSxPQUFPQTtBQUNUO0FBRUEsU0FBU00scUJBQXFCakcsSUFBaUI7SUFDN0MsSUFBSSxDQUFDQSxLQUFLd0csT0FBTyxFQUFFO1FBQ2pCLE9BQU87SUFDVDtJQUNBLE1BQU1DLFNBQVMsRUFBRTtJQUNqQixLQUFLLE1BQU0sQ0FBQ0MsV0FBVzNDLE1BQU0sSUFBSS9ELEtBQUt3RyxPQUFPLENBQUNHLFVBQVUsQ0FBQ3RDLE9BQU8sR0FBSTtRQUNsRSxJQUFJcUMsVUFBVUUsT0FBTyxDQUFDN0MsT0FBTzJDLFVBQVVHLFlBQVksR0FBRztZQUNwRDtRQUNGO1FBQ0EsTUFBTUMsWUFBWUMsS0FBS0MsU0FBUyxDQUFDTixVQUFVTyxPQUFPLENBQUNsRDtRQUNuRDBDLE9BQU9TLElBQUksQ0FBQyxJQUFzQkosT0FBbEJKLFVBQVUxRCxHQUFHLEVBQUMsTUFBYyxPQUFWOEQsV0FBVTtJQUM5QztJQUNBLElBQUluQixNQUFNYyxPQUFPbEgsSUFBSSxDQUFDO0lBQ3RCLElBQUlvRyxRQUFRLElBQUk7UUFDZEEsTUFBTSxZQUFZQTtJQUNwQjtJQUNBLE9BQU9BO0FBQ1Q7QUFFQSxTQUFTckQsd0JBQXdCLEtBY2hDO1FBZGdDLEVBQy9CUixNQUFNLEVBQ05NLFVBQVUsRUFDVnBDLElBQUksRUFDSmlDLGNBQWMsRUFDZEwsU0FBUyxFQUNUTSxXQUFXLEVBUVosR0FkZ0M7SUFlL0Isd0NBQXdDO0lBQ3hDLElBQ0UsQ0FBQ2xELG9EQUFXQSxDQUFDZ0IsU0FDYixDQUFDakIsMERBQWlCQSxDQUFDNkMsY0FDbkIsQ0FBQ1EsY0FDRHhELHVEQUFjQSxDQUFDb0IsT0FDZjtRQUNBLE9BQU87SUFDVDtJQUVBLDBCQUEwQjtJQUMxQixNQUFNMkMsU0FBU2YsVUFBVWUsTUFBTTtJQUMvQixNQUFNQyxRQUFRaEIsVUFBVWdCLEtBQUs7SUFFN0IsSUFDRTVDLEtBQUs0RSxjQUFjLE9BQU8sTUFDekJqQyxPQUFPd0UsT0FBTyxPQUFPdkYsVUFBVWdCLEtBQUssQ0FBQ3VFLE9BQU8sTUFDM0N4RSxPQUFPRyxNQUFNLEtBQUtGLE1BQU1FLE1BQU0sRUFDaEM7UUFDQSxPQUFPO0lBQ1Q7SUFFQSxNQUFNLENBQUNzRSxPQUFPQyxJQUFJLEdBQUdDLHNCQUFzQnRILE1BQU00QjtJQUVqRCxJQUFJd0YsVUFBVUMsS0FBSztRQUNqQixPQUFPO0lBQ1Q7SUFFQSxNQUFNRSxzQkFDSnpGLE1BQU0sQ0FBQ0EsT0FBTzZCLE1BQU0sR0FBRyxFQUFFLEtBQUtuRSxRQUFRRyxjQUFjLEdBQ2hESCxRQUFRQyxzQkFBc0IsR0FDOUJELFFBQVFFLG1CQUFtQjtJQUVqQyxNQUFNOEgsaUJBQWlCO1dBQ2xCMUYsT0FBTzJGLEtBQUssQ0FBQyxHQUFHM0YsT0FBTzZCLE1BQU0sR0FBRztRQUNuQzREO0tBQ0Q7SUFDRCxNQUFNRyxrQkFBa0J2RSxNQUFNaUUsUUFBUSxHQUFHTyxJQUFJLENBQUM7SUFDOUMsTUFBTUMsZ0JBQWdCekUsTUFBTWtFLE1BQU1ELE9BQU9PLElBQUksQ0FBQ25JLFFBQVFLLFlBQVk7SUFDbEUsTUFBTWdJLGdCQUFnQjNGLFlBQVl5QixNQUFNLEdBQUcsR0FBRyxrREFBa0Q7SUFFaEcsTUFBTW1FLGtCQUFrQjNFLE1BQU1sQixlQUFlMEIsTUFBTSxHQUFHa0UsZUFBZUYsSUFBSSxDQUN2RTtJQUdGLE9BQ0U7UUFDRW5JLFFBQVFNLFlBQVk7UUFDcEIwSCxlQUFlakksSUFBSSxDQUFDO1FBQ3BCO2VBQUl1STtlQUFvQko7ZUFBb0JFO1NBQWMsQ0FBQ3JJLElBQUksQ0FBQztLQUNqRSxDQUFDQSxJQUFJLENBQUMsT0FBTztBQUVsQjtBQUVBLFNBQVNrQyxnQkFBZ0JrRSxHQUFXO0lBQ2xDLE1BQU1vQyxNQUFNQyxTQUFTQyxhQUFhLENBQUM7SUFDbkNGLElBQUlHLFNBQVMsR0FBR3ZDLElBQUlULElBQUk7SUFDeEIsT0FBT2lELGFBQWFKLEtBQUssR0FBR0csU0FBUztBQUN2QztBQUVBLFNBQVNDLGFBQWFuSSxJQUFhLEVBQUVvSSxLQUFhO0lBQ2hELE1BQU1DLGVBQWUsSUFBSWxGLE1BQU1pRixVQUFVLEdBQUc3SSxJQUFJLENBQUM7SUFDakQsTUFBTStJLGNBQWMsSUFBSW5GLE1BQU1pRixRQUFRLEdBQUc3SSxJQUFJLENBQUM7SUFDOUMsSUFBSWdKO0lBRUosSUFBSyxJQUFJekUsSUFBSSxHQUFHQSxJQUFJOUQsS0FBS3dJLFFBQVEsQ0FBQzdFLE1BQU0sRUFBRUcsSUFBSztRQUM3Q3lFLFdBQVdQLFNBQVNTLGNBQWMsQ0FBQyxPQUFPSjtRQUMxQ3JJLEtBQUswSSxZQUFZLENBQUNILFVBQVV2SSxLQUFLd0ksUUFBUSxDQUFDMUUsRUFBRTtRQUM1Q3FFLGFBQWFuSSxLQUFLd0ksUUFBUSxDQUFDMUUsRUFBRSxFQUFHc0U7UUFDaEMsSUFBSXBJLEtBQUsySSxnQkFBZ0IsS0FBSzNJLEtBQUt3SSxRQUFRLENBQUMxRSxFQUFFLEVBQUU7WUFDOUN5RSxXQUFXUCxTQUFTUyxjQUFjLENBQUMsT0FBT0g7WUFDMUN0SSxLQUFLNEksV0FBVyxDQUFDTDtRQUNuQjtJQUNGO0lBRUEsT0FBT3ZJO0FBQ1Q7QUFFQSxTQUFTc0gsc0JBQ1B0SCxJQUFpQixFQUNqQjRCLFNBQXdCO0lBRXhCLE1BQU1pSCxpQkFBaUJqSCxVQUFVa0gsaUJBQWlCO0lBQ2xELElBQUlqSyx5REFBZ0JBLENBQUMrQyxjQUFjaUgsbUJBQW1CLE1BQU07UUFDMUQsT0FBTztZQUFDLENBQUM7WUFBRyxDQUFDO1NBQUU7SUFDakI7SUFDQSxNQUFNLENBQUNsRyxRQUFRQyxNQUFNLEdBQUdpRztJQUN4QixNQUFNRSxjQUFjL0ksS0FBSzRFLGNBQWM7SUFDdkMsTUFBTW9FLGFBQWFELFlBQVlwRixNQUFNO0lBRXJDLElBQUl5RCxRQUFRLENBQUM7SUFDYixJQUFJQyxNQUFNLENBQUM7SUFFWCxtQ0FBbUM7SUFDbkMsSUFBSTFFLE9BQU9NLElBQUksS0FBSyxVQUFVTCxNQUFNSyxJQUFJLEtBQUssUUFBUTtRQUNuRCxNQUFNZ0csYUFBYXRHLE9BQU93RSxPQUFPO1FBQ2pDLE1BQU0rQixZQUFZdEcsTUFBTXVFLE9BQU87UUFFL0IsSUFDRThCLGVBQWVDLGFBQ2ZsSixTQUFTaUosY0FDVHRHLE9BQU9HLE1BQU0sS0FBS0YsTUFBTUUsTUFBTSxFQUM5QjtZQUNBLENBQUNzRSxPQUFPQyxJQUFJLEdBQ1YxRSxPQUFPRyxNQUFNLEdBQUdGLE1BQU1FLE1BQU0sR0FDeEI7Z0JBQUNILE9BQU9HLE1BQU07Z0JBQUVGLE1BQU1FLE1BQU07YUFBQyxHQUM3QjtnQkFBQ0YsTUFBTUUsTUFBTTtnQkFBRUgsT0FBT0csTUFBTTthQUFDO1FBQ3JDLE9BQU8sSUFBSTlDLFNBQVNpSixZQUFZO1lBQzlCLENBQUM3QixPQUFPQyxJQUFJLEdBQUc0QixXQUFXRSxRQUFRLENBQUNELGFBQy9CO2dCQUFDdkcsT0FBT0csTUFBTTtnQkFBRWtHO2FBQVcsR0FDM0I7Z0JBQUM7Z0JBQUdyRyxPQUFPRyxNQUFNO2FBQUM7UUFDeEIsT0FBTyxJQUFJOUMsU0FBU2tKLFdBQVc7WUFDN0IsQ0FBQzlCLE9BQU9DLElBQUksR0FBRzZCLFVBQVVDLFFBQVEsQ0FBQ0YsY0FDOUI7Z0JBQUNyRyxNQUFNRSxNQUFNO2dCQUFFa0c7YUFBVyxHQUMxQjtnQkFBQztnQkFBR3BHLE1BQU1FLE1BQU07YUFBQztRQUN2QixPQUFPO1lBQ0wseURBQXlEO1lBQ3pELENBQUNzRSxPQUFPQyxJQUFJLEdBQUc7Z0JBQUM7Z0JBQUcyQjthQUFXO1FBQ2hDO0lBQ0Y7SUFFQSwyQ0FBMkM7SUFDM0MsTUFBTUksdUNBQXVDLENBQzNDTCxZQUFZdEIsS0FBSyxDQUFDLEdBQUdMLE9BQU9pQyxLQUFLLENBQUNqSyxpQ0FBaUMsRUFBRSxFQUNyRXVFLE1BQU07SUFDUixNQUFNMkYsbUNBQW1DLENBQ3ZDUCxZQUFZdEIsS0FBSyxDQUFDTCxPQUFPQyxLQUFLZ0MsS0FBSyxDQUFDakssaUNBQWlDLEVBQUUsRUFDdkV1RSxNQUFNO0lBRVIsT0FBTztRQUNMeUQsUUFBUWdDO1FBQ1IvQixNQUNFK0IsdUNBQ0FFO0tBQ0g7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9nZW5lcmF0ZUNvbnRlbnQudHM/YjcxMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB0eXBlIHtcbiAgQmFzZVNlbGVjdGlvbixcbiAgRWxlbWVudE5vZGUsXG4gIExleGljYWxFZGl0b3IsXG4gIExleGljYWxOb2RlLFxuICBQYXJhZ3JhcGhOb2RlLFxuICBSYW5nZVNlbGVjdGlvbixcbiAgVGV4dE5vZGUsXG59IGZyb20gXCJsZXhpY2FsXCI7XG5cbmltcG9ydCB7ICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMgfSBmcm9tIFwiQGxleGljYWwvaHRtbFwiO1xuaW1wb3J0IHsgJGlzTGlua05vZGUsIExpbmtOb2RlIH0gZnJvbSBcIkBsZXhpY2FsL2xpbmtcIjtcbmltcG9ydCB7ICRpc01hcmtOb2RlIH0gZnJvbSBcIkBsZXhpY2FsL21hcmtcIjtcbmltcG9ydCB7XG4gICRnZXRSb290LFxuICAkZ2V0U2VsZWN0aW9uLFxuICAkaXNFbGVtZW50Tm9kZSxcbiAgJGlzTm9kZVNlbGVjdGlvbixcbiAgJGlzUGFyYWdyYXBoTm9kZSxcbiAgJGlzUmFuZ2VTZWxlY3Rpb24sXG4gICRpc1RleHROb2RlLFxufSBmcm9tIFwibGV4aWNhbFwiO1xuXG5leHBvcnQgdHlwZSBDdXN0b21QcmludE5vZGVGbiA9IChcbiAgbm9kZTogTGV4aWNhbE5vZGUsXG4gIG9iZnVzY2F0ZVRleHQ/OiBib29sZWFuXG4pID0+IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuY29uc3QgTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRVBMQUNFTUVOVDogUmVhZG9ubHk8UmVjb3JkPHN0cmluZywgc3RyaW5nPj4gPVxuICBPYmplY3QuZnJlZXplKHtcbiAgICBcIlxcdFwiOiBcIlxcXFx0XCIsXG4gICAgXCJcXG5cIjogXCJcXFxcblwiLFxuICB9KTtcbmNvbnN0IE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVHRVggPSBuZXcgUmVnRXhwKFxuICBPYmplY3Qua2V5cyhOT05fU0lOR0xFX1dJRFRIX0NIQVJTX1JFUExBQ0VNRU5UKS5qb2luKFwifFwiKSxcbiAgXCJnXCJcbik7XG5jb25zdCBTWU1CT0xTOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGFuY2VzdG9ySGFzTmV4dFNpYmxpbmc6IFwifFwiLFxuICBhbmNlc3RvcklzTGFzdENoaWxkOiBcIiBcIixcbiAgaGFzTmV4dFNpYmxpbmc6IFwi4pScXCIsXG4gIGlzTGFzdENoaWxkOiBcIuKUlFwiLFxuICBzZWxlY3RlZENoYXI6IFwiXlwiLFxuICBzZWxlY3RlZExpbmU6IFwiPlwiLFxufSk7XG5cbmNvbnN0IEZPUk1BVF9QUkVESUNBVEVTID0gW1xuICAobm9kZTogVGV4dE5vZGUgfCBSYW5nZVNlbGVjdGlvbikgPT4gbm9kZS5oYXNGb3JtYXQoXCJib2xkXCIpICYmIFwiQm9sZFwiLFxuICAobm9kZTogVGV4dE5vZGUgfCBSYW5nZVNlbGVjdGlvbikgPT4gbm9kZS5oYXNGb3JtYXQoXCJjb2RlXCIpICYmIFwiQ29kZVwiLFxuICAobm9kZTogVGV4dE5vZGUgfCBSYW5nZVNlbGVjdGlvbikgPT4gbm9kZS5oYXNGb3JtYXQoXCJpdGFsaWNcIikgJiYgXCJJdGFsaWNcIixcbiAgKG5vZGU6IFRleHROb2RlIHwgUmFuZ2VTZWxlY3Rpb24pID0+XG4gICAgbm9kZS5oYXNGb3JtYXQoXCJzdHJpa2V0aHJvdWdoXCIpICYmIFwiU3RyaWtldGhyb3VnaFwiLFxuICAobm9kZTogVGV4dE5vZGUgfCBSYW5nZVNlbGVjdGlvbikgPT5cbiAgICBub2RlLmhhc0Zvcm1hdChcInN1YnNjcmlwdFwiKSAmJiBcIlN1YnNjcmlwdFwiLFxuICAobm9kZTogVGV4dE5vZGUgfCBSYW5nZVNlbGVjdGlvbikgPT5cbiAgICBub2RlLmhhc0Zvcm1hdChcInN1cGVyc2NyaXB0XCIpICYmIFwiU3VwZXJzY3JpcHRcIixcbiAgKG5vZGU6IFRleHROb2RlIHwgUmFuZ2VTZWxlY3Rpb24pID0+XG4gICAgbm9kZS5oYXNGb3JtYXQoXCJ1bmRlcmxpbmVcIikgJiYgXCJVbmRlcmxpbmVcIixcbiAgKG5vZGU6IFRleHROb2RlIHwgUmFuZ2VTZWxlY3Rpb24pID0+XG4gICAgbm9kZS5oYXNGb3JtYXQoXCJoaWdobGlnaHRcIikgJiYgXCJIaWdobGlnaHRcIixcbl07XG5cbmNvbnN0IEZPUk1BVF9QUkVESUNBVEVTX1BBUkFHUkFQSCA9IFtcbiAgKG5vZGU6IFBhcmFncmFwaE5vZGUpID0+IG5vZGUuaGFzVGV4dEZvcm1hdChcImJvbGRcIikgJiYgXCJCb2xkXCIsXG4gIChub2RlOiBQYXJhZ3JhcGhOb2RlKSA9PiBub2RlLmhhc1RleHRGb3JtYXQoXCJjb2RlXCIpICYmIFwiQ29kZVwiLFxuICAobm9kZTogUGFyYWdyYXBoTm9kZSkgPT4gbm9kZS5oYXNUZXh0Rm9ybWF0KFwiaXRhbGljXCIpICYmIFwiSXRhbGljXCIsXG4gIChub2RlOiBQYXJhZ3JhcGhOb2RlKSA9PlxuICAgIG5vZGUuaGFzVGV4dEZvcm1hdChcInN0cmlrZXRocm91Z2hcIikgJiYgXCJTdHJpa2V0aHJvdWdoXCIsXG4gIChub2RlOiBQYXJhZ3JhcGhOb2RlKSA9PiBub2RlLmhhc1RleHRGb3JtYXQoXCJzdWJzY3JpcHRcIikgJiYgXCJTdWJzY3JpcHRcIixcbiAgKG5vZGU6IFBhcmFncmFwaE5vZGUpID0+IG5vZGUuaGFzVGV4dEZvcm1hdChcInN1cGVyc2NyaXB0XCIpICYmIFwiU3VwZXJzY3JpcHRcIixcbiAgKG5vZGU6IFBhcmFncmFwaE5vZGUpID0+IG5vZGUuaGFzVGV4dEZvcm1hdChcInVuZGVybGluZVwiKSAmJiBcIlVuZGVybGluZVwiLFxuICAobm9kZTogUGFyYWdyYXBoTm9kZSkgPT4gbm9kZS5oYXNUZXh0Rm9ybWF0KFwiaGlnaGxpZ2h0XCIpICYmIFwiSGlnaGxpZ2h0XCIsXG5dO1xuXG5jb25zdCBERVRBSUxfUFJFRElDQVRFUyA9IFtcbiAgKG5vZGU6IFRleHROb2RlKSA9PiBub2RlLmlzRGlyZWN0aW9ubGVzcygpICYmIFwiRGlyZWN0aW9ubGVzc1wiLFxuICAobm9kZTogVGV4dE5vZGUpID0+IG5vZGUuaXNVbm1lcmdlYWJsZSgpICYmIFwiVW5tZXJnZWFibGVcIixcbl07XG5cbmNvbnN0IE1PREVfUFJFRElDQVRFUyA9IFtcbiAgKG5vZGU6IFRleHROb2RlKSA9PiBub2RlLmlzVG9rZW4oKSAmJiBcIlRva2VuXCIsXG4gIChub2RlOiBUZXh0Tm9kZSkgPT4gbm9kZS5pc1NlZ21lbnRlZCgpICYmIFwiU2VnbWVudGVkXCIsXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50KFxuICBlZGl0b3I6IExleGljYWxFZGl0b3IsXG4gIGV4cG9ydERPTTogYm9vbGVhbixcbiAgY3VzdG9tUHJpbnROb2RlPzogQ3VzdG9tUHJpbnROb2RlRm4sXG4gIG9iZnVzY2F0ZVRleHQ6IGJvb2xlYW4gPSBmYWxzZVxuKTogc3RyaW5nIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgZWRpdG9yQ29uZmlnID0gZWRpdG9yLl9jb25maWc7XG4gIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gZWRpdG9yLl9jb21wb3NpdGlvbktleTtcbiAgY29uc3QgZWRpdGFibGUgPSBlZGl0b3IuX2VkaXRhYmxlO1xuXG4gIGlmIChleHBvcnRET00pIHtcbiAgICBsZXQgaHRtbFN0cmluZyA9IFwiXCI7XG4gICAgZWRpdG9yU3RhdGUucmVhZCgoKSA9PiB7XG4gICAgICBodG1sU3RyaW5nID0gcHJpbnRQcmV0dHlIVE1MKCRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMoZWRpdG9yKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGh0bWxTdHJpbmc7XG4gIH1cblxuICBsZXQgcmVzID0gXCIgcm9vdFxcblwiO1xuXG4gIGNvbnN0IHNlbGVjdGlvblN0cmluZyA9IGVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIHZpc2l0VHJlZSgkZ2V0Um9vdCgpLCAobm9kZTogTGV4aWNhbE5vZGUsIGluZGVudDogQXJyYXk8c3RyaW5nPikgPT4ge1xuICAgICAgY29uc3Qgbm9kZUtleSA9IG5vZGUuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBub2RlS2V5RGlzcGxheSA9IGBgO1xuICAgICAgY29uc3QgdHlwZURpc3BsYXkgPSBub2RlLmdldFR5cGUoKSB8fCBcIlwiO1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IG5vZGUuaXNTZWxlY3RlZCgpO1xuXG4gICAgICByZXMgKz0gYCR7aXNTZWxlY3RlZCA/IFNZTUJPTFMuc2VsZWN0ZWRMaW5lIDogXCIgXCJ9ICR7aW5kZW50LmpvaW4oXG4gICAgICAgIFwiIFwiXG4gICAgICApfSAke25vZGVLZXlEaXNwbGF5fSAke3R5cGVEaXNwbGF5fSAke3ByaW50Tm9kZShcbiAgICAgICAgbm9kZSxcbiAgICAgICAgY3VzdG9tUHJpbnROb2RlLFxuICAgICAgICBvYmZ1c2NhdGVUZXh0XG4gICAgICApfVxcbmA7XG5cbiAgICAgIHJlcyArPSAkcHJpbnRTZWxlY3RlZENoYXJzTGluZSh7XG4gICAgICAgIGluZGVudCxcbiAgICAgICAgaXNTZWxlY3RlZCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgbm9kZUtleURpc3BsYXksXG4gICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgdHlwZURpc3BsYXksXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzZWxlY3Rpb24gPT09IG51bGxcbiAgICAgID8gXCI6IG51bGxcIlxuICAgICAgOiAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pXG4gICAgICA/IHByaW50UmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKVxuICAgICAgOiBudWxsO1xuICB9KTtcblxuICByZXMgKz0gXCJcXG4gc2VsZWN0aW9uXCIgKyBzZWxlY3Rpb25TdHJpbmc7XG5cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gcHJpbnRSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb246IFJhbmdlU2VsZWN0aW9uKTogc3RyaW5nIHtcbiAgbGV0IHJlcyA9IFwiXCI7XG5cbiAgY29uc3QgZm9ybWF0VGV4dCA9IHByaW50Rm9ybWF0UHJvcGVydGllcyhzZWxlY3Rpb24pO1xuXG4gIHJlcyArPSBgOiByYW5nZSAke2Zvcm1hdFRleHQgIT09IFwiXCIgPyBgeyAke2Zvcm1hdFRleHR9IH1gIDogXCJcIn0gJHtcbiAgICBzZWxlY3Rpb24uc3R5bGUgIT09IFwiXCIgPyBgeyBzdHlsZTogJHtzZWxlY3Rpb24uc3R5bGV9IH0gYCA6IFwiXCJcbiAgfWA7XG5cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuXG4gIHJlcyArPSBgXFxuICDilJwgYW5jaG9yIHsga2V5OiAke2FuY2hvci5rZXl9LCBvZmZzZXQ6ICR7XG4gICAgYW5jaG9yT2Zmc2V0ID09PSBudWxsID8gXCJudWxsXCIgOiBhbmNob3JPZmZzZXRcbiAgfSwgdHlwZTogJHthbmNob3IudHlwZX0gfWA7XG4gIHJlcyArPSBgXFxuICDilJQgZm9jdXMgeyBrZXk6ICR7Zm9jdXMua2V5fSwgb2Zmc2V0OiAke1xuICAgIGZvY3VzT2Zmc2V0ID09PSBudWxsID8gXCJudWxsXCIgOiBmb2N1c09mZnNldFxuICB9LCB0eXBlOiAke2ZvY3VzLnR5cGV9IH1gO1xuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIHByaW50Tm9kZVNlbGVjdGlvbihzZWxlY3Rpb246IEJhc2VTZWxlY3Rpb24pOiBzdHJpbmcge1xuICBpZiAoISRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHJldHVybiBgOiBub2RlXFxuICDilJQgWyR7QXJyYXkuZnJvbShzZWxlY3Rpb24uX25vZGVzKS5qb2luKFwiLCBcIil9XWA7XG59XG5cbmZ1bmN0aW9uIHZpc2l0VHJlZShcbiAgY3VycmVudE5vZGU6IEVsZW1lbnROb2RlLFxuICB2aXNpdG9yOiAobm9kZTogTGV4aWNhbE5vZGUsIGluZGVudEFycjogQXJyYXk8c3RyaW5nPikgPT4gdm9pZCxcbiAgaW5kZW50OiBBcnJheTxzdHJpbmc+ID0gW11cbikge1xuICBjb25zdCBjaGlsZE5vZGVzID0gY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gIGNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlLCBpKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPVxuICAgICAgaSA9PT0gY2hpbGROb2Rlc0xlbmd0aCAtIDEgPyBTWU1CT0xTLmlzTGFzdENoaWxkIDogU1lNQk9MUy5oYXNOZXh0U2libGluZztcbiAgICB2aXNpdG9yKGNoaWxkTm9kZSwgaW5kZW50LmNvbmNhdCh2YWx1ZSEpKTtcblxuICAgIGNvbnN0IHZhbHVlMiA9XG4gICAgICBpID09PSBjaGlsZE5vZGVzTGVuZ3RoIC0gMVxuICAgICAgICA/IFNZTUJPTFMuYW5jZXN0b3JJc0xhc3RDaGlsZFxuICAgICAgICA6IFNZTUJPTFMuYW5jZXN0b3JIYXNOZXh0U2libGluZztcblxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZE5vZGUpKSB7XG4gICAgICB2aXNpdFRyZWUoY2hpbGROb2RlLCB2aXNpdG9yLCBpbmRlbnQuY29uY2F0KHZhbHVlMiEpKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemUodGV4dDogc3RyaW5nLCBvYmZ1c2NhdGVUZXh0OiBib29sZWFuID0gZmFsc2UpIHtcbiAgY29uc3QgdGV4dFRvUHJpbnQgPSBPYmplY3QuZW50cmllcyhOT05fU0lOR0xFX1dJRFRIX0NIQVJTX1JFUExBQ0VNRU5UKS5yZWR1Y2UoXG4gICAgKGFjYywgW2tleSwgdmFsdWVdKSA9PiBhY2MucmVwbGFjZShuZXcgUmVnRXhwKGtleSwgXCJnXCIpLCBTdHJpbmcodmFsdWUpKSxcbiAgICB0ZXh0XG4gICk7XG4gIGlmIChvYmZ1c2NhdGVUZXh0KSB7XG4gICAgcmV0dXJuIHRleHRUb1ByaW50LnJlcGxhY2UoL1teXFxzXS9nLCBcIipcIik7XG4gIH1cbiAgcmV0dXJuIHRleHRUb1ByaW50O1xufVxuXG5mdW5jdGlvbiBwcmludE5vZGUoXG4gIG5vZGU6IExleGljYWxOb2RlLFxuICBjdXN0b21QcmludE5vZGU/OiBDdXN0b21QcmludE5vZGVGbixcbiAgb2JmdXNjYXRlVGV4dDogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgY29uc3QgY3VzdG9tUHJpbnQ6IHN0cmluZyB8IHVuZGVmaW5lZCA9IGN1c3RvbVByaW50Tm9kZVxuICAgID8gY3VzdG9tUHJpbnROb2RlKG5vZGUsIG9iZnVzY2F0ZVRleHQpXG4gICAgOiB1bmRlZmluZWQ7XG4gIGlmIChjdXN0b21QcmludCAhPT0gdW5kZWZpbmVkICYmIGN1c3RvbVByaW50Lmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY3VzdG9tUHJpbnQ7XG4gIH1cblxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IHRpdGxlID1cbiAgICAgIHRleHQubGVuZ3RoID09PSAwID8gXCIoZW1wdHkpXCIgOiBgXCIke25vcm1hbGl6ZSh0ZXh0LCBvYmZ1c2NhdGVUZXh0KX1cImA7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IHByaW50QWxsVGV4dE5vZGVQcm9wZXJ0aWVzKG5vZGUpO1xuICAgIHJldHVybiBbdGl0bGUsIHByb3BlcnRpZXMubGVuZ3RoICE9PSAwID8gYHsgJHtwcm9wZXJ0aWVzfSB9YCA6IG51bGxdXG4gICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAuam9pbihcIiBcIilcbiAgICAgIC50cmltKCk7XG4gIH0gZWxzZSBpZiAoJGlzTGlua05vZGUobm9kZSkpIHtcbiAgICBjb25zdCBsaW5rID0gbm9kZS5nZXRVUkwoKTtcbiAgICBjb25zdCB0aXRsZSA9XG4gICAgICBsaW5rLmxlbmd0aCA9PT0gMCA/IFwiKGVtcHR5KVwiIDogYFwiJHtub3JtYWxpemUobGluaywgb2JmdXNjYXRlVGV4dCl9XCJgO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBwcmludEFsbExpbmtOb2RlUHJvcGVydGllcyhub2RlKTtcbiAgICByZXR1cm4gW3RpdGxlLCBwcm9wZXJ0aWVzLmxlbmd0aCAhPT0gMCA/IGB7ICR7cHJvcGVydGllc30gfWAgOiBudWxsXVxuICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgLmpvaW4oXCIgXCIpXG4gICAgICAudHJpbSgpO1xuICB9IGVsc2UgaWYgKCRpc01hcmtOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIGBpZHM6IFsgJHtub2RlLmdldElEcygpLmpvaW4oXCIsIFwiKX0gXWA7XG4gIH0gZWxzZSBpZiAoJGlzUGFyYWdyYXBoTm9kZShub2RlKSkge1xuICAgIGNvbnN0IGZvcm1hdFRleHQgPSBwcmludFRleHRGb3JtYXRQcm9wZXJ0aWVzKG5vZGUpO1xuICAgIGxldCBwYXJhZ3JhcGhEYXRhID0gZm9ybWF0VGV4dCAhPT0gXCJcIiA/IGB7ICR7Zm9ybWF0VGV4dH0gfWAgOiBcIlwiO1xuICAgIHBhcmFncmFwaERhdGEgKz0gbm9kZS5fX3N0eWxlID8gYCgke25vZGUuX19zdHlsZX0pYCA6IFwiXCI7XG4gICAgcmV0dXJuIHBhcmFncmFwaERhdGE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRUZXh0Rm9ybWF0UHJvcGVydGllcyhub2RlT3JTZWxlY3Rpb246IFBhcmFncmFwaE5vZGUpIHtcbiAgbGV0IHN0ciA9IEZPUk1BVF9QUkVESUNBVEVTX1BBUkFHUkFQSC5tYXAoKHByZWRpY2F0ZSkgPT5cbiAgICBwcmVkaWNhdGUobm9kZU9yU2VsZWN0aW9uKVxuICApXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5qb2luKFwiLCBcIilcbiAgICAudG9Mb2NhbGVMb3dlckNhc2UoKTtcblxuICBpZiAoc3RyICE9PSBcIlwiKSB7XG4gICAgc3RyID0gXCJmb3JtYXQ6IFwiICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcHJpbnRBbGxUZXh0Tm9kZVByb3BlcnRpZXMobm9kZTogVGV4dE5vZGUpIHtcbiAgcmV0dXJuIFtcbiAgICBwcmludEZvcm1hdFByb3BlcnRpZXMobm9kZSksXG4gICAgcHJpbnREZXRhaWxQcm9wZXJ0aWVzKG5vZGUpLFxuICAgIHByaW50TW9kZVByb3BlcnRpZXMobm9kZSksXG4gICAgcHJpbnRTdGF0ZVByb3BlcnRpZXMobm9kZSksXG4gIF1cbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLmpvaW4oXCIsIFwiKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRBbGxMaW5rTm9kZVByb3BlcnRpZXMobm9kZTogTGlua05vZGUpIHtcbiAgcmV0dXJuIFtcbiAgICBwcmludFRhcmdldFByb3BlcnRpZXMobm9kZSksXG4gICAgcHJpbnRSZWxQcm9wZXJ0aWVzKG5vZGUpLFxuICAgIHByaW50VGl0bGVQcm9wZXJ0aWVzKG5vZGUpLFxuICAgIHByaW50U3RhdGVQcm9wZXJ0aWVzKG5vZGUpLFxuICBdXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5qb2luKFwiLCBcIik7XG59XG5cbmZ1bmN0aW9uIHByaW50RGV0YWlsUHJvcGVydGllcyhub2RlT3JTZWxlY3Rpb246IFRleHROb2RlKSB7XG4gIGxldCBzdHIgPSBERVRBSUxfUFJFRElDQVRFUy5tYXAoKHByZWRpY2F0ZSkgPT4gcHJlZGljYXRlKG5vZGVPclNlbGVjdGlvbikpXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5qb2luKFwiLCBcIilcbiAgICAudG9Mb2NhbGVMb3dlckNhc2UoKTtcblxuICBpZiAoc3RyICE9PSBcIlwiKSB7XG4gICAgc3RyID0gXCJkZXRhaWw6IFwiICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcHJpbnRNb2RlUHJvcGVydGllcyhub2RlT3JTZWxlY3Rpb246IFRleHROb2RlKSB7XG4gIGxldCBzdHIgPSBNT0RFX1BSRURJQ0FURVMubWFwKChwcmVkaWNhdGUpID0+IHByZWRpY2F0ZShub2RlT3JTZWxlY3Rpb24pKVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAuam9pbihcIiwgXCIpXG4gICAgLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHN0ciAhPT0gXCJcIikge1xuICAgIHN0ciA9IFwibW9kZTogXCIgKyBzdHI7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBwcmludEZvcm1hdFByb3BlcnRpZXMobm9kZU9yU2VsZWN0aW9uOiBUZXh0Tm9kZSB8IFJhbmdlU2VsZWN0aW9uKSB7XG4gIGxldCBzdHIgPSBGT1JNQVRfUFJFRElDQVRFUy5tYXAoKHByZWRpY2F0ZSkgPT4gcHJlZGljYXRlKG5vZGVPclNlbGVjdGlvbikpXG4gICAgLmZpbHRlcihCb29sZWFuKVxuICAgIC5qb2luKFwiLCBcIilcbiAgICAudG9Mb2NhbGVMb3dlckNhc2UoKTtcblxuICBpZiAoc3RyICE9PSBcIlwiKSB7XG4gICAgc3RyID0gXCJmb3JtYXQ6IFwiICsgc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcHJpbnRUYXJnZXRQcm9wZXJ0aWVzKG5vZGU6IExpbmtOb2RlKSB7XG4gIGxldCBzdHIgPSBub2RlLmdldFRhcmdldCgpO1xuICAvLyBUT0RPIEZpeCBudWxsaXNoIG9uIExpbmtOb2RlXG4gIGlmIChzdHIgIT0gbnVsbCkge1xuICAgIHN0ciA9IFwidGFyZ2V0OiBcIiArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiBwcmludFJlbFByb3BlcnRpZXMobm9kZTogTGlua05vZGUpIHtcbiAgbGV0IHN0ciA9IG5vZGUuZ2V0UmVsKCk7XG4gIC8vIFRPRE8gRml4IG51bGxpc2ggb24gTGlua05vZGVcbiAgaWYgKHN0ciAhPSBudWxsKSB7XG4gICAgc3RyID0gXCJyZWw6IFwiICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbmZ1bmN0aW9uIHByaW50VGl0bGVQcm9wZXJ0aWVzKG5vZGU6IExpbmtOb2RlKSB7XG4gIGxldCBzdHIgPSBub2RlLmdldFRpdGxlKCk7XG4gIC8vIFRPRE8gRml4IG51bGxpc2ggb24gTGlua05vZGVcbiAgaWYgKHN0ciAhPSBudWxsKSB7XG4gICAgc3RyID0gXCJ0aXRsZTogXCIgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cblxuZnVuY3Rpb24gcHJpbnRTdGF0ZVByb3BlcnRpZXMobm9kZTogTGV4aWNhbE5vZGUpIHtcbiAgaWYgKCFub2RlLl9fc3RhdGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3RhdGVzID0gW107XG4gIGZvciAoY29uc3QgW3N0YXRlVHlwZSwgdmFsdWVdIG9mIG5vZGUuX19zdGF0ZS5rbm93blN0YXRlLmVudHJpZXMoKSkge1xuICAgIGlmIChzdGF0ZVR5cGUuaXNFcXVhbCh2YWx1ZSwgc3RhdGVUeXBlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VmFsdWUgPSBKU09OLnN0cmluZ2lmeShzdGF0ZVR5cGUudW5wYXJzZSh2YWx1ZSkpO1xuICAgIHN0YXRlcy5wdXNoKGBbJHtzdGF0ZVR5cGUua2V5fTogJHt0ZXh0VmFsdWV9XWApO1xuICB9XG4gIGxldCBzdHIgPSBzdGF0ZXMuam9pbihcIixcIik7XG4gIGlmIChzdHIgIT09IFwiXCIpIHtcbiAgICBzdHIgPSBcInN0YXRlOiBcIiArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuXG5mdW5jdGlvbiAkcHJpbnRTZWxlY3RlZENoYXJzTGluZSh7XG4gIGluZGVudCxcbiAgaXNTZWxlY3RlZCxcbiAgbm9kZSxcbiAgbm9kZUtleURpc3BsYXksXG4gIHNlbGVjdGlvbixcbiAgdHlwZURpc3BsYXksXG59OiB7XG4gIGluZGVudDogQXJyYXk8c3RyaW5nPjtcbiAgaXNTZWxlY3RlZDogYm9vbGVhbjtcbiAgbm9kZTogTGV4aWNhbE5vZGU7XG4gIG5vZGVLZXlEaXNwbGF5OiBzdHJpbmc7XG4gIHNlbGVjdGlvbjogQmFzZVNlbGVjdGlvbiB8IG51bGw7XG4gIHR5cGVEaXNwbGF5OiBzdHJpbmc7XG59KSB7XG4gIC8vIE5vIHNlbGVjdGlvbiBvciBub2RlIGlzIG5vdCBzZWxlY3RlZC5cbiAgaWYgKFxuICAgICEkaXNUZXh0Tm9kZShub2RlKSB8fFxuICAgICEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8XG4gICAgIWlzU2VsZWN0ZWQgfHxcbiAgICAkaXNFbGVtZW50Tm9kZShub2RlKVxuICApIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIC8vIE5vIHNlbGVjdGVkIGNoYXJhY3RlcnMuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuXG4gIGlmIChcbiAgICBub2RlLmdldFRleHRDb250ZW50KCkgPT09IFwiXCIgfHxcbiAgICAoYW5jaG9yLmdldE5vZGUoKSA9PT0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSAmJlxuICAgICAgYW5jaG9yLm9mZnNldCA9PT0gZm9jdXMub2Zmc2V0KVxuICApIHtcbiAgICByZXR1cm4gXCJcIjtcbiAgfVxuXG4gIGNvbnN0IFtzdGFydCwgZW5kXSA9ICRnZXRTZWxlY3Rpb25TdGFydEVuZChub2RlLCBzZWxlY3Rpb24pO1xuXG4gIGlmIChzdGFydCA9PT0gZW5kKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICBjb25zdCBzZWxlY3Rpb25MYXN0SW5kZW50ID1cbiAgICBpbmRlbnRbaW5kZW50Lmxlbmd0aCAtIDFdID09PSBTWU1CT0xTLmhhc05leHRTaWJsaW5nXG4gICAgICA/IFNZTUJPTFMuYW5jZXN0b3JIYXNOZXh0U2libGluZ1xuICAgICAgOiBTWU1CT0xTLmFuY2VzdG9ySXNMYXN0Q2hpbGQ7XG5cbiAgY29uc3QgaW5kZW50aW9uQ2hhcnMgPSBbXG4gICAgLi4uaW5kZW50LnNsaWNlKDAsIGluZGVudC5sZW5ndGggLSAxKSxcbiAgICBzZWxlY3Rpb25MYXN0SW5kZW50LFxuICBdO1xuICBjb25zdCB1bnNlbGVjdGVkQ2hhcnMgPSBBcnJheShzdGFydCArIDEpLmZpbGwoXCIgXCIpO1xuICBjb25zdCBzZWxlY3RlZENoYXJzID0gQXJyYXkoZW5kIC0gc3RhcnQpLmZpbGwoU1lNQk9MUy5zZWxlY3RlZENoYXIpO1xuICBjb25zdCBwYWRkaW5nTGVuZ3RoID0gdHlwZURpc3BsYXkubGVuZ3RoICsgMjsgLy8gMSBmb3IgdGhlIHNwYWNlIGFmdGVyICsgMSBmb3IgdGhlIGRvdWJsZSBxdW90ZS5cblxuICBjb25zdCBub2RlUHJpbnRTcGFjZXMgPSBBcnJheShub2RlS2V5RGlzcGxheS5sZW5ndGggKyBwYWRkaW5nTGVuZ3RoKS5maWxsKFxuICAgIFwiIFwiXG4gICk7XG5cbiAgcmV0dXJuIChcbiAgICBbXG4gICAgICBTWU1CT0xTLnNlbGVjdGVkTGluZSxcbiAgICAgIGluZGVudGlvbkNoYXJzLmpvaW4oXCIgXCIpLFxuICAgICAgWy4uLm5vZGVQcmludFNwYWNlcywgLi4udW5zZWxlY3RlZENoYXJzLCAuLi5zZWxlY3RlZENoYXJzXS5qb2luKFwiXCIpLFxuICAgIF0uam9pbihcIiBcIikgKyBcIlxcblwiXG4gICk7XG59XG5cbmZ1bmN0aW9uIHByaW50UHJldHR5SFRNTChzdHI6IHN0cmluZykge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBkaXYuaW5uZXJIVE1MID0gc3RyLnRyaW0oKTtcbiAgcmV0dXJuIHByZXR0aWZ5SFRNTChkaXYsIDApLmlubmVySFRNTDtcbn1cblxuZnVuY3Rpb24gcHJldHRpZnlIVE1MKG5vZGU6IEVsZW1lbnQsIGxldmVsOiBudW1iZXIpIHtcbiAgY29uc3QgaW5kZW50QmVmb3JlID0gbmV3IEFycmF5KGxldmVsKysgKyAxKS5qb2luKFwiICBcIik7XG4gIGNvbnN0IGluZGVudEFmdGVyID0gbmV3IEFycmF5KGxldmVsIC0gMSkuam9pbihcIiAgXCIpO1xuICBsZXQgdGV4dE5vZGU7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlxcblwiICsgaW5kZW50QmVmb3JlKTtcbiAgICBub2RlLmluc2VydEJlZm9yZSh0ZXh0Tm9kZSwgbm9kZS5jaGlsZHJlbltpXSEpO1xuICAgIHByZXR0aWZ5SFRNTChub2RlLmNoaWxkcmVuW2ldISwgbGV2ZWwpO1xuICAgIGlmIChub2RlLmxhc3RFbGVtZW50Q2hpbGQgPT09IG5vZGUuY2hpbGRyZW5baV0pIHtcbiAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIiArIGluZGVudEFmdGVyKTtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiAkZ2V0U2VsZWN0aW9uU3RhcnRFbmQoXG4gIG5vZGU6IExleGljYWxOb2RlLFxuICBzZWxlY3Rpb246IEJhc2VTZWxlY3Rpb25cbik6IFtudW1iZXIsIG51bWJlcl0ge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBpZiAoJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGFuY2hvckFuZEZvY3VzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFstMSwgLTFdO1xuICB9XG4gIGNvbnN0IFthbmNob3IsIGZvY3VzXSA9IGFuY2hvckFuZEZvY3VzO1xuICBjb25zdCB0ZXh0Q29udGVudCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgY29uc3QgdGV4dExlbmd0aCA9IHRleHRDb250ZW50Lmxlbmd0aDtcblxuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuXG4gIC8vIE9ubHkgb25lIG5vZGUgaXMgYmVpbmcgc2VsZWN0ZWQuXG4gIGlmIChhbmNob3IudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgZm9jdXMudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG5cbiAgICBpZiAoXG4gICAgICBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiZcbiAgICAgIG5vZGUgPT09IGFuY2hvck5vZGUgJiZcbiAgICAgIGFuY2hvci5vZmZzZXQgIT09IGZvY3VzLm9mZnNldFxuICAgICkge1xuICAgICAgW3N0YXJ0LCBlbmRdID1cbiAgICAgICAgYW5jaG9yLm9mZnNldCA8IGZvY3VzLm9mZnNldFxuICAgICAgICAgID8gW2FuY2hvci5vZmZzZXQsIGZvY3VzLm9mZnNldF1cbiAgICAgICAgICA6IFtmb2N1cy5vZmZzZXQsIGFuY2hvci5vZmZzZXRdO1xuICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSkge1xuICAgICAgW3N0YXJ0LCBlbmRdID0gYW5jaG9yTm9kZS5pc0JlZm9yZShmb2N1c05vZGUpXG4gICAgICAgID8gW2FuY2hvci5vZmZzZXQsIHRleHRMZW5ndGhdXG4gICAgICAgIDogWzAsIGFuY2hvci5vZmZzZXRdO1xuICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gZm9jdXNOb2RlKSB7XG4gICAgICBbc3RhcnQsIGVuZF0gPSBmb2N1c05vZGUuaXNCZWZvcmUoYW5jaG9yTm9kZSlcbiAgICAgICAgPyBbZm9jdXMub2Zmc2V0LCB0ZXh0TGVuZ3RoXVxuICAgICAgICA6IFswLCBmb2N1cy5vZmZzZXRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb2RlIGlzIHdpdGhpbiBzZWxlY3Rpb24gYnV0IG5vdCB0aGUgYW5jaG9yIG5vciBmb2N1cy5cbiAgICAgIFtzdGFydCwgZW5kXSA9IFswLCB0ZXh0TGVuZ3RoXTtcbiAgICB9XG4gIH1cblxuICAvLyBBY2NvdW50IGZvciBub24tc2luZ2xlIHdpZHRoIGNoYXJhY3RlcnMuXG4gIGNvbnN0IG51bU5vblNpbmdsZVdpZHRoQ2hhckJlZm9yZVNlbGVjdGlvbiA9IChcbiAgICB0ZXh0Q29udGVudC5zbGljZSgwLCBzdGFydCkubWF0Y2goTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRUdFWCkgfHwgW11cbiAgKS5sZW5ndGg7XG4gIGNvbnN0IG51bU5vblNpbmdsZVdpZHRoQ2hhckluU2VsZWN0aW9uID0gKFxuICAgIHRleHRDb250ZW50LnNsaWNlKHN0YXJ0LCBlbmQpLm1hdGNoKE5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVHRVgpIHx8IFtdXG4gICkubGVuZ3RoO1xuXG4gIHJldHVybiBbXG4gICAgc3RhcnQgKyBudW1Ob25TaW5nbGVXaWR0aENoYXJCZWZvcmVTZWxlY3Rpb24sXG4gICAgZW5kICtcbiAgICAgIG51bU5vblNpbmdsZVdpZHRoQ2hhckJlZm9yZVNlbGVjdGlvbiArXG4gICAgICBudW1Ob25TaW5nbGVXaWR0aENoYXJJblNlbGVjdGlvbixcbiAgXTtcbn1cbiJdLCJuYW1lcyI6WyIkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzIiwiJGlzTGlua05vZGUiLCIkaXNNYXJrTm9kZSIsIiRnZXRSb290IiwiJGdldFNlbGVjdGlvbiIsIiRpc0VsZW1lbnROb2RlIiwiJGlzTm9kZVNlbGVjdGlvbiIsIiRpc1BhcmFncmFwaE5vZGUiLCIkaXNSYW5nZVNlbGVjdGlvbiIsIiRpc1RleHROb2RlIiwiTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRVBMQUNFTUVOVCIsIk9iamVjdCIsImZyZWV6ZSIsIk5PTl9TSU5HTEVfV0lEVEhfQ0hBUlNfUkVHRVgiLCJSZWdFeHAiLCJrZXlzIiwiam9pbiIsIlNZTUJPTFMiLCJhbmNlc3Rvckhhc05leHRTaWJsaW5nIiwiYW5jZXN0b3JJc0xhc3RDaGlsZCIsImhhc05leHRTaWJsaW5nIiwiaXNMYXN0Q2hpbGQiLCJzZWxlY3RlZENoYXIiLCJzZWxlY3RlZExpbmUiLCJGT1JNQVRfUFJFRElDQVRFUyIsIm5vZGUiLCJoYXNGb3JtYXQiLCJGT1JNQVRfUFJFRElDQVRFU19QQVJBR1JBUEgiLCJoYXNUZXh0Rm9ybWF0IiwiREVUQUlMX1BSRURJQ0FURVMiLCJpc0RpcmVjdGlvbmxlc3MiLCJpc1VubWVyZ2VhYmxlIiwiTU9ERV9QUkVESUNBVEVTIiwiaXNUb2tlbiIsImlzU2VnbWVudGVkIiwiZ2VuZXJhdGVDb250ZW50IiwiZWRpdG9yIiwiZXhwb3J0RE9NIiwiY3VzdG9tUHJpbnROb2RlIiwib2JmdXNjYXRlVGV4dCIsImVkaXRvclN0YXRlIiwiZ2V0RWRpdG9yU3RhdGUiLCJlZGl0b3JDb25maWciLCJfY29uZmlnIiwiY29tcG9zaXRpb25LZXkiLCJfY29tcG9zaXRpb25LZXkiLCJlZGl0YWJsZSIsIl9lZGl0YWJsZSIsImh0bWxTdHJpbmciLCJyZWFkIiwicHJpbnRQcmV0dHlIVE1MIiwicmVzIiwic2VsZWN0aW9uU3RyaW5nIiwic2VsZWN0aW9uIiwidmlzaXRUcmVlIiwiaW5kZW50Iiwibm9kZUtleSIsImdldEtleSIsIm5vZGVLZXlEaXNwbGF5IiwidHlwZURpc3BsYXkiLCJnZXRUeXBlIiwiaXNTZWxlY3RlZCIsInByaW50Tm9kZSIsIiRwcmludFNlbGVjdGVkQ2hhcnNMaW5lIiwicHJpbnRSYW5nZVNlbGVjdGlvbiIsImZvcm1hdFRleHQiLCJwcmludEZvcm1hdFByb3BlcnRpZXMiLCJzdHlsZSIsImFuY2hvciIsImZvY3VzIiwiYW5jaG9yT2Zmc2V0Iiwib2Zmc2V0IiwiZm9jdXNPZmZzZXQiLCJrZXkiLCJ0eXBlIiwicHJpbnROb2RlU2VsZWN0aW9uIiwiQXJyYXkiLCJmcm9tIiwiX25vZGVzIiwiY3VycmVudE5vZGUiLCJ2aXNpdG9yIiwiY2hpbGROb2RlcyIsImdldENoaWxkcmVuIiwiY2hpbGROb2Rlc0xlbmd0aCIsImxlbmd0aCIsImZvckVhY2giLCJjaGlsZE5vZGUiLCJpIiwidmFsdWUiLCJjb25jYXQiLCJ2YWx1ZTIiLCJub3JtYWxpemUiLCJ0ZXh0IiwidGV4dFRvUHJpbnQiLCJlbnRyaWVzIiwicmVkdWNlIiwiYWNjIiwicmVwbGFjZSIsIlN0cmluZyIsImN1c3RvbVByaW50IiwidW5kZWZpbmVkIiwiZ2V0VGV4dENvbnRlbnQiLCJ0aXRsZSIsInByb3BlcnRpZXMiLCJwcmludEFsbFRleHROb2RlUHJvcGVydGllcyIsImZpbHRlciIsIkJvb2xlYW4iLCJ0cmltIiwibGluayIsImdldFVSTCIsInByaW50QWxsTGlua05vZGVQcm9wZXJ0aWVzIiwiZ2V0SURzIiwicHJpbnRUZXh0Rm9ybWF0UHJvcGVydGllcyIsInBhcmFncmFwaERhdGEiLCJfX3N0eWxlIiwibm9kZU9yU2VsZWN0aW9uIiwic3RyIiwibWFwIiwicHJlZGljYXRlIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJwcmludERldGFpbFByb3BlcnRpZXMiLCJwcmludE1vZGVQcm9wZXJ0aWVzIiwicHJpbnRTdGF0ZVByb3BlcnRpZXMiLCJwcmludFRhcmdldFByb3BlcnRpZXMiLCJwcmludFJlbFByb3BlcnRpZXMiLCJwcmludFRpdGxlUHJvcGVydGllcyIsImdldFRhcmdldCIsImdldFJlbCIsImdldFRpdGxlIiwiX19zdGF0ZSIsInN0YXRlcyIsInN0YXRlVHlwZSIsImtub3duU3RhdGUiLCJpc0VxdWFsIiwiZGVmYXVsdFZhbHVlIiwidGV4dFZhbHVlIiwiSlNPTiIsInN0cmluZ2lmeSIsInVucGFyc2UiLCJwdXNoIiwiZ2V0Tm9kZSIsInN0YXJ0IiwiZW5kIiwiJGdldFNlbGVjdGlvblN0YXJ0RW5kIiwic2VsZWN0aW9uTGFzdEluZGVudCIsImluZGVudGlvbkNoYXJzIiwic2xpY2UiLCJ1bnNlbGVjdGVkQ2hhcnMiLCJmaWxsIiwic2VsZWN0ZWRDaGFycyIsInBhZGRpbmdMZW5ndGgiLCJub2RlUHJpbnRTcGFjZXMiLCJkaXYiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbm5lckhUTUwiLCJwcmV0dGlmeUhUTUwiLCJsZXZlbCIsImluZGVudEJlZm9yZSIsImluZGVudEFmdGVyIiwidGV4dE5vZGUiLCJjaGlsZHJlbiIsImNyZWF0ZVRleHROb2RlIiwiaW5zZXJ0QmVmb3JlIiwibGFzdEVsZW1lbnRDaGlsZCIsImFwcGVuZENoaWxkIiwiYW5jaG9yQW5kRm9jdXMiLCJnZXRTdGFydEVuZFBvaW50cyIsInRleHRDb250ZW50IiwidGV4dExlbmd0aCIsImFuY2hvck5vZGUiLCJmb2N1c05vZGUiLCJpc0JlZm9yZSIsIm51bU5vblNpbmdsZVdpZHRoQ2hhckJlZm9yZVNlbGVjdGlvbiIsIm1hdGNoIiwibnVtTm9uU2luZ2xlV2lkdGhDaGFySW5TZWxlY3Rpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/generateContent.ts\n"));

/***/ }),

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Hero_tsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Hero.tsx */ \"./src/components/Hero.tsx\");\n\n\nconst Home = ()=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Hero_tsx__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n            fileName: \"/home/nick/projects/portfolio/src/pages/index.tsx\",\n            lineNumber: 6,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/home/nick/projects/portfolio/src/pages/index.tsx\",\n        lineNumber: 5,\n        columnNumber: 5\n    }, undefined);\n};\n_c = Home;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXgudHN4IiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBDO0FBRTFDLE1BQU1DLE9BQU87SUFDWCxxQkFDRSw4REFBQ0M7a0JBQ0MsNEVBQUNGLDREQUFJQTs7Ozs7Ozs7OztBQUdYO0tBTk1DO0FBUU4sK0RBQWVBLElBQUlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3BhZ2VzL2luZGV4LnRzeD8xOWEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBIZXJvIGZyb20gXCIuLi9jb21wb25lbnRzL0hlcm8udHN4XCI7XG5cbmNvbnN0IEhvbWUgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxIZXJvIC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBIb21lO1xuIl0sIm5hbWVzIjpbIkhlcm8iLCJIb21lIiwiZGl2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n"));

/***/ }),

/***/ "./src/utils/editorStates.tsx":
/*!************************************!*\
  !*** ./src/utils/editorStates.tsx ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mainEditorState: function() { return /* binding */ mainEditorState; }\n/* harmony export */ });\nconst mainEditorState = {\n    root: {\n        children: [\n            {\n                children: [\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"Current Project\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"mark\",\n                        version: 1,\n                        ids: [\n                            \"kgds89gyr\"\n                        ]\n                    },\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"  Document Editing Platform\",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"heading\",\n                version: 1,\n                tag: \"h1\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"Overview\",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"heading\",\n                version: 1,\n                tag: \"h3\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"I lead the frontend design and development of a Google Docs-style editor tailored to linguist and analyst workflows, drastically increasing the speed that documents are translated, reviewed, and processed. Built with \",\n                        type: \"text\",\n                        version: 1\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"Typescript\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"mark\",\n                        version: 1,\n                        ids: [\n                            \"n05wjyd51\"\n                        ]\n                    },\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \", \",\n                        type: \"text\",\n                        version: 1\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"React\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"mark\",\n                        version: 1,\n                        ids: [\n                            \"ozghi7zur\"\n                        ]\n                    },\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \", and \",\n                        type: \"text\",\n                        version: 1\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"Lexical\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"mark\",\n                        version: 1,\n                        ids: [\n                            \"gaccvxyyp\"\n                        ]\n                    },\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \".\",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"paragraph\",\n                version: 1,\n                textFormat: 0,\n                textStyle: \"\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"Features\",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"heading\",\n                version: 1,\n                tag: \"h3\"\n            },\n            {\n                children: [\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \" Automatic AI translations and replacements\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"listitem\",\n                        version: 1,\n                        value: 1\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \" Live collaboration through websockets\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"listitem\",\n                        version: 1,\n                        value: 2\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"\\uD83D\\uDCAC Commenting and annotation tools\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"listitem\",\n                        version: 1,\n                        value: 3\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"\\uD83D\\uDC40 Review mode to track changes\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"listitem\",\n                        version: 1,\n                        value: 4\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"\\uD83D\\uDCC4 Import documents from Word, PDF, Excel, and more\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"listitem\",\n                        version: 1,\n                        value: 5\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"\\uD83D\\uDDA8 Export and print to PDF\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"listitem\",\n                        version: 1,\n                        value: 6\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \" A suite of rich text formatting capabilities\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"listitem\",\n                        version: 1,\n                        value: 7\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"list\",\n                version: 1,\n                listType: \"bullet\",\n                start: 1,\n                tag: \"ul\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"Technical Leadership\",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"heading\",\n                version: 1,\n                tag: \"h3\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"I \",\n                        type: \"text\",\n                        version: 1\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"evolved and scaled\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"mark\",\n                        version: 1,\n                        ids: [\n                            \"mcsh9e5l7\"\n                        ]\n                    },\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \" the frontend architecture through reusable component libraries and consistent state management patterns, and championed accessibility, performance, and engineering best practices. \",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"paragraph\",\n                version: 1,\n                textFormat: 0,\n                textStyle: \"\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"I take owership of features from conceptualisation to implementation, and \",\n                        type: \"text\",\n                        version: 1\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"collaborate\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"mark\",\n                        version: 1,\n                        ids: [\n                            \"8zb5eitfs\"\n                        ]\n                    },\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \" with teammates across disciplines to ensure the product is aligned as a whole. I have a fullstack background and am not afraid to work across the backend and devops infrastructure in order to ensure features are robustly implemented.\",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"paragraph\",\n                version: 1,\n                textFormat: 0,\n                textStyle: \"\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"The secure and classified nature of the project's environment imposes great challenges, as well as the large and complex scope of it's features. I'm used to working on ambitious goals and punching above my weight, and the magic of improving people's lives makes it all worth it. \",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"paragraph\",\n                version: 1,\n                textFormat: 0,\n                textStyle: \"\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"UI/UX Design\",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"heading\",\n                version: 1,\n                tag: \"h3\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"I have a eye for detail, but a great appreciation for \",\n                        type: \"text\",\n                        version: 1\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"pragmatism and simplicity\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"mark\",\n                        version: 1,\n                        ids: [\n                            \"oksg34v61\"\n                        ]\n                    },\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \". I collaborate with stakeholders, engineers, and designers to scope and define features and often navigate difficult constraints to find solutions that make sense for everybody. \",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"paragraph\",\n                version: 1,\n                textFormat: 0,\n                textStyle: \"\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"I've conducted user workshops to gather and validate requirements, created designs and code prototypes, and regularly presented demos to stakeholders and potential customers to iteratively improve solutions. \",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"paragraph\",\n                version: 1,\n                textFormat: 0,\n                textStyle: \"\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"I supported production releases and closely managed issue tickets and \",\n                        type: \"text\",\n                        version: 1\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"user feedback\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"mark\",\n                        version: 1,\n                        ids: [\n                            \"277uj1u6l\"\n                        ]\n                    },\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \" to refine features with quick turnarounds, ensuring users felt heard and that their concerns were being addressed.\",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"paragraph\",\n                version: 1,\n                textFormat: 0,\n                textStyle: \"\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"Mentoring\",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"heading\",\n                version: 1,\n                tag: \"h3\"\n            },\n            {\n                children: [\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \"I mentored several new frontend developers in \",\n                        type: \"text\",\n                        version: 1\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"best practice\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"mark\",\n                        version: 1,\n                        ids: [\n                            \"cmrb9hk6l\"\n                        ]\n                    },\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \" Typescript and React development, directing and reviewing code and design changes with constructive feedback. With the big picture in mind, I kept the project and other team members' approach directed to \",\n                        type: \"text\",\n                        version: 1\n                    },\n                    {\n                        children: [\n                            {\n                                detail: 0,\n                                format: 0,\n                                mode: \"normal\",\n                                style: \"\",\n                                text: \"solving critical mission needs\",\n                                type: \"text\",\n                                version: 1\n                            }\n                        ],\n                        direction: \"ltr\",\n                        format: \"\",\n                        indent: 0,\n                        type: \"mark\",\n                        version: 1,\n                        ids: [\n                            \"q9tfb9m9t\"\n                        ]\n                    },\n                    {\n                        detail: 0,\n                        format: 0,\n                        mode: \"normal\",\n                        style: \"\",\n                        text: \".\",\n                        type: \"text\",\n                        version: 1\n                    }\n                ],\n                direction: \"ltr\",\n                format: \"\",\n                indent: 0,\n                type: \"paragraph\",\n                version: 1,\n                textFormat: 0,\n                textStyle: \"\"\n            }\n        ],\n        direction: \"ltr\",\n        format: \"\",\n        indent: 0,\n        type: \"root\",\n        version: 1\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdXRpbHMvZWRpdG9yU3RhdGVzLnRzeCIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsa0JBQWtCO0lBQzdCQyxNQUFNO1FBQ0pDLFVBQVU7WUFDUjtnQkFDRUEsVUFBVTtvQkFDUjt3QkFDRUEsVUFBVTs0QkFDUjtnQ0FDRUMsUUFBUTtnQ0FDUkMsUUFBUTtnQ0FDUkMsTUFBTTtnQ0FDTkMsT0FBTztnQ0FDUEMsTUFBTTtnQ0FDTkMsTUFBTTtnQ0FDTkMsU0FBUzs0QkFDWDt5QkFDRDt3QkFDREMsV0FBVzt3QkFDWE4sUUFBUTt3QkFDUk8sUUFBUTt3QkFDUkgsTUFBTTt3QkFDTkMsU0FBUzt3QkFDVEcsS0FBSzs0QkFBQzt5QkFBWTtvQkFDcEI7b0JBQ0E7d0JBQ0VULFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLE1BQU07d0JBQ05DLE9BQU87d0JBQ1BDLE1BQU07d0JBQ05DLE1BQU07d0JBQ05DLFNBQVM7b0JBQ1g7aUJBQ0Q7Z0JBQ0RDLFdBQVc7Z0JBQ1hOLFFBQVE7Z0JBQ1JPLFFBQVE7Z0JBQ1JILE1BQU07Z0JBQ05DLFNBQVM7Z0JBQ1RJLEtBQUs7WUFDUDtZQUNBO2dCQUNFWCxVQUFVO29CQUNSO3dCQUNFQyxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxNQUFNO3dCQUNOQyxPQUFPO3dCQUNQQyxNQUFNO3dCQUNOQyxNQUFNO3dCQUNOQyxTQUFTO29CQUNYO2lCQUNEO2dCQUNEQyxXQUFXO2dCQUNYTixRQUFRO2dCQUNSTyxRQUFRO2dCQUNSSCxNQUFNO2dCQUNOQyxTQUFTO2dCQUNUSSxLQUFLO1lBQ1A7WUFDQTtnQkFDRVgsVUFBVTtvQkFDUjt3QkFDRUMsUUFBUTt3QkFDUkMsUUFBUTt3QkFDUkMsTUFBTTt3QkFDTkMsT0FBTzt3QkFDUEMsTUFBTTt3QkFDTkMsTUFBTTt3QkFDTkMsU0FBUztvQkFDWDtvQkFDQTt3QkFDRVAsVUFBVTs0QkFDUjtnQ0FDRUMsUUFBUTtnQ0FDUkMsUUFBUTtnQ0FDUkMsTUFBTTtnQ0FDTkMsT0FBTztnQ0FDUEMsTUFBTTtnQ0FDTkMsTUFBTTtnQ0FDTkMsU0FBUzs0QkFDWDt5QkFDRDt3QkFDREMsV0FBVzt3QkFDWE4sUUFBUTt3QkFDUk8sUUFBUTt3QkFDUkgsTUFBTTt3QkFDTkMsU0FBUzt3QkFDVEcsS0FBSzs0QkFBQzt5QkFBWTtvQkFDcEI7b0JBQ0E7d0JBQ0VULFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLE1BQU07d0JBQ05DLE9BQU87d0JBQ1BDLE1BQU07d0JBQ05DLE1BQU07d0JBQ05DLFNBQVM7b0JBQ1g7b0JBQ0E7d0JBQ0VQLFVBQVU7NEJBQ1I7Z0NBQ0VDLFFBQVE7Z0NBQ1JDLFFBQVE7Z0NBQ1JDLE1BQU07Z0NBQ05DLE9BQU87Z0NBQ1BDLE1BQU07Z0NBQ05DLE1BQU07Z0NBQ05DLFNBQVM7NEJBQ1g7eUJBQ0Q7d0JBQ0RDLFdBQVc7d0JBQ1hOLFFBQVE7d0JBQ1JPLFFBQVE7d0JBQ1JILE1BQU07d0JBQ05DLFNBQVM7d0JBQ1RHLEtBQUs7NEJBQUM7eUJBQVk7b0JBQ3BCO29CQUNBO3dCQUNFVCxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxNQUFNO3dCQUNOQyxPQUFPO3dCQUNQQyxNQUFNO3dCQUNOQyxNQUFNO3dCQUNOQyxTQUFTO29CQUNYO29CQUNBO3dCQUNFUCxVQUFVOzRCQUNSO2dDQUNFQyxRQUFRO2dDQUNSQyxRQUFRO2dDQUNSQyxNQUFNO2dDQUNOQyxPQUFPO2dDQUNQQyxNQUFNO2dDQUNOQyxNQUFNO2dDQUNOQyxTQUFTOzRCQUNYO3lCQUNEO3dCQUNEQyxXQUFXO3dCQUNYTixRQUFRO3dCQUNSTyxRQUFRO3dCQUNSSCxNQUFNO3dCQUNOQyxTQUFTO3dCQUNURyxLQUFLOzRCQUFDO3lCQUFZO29CQUNwQjtvQkFDQTt3QkFDRVQsUUFBUTt3QkFDUkMsUUFBUTt3QkFDUkMsTUFBTTt3QkFDTkMsT0FBTzt3QkFDUEMsTUFBTTt3QkFDTkMsTUFBTTt3QkFDTkMsU0FBUztvQkFDWDtpQkFDRDtnQkFDREMsV0FBVztnQkFDWE4sUUFBUTtnQkFDUk8sUUFBUTtnQkFDUkgsTUFBTTtnQkFDTkMsU0FBUztnQkFDVEssWUFBWTtnQkFDWkMsV0FBVztZQUNiO1lBQ0E7Z0JBQ0ViLFVBQVU7b0JBQ1I7d0JBQ0VDLFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLE1BQU07d0JBQ05DLE9BQU87d0JBQ1BDLE1BQU07d0JBQ05DLE1BQU07d0JBQ05DLFNBQVM7b0JBQ1g7aUJBQ0Q7Z0JBQ0RDLFdBQVc7Z0JBQ1hOLFFBQVE7Z0JBQ1JPLFFBQVE7Z0JBQ1JILE1BQU07Z0JBQ05DLFNBQVM7Z0JBQ1RJLEtBQUs7WUFDUDtZQUNBO2dCQUNFWCxVQUFVO29CQUNSO3dCQUNFQSxVQUFVOzRCQUNSO2dDQUNFQyxRQUFRO2dDQUNSQyxRQUFRO2dDQUNSQyxNQUFNO2dDQUNOQyxPQUFPO2dDQUNQQyxNQUFNO2dDQUNOQyxNQUFNO2dDQUNOQyxTQUFTOzRCQUNYO3lCQUNEO3dCQUNEQyxXQUFXO3dCQUNYTixRQUFRO3dCQUNSTyxRQUFRO3dCQUNSSCxNQUFNO3dCQUNOQyxTQUFTO3dCQUNUTyxPQUFPO29CQUNUO29CQUNBO3dCQUNFZCxVQUFVOzRCQUNSO2dDQUNFQyxRQUFRO2dDQUNSQyxRQUFRO2dDQUNSQyxNQUFNO2dDQUNOQyxPQUFPO2dDQUNQQyxNQUFNO2dDQUNOQyxNQUFNO2dDQUNOQyxTQUFTOzRCQUNYO3lCQUNEO3dCQUNEQyxXQUFXO3dCQUNYTixRQUFRO3dCQUNSTyxRQUFRO3dCQUNSSCxNQUFNO3dCQUNOQyxTQUFTO3dCQUNUTyxPQUFPO29CQUNUO29CQUNBO3dCQUNFZCxVQUFVOzRCQUNSO2dDQUNFQyxRQUFRO2dDQUNSQyxRQUFRO2dDQUNSQyxNQUFNO2dDQUNOQyxPQUFPO2dDQUNQQyxNQUFNO2dDQUNOQyxNQUFNO2dDQUNOQyxTQUFTOzRCQUNYO3lCQUNEO3dCQUNEQyxXQUFXO3dCQUNYTixRQUFRO3dCQUNSTyxRQUFRO3dCQUNSSCxNQUFNO3dCQUNOQyxTQUFTO3dCQUNUTyxPQUFPO29CQUNUO29CQUNBO3dCQUNFZCxVQUFVOzRCQUNSO2dDQUNFQyxRQUFRO2dDQUNSQyxRQUFRO2dDQUNSQyxNQUFNO2dDQUNOQyxPQUFPO2dDQUNQQyxNQUFNO2dDQUNOQyxNQUFNO2dDQUNOQyxTQUFTOzRCQUNYO3lCQUNEO3dCQUNEQyxXQUFXO3dCQUNYTixRQUFRO3dCQUNSTyxRQUFRO3dCQUNSSCxNQUFNO3dCQUNOQyxTQUFTO3dCQUNUTyxPQUFPO29CQUNUO29CQUNBO3dCQUNFZCxVQUFVOzRCQUNSO2dDQUNFQyxRQUFRO2dDQUNSQyxRQUFRO2dDQUNSQyxNQUFNO2dDQUNOQyxPQUFPO2dDQUNQQyxNQUFNO2dDQUNOQyxNQUFNO2dDQUNOQyxTQUFTOzRCQUNYO3lCQUNEO3dCQUNEQyxXQUFXO3dCQUNYTixRQUFRO3dCQUNSTyxRQUFRO3dCQUNSSCxNQUFNO3dCQUNOQyxTQUFTO3dCQUNUTyxPQUFPO29CQUNUO29CQUNBO3dCQUNFZCxVQUFVOzRCQUNSO2dDQUNFQyxRQUFRO2dDQUNSQyxRQUFRO2dDQUNSQyxNQUFNO2dDQUNOQyxPQUFPO2dDQUNQQyxNQUFNO2dDQUNOQyxNQUFNO2dDQUNOQyxTQUFTOzRCQUNYO3lCQUNEO3dCQUNEQyxXQUFXO3dCQUNYTixRQUFRO3dCQUNSTyxRQUFRO3dCQUNSSCxNQUFNO3dCQUNOQyxTQUFTO3dCQUNUTyxPQUFPO29CQUNUO29CQUNBO3dCQUNFZCxVQUFVOzRCQUNSO2dDQUNFQyxRQUFRO2dDQUNSQyxRQUFRO2dDQUNSQyxNQUFNO2dDQUNOQyxPQUFPO2dDQUNQQyxNQUFNO2dDQUNOQyxNQUFNO2dDQUNOQyxTQUFTOzRCQUNYO3lCQUNEO3dCQUNEQyxXQUFXO3dCQUNYTixRQUFRO3dCQUNSTyxRQUFRO3dCQUNSSCxNQUFNO3dCQUNOQyxTQUFTO3dCQUNUTyxPQUFPO29CQUNUO2lCQUNEO2dCQUNETixXQUFXO2dCQUNYTixRQUFRO2dCQUNSTyxRQUFRO2dCQUNSSCxNQUFNO2dCQUNOQyxTQUFTO2dCQUNUUSxVQUFVO2dCQUNWQyxPQUFPO2dCQUNQTCxLQUFLO1lBQ1A7WUFDQTtnQkFDRVgsVUFBVTtvQkFDUjt3QkFDRUMsUUFBUTt3QkFDUkMsUUFBUTt3QkFDUkMsTUFBTTt3QkFDTkMsT0FBTzt3QkFDUEMsTUFBTTt3QkFDTkMsTUFBTTt3QkFDTkMsU0FBUztvQkFDWDtpQkFDRDtnQkFDREMsV0FBVztnQkFDWE4sUUFBUTtnQkFDUk8sUUFBUTtnQkFDUkgsTUFBTTtnQkFDTkMsU0FBUztnQkFDVEksS0FBSztZQUNQO1lBQ0E7Z0JBQ0VYLFVBQVU7b0JBQ1I7d0JBQ0VDLFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLE1BQU07d0JBQ05DLE9BQU87d0JBQ1BDLE1BQU07d0JBQ05DLE1BQU07d0JBQ05DLFNBQVM7b0JBQ1g7b0JBQ0E7d0JBQ0VQLFVBQVU7NEJBQ1I7Z0NBQ0VDLFFBQVE7Z0NBQ1JDLFFBQVE7Z0NBQ1JDLE1BQU07Z0NBQ05DLE9BQU87Z0NBQ1BDLE1BQU07Z0NBQ05DLE1BQU07Z0NBQ05DLFNBQVM7NEJBQ1g7eUJBQ0Q7d0JBQ0RDLFdBQVc7d0JBQ1hOLFFBQVE7d0JBQ1JPLFFBQVE7d0JBQ1JILE1BQU07d0JBQ05DLFNBQVM7d0JBQ1RHLEtBQUs7NEJBQUM7eUJBQVk7b0JBQ3BCO29CQUNBO3dCQUNFVCxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxNQUFNO3dCQUNOQyxPQUFPO3dCQUNQQyxNQUFNO3dCQUNOQyxNQUFNO3dCQUNOQyxTQUFTO29CQUNYO2lCQUNEO2dCQUNEQyxXQUFXO2dCQUNYTixRQUFRO2dCQUNSTyxRQUFRO2dCQUNSSCxNQUFNO2dCQUNOQyxTQUFTO2dCQUNUSyxZQUFZO2dCQUNaQyxXQUFXO1lBQ2I7WUFDQTtnQkFDRWIsVUFBVTtvQkFDUjt3QkFDRUMsUUFBUTt3QkFDUkMsUUFBUTt3QkFDUkMsTUFBTTt3QkFDTkMsT0FBTzt3QkFDUEMsTUFBTTt3QkFDTkMsTUFBTTt3QkFDTkMsU0FBUztvQkFDWDtvQkFDQTt3QkFDRVAsVUFBVTs0QkFDUjtnQ0FDRUMsUUFBUTtnQ0FDUkMsUUFBUTtnQ0FDUkMsTUFBTTtnQ0FDTkMsT0FBTztnQ0FDUEMsTUFBTTtnQ0FDTkMsTUFBTTtnQ0FDTkMsU0FBUzs0QkFDWDt5QkFDRDt3QkFDREMsV0FBVzt3QkFDWE4sUUFBUTt3QkFDUk8sUUFBUTt3QkFDUkgsTUFBTTt3QkFDTkMsU0FBUzt3QkFDVEcsS0FBSzs0QkFBQzt5QkFBWTtvQkFDcEI7b0JBQ0E7d0JBQ0VULFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLE1BQU07d0JBQ05DLE9BQU87d0JBQ1BDLE1BQU07d0JBQ05DLE1BQU07d0JBQ05DLFNBQVM7b0JBQ1g7aUJBQ0Q7Z0JBQ0RDLFdBQVc7Z0JBQ1hOLFFBQVE7Z0JBQ1JPLFFBQVE7Z0JBQ1JILE1BQU07Z0JBQ05DLFNBQVM7Z0JBQ1RLLFlBQVk7Z0JBQ1pDLFdBQVc7WUFDYjtZQUNBO2dCQUNFYixVQUFVO29CQUNSO3dCQUNFQyxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxNQUFNO3dCQUNOQyxPQUFPO3dCQUNQQyxNQUFNO3dCQUNOQyxNQUFNO3dCQUNOQyxTQUFTO29CQUNYO2lCQUNEO2dCQUNEQyxXQUFXO2dCQUNYTixRQUFRO2dCQUNSTyxRQUFRO2dCQUNSSCxNQUFNO2dCQUNOQyxTQUFTO2dCQUNUSyxZQUFZO2dCQUNaQyxXQUFXO1lBQ2I7WUFDQTtnQkFDRWIsVUFBVTtvQkFDUjt3QkFDRUMsUUFBUTt3QkFDUkMsUUFBUTt3QkFDUkMsTUFBTTt3QkFDTkMsT0FBTzt3QkFDUEMsTUFBTTt3QkFDTkMsTUFBTTt3QkFDTkMsU0FBUztvQkFDWDtpQkFDRDtnQkFDREMsV0FBVztnQkFDWE4sUUFBUTtnQkFDUk8sUUFBUTtnQkFDUkgsTUFBTTtnQkFDTkMsU0FBUztnQkFDVEksS0FBSztZQUNQO1lBQ0E7Z0JBQ0VYLFVBQVU7b0JBQ1I7d0JBQ0VDLFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLE1BQU07d0JBQ05DLE9BQU87d0JBQ1BDLE1BQU07d0JBQ05DLE1BQU07d0JBQ05DLFNBQVM7b0JBQ1g7b0JBQ0E7d0JBQ0VQLFVBQVU7NEJBQ1I7Z0NBQ0VDLFFBQVE7Z0NBQ1JDLFFBQVE7Z0NBQ1JDLE1BQU07Z0NBQ05DLE9BQU87Z0NBQ1BDLE1BQU07Z0NBQ05DLE1BQU07Z0NBQ05DLFNBQVM7NEJBQ1g7eUJBQ0Q7d0JBQ0RDLFdBQVc7d0JBQ1hOLFFBQVE7d0JBQ1JPLFFBQVE7d0JBQ1JILE1BQU07d0JBQ05DLFNBQVM7d0JBQ1RHLEtBQUs7NEJBQUM7eUJBQVk7b0JBQ3BCO29CQUNBO3dCQUNFVCxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxNQUFNO3dCQUNOQyxPQUFPO3dCQUNQQyxNQUFNO3dCQUNOQyxNQUFNO3dCQUNOQyxTQUFTO29CQUNYO2lCQUNEO2dCQUNEQyxXQUFXO2dCQUNYTixRQUFRO2dCQUNSTyxRQUFRO2dCQUNSSCxNQUFNO2dCQUNOQyxTQUFTO2dCQUNUSyxZQUFZO2dCQUNaQyxXQUFXO1lBQ2I7WUFDQTtnQkFDRWIsVUFBVTtvQkFDUjt3QkFDRUMsUUFBUTt3QkFDUkMsUUFBUTt3QkFDUkMsTUFBTTt3QkFDTkMsT0FBTzt3QkFDUEMsTUFBTTt3QkFDTkMsTUFBTTt3QkFDTkMsU0FBUztvQkFDWDtpQkFDRDtnQkFDREMsV0FBVztnQkFDWE4sUUFBUTtnQkFDUk8sUUFBUTtnQkFDUkgsTUFBTTtnQkFDTkMsU0FBUztnQkFDVEssWUFBWTtnQkFDWkMsV0FBVztZQUNiO1lBQ0E7Z0JBQ0ViLFVBQVU7b0JBQ1I7d0JBQ0VDLFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLE1BQU07d0JBQ05DLE9BQU87d0JBQ1BDLE1BQU07d0JBQ05DLE1BQU07d0JBQ05DLFNBQVM7b0JBQ1g7b0JBQ0E7d0JBQ0VQLFVBQVU7NEJBQ1I7Z0NBQ0VDLFFBQVE7Z0NBQ1JDLFFBQVE7Z0NBQ1JDLE1BQU07Z0NBQ05DLE9BQU87Z0NBQ1BDLE1BQU07Z0NBQ05DLE1BQU07Z0NBQ05DLFNBQVM7NEJBQ1g7eUJBQ0Q7d0JBQ0RDLFdBQVc7d0JBQ1hOLFFBQVE7d0JBQ1JPLFFBQVE7d0JBQ1JILE1BQU07d0JBQ05DLFNBQVM7d0JBQ1RHLEtBQUs7NEJBQUM7eUJBQVk7b0JBQ3BCO29CQUNBO3dCQUNFVCxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxNQUFNO3dCQUNOQyxPQUFPO3dCQUNQQyxNQUFNO3dCQUNOQyxNQUFNO3dCQUNOQyxTQUFTO29CQUNYO2lCQUNEO2dCQUNEQyxXQUFXO2dCQUNYTixRQUFRO2dCQUNSTyxRQUFRO2dCQUNSSCxNQUFNO2dCQUNOQyxTQUFTO2dCQUNUSyxZQUFZO2dCQUNaQyxXQUFXO1lBQ2I7WUFDQTtnQkFDRWIsVUFBVTtvQkFDUjt3QkFDRUMsUUFBUTt3QkFDUkMsUUFBUTt3QkFDUkMsTUFBTTt3QkFDTkMsT0FBTzt3QkFDUEMsTUFBTTt3QkFDTkMsTUFBTTt3QkFDTkMsU0FBUztvQkFDWDtpQkFDRDtnQkFDREMsV0FBVztnQkFDWE4sUUFBUTtnQkFDUk8sUUFBUTtnQkFDUkgsTUFBTTtnQkFDTkMsU0FBUztnQkFDVEksS0FBSztZQUNQO1lBQ0E7Z0JBQ0VYLFVBQVU7b0JBQ1I7d0JBQ0VDLFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLE1BQU07d0JBQ05DLE9BQU87d0JBQ1BDLE1BQU07d0JBQ05DLE1BQU07d0JBQ05DLFNBQVM7b0JBQ1g7b0JBQ0E7d0JBQ0VQLFVBQVU7NEJBQ1I7Z0NBQ0VDLFFBQVE7Z0NBQ1JDLFFBQVE7Z0NBQ1JDLE1BQU07Z0NBQ05DLE9BQU87Z0NBQ1BDLE1BQU07Z0NBQ05DLE1BQU07Z0NBQ05DLFNBQVM7NEJBQ1g7eUJBQ0Q7d0JBQ0RDLFdBQVc7d0JBQ1hOLFFBQVE7d0JBQ1JPLFFBQVE7d0JBQ1JILE1BQU07d0JBQ05DLFNBQVM7d0JBQ1RHLEtBQUs7NEJBQUM7eUJBQVk7b0JBQ3BCO29CQUNBO3dCQUNFVCxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxNQUFNO3dCQUNOQyxPQUFPO3dCQUNQQyxNQUFNO3dCQUNOQyxNQUFNO3dCQUNOQyxTQUFTO29CQUNYO29CQUNBO3dCQUNFUCxVQUFVOzRCQUNSO2dDQUNFQyxRQUFRO2dDQUNSQyxRQUFRO2dDQUNSQyxNQUFNO2dDQUNOQyxPQUFPO2dDQUNQQyxNQUFNO2dDQUNOQyxNQUFNO2dDQUNOQyxTQUFTOzRCQUNYO3lCQUNEO3dCQUNEQyxXQUFXO3dCQUNYTixRQUFRO3dCQUNSTyxRQUFRO3dCQUNSSCxNQUFNO3dCQUNOQyxTQUFTO3dCQUNURyxLQUFLOzRCQUFDO3lCQUFZO29CQUNwQjtvQkFDQTt3QkFDRVQsUUFBUTt3QkFDUkMsUUFBUTt3QkFDUkMsTUFBTTt3QkFDTkMsT0FBTzt3QkFDUEMsTUFBTTt3QkFDTkMsTUFBTTt3QkFDTkMsU0FBUztvQkFDWDtpQkFDRDtnQkFDREMsV0FBVztnQkFDWE4sUUFBUTtnQkFDUk8sUUFBUTtnQkFDUkgsTUFBTTtnQkFDTkMsU0FBUztnQkFDVEssWUFBWTtnQkFDWkMsV0FBVztZQUNiO1NBQ0Q7UUFDREwsV0FBVztRQUNYTixRQUFRO1FBQ1JPLFFBQVE7UUFDUkgsTUFBTTtRQUNOQyxTQUFTO0lBQ1g7QUFDRixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy91dGlscy9lZGl0b3JTdGF0ZXMudHN4PzZmMTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IG1haW5FZGl0b3JTdGF0ZSA9IHtcbiAgcm9vdDoge1xuICAgIGNoaWxkcmVuOiBbXG4gICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIkN1cnJlbnQgUHJvamVjdFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgdHlwZTogXCJtYXJrXCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgaWRzOiBbXCJrZ2RzODlneXJcIl0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIiAgRG9jdW1lbnQgRWRpdGluZyBQbGF0Zm9ybVwiLFxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICB0YWc6IFwiaDFcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgdGV4dDogXCJPdmVydmlld1wiLFxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICB0YWc6IFwiaDNcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgdGV4dDogXCJJIGxlYWQgdGhlIGZyb250ZW5kIGRlc2lnbiBhbmQgZGV2ZWxvcG1lbnQgb2YgYSBHb29nbGUgRG9jcy1zdHlsZSBlZGl0b3IgdGFpbG9yZWQgdG8gbGluZ3Vpc3QgYW5kIGFuYWx5c3Qgd29ya2Zsb3dzLCBkcmFzdGljYWxseSBpbmNyZWFzaW5nIHRoZSBzcGVlZCB0aGF0IGRvY3VtZW50cyBhcmUgdHJhbnNsYXRlZCwgcmV2aWV3ZWQsIGFuZCBwcm9jZXNzZWQuIEJ1aWx0IHdpdGggXCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiVHlwZXNjcmlwdFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgdHlwZTogXCJtYXJrXCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgaWRzOiBbXCJuMDV3anlkNTFcIl0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIiwgXCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiUmVhY3RcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJcIixcbiAgICAgICAgICAgIGluZGVudDogMCxcbiAgICAgICAgICAgIHR5cGU6IFwibWFya1wiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIGlkczogW1wib3pnaGk3enVyXCJdLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgdGV4dDogXCIsIGFuZCBcIixcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgICAgIG1vZGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJMZXhpY2FsXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgICAgICB0eXBlOiBcIm1hcmtcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICBpZHM6IFtcImdhY2N2eHl5cFwiXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgIG1vZGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgIHRleHQ6IFwiLlwiLFxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIHRleHRGb3JtYXQ6IDAsXG4gICAgICAgIHRleHRTdHlsZTogXCJcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgdGV4dDogXCJGZWF0dXJlc1wiLFxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICB0YWc6IFwiaDNcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIuKcqCBBdXRvbWF0aWMgQUkgdHJhbnNsYXRpb25zIGFuZCByZXBsYWNlbWVudHNcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJcIixcbiAgICAgICAgICAgIGluZGVudDogMCxcbiAgICAgICAgICAgIHR5cGU6IFwibGlzdGl0ZW1cIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICB2YWx1ZTogMSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgICAgIG1vZGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCLimqEgTGl2ZSBjb2xsYWJvcmF0aW9uIHRocm91Z2ggd2Vic29ja2V0c1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgdHlwZTogXCJsaXN0aXRlbVwiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHZhbHVlOiAyLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIvCfkqwgQ29tbWVudGluZyBhbmQgYW5ub3RhdGlvbiB0b29sc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgdHlwZTogXCJsaXN0aXRlbVwiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHZhbHVlOiAzLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIvCfkYAgUmV2aWV3IG1vZGUgdG8gdHJhY2sgY2hhbmdlc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgdHlwZTogXCJsaXN0aXRlbVwiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHZhbHVlOiA0LFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIvCfk4QgSW1wb3J0IGRvY3VtZW50cyBmcm9tIFdvcmQsIFBERiwgRXhjZWwsIGFuZCBtb3JlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgICAgICB0eXBlOiBcImxpc3RpdGVtXCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgdmFsdWU6IDUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwi8J+WqO+4jyBFeHBvcnQgYW5kIHByaW50IHRvIFBERlwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgdHlwZTogXCJsaXN0aXRlbVwiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHZhbHVlOiA2LFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIuKcj++4jyBBIHN1aXRlIG9mIHJpY2ggdGV4dCBmb3JtYXR0aW5nIGNhcGFiaWxpdGllc1wiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgdHlwZTogXCJsaXN0aXRlbVwiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHZhbHVlOiA3LFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICBsaXN0VHlwZTogXCJidWxsZXRcIixcbiAgICAgICAgc3RhcnQ6IDEsXG4gICAgICAgIHRhZzogXCJ1bFwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIlRlY2huaWNhbCBMZWFkZXJzaGlwXCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgIGluZGVudDogMCxcbiAgICAgICAgdHlwZTogXCJoZWFkaW5nXCIsXG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIHRhZzogXCJoM1wiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIkkgXCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiZXZvbHZlZCBhbmQgc2NhbGVkXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgICAgICB0eXBlOiBcIm1hcmtcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICBpZHM6IFtcIm1jc2g5ZTVsN1wiXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgIG1vZGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgIHRleHQ6IFwiIHRoZSBmcm9udGVuZCBhcmNoaXRlY3R1cmUgdGhyb3VnaCByZXVzYWJsZSBjb21wb25lbnQgbGlicmFyaWVzIGFuZCBjb25zaXN0ZW50IHN0YXRlIG1hbmFnZW1lbnQgcGF0dGVybnMsIGFuZCBjaGFtcGlvbmVkIGFjY2Vzc2liaWxpdHksIHBlcmZvcm1hbmNlLCBhbmQgZW5naW5lZXJpbmcgYmVzdCBwcmFjdGljZXMuIFwiLFxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIHRleHRGb3JtYXQ6IDAsXG4gICAgICAgIHRleHRTdHlsZTogXCJcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgdGV4dDogXCJJIHRha2Ugb3dlcnNoaXAgb2YgZmVhdHVyZXMgZnJvbSBjb25jZXB0dWFsaXNhdGlvbiB0byBpbXBsZW1lbnRhdGlvbiwgYW5kIFwiLFxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcImNvbGxhYm9yYXRlXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgICAgICB0eXBlOiBcIm1hcmtcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICBpZHM6IFtcIjh6YjVlaXRmc1wiXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgIG1vZGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgIHRleHQ6IFwiIHdpdGggdGVhbW1hdGVzIGFjcm9zcyBkaXNjaXBsaW5lcyB0byBlbnN1cmUgdGhlIHByb2R1Y3QgaXMgYWxpZ25lZCBhcyBhIHdob2xlLiBJIGhhdmUgYSBmdWxsc3RhY2sgYmFja2dyb3VuZCBhbmQgYW0gbm90IGFmcmFpZCB0byB3b3JrIGFjcm9zcyB0aGUgYmFja2VuZCBhbmQgZGV2b3BzIGluZnJhc3RydWN0dXJlIGluIG9yZGVyIHRvIGVuc3VyZSBmZWF0dXJlcyBhcmUgcm9idXN0bHkgaW1wbGVtZW50ZWQuXCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgIGluZGVudDogMCxcbiAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgdGV4dEZvcm1hdDogMCxcbiAgICAgICAgdGV4dFN0eWxlOiBcIlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIlRoZSBzZWN1cmUgYW5kIGNsYXNzaWZpZWQgbmF0dXJlIG9mIHRoZSBwcm9qZWN0J3MgZW52aXJvbm1lbnQgaW1wb3NlcyBncmVhdCBjaGFsbGVuZ2VzLCBhcyB3ZWxsIGFzIHRoZSBsYXJnZSBhbmQgY29tcGxleCBzY29wZSBvZiBpdCdzIGZlYXR1cmVzLiBJJ20gdXNlZCB0byB3b3JraW5nIG9uIGFtYml0aW91cyBnb2FscyBhbmQgcHVuY2hpbmcgYWJvdmUgbXkgd2VpZ2h0LCBhbmQgdGhlIG1hZ2ljIG9mIGltcHJvdmluZyBwZW9wbGUncyBsaXZlcyBtYWtlcyBpdCBhbGwgd29ydGggaXQuIFwiLFxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgIHRleHRGb3JtYXQ6IDAsXG4gICAgICAgIHRleHRTdHlsZTogXCJcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgdGV4dDogXCJVSS9VWCBEZXNpZ25cIixcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgIGZvcm1hdDogXCJcIixcbiAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgdGFnOiBcImgzXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgIG1vZGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgIHRleHQ6IFwiSSBoYXZlIGEgZXllIGZvciBkZXRhaWwsIGJ1dCBhIGdyZWF0IGFwcHJlY2lhdGlvbiBmb3IgXCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwicHJhZ21hdGlzbSBhbmQgc2ltcGxpY2l0eVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgdHlwZTogXCJtYXJrXCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgaWRzOiBbXCJva3NnMzR2NjFcIl0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIi4gSSBjb2xsYWJvcmF0ZSB3aXRoIHN0YWtlaG9sZGVycywgZW5naW5lZXJzLCBhbmQgZGVzaWduZXJzIHRvIHNjb3BlIGFuZCBkZWZpbmUgZmVhdHVyZXMgYW5kIG9mdGVuIG5hdmlnYXRlIGRpZmZpY3VsdCBjb25zdHJhaW50cyB0byBmaW5kIHNvbHV0aW9ucyB0aGF0IG1ha2Ugc2Vuc2UgZm9yIGV2ZXJ5Ym9keS4gXCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgIGluZGVudDogMCxcbiAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgdGV4dEZvcm1hdDogMCxcbiAgICAgICAgdGV4dFN0eWxlOiBcIlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIkkndmUgY29uZHVjdGVkIHVzZXIgd29ya3Nob3BzIHRvIGdhdGhlciBhbmQgdmFsaWRhdGUgcmVxdWlyZW1lbnRzLCBjcmVhdGVkIGRlc2lnbnMgYW5kIGNvZGUgcHJvdG90eXBlcywgYW5kIHJlZ3VsYXJseSBwcmVzZW50ZWQgZGVtb3MgdG8gc3Rha2Vob2xkZXJzIGFuZCBwb3RlbnRpYWwgY3VzdG9tZXJzIHRvIGl0ZXJhdGl2ZWx5IGltcHJvdmUgc29sdXRpb25zLiBcIixcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBkaXJlY3Rpb246IFwibHRyXCIsXG4gICAgICAgIGZvcm1hdDogXCJcIixcbiAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICB0eXBlOiBcInBhcmFncmFwaFwiLFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICB0ZXh0Rm9ybWF0OiAwLFxuICAgICAgICB0ZXh0U3R5bGU6IFwiXCIsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgIG1vZGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgIHRleHQ6IFwiSSBzdXBwb3J0ZWQgcHJvZHVjdGlvbiByZWxlYXNlcyBhbmQgY2xvc2VseSBtYW5hZ2VkIGlzc3VlIHRpY2tldHMgYW5kIFwiLFxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGRldGFpbDogMCxcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgICAgICBzdHlsZTogXCJcIixcbiAgICAgICAgICAgICAgICB0ZXh0OiBcInVzZXIgZmVlZGJhY2tcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJcIixcbiAgICAgICAgICAgIGluZGVudDogMCxcbiAgICAgICAgICAgIHR5cGU6IFwibWFya1wiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIGlkczogW1wiMjc3dWoxdTZsXCJdLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgdGV4dDogXCIgdG8gcmVmaW5lIGZlYXR1cmVzIHdpdGggcXVpY2sgdHVybmFyb3VuZHMsIGVuc3VyaW5nIHVzZXJzIGZlbHQgaGVhcmQgYW5kIHRoYXQgdGhlaXIgY29uY2VybnMgd2VyZSBiZWluZyBhZGRyZXNzZWQuXCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgIGluZGVudDogMCxcbiAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgdGV4dEZvcm1hdDogMCxcbiAgICAgICAgdGV4dFN0eWxlOiBcIlwiLFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIk1lbnRvcmluZ1wiLFxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICBpbmRlbnQ6IDAsXG4gICAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICB0YWc6IFwiaDNcIixcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgdGV4dDogXCJJIG1lbnRvcmVkIHNldmVyYWwgbmV3IGZyb250ZW5kIGRldmVsb3BlcnMgaW4gXCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogMCxcbiAgICAgICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgICAgIHRleHQ6IFwiYmVzdCBwcmFjdGljZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcIlwiLFxuICAgICAgICAgICAgaW5kZW50OiAwLFxuICAgICAgICAgICAgdHlwZTogXCJtYXJrXCIsXG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgaWRzOiBbXCJjbXJiOWhrNmxcIl0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICBmb3JtYXQ6IDAsXG4gICAgICAgICAgICBtb2RlOiBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICB0ZXh0OiBcIiBUeXBlc2NyaXB0IGFuZCBSZWFjdCBkZXZlbG9wbWVudCwgZGlyZWN0aW5nIGFuZCByZXZpZXdpbmcgY29kZSBhbmQgZGVzaWduIGNoYW5nZXMgd2l0aCBjb25zdHJ1Y3RpdmUgZmVlZGJhY2suIFdpdGggdGhlIGJpZyBwaWN0dXJlIGluIG1pbmQsIEkga2VwdCB0aGUgcHJvamVjdCBhbmQgb3RoZXIgdGVhbSBtZW1iZXJzJyBhcHByb2FjaCBkaXJlY3RlZCB0byBcIixcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBkZXRhaWw6IDAsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgICAgIG1vZGU6IFwibm9ybWFsXCIsXG4gICAgICAgICAgICAgICAgc3R5bGU6IFwiXCIsXG4gICAgICAgICAgICAgICAgdGV4dDogXCJzb2x2aW5nIGNyaXRpY2FsIG1pc3Npb24gbmVlZHNcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJcIixcbiAgICAgICAgICAgIGluZGVudDogMCxcbiAgICAgICAgICAgIHR5cGU6IFwibWFya1wiLFxuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIGlkczogW1wicTl0ZmI5bTl0XCJdLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGV0YWlsOiAwLFxuICAgICAgICAgICAgZm9ybWF0OiAwLFxuICAgICAgICAgICAgbW9kZTogXCJub3JtYWxcIixcbiAgICAgICAgICAgIHN0eWxlOiBcIlwiLFxuICAgICAgICAgICAgdGV4dDogXCIuXCIsXG4gICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgZGlyZWN0aW9uOiBcImx0clwiLFxuICAgICAgICBmb3JtYXQ6IFwiXCIsXG4gICAgICAgIGluZGVudDogMCxcbiAgICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgdGV4dEZvcm1hdDogMCxcbiAgICAgICAgdGV4dFN0eWxlOiBcIlwiLFxuICAgICAgfSxcbiAgICBdLFxuICAgIGRpcmVjdGlvbjogXCJsdHJcIixcbiAgICBmb3JtYXQ6IFwiXCIsXG4gICAgaW5kZW50OiAwLFxuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIHZlcnNpb246IDEsXG4gIH0sXG59O1xuIl0sIm5hbWVzIjpbIm1haW5FZGl0b3JTdGF0ZSIsInJvb3QiLCJjaGlsZHJlbiIsImRldGFpbCIsImZvcm1hdCIsIm1vZGUiLCJzdHlsZSIsInRleHQiLCJ0eXBlIiwidmVyc2lvbiIsImRpcmVjdGlvbiIsImluZGVudCIsImlkcyIsInRhZyIsInRleHRGb3JtYXQiLCJ0ZXh0U3R5bGUiLCJ2YWx1ZSIsImxpc3RUeXBlIiwic3RhcnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/utils/editorStates.tsx\n"));

/***/ }),

/***/ "./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateJSONFromSelectedNodes: function() { return /* binding */ $generateJSONFromSelectedNodes; },\n/* harmony export */   $generateNodesFromSerializedNodes: function() { return /* binding */ $generateNodesFromSerializedNodes; },\n/* harmony export */   $getClipboardDataFromSelection: function() { return /* binding */ $getClipboardDataFromSelection; },\n/* harmony export */   $getHtmlContent: function() { return /* binding */ $getHtmlContent; },\n/* harmony export */   $getLexicalContent: function() { return /* binding */ $getLexicalContent; },\n/* harmony export */   $insertDataTransferForPlainText: function() { return /* binding */ $insertDataTransferForPlainText; },\n/* harmony export */   $insertDataTransferForRichText: function() { return /* binding */ $insertDataTransferForRichText; },\n/* harmony export */   $insertGeneratedNodes: function() { return /* binding */ $insertGeneratedNodes; },\n/* harmony export */   copyToClipboard: function() { return /* binding */ copyToClipboard; },\n/* harmony export */   setLexicalClipboardDataTransfer: function() { return /* binding */ setLexicalClipboardDataTransfer; }\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/html */ \"./node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns a string of HTML content\n */\nfunction $getHtmlContent(editor, selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n  return (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateHtmlFromNodes)(editor, selection);\n}\n\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @param selection - The selection to use (default is $getSelection())\n * @returns\n */\nfunction $getLexicalContent(editor, selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  if (selection == null) {\n    {\n      formatDevErrorMessage(`Expected valid LexicalSelection`);\n    }\n  }\n\n  // If we haven't selected anything\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch (_unused) {\n      // Fail silently.\n    }\n  }\n  const htmlString = dataTransfer.getData('text/html');\n  const plainString = dataTransfer.getData('text/plain');\n\n  // Skip HTML handling if it matches the plain text representation.\n  // This avoids unnecessary processing for plain text strings created by\n  // iOS Safari autocorrect, which incorrectly includes a `text/html` type.\n  if (htmlString && plainString !== htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(trustHTML(htmlString), 'text/html');\n      const nodes = (0,_lexical_html__WEBPACK_IMPORTED_MODULE_1__.$generateNodesFromDOM)(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch (_unused2) {\n      // Fail silently.\n    }\n  }\n\n  // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n  const text = plainString || dataTransfer.getData('text/uri-list');\n  if (text != null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      if (parts[parts.length - 1] === '') {\n        parts.pop();\n      }\n      for (let i = 0; i < parts.length; i++) {\n        const currentSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(currentSelection)) {\n          const part = parts[i];\n          if (part === '\\n' || part === '\\r\\n') {\n            currentSelection.insertParagraph();\n          } else if (part === '\\t') {\n            currentSelection.insertNodes([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n          } else {\n            currentSelection.insertText(part);\n          }\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\nfunction trustHTML(html) {\n  if (window.trustedTypes && window.trustedTypes.createPolicy) {\n    const policy = window.trustedTypes.createPolicy('lexical', {\n      createHTML: input => input\n    });\n    return policy.createHTML(html);\n  }\n  return html;\n}\n\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  if (!editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, {\n    nodes,\n    selection\n  })) {\n    selection.insertNodes(nodes);\n    $updateSelectionOnInsert(selection);\n  }\n  return;\n}\nfunction $updateSelectionOnInsert(selection) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n    const anchor = selection.anchor;\n    let nodeToInspect = null;\n    const anchorCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(anchor, 'previous');\n    if (anchorCaret) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextPointCaret)(anchorCaret)) {\n        nodeToInspect = anchorCaret.origin;\n      } else {\n        const range = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCaretRange)(anchorCaret, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)(), 'next').getFlipped());\n        for (const caret of range) {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(caret.origin)) {\n            nodeToInspect = caret.origin;\n            break;\n          } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(caret.origin) && !caret.origin.isInline()) {\n            break;\n          }\n        }\n      }\n    }\n    if (nodeToInspect && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nodeToInspect)) {\n      const newFormat = nodeToInspect.getFormat();\n      const newStyle = nodeToInspect.getStyle();\n      if (selection.format !== newFormat || selection.style !== newStyle) {\n        selection.format = newFormat;\n        selection.style = newStyle;\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n  return serializedNode;\n}\nfunction $appendNodesToJSON(editor, selection, currentNode, targetArray = []) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target);\n\n  // TODO: TextNode calls getTextContent() (NOT node.__text) within its exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with its own key, but\n  // until then this hack will work for the selected text extract use case.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    const text = target.__text;\n    // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection, childNode, serializedNode.children);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n  return shouldInclude;\n}\n\n// TODO why $ function with Editor instance?\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n\n/**\n * This method takes an array of objects conforming to the BaseSerializedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$parseSerializedNode)(serializedNode);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.$addNodeStyle)(node);\n    }\n    nodes.push(node);\n  }\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null;\n\n// TODO custom selection\n// TODO potentially have a node customizable version for plain text\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\nasync function copyToClipboard(editor, event, data) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event, data));\n      });\n    });\n  }\n  const rootElement = editor.getRootElement();\n  const editorWindow = editor._window || window;\n  const windowDocument = window.document;\n  const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editorWindow);\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, secondEvent => {\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.objectKlassEquals)(secondEvent, ClipboardEvent)) {\n        removeListener();\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n        resolve($copyToClipboardEvent(editor, secondEvent, data));\n      }\n      // Block the entire copy flow while we wait for the next ClipboardEvent\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL);\n    // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n}\n\n// TODO shouldn't pass editor (pass namespace directly)\nfunction $copyToClipboardEvent(editor, event, data) {\n  if (data === undefined) {\n    const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editor._window);\n    if (!domSelection) {\n      return false;\n    }\n    const anchorDOM = domSelection.anchorNode;\n    const focusDOM = domSelection.focusNode;\n    if (anchorDOM !== null && focusDOM !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionWithinEditor)(editor, anchorDOM, focusDOM)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection === null) {\n      return false;\n    }\n    data = $getClipboardDataFromSelection(selection);\n  }\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  if (clipboardData === null) {\n    return false;\n  }\n  setLexicalClipboardDataTransfer(clipboardData, data);\n  return true;\n}\nconst clipboardDataFunctions = [['text/html', $getHtmlContent], ['application/x-lexical-editor', $getLexicalContent]];\n\n/**\n * Serialize the content of the current selection to strings in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats (as available).\n *\n * @param selection the selection to serialize (defaults to $getSelection())\n * @returns LexicalClipboardData\n */\nfunction $getClipboardDataFromSelection(selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)()) {\n  const clipboardData = {\n    'text/plain': selection ? selection.getTextContent() : ''\n  };\n  if (selection) {\n    const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)();\n    for (const [mimeType, $editorFn] of clipboardDataFunctions) {\n      const v = $editorFn(editor, selection);\n      if (v !== null) {\n        clipboardData[mimeType] = v;\n      }\n    }\n  }\n  return clipboardData;\n}\n\n/**\n * Call setData on the given clipboardData for each MIME type present\n * in the given data (from {@link $getClipboardDataFromSelection})\n *\n * @param clipboardData the event.clipboardData to populate from data\n * @param data The lexical data\n */\nfunction setLexicalClipboardDataTransfer(clipboardData, data) {\n  for (const k in data) {\n    const v = data[k];\n    if (v !== undefined) {\n      clipboardData.setData(k, v);\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvY2xpcGJvYXJkL0xleGljYWxDbGlwYm9hcmQuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4RTtBQUNJO0FBQy9CO0FBQ3dUOztBQUUzVztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsc0RBQWE7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQSxTQUFTLHFFQUFzQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxzREFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvRUFBcUI7QUFDekM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixrQkFBa0I7QUFDeEMsaUNBQWlDLHNEQUFhO0FBQzlDLFlBQVksMERBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWiwwQ0FBMEMsdURBQWM7QUFDeEQsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZFQUF3QztBQUN0RTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQWU7QUFDdkM7QUFDQSxVQUFVLDBEQUFpQjtBQUMzQjtBQUNBLFFBQVE7QUFDUixzQkFBc0IsdURBQWMsY0FBYyx1REFBYyxDQUFDLGlEQUFRO0FBQ3pFO0FBQ0EsY0FBYyxvREFBVztBQUN6QjtBQUNBO0FBQ0EsWUFBWSxTQUFTLHVEQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0RBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFjO0FBQ3RDO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQW9CO0FBQ3BDLFlBQVksb0RBQVcsZ0NBQWdDLGlGQUE2QjtBQUNwRjtBQUNBO0FBQ0EsbUJBQW1CLHVEQUFjO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQix1REFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG9CQUFvQixvQ0FBb0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBLGlCQUFpQiw2REFBb0I7QUFDckMsUUFBUSxvREFBVztBQUNuQixNQUFNLGlFQUFhO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0RBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlEQUFZO0FBQzlELFVBQVUsaUVBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssRUFBRSw4REFBeUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdEQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0VBQXVCO0FBQzNFO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHNEQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1EQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTRSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9jbGlwYm9hcmQvTGV4aWNhbENsaXBib2FyZC5kZXYubWpzP2NhYjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00gfSBmcm9tICdAbGV4aWNhbC9odG1sJztcbmltcG9ydCB7ICRhZGROb2RlU3R5bGUsICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50IH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcbmltcG9ydCB7IG9iamVjdEtsYXNzRXF1YWxzIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgJGlzUmFuZ2VTZWxlY3Rpb24sICRnZXRTZWxlY3Rpb24sICRjcmVhdGVUYWJOb2RlLCBTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCAkY2FyZXRGcm9tUG9pbnQsICRpc1RleHRQb2ludENhcmV0LCAkZ2V0Q2FyZXRSYW5nZSwgJGdldENoaWxkQ2FyZXQsICRnZXRSb290LCAkaXNUZXh0Tm9kZSwgJGlzRWxlbWVudE5vZGUsICRwYXJzZVNlcmlhbGl6ZWROb2RlLCBnZXRET01TZWxlY3Rpb24sIENPUFlfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCwgaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IsICRnZXRFZGl0b3IsICRjbG9uZVdpdGhQcm9wZXJ0aWVzIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMuXG5cbmZ1bmN0aW9uIGZvcm1hdERldkVycm9yTWVzc2FnZShtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAqY3VycmVudGx5IHNlbGVjdGVkKiBMZXhpY2FsIGNvbnRlbnQgYXMgYW4gSFRNTCBzdHJpbmcsIHJlbHlpbmcgb24gdGhlXG4gKiBsb2dpYyBkZWZpbmVkIGluIHRoZSBleHBvcnRET00gbWV0aG9kcyBvbiB0aGUgTGV4aWNhbE5vZGUgY2xhc3Nlcy4gTm90ZSB0aGF0XG4gKiB0aGlzIHdpbGwgbm90IHJldHVybiB0aGUgSFRNTCBjb250ZW50IG9mIHRoZSBlbnRpcmUgZWRpdG9yICh1bmxlc3MgYWxsIHRoZSBjb250ZW50IGlzIGluY2x1ZGVkXG4gKiBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24pLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgLSBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGdldCBIVE1MIGNvbnRlbnQgZnJvbVxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gdG8gdXNlIChkZWZhdWx0IGlzICRnZXRTZWxlY3Rpb24oKSlcbiAqIEByZXR1cm5zIGEgc3RyaW5nIG9mIEhUTUwgY29udGVudFxuICovXG5mdW5jdGlvbiAkZ2V0SHRtbENvbnRlbnQoZWRpdG9yLCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkpIHtcbiAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB2YWxpZCBMZXhpY2FsU2VsZWN0aW9uYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZW4ndCBzZWxlY3RlZCBhbnl0aGluZ1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMoZWRpdG9yLCBzZWxlY3Rpb24pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlICpjdXJyZW50bHkgc2VsZWN0ZWQqIExleGljYWwgY29udGVudCBhcyBhIEpTT04gc3RyaW5nLCByZWx5aW5nIG9uIHRoZVxuICogbG9naWMgZGVmaW5lZCBpbiB0aGUgZXhwb3J0SlNPTiBtZXRob2RzIG9uIHRoZSBMZXhpY2FsTm9kZSBjbGFzc2VzLiBOb3RlIHRoYXRcbiAqIHRoaXMgd2lsbCBub3QgcmV0dXJuIHRoZSBKU09OIGNvbnRlbnQgb2YgdGhlIGVudGlyZSBlZGl0b3IgKHVubGVzcyBhbGwgdGhlIGNvbnRlbnQgaXMgaW5jbHVkZWRcbiAqIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbikuXG4gKlxuICogQHBhcmFtIGVkaXRvciAgLSBMZXhpY2FsRWRpdG9yIGluc3RhbmNlIHRvIGdldCB0aGUgSlNPTiBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHRvIHVzZSAoZGVmYXVsdCBpcyAkZ2V0U2VsZWN0aW9uKCkpXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiAkZ2V0TGV4aWNhbENvbnRlbnQoZWRpdG9yLCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkpIHtcbiAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB2YWxpZCBMZXhpY2FsU2VsZWN0aW9uYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgd2UgaGF2ZW4ndCBzZWxlY3RlZCBhbnl0aGluZ1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBzZWxlY3Rpb24uZ2V0Tm9kZXMoKS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKSk7XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGNvbnRlbnQgb2YgdGhlIG1pbWUtdHlwZXMgdGV4dC9wbGFpbiBvciB0ZXh0L3VyaS1saXN0IGZyb21cbiAqIHRoZSBwcm92aWRlZCBEYXRhVHJhbnNmZXIgb2JqZWN0IGludG8gdGhlIGVkaXRvciBhdCB0aGUgcHJvdmlkZWQgc2VsZWN0aW9uLlxuICogdGV4dC91cmktbGlzdCBpcyBvbmx5IHVzZWQgaWYgdGV4dC9wbGFpbiBpcyBub3QgYWxzbyBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gZGF0YVRyYW5zZmVyIGFuIG9iamVjdCBjb25mb3JtaW5nIHRvIHRoZSBbRGF0YVRyYW5zZmVyIGludGVyZmFjZV0gKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2RuZC5odG1sI3RoZS1kYXRhdHJhbnNmZXItaW50ZXJmYWNlKVxuICogQHBhcmFtIHNlbGVjdGlvbiB0aGUgc2VsZWN0aW9uIHRvIHVzZSBhcyB0aGUgaW5zZXJ0aW9uIHBvaW50IGZvciB0aGUgY29udGVudCBpbiB0aGUgRGF0YVRyYW5zZmVyIG9iamVjdFxuICovXG5mdW5jdGlvbiAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUGxhaW5UZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IHRleHQgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9wbGFpbicpIHx8IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3VyaS1saXN0Jyk7XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGluc2VydCBjb250ZW50IG9mIHRoZSBtaW1lLXR5cGVzIGFwcGxpY2F0aW9uL3gtbGV4aWNhbC1lZGl0b3IsIHRleHQvaHRtbCxcbiAqIHRleHQvcGxhaW4sIG9yIHRleHQvdXJpLWxpc3QgKGluIGRlc2NlbmRpbmcgb3JkZXIgb2YgcHJpb3JpdHkpIGZyb20gdGhlIHByb3ZpZGVkIERhdGFUcmFuc2ZlclxuICogb2JqZWN0IGludG8gdGhlIGVkaXRvciBhdCB0aGUgcHJvdmlkZWQgc2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBkYXRhVHJhbnNmZXIgYW4gb2JqZWN0IGNvbmZvcm1pbmcgdG8gdGhlIFtEYXRhVHJhbnNmZXIgaW50ZXJmYWNlXSAoaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG5kLmh0bWwjdGhlLWRhdGF0cmFuc2Zlci1pbnRlcmZhY2UpXG4gKiBAcGFyYW0gc2VsZWN0aW9uIHRoZSBzZWxlY3Rpb24gdG8gdXNlIGFzIHRoZSBpbnNlcnRpb24gcG9pbnQgZm9yIHRoZSBjb250ZW50IGluIHRoZSBEYXRhVHJhbnNmZXIgb2JqZWN0XG4gKiBAcGFyYW0gZWRpdG9yIHRoZSBMZXhpY2FsRWRpdG9yIHRoZSBjb250ZW50IGlzIGJlaW5nIGluc2VydGVkIGludG8uXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dChkYXRhVHJhbnNmZXIsIHNlbGVjdGlvbiwgZWRpdG9yKSB7XG4gIGNvbnN0IGxleGljYWxTdHJpbmcgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgnYXBwbGljYXRpb24veC1sZXhpY2FsLWVkaXRvcicpO1xuICBpZiAobGV4aWNhbFN0cmluZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShsZXhpY2FsU3RyaW5nKTtcbiAgICAgIGlmIChwYXlsb2FkLm5hbWVzcGFjZSA9PT0gZWRpdG9yLl9jb25maWcubmFtZXNwYWNlICYmIEFycmF5LmlzQXJyYXkocGF5bG9hZC5ub2RlcykpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMocGF5bG9hZC5ub2Rlcyk7XG4gICAgICAgIHJldHVybiAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMoZWRpdG9yLCBub2Rlcywgc2VsZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICAvLyBGYWlsIHNpbGVudGx5LlxuICAgIH1cbiAgfVxuICBjb25zdCBodG1sU3RyaW5nID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICBjb25zdCBwbGFpblN0cmluZyA9IGRhdGFUcmFuc2Zlci5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG5cbiAgLy8gU2tpcCBIVE1MIGhhbmRsaW5nIGlmIGl0IG1hdGNoZXMgdGhlIHBsYWluIHRleHQgcmVwcmVzZW50YXRpb24uXG4gIC8vIFRoaXMgYXZvaWRzIHVubmVjZXNzYXJ5IHByb2Nlc3NpbmcgZm9yIHBsYWluIHRleHQgc3RyaW5ncyBjcmVhdGVkIGJ5XG4gIC8vIGlPUyBTYWZhcmkgYXV0b2NvcnJlY3QsIHdoaWNoIGluY29ycmVjdGx5IGluY2x1ZGVzIGEgYHRleHQvaHRtbGAgdHlwZS5cbiAgaWYgKGh0bWxTdHJpbmcgJiYgcGxhaW5TdHJpbmcgIT09IGh0bWxTdHJpbmcpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgY29uc3QgZG9tID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0cnVzdEhUTUwoaHRtbFN0cmluZyksICd0ZXh0L2h0bWwnKTtcbiAgICAgIGNvbnN0IG5vZGVzID0gJGdlbmVyYXRlTm9kZXNGcm9tRE9NKGVkaXRvciwgZG9tKTtcbiAgICAgIHJldHVybiAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMoZWRpdG9yLCBub2Rlcywgc2VsZWN0aW9uKTtcbiAgICB9IGNhdGNoIChfdW51c2VkMikge1xuICAgICAgLy8gRmFpbCBzaWxlbnRseS5cbiAgICB9XG4gIH1cblxuICAvLyBNdWx0aS1saW5lIHBsYWluIHRleHQgaW4gcmljaCB0ZXh0IG1vZGUgcGFzdGVkIGFzIHNlcGFyYXRlIHBhcmFncmFwaHNcbiAgLy8gaW5zdGVhZCBvZiBzaW5nbGUgcGFyYWdyYXBoIHdpdGggbGluZWJyZWFrcy5cbiAgLy8gV2Via2l0LXNwZWNpZmljOiBTdXBwb3J0cyByZWFkICd0ZXh0L3VyaS1saXN0JyBpbiBjbGlwYm9hcmQuXG4gIGNvbnN0IHRleHQgPSBwbGFpblN0cmluZyB8fCBkYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC91cmktbGlzdCcpO1xuICBpZiAodGV4dCAhPSBudWxsKSB7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdGV4dC5zcGxpdCgvKFxccj9cXG58XFx0KS8pO1xuICAgICAgaWYgKHBhcnRzW3BhcnRzLmxlbmd0aCAtIDFdID09PSAnJykge1xuICAgICAgICBwYXJ0cy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgIGlmIChwYXJ0ID09PSAnXFxuJyB8fCBwYXJ0ID09PSAnXFxyXFxuJykge1xuICAgICAgICAgICAgY3VycmVudFNlbGVjdGlvbi5pbnNlcnRQYXJhZ3JhcGgoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICdcXHQnKSB7XG4gICAgICAgICAgICBjdXJyZW50U2VsZWN0aW9uLmluc2VydE5vZGVzKFskY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRTZWxlY3Rpb24uaW5zZXJ0VGV4dChwYXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cnVzdEhUTUwoaHRtbCkge1xuICBpZiAod2luZG93LnRydXN0ZWRUeXBlcyAmJiB3aW5kb3cudHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSkge1xuICAgIGNvbnN0IHBvbGljeSA9IHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KCdsZXhpY2FsJywge1xuICAgICAgY3JlYXRlSFRNTDogaW5wdXQgPT4gaW5wdXRcbiAgICB9KTtcbiAgICByZXR1cm4gcG9saWN5LmNyZWF0ZUhUTUwoaHRtbCk7XG4gIH1cbiAgcmV0dXJuIGh0bWw7XG59XG5cbi8qKlxuICogSW5zZXJ0cyBMZXhpY2FsIG5vZGVzIGludG8gdGhlIGVkaXRvciB1c2luZyBkaWZmZXJlbnQgc3RyYXRlZ2llcyBkZXBlbmRpbmcgb25cbiAqIHNvbWUgc2ltcGxlIHNlbGVjdGlvbi1iYXNlZCBoZXVyaXN0aWNzLiBJZiB5b3UncmUgbG9va2luZyBmb3IgYSBnZW5lcmljIHdheSB0b1xuICogdG8gaW5zZXJ0IG5vZGVzIGludG8gdGhlIGVkaXRvciBhdCBhIHNwZWNpZmljIHNlbGVjdGlvbiBwb2ludCwgeW91IHByb2JhYmx5IHdhbnRcbiAqIHtAbGluayBsZXhpY2FsLiRpbnNlcnROb2Rlc31cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIExleGljYWxFZGl0b3IgaW5zdGFuY2UgdG8gaW5zZXJ0IHRoZSBub2RlcyBpbnRvLlxuICogQHBhcmFtIG5vZGVzIFRoZSBub2RlcyB0byBpbnNlcnQuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIFRoZSBzZWxlY3Rpb24gdG8gaW5zZXJ0IHRoZSBub2RlcyBpbnRvLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMoZWRpdG9yLCBub2Rlcywgc2VsZWN0aW9uKSB7XG4gIGlmICghZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCB7XG4gICAgbm9kZXMsXG4gICAgc2VsZWN0aW9uXG4gIH0pKSB7XG4gICAgc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzKTtcbiAgICAkdXBkYXRlU2VsZWN0aW9uT25JbnNlcnQoc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm47XG59XG5mdW5jdGlvbiAkdXBkYXRlU2VsZWN0aW9uT25JbnNlcnQoc2VsZWN0aW9uKSB7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICBsZXQgbm9kZVRvSW5zcGVjdCA9IG51bGw7XG4gICAgY29uc3QgYW5jaG9yQ2FyZXQgPSAkY2FyZXRGcm9tUG9pbnQoYW5jaG9yLCAncHJldmlvdXMnKTtcbiAgICBpZiAoYW5jaG9yQ2FyZXQpIHtcbiAgICAgIGlmICgkaXNUZXh0UG9pbnRDYXJldChhbmNob3JDYXJldCkpIHtcbiAgICAgICAgbm9kZVRvSW5zcGVjdCA9IGFuY2hvckNhcmV0Lm9yaWdpbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gJGdldENhcmV0UmFuZ2UoYW5jaG9yQ2FyZXQsICRnZXRDaGlsZENhcmV0KCRnZXRSb290KCksICduZXh0JykuZ2V0RmxpcHBlZCgpKTtcbiAgICAgICAgZm9yIChjb25zdCBjYXJldCBvZiByYW5nZSkge1xuICAgICAgICAgIGlmICgkaXNUZXh0Tm9kZShjYXJldC5vcmlnaW4pKSB7XG4gICAgICAgICAgICBub2RlVG9JbnNwZWN0ID0gY2FyZXQub3JpZ2luO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShjYXJldC5vcmlnaW4pICYmICFjYXJldC5vcmlnaW4uaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlVG9JbnNwZWN0ICYmICRpc1RleHROb2RlKG5vZGVUb0luc3BlY3QpKSB7XG4gICAgICBjb25zdCBuZXdGb3JtYXQgPSBub2RlVG9JbnNwZWN0LmdldEZvcm1hdCgpO1xuICAgICAgY29uc3QgbmV3U3R5bGUgPSBub2RlVG9JbnNwZWN0LmdldFN0eWxlKCk7XG4gICAgICBpZiAoc2VsZWN0aW9uLmZvcm1hdCAhPT0gbmV3Rm9ybWF0IHx8IHNlbGVjdGlvbi5zdHlsZSAhPT0gbmV3U3R5bGUpIHtcbiAgICAgICAgc2VsZWN0aW9uLmZvcm1hdCA9IG5ld0Zvcm1hdDtcbiAgICAgICAgc2VsZWN0aW9uLnN0eWxlID0gbmV3U3R5bGU7XG4gICAgICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBleHBvcnROb2RlVG9KU09OKG5vZGUpIHtcbiAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBub2RlLmV4cG9ydEpTT04oKTtcbiAgY29uc3Qgbm9kZUNsYXNzID0gbm9kZS5jb25zdHJ1Y3RvcjtcbiAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgIT09IG5vZGVDbGFzcy5nZXRUeXBlKCkpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuZXhwb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkQ2hpbGRyZW4gPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2VyaWFsaXplZENoaWxkcmVuKSkge1xuICAgICAge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGlzIGFuIGVsZW1lbnQgYnV0IC5leHBvcnRKU09OKCkgZG9lcyBub3QgaGF2ZSBhIGNoaWxkcmVuIGFycmF5LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZE5vZGU7XG59XG5mdW5jdGlvbiAkYXBwZW5kTm9kZXNUb0pTT04oZWRpdG9yLCBzZWxlY3Rpb24sIGN1cnJlbnROb2RlLCB0YXJnZXRBcnJheSA9IFtdKSB7XG4gIGxldCBzaG91bGRJbmNsdWRlID0gc2VsZWN0aW9uICE9PSBudWxsID8gY3VycmVudE5vZGUuaXNTZWxlY3RlZChzZWxlY3Rpb24pIDogdHJ1ZTtcbiAgY29uc3Qgc2hvdWxkRXhjbHVkZSA9ICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBjdXJyZW50Tm9kZS5leGNsdWRlRnJvbUNvcHkoJ2h0bWwnKTtcbiAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgbGV0IGNsb25lID0gJGNsb25lV2l0aFByb3BlcnRpZXMoY3VycmVudE5vZGUpO1xuICAgIGNsb25lID0gJGlzVGV4dE5vZGUoY2xvbmUpICYmIHNlbGVjdGlvbiAhPT0gbnVsbCA/ICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgY2xvbmUpIDogY2xvbmU7XG4gICAgdGFyZ2V0ID0gY2xvbmU7XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSAkaXNFbGVtZW50Tm9kZSh0YXJnZXQpID8gdGFyZ2V0LmdldENoaWxkcmVuKCkgOiBbXTtcbiAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBleHBvcnROb2RlVG9KU09OKHRhcmdldCk7XG5cbiAgLy8gVE9ETzogVGV4dE5vZGUgY2FsbHMgZ2V0VGV4dENvbnRlbnQoKSAoTk9UIG5vZGUuX190ZXh0KSB3aXRoaW4gaXRzIGV4cG9ydEpTT04gbWV0aG9kXG4gIC8vIHdoaWNoIHVzZXMgZ2V0TGF0ZXN0KCkgdG8gZ2V0IHRoZSB0ZXh0IGZyb20gdGhlIG9yaWdpbmFsIG5vZGUgd2l0aCB0aGUgc2FtZSBrZXkuXG4gIC8vIFRoaXMgaXMgYSBkZWVwZXIgaXNzdWUgd2l0aCB0aGUgd29yZCBcImNsb25lXCIgaGVyZSwgaXQncyBzdGlsbCBhIHJlZmVyZW5jZSB0byB0aGVcbiAgLy8gc2FtZSBub2RlIGFzIGZhciBhcyB0aGUgTGV4aWNhbEVkaXRvciBpcyBjb25jZXJuZWQgc2luY2UgaXQgc2hhcmVzIGEga2V5LlxuICAvLyBXZSBuZWVkIGEgd2F5IHRvIGNyZWF0ZSBhIGNsb25lIG9mIGEgTm9kZSBpbiBtZW1vcnkgd2l0aCBpdHMgb3duIGtleSwgYnV0XG4gIC8vIHVudGlsIHRoZW4gdGhpcyBoYWNrIHdpbGwgd29yayBmb3IgdGhlIHNlbGVjdGVkIHRleHQgZXh0cmFjdCB1c2UgY2FzZS5cbiAgaWYgKCRpc1RleHROb2RlKHRhcmdldCkpIHtcbiAgICBjb25zdCB0ZXh0ID0gdGFyZ2V0Ll9fdGV4dDtcbiAgICAvLyBJZiBhbiB1bmNvbGxhcHNlZCBzZWxlY3Rpb24gZW5kcyBvciBzdGFydHMgYXQgdGhlIGVuZCBvZiBhIGxpbmUgb2Ygc3BlY2lhbGl6ZWQsXG4gICAgLy8gVGV4dE5vZGVzLCBzdWNoIGFzIGNvZGUgdG9rZW5zLCB3ZSB3aWxsIGdldCBhICdibGFuaycgVGV4dE5vZGUgaGVyZSwgaS5lLiwgb25lXG4gICAgLy8gd2l0aCB0ZXh0IG9mIGxlbmd0aCAwLiBXZSBkb24ndCB3YW50IHRoaXMsIGl0IG1ha2VzIGEgY29uZnVzaW5nIG1lc3MuIFJlc2V0IVxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHNlcmlhbGl6ZWROb2RlLnRleHQgPSB0ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzaG91bGRJbmNsdWRlID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBzaG91bGRJbmNsdWRlQ2hpbGQgPSAkYXBwZW5kTm9kZXNUb0pTT04oZWRpdG9yLCBzZWxlY3Rpb24sIGNoaWxkTm9kZSwgc2VyaWFsaXplZE5vZGUuY2hpbGRyZW4pO1xuICAgIGlmICghc2hvdWxkSW5jbHVkZSAmJiAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgc2hvdWxkSW5jbHVkZUNoaWxkICYmIGN1cnJlbnROb2RlLmV4dHJhY3RXaXRoQ2hpbGQoY2hpbGROb2RlLCBzZWxlY3Rpb24sICdjbG9uZScpKSB7XG4gICAgICBzaG91bGRJbmNsdWRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNob3VsZEluY2x1ZGUgJiYgIXNob3VsZEV4Y2x1ZGUpIHtcbiAgICB0YXJnZXRBcnJheS5wdXNoKHNlcmlhbGl6ZWROb2RlKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWFsaXplZE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVkTm9kZS5jaGlsZHJlbltpXTtcbiAgICAgIHRhcmdldEFycmF5LnB1c2goc2VyaWFsaXplZENoaWxkTm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzaG91bGRJbmNsdWRlO1xufVxuXG4vLyBUT0RPIHdoeSAkIGZ1bmN0aW9uIHdpdGggRWRpdG9yIGluc3RhbmNlP1xuLyoqXG4gKiBHZXRzIHRoZSBMZXhpY2FsIEpTT04gb2YgdGhlIG5vZGVzIGluc2lkZSB0aGUgcHJvdmlkZWQgU2VsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBlZGl0b3IgTGV4aWNhbEVkaXRvciB0byBnZXQgdGhlIEpTT04gY29udGVudCBmcm9tLlxuICogQHBhcmFtIHNlbGVjdGlvbiBTZWxlY3Rpb24gdG8gZ2V0IHRoZSBKU09OIGNvbnRlbnQgZnJvbS5cbiAqIEByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBlZGl0b3IgbmFtZXNwYWNlIGFuZCBhIGxpc3Qgb2Ygc2VyaWFsaXphYmxlIG5vZGVzIGFzIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gJGdlbmVyYXRlSlNPTkZyb21TZWxlY3RlZE5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICBjb25zdCB0b3BMZXZlbENoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRvcExldmVsQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b3BMZXZlbE5vZGUgPSB0b3BMZXZlbENoaWxkcmVuW2ldO1xuICAgICRhcHBlbmROb2Rlc1RvSlNPTihlZGl0b3IsIHNlbGVjdGlvbiwgdG9wTGV2ZWxOb2RlLCBub2Rlcyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lc3BhY2U6IGVkaXRvci5fY29uZmlnLm5hbWVzcGFjZSxcbiAgICBub2Rlc1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHRha2VzIGFuIGFycmF5IG9mIG9iamVjdHMgY29uZm9ybWluZyB0byB0aGUgQmFzZVNlcmlhbGl6ZWROb2RlIGludGVyZmFjZSBhbmQgcmV0dXJuc1xuICogYW4gQXJyYXkgY29udGFpbmluZyBpbnN0YW5jZXMgb2YgdGhlIGNvcnJlc3BvbmRpbmcgTGV4aWNhbE5vZGUgY2xhc3NlcyByZWdpc3RlcmVkIG9uIHRoZSBlZGl0b3IuXG4gKiBOb3JtYWxseSwgeW91J2QgZ2V0IGFuIEFycmF5IG9mIEJhc2VTZXJpYWxpemVkIG5vZGVzIGZyb20ge0BsaW5rICRnZW5lcmF0ZUpTT05Gcm9tU2VsZWN0ZWROb2Rlc31cbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZE5vZGVzIGFuIEFycmF5IG9mIG9iamVjdHMgY29uZm9ybWluZyB0byB0aGUgQmFzZVNlcmlhbGl6ZWROb2RlIGludGVyZmFjZS5cbiAqIEByZXR1cm5zIGFuIEFycmF5IG9mIExleGljYWwgTm9kZSBvYmplY3RzLlxuICovXG5mdW5jdGlvbiAkZ2VuZXJhdGVOb2Rlc0Zyb21TZXJpYWxpemVkTm9kZXMoc2VyaWFsaXplZE5vZGVzKSB7XG4gIGNvbnN0IG5vZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VyaWFsaXplZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVkTm9kZXNbaV07XG4gICAgY29uc3Qgbm9kZSA9ICRwYXJzZVNlcmlhbGl6ZWROb2RlKHNlcmlhbGl6ZWROb2RlKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICRhZGROb2RlU3R5bGUobm9kZSk7XG4gICAgfVxuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuY29uc3QgRVZFTlRfTEFURU5DWSA9IDUwO1xubGV0IGNsaXBib2FyZEV2ZW50VGltZW91dCA9IG51bGw7XG5cbi8vIFRPRE8gY3VzdG9tIHNlbGVjdGlvblxuLy8gVE9ETyBwb3RlbnRpYWxseSBoYXZlIGEgbm9kZSBjdXN0b21pemFibGUgdmVyc2lvbiBmb3IgcGxhaW4gdGV4dFxuLyoqXG4gKiBDb3BpZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIHRvIHRoZSBjbGlwYm9hcmQgaW5cbiAqIHRleHQvcGxhaW4sIHRleHQvaHRtbCwgYW5kIGFwcGxpY2F0aW9uL3gtbGV4aWNhbC1lZGl0b3IgKExleGljYWwgSlNPTilcbiAqIGZvcm1hdHMuXG4gKlxuICogQHBhcmFtIGVkaXRvciB0aGUgTGV4aWNhbEVkaXRvciBpbnN0YW5jZSB0byBjb3B5IGNvbnRlbnQgZnJvbVxuICogQHBhcmFtIGV2ZW50IHRoZSBuYXRpdmUgYnJvd3NlciBDbGlwYm9hcmRFdmVudCB0byBhZGQgdGhlIGNvbnRlbnQgdG8uXG4gKiBAcmV0dXJuc1xuICovXG5hc3luYyBmdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCBldmVudCwgZGF0YSkge1xuICBpZiAoY2xpcGJvYXJkRXZlbnRUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgLy8gUHJldmVudCB3ZWlyZCByYWNlIGNvbmRpdGlvbnMgdGhhdCBjYW4gaGFwcGVuIHdoZW4gdGhpcyBmdW5jdGlvbiBpcyBydW4gbXVsdGlwbGUgdGltZXNcbiAgICAvLyBzeW5jaHJvbm91c2x5LiBJbiB0aGUgZnV0dXJlLCB3ZSBjYW4gZG8gYmV0dGVyLCB3ZSBjYW4gY2FuY2VsL292ZXJyaWRlIHRoZSBwcmV2aW91c2x5IHJ1bm5pbmcgam9iLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZXZlbnQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoJGNvcHlUb0NsaXBib2FyZEV2ZW50KGVkaXRvciwgZXZlbnQsIGRhdGEpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIGNvbnN0IGVkaXRvcldpbmRvdyA9IGVkaXRvci5fd2luZG93IHx8IHdpbmRvdztcbiAgY29uc3Qgd2luZG93RG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3JXaW5kb3cpO1xuICBpZiAocm9vdEVsZW1lbnQgPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGVsZW1lbnQgPSB3aW5kb3dEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gIGVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogZml4ZWQ7IHRvcDogLTEwMDBweDsnO1xuICBlbGVtZW50LmFwcGVuZCh3aW5kb3dEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnIycpKTtcbiAgcm9vdEVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChlbGVtZW50LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVsZW1lbnQsIDEpO1xuICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gIGRvbVNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENPUFlfQ09NTUFORCwgc2Vjb25kRXZlbnQgPT4ge1xuICAgICAgaWYgKG9iamVjdEtsYXNzRXF1YWxzKHNlY29uZEV2ZW50LCBDbGlwYm9hcmRFdmVudCkpIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoKTtcbiAgICAgICAgaWYgKGNsaXBib2FyZEV2ZW50VGltZW91dCAhPT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY2xpcGJvYXJkRXZlbnRUaW1lb3V0KTtcbiAgICAgICAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoJGNvcHlUb0NsaXBib2FyZEV2ZW50KGVkaXRvciwgc2Vjb25kRXZlbnQsIGRhdGEpKTtcbiAgICAgIH1cbiAgICAgIC8vIEJsb2NrIHRoZSBlbnRpcmUgY29weSBmbG93IHdoaWxlIHdlIHdhaXQgZm9yIHRoZSBuZXh0IENsaXBib2FyZEV2ZW50XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKTtcbiAgICAvLyBJZiB0aGUgYWJvdmUgaGFjayBleGVjQ29tbWFuZCBoYWNrIHdvcmtzLCB0aGlzIHRpbWVvdXQgY29kZSBzaG91bGQgbmV2ZXIgZmlyZS4gT3RoZXJ3aXNlLFxuICAgIC8vIHRoZSBsaXN0ZW5lciB3aWxsIGJlIHF1aWNrbHkgZnJlZWQgc28gdGhhdCB0aGUgdXNlciBjYW4gcmV1c2UgaXQgYWdhaW5cbiAgICBjbGlwYm9hcmRFdmVudFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgY2xpcGJvYXJkRXZlbnRUaW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc29sdmUoZmFsc2UpO1xuICAgIH0sIEVWRU5UX0xBVEVOQ1kpO1xuICAgIHdpbmRvd0RvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG4gICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgfSk7XG59XG5cbi8vIFRPRE8gc2hvdWxkbid0IHBhc3MgZWRpdG9yIChwYXNzIG5hbWVzcGFjZSBkaXJlY3RseSlcbmZ1bmN0aW9uICRjb3B5VG9DbGlwYm9hcmRFdmVudChlZGl0b3IsIGV2ZW50LCBkYXRhKSB7XG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZWRpdG9yLl93aW5kb3cpO1xuICAgIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvckRPTSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgIGNvbnN0IGZvY3VzRE9NID0gZG9tU2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgICBpZiAoYW5jaG9yRE9NICE9PSBudWxsICYmIGZvY3VzRE9NICE9PSBudWxsICYmICFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRhdGEgPSAkZ2V0Q2xpcGJvYXJkRGF0YUZyb21TZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBjb25zdCBjbGlwYm9hcmREYXRhID0gZXZlbnQuY2xpcGJvYXJkRGF0YTtcbiAgaWYgKGNsaXBib2FyZERhdGEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc2V0TGV4aWNhbENsaXBib2FyZERhdGFUcmFuc2ZlcihjbGlwYm9hcmREYXRhLCBkYXRhKTtcbiAgcmV0dXJuIHRydWU7XG59XG5jb25zdCBjbGlwYm9hcmREYXRhRnVuY3Rpb25zID0gW1sndGV4dC9odG1sJywgJGdldEh0bWxDb250ZW50XSwgWydhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yJywgJGdldExleGljYWxDb250ZW50XV07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0byBzdHJpbmdzIGluXG4gKiB0ZXh0L3BsYWluLCB0ZXh0L2h0bWwsIGFuZCBhcHBsaWNhdGlvbi94LWxleGljYWwtZWRpdG9yIChMZXhpY2FsIEpTT04pXG4gKiBmb3JtYXRzIChhcyBhdmFpbGFibGUpLlxuICpcbiAqIEBwYXJhbSBzZWxlY3Rpb24gdGhlIHNlbGVjdGlvbiB0byBzZXJpYWxpemUgKGRlZmF1bHRzIHRvICRnZXRTZWxlY3Rpb24oKSlcbiAqIEByZXR1cm5zIExleGljYWxDbGlwYm9hcmREYXRhXG4gKi9cbmZ1bmN0aW9uICRnZXRDbGlwYm9hcmREYXRhRnJvbVNlbGVjdGlvbihzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkpIHtcbiAgY29uc3QgY2xpcGJvYXJkRGF0YSA9IHtcbiAgICAndGV4dC9wbGFpbic6IHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5nZXRUZXh0Q29udGVudCgpIDogJydcbiAgfTtcbiAgaWYgKHNlbGVjdGlvbikge1xuICAgIGNvbnN0IGVkaXRvciA9ICRnZXRFZGl0b3IoKTtcbiAgICBmb3IgKGNvbnN0IFttaW1lVHlwZSwgJGVkaXRvckZuXSBvZiBjbGlwYm9hcmREYXRhRnVuY3Rpb25zKSB7XG4gICAgICBjb25zdCB2ID0gJGVkaXRvckZuKGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIGlmICh2ICE9PSBudWxsKSB7XG4gICAgICAgIGNsaXBib2FyZERhdGFbbWltZVR5cGVdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsaXBib2FyZERhdGE7XG59XG5cbi8qKlxuICogQ2FsbCBzZXREYXRhIG9uIHRoZSBnaXZlbiBjbGlwYm9hcmREYXRhIGZvciBlYWNoIE1JTUUgdHlwZSBwcmVzZW50XG4gKiBpbiB0aGUgZ2l2ZW4gZGF0YSAoZnJvbSB7QGxpbmsgJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9ufSlcbiAqXG4gKiBAcGFyYW0gY2xpcGJvYXJkRGF0YSB0aGUgZXZlbnQuY2xpcGJvYXJkRGF0YSB0byBwb3B1bGF0ZSBmcm9tIGRhdGFcbiAqIEBwYXJhbSBkYXRhIFRoZSBsZXhpY2FsIGRhdGFcbiAqL1xuZnVuY3Rpb24gc2V0TGV4aWNhbENsaXBib2FyZERhdGFUcmFuc2ZlcihjbGlwYm9hcmREYXRhLCBkYXRhKSB7XG4gIGZvciAoY29uc3QgayBpbiBkYXRhKSB7XG4gICAgY29uc3QgdiA9IGRhdGFba107XG4gICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xpcGJvYXJkRGF0YS5zZXREYXRhKGssIHYpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyAkZ2VuZXJhdGVKU09ORnJvbVNlbGVjdGVkTm9kZXMsICRnZW5lcmF0ZU5vZGVzRnJvbVNlcmlhbGl6ZWROb2RlcywgJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9uLCAkZ2V0SHRtbENvbnRlbnQsICRnZXRMZXhpY2FsQ29udGVudCwgJGluc2VydERhdGFUcmFuc2ZlckZvclBsYWluVGV4dCwgJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0LCAkaW5zZXJ0R2VuZXJhdGVkTm9kZXMsIGNvcHlUb0NsaXBib2FyZCwgc2V0TGV4aWNhbENsaXBib2FyZERhdGFUcmFuc2ZlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TreeView: function() { return /* binding */ TreeView; },\n/* harmony export */   generateContent: function() { return /* binding */ generateContent; },\n/* harmony export */   registerLexicalCommandLogger: function() { return /* binding */ registerLexicalCommandLogger; },\n/* harmony export */   useLexicalCommandsLog: function() { return /* binding */ useLexicalCommandsLog; }\n/* harmony export */ });\n/* harmony import */ var _lexical_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/html */ \"./node_modules/@lexical/html/LexicalHtml.dev.mjs\");\n/* harmony import */ var _lexical_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/link */ \"./node_modules/@lexical/link/LexicalLink.dev.mjs\");\n/* harmony import */ var _lexical_mark__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/mark */ \"./node_modules/@lexical/mark/LexicalMark.dev.mjs\");\n/* harmony import */ var _lexical_table__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/table */ \"./node_modules/@lexical/table/LexicalTable.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({\n  '\\t': '\\\\t',\n  '\\n': '\\\\n'\n});\nconst NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join('|'), 'g');\nconst SYMBOLS = Object.freeze({\n  ancestorHasNextSibling: '|',\n  ancestorIsLastChild: ' ',\n  hasNextSibling: '',\n  isLastChild: '',\n  selectedChar: '^',\n  selectedLine: '>'\n});\nconst FORMAT_PREDICATES = [node => node.hasFormat('bold') && 'Bold', node => node.hasFormat('code') && 'Code', node => node.hasFormat('italic') && 'Italic', node => node.hasFormat('strikethrough') && 'Strikethrough', node => node.hasFormat('subscript') && 'Subscript', node => node.hasFormat('superscript') && 'Superscript', node => node.hasFormat('underline') && 'Underline', node => node.hasFormat('highlight') && 'Highlight'];\nconst FORMAT_PREDICATES_PARAGRAPH = [node => node.hasTextFormat('bold') && 'Bold', node => node.hasTextFormat('code') && 'Code', node => node.hasTextFormat('italic') && 'Italic', node => node.hasTextFormat('strikethrough') && 'Strikethrough', node => node.hasTextFormat('subscript') && 'Subscript', node => node.hasTextFormat('superscript') && 'Superscript', node => node.hasTextFormat('underline') && 'Underline', node => node.hasTextFormat('highlight') && 'Highlight'];\nconst DETAIL_PREDICATES = [node => node.isDirectionless() && 'Directionless', node => node.isUnmergeable() && 'Unmergeable'];\nconst MODE_PREDICATES = [node => node.isToken() && 'Token', node => node.isSegmented() && 'Segmented'];\nfunction generateContent(editor, commandsLog, exportDOM, customPrintNode, obfuscateText = false) {\n  const editorState = editor.getEditorState();\n  const editorConfig = editor._config;\n  const compositionKey = editor._compositionKey;\n  const editable = editor._editable;\n  if (exportDOM) {\n    let htmlString = '';\n    editorState.read(() => {\n      htmlString = printPrettyHTML((0,_lexical_html__WEBPACK_IMPORTED_MODULE_2__.$generateHtmlFromNodes)(editor));\n    });\n    return htmlString;\n  }\n  let res = ' root\\n';\n  const selectionString = editorState.read(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getSelection)();\n    visitTree((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$getRoot)(), (node, indent) => {\n      const nodeKey = node.getKey();\n      const nodeKeyDisplay = `(${nodeKey})`;\n      const typeDisplay = node.getType() || '';\n      const isSelected = node.isSelected();\n      res += `${isSelected ? SYMBOLS.selectedLine : ' '} ${indent.join(' ')} ${nodeKeyDisplay} ${typeDisplay} ${printNode(node, customPrintNode, obfuscateText)}\\n`;\n      res += $printSelectedCharsLine({\n        indent,\n        isSelected,\n        node,\n        nodeKeyDisplay,\n        selection,\n        typeDisplay\n      });\n    });\n    return selection === null ? ': null' : (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection) ? printRangeSelection(selection) : (0,_lexical_table__WEBPACK_IMPORTED_MODULE_4__.$isTableSelection)(selection) ? printTableSelection(selection) : printNodeSelection(selection);\n  });\n  res += '\\n selection' + selectionString;\n  res += '\\n\\n commands:';\n  if (commandsLog.length) {\n    for (const {\n      index,\n      type,\n      payload\n    } of commandsLog) {\n      res += `\\n   ${index}. { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;\n    }\n  } else {\n    res += '\\n   None dispatched.';\n  }\n  const {\n    version\n  } = editor.constructor;\n  res += `\\n\\n editor${version ? ` (v${version})` : ''}:`;\n  res += `\\n   namespace ${editorConfig.namespace}`;\n  if (compositionKey !== null) {\n    res += `\\n   compositionKey ${compositionKey}`;\n  }\n  res += `\\n   editable ${String(editable)}`;\n  return res;\n}\nfunction printRangeSelection(selection) {\n  let res = '';\n  const formatText = printFormatProperties(selection);\n  res += `: range ${formatText !== '' ? `{ ${formatText} }` : ''} ${selection.style !== '' ? `{ style: ${selection.style} } ` : ''}`;\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorOffset = anchor.offset;\n  const focusOffset = focus.offset;\n  res += `\\n   anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? 'null' : anchorOffset}, type: ${anchor.type} }`;\n  res += `\\n   focus { key: ${focus.key}, offset: ${focusOffset === null ? 'null' : focusOffset}, type: ${focus.type} }`;\n  return res;\n}\nfunction printNodeSelection(selection) {\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isNodeSelection)(selection)) {\n    return '';\n  }\n  return `: node\\n   [${Array.from(selection._nodes).join(', ')}]`;\n}\nfunction printTableSelection(selection) {\n  return `: table\\n   { table: ${selection.tableKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;\n}\nfunction visitTree(currentNode, visitor, indent = []) {\n  const childNodes = currentNode.getChildren();\n  const childNodesLength = childNodes.length;\n  childNodes.forEach((childNode, i) => {\n    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isElementNode)(childNode)) {\n      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));\n    }\n  });\n}\nfunction normalize(text, obfuscateText = false) {\n  const textToPrint = Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, 'g'), String(value)), text);\n  if (obfuscateText) {\n    return textToPrint.replace(/[^\\s]/g, '*');\n  }\n  return textToPrint;\n}\nfunction printNode(node, customPrintNode, obfuscateText = false) {\n  const customPrint = customPrintNode ? customPrintNode(node, obfuscateText) : undefined;\n  if (customPrint !== undefined && customPrint.length > 0) {\n    return customPrint;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isTextNode)(node)) {\n    const text = node.getTextContent();\n    const title = text.length === 0 ? '(empty)' : `\"${normalize(text, obfuscateText)}\"`;\n    const properties = printAllTextNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ((0,_lexical_link__WEBPACK_IMPORTED_MODULE_5__.$isLinkNode)(node)) {\n    const link = node.getURL();\n    const title = link.length === 0 ? '(empty)' : `\"${normalize(link, obfuscateText)}\"`;\n    const properties = printAllLinkNodeProperties(node);\n    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(' ').trim();\n  } else if ((0,_lexical_mark__WEBPACK_IMPORTED_MODULE_6__.$isMarkNode)(node)) {\n    return `ids: [ ${node.getIDs().join(', ')} ]`;\n  } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isParagraphNode)(node)) {\n    const formatText = printTextFormatProperties(node);\n    let paragraphData = formatText !== '' ? `{ ${formatText} }` : '';\n    paragraphData += node.__style ? `(${node.__style})` : '';\n    return paragraphData;\n  } else {\n    return '';\n  }\n}\nfunction printTextFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES_PARAGRAPH.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printAllTextNodeProperties(node) {\n  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node), printStateProperties(node)].filter(Boolean).join(', ');\n}\nfunction printAllLinkNodeProperties(node) {\n  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node), printStateProperties(node)].filter(Boolean).join(', ');\n}\nfunction printDetailProperties(nodeOrSelection) {\n  let str = DETAIL_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'detail: ' + str;\n  }\n  return str;\n}\nfunction printModeProperties(nodeOrSelection) {\n  let str = MODE_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'mode: ' + str;\n  }\n  return str;\n}\nfunction printFormatProperties(nodeOrSelection) {\n  let str = FORMAT_PREDICATES.map(predicate => predicate(nodeOrSelection)).filter(Boolean).join(', ').toLocaleLowerCase();\n  if (str !== '') {\n    str = 'format: ' + str;\n  }\n  return str;\n}\nfunction printTargetProperties(node) {\n  let str = node.getTarget();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'target: ' + str;\n  }\n  return str;\n}\nfunction printRelProperties(node) {\n  let str = node.getRel();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'rel: ' + str;\n  }\n  return str;\n}\nfunction printTitleProperties(node) {\n  let str = node.getTitle();\n  // TODO Fix nullish on LinkNode\n  if (str != null) {\n    str = 'title: ' + str;\n  }\n  return str;\n}\nfunction printStateProperties(node) {\n  if (!node.__state) {\n    return false;\n  }\n  const states = [];\n  for (const [stateType, value] of node.__state.knownState.entries()) {\n    if (stateType.isEqual(value, stateType.defaultValue)) {\n      continue;\n    }\n    const textValue = JSON.stringify(stateType.unparse(value));\n    states.push(`[${stateType.key}: ${textValue}]`);\n  }\n  let str = states.join(',');\n  if (str !== '') {\n    str = 'state: ' + str;\n  }\n  return str;\n}\nfunction $printSelectedCharsLine({\n  indent,\n  isSelected,\n  node,\n  nodeKeyDisplay,\n  selection,\n  typeDisplay\n}) {\n  // No selection or node is not selected.\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isTextNode)(node) || !(0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isRangeSelection)(selection) || !isSelected || (0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isElementNode)(node)) {\n    return '';\n  }\n\n  // No selected characters.\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  if (node.getTextContent() === '' || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {\n    return '';\n  }\n  const [start, end] = $getSelectionStartEnd(node, selection);\n  if (start === end) {\n    return '';\n  }\n  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;\n  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];\n  const unselectedChars = Array(start + 1).fill(' ');\n  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);\n  const paddingLength = typeDisplay.length + 2; // 1 for the space after + 1 for the double quote.\n\n  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(' ');\n  return [SYMBOLS.selectedLine, indentionChars.join(' '), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join('')].join(' ') + '\\n';\n}\nfunction printPrettyHTML(str) {\n  const div = document.createElement('div');\n  div.innerHTML = str.trim();\n  return prettifyHTML(div, 0).innerHTML;\n}\nfunction prettifyHTML(node, level) {\n  const indentBefore = new Array(level++ + 1).join('  ');\n  const indentAfter = new Array(level - 1).join('  ');\n  let textNode;\n  for (let i = 0; i < node.children.length; i++) {\n    textNode = document.createTextNode('\\n' + indentBefore);\n    node.insertBefore(textNode, node.children[i]);\n    prettifyHTML(node.children[i], level);\n    if (node.lastElementChild === node.children[i]) {\n      textNode = document.createTextNode('\\n' + indentAfter);\n      node.appendChild(textNode);\n    }\n  }\n  return node;\n}\nfunction $getSelectionStartEnd(node, selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_3__.$isNodeSelection)(selection) || anchorAndFocus === null) {\n    return [-1, -1];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  const textContent = node.getTextContent();\n  const textLength = textContent.length;\n  let start = -1;\n  let end = -1;\n\n  // Only one node is being selected.\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {\n      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];\n    } else if (node === anchorNode) {\n      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];\n    } else if (node === focusNode) {\n      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];\n    } else {\n      // Node is within selection but not the anchor nor focus.\n      [start, end] = [0, textLength];\n    }\n  }\n\n  // Account for non-single width characters.\n  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;\n  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst LARGE_EDITOR_STATE_SIZE = 1000;\nconst TreeView = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function TreeViewWrapped({\n  treeTypeButtonClassName,\n  timeTravelButtonClassName,\n  timeTravelPanelSliderClassName,\n  timeTravelPanelButtonClassName,\n  viewClassName,\n  timeTravelPanelClassName,\n  editorState,\n  setEditorState,\n  setEditorReadOnly,\n  generateContent,\n  commandsLog = []\n}, ref) {\n  const [timeStampedEditorStates, setTimeStampedEditorStates] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [content, setContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('');\n  const [timeTravelEnabled, setTimeTravelEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [showExportDOM, setShowExportDOM] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const playingIndexRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n  const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const [isPlaying, setIsPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [isLimited, setIsLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [showLimited, setShowLimited] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const lastEditorStateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  const lastCommandsLogRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n  const lastGenerationID = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(0);\n  const generateTree = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(exportDOM => {\n    const myID = ++lastGenerationID.current;\n    generateContent(exportDOM).then(treeText => {\n      if (myID === lastGenerationID.current) {\n        setContent(treeText);\n      }\n    }).catch(err => {\n      if (myID === lastGenerationID.current) {\n        setContent(`Error rendering tree: ${err.message}\\n\\nStack:\\n${err.stack}`);\n      }\n    });\n  }, [generateContent]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!showLimited && editorState._nodeMap.size > LARGE_EDITOR_STATE_SIZE) {\n      setIsLimited(true);\n      if (!showLimited) {\n        return;\n      }\n    }\n\n    // Update view when either editor state changes or new commands are logged\n    const shouldUpdate = lastEditorStateRef.current !== editorState || lastCommandsLogRef.current !== commandsLog;\n    if (shouldUpdate) {\n      // Check if it's a real editor state change\n      const isEditorStateChange = lastEditorStateRef.current !== editorState;\n      lastEditorStateRef.current = editorState;\n      lastCommandsLogRef.current = commandsLog;\n      generateTree(showExportDOM);\n\n      // Only record in time travel if there was an actual editor state change\n      if (!timeTravelEnabled && isEditorStateChange) {\n        setTimeStampedEditorStates(currentEditorStates => [...currentEditorStates, [Date.now(), editorState]]);\n      }\n    }\n  }, [editorState, generateTree, showExportDOM, showLimited, timeTravelEnabled, commandsLog]);\n  const totalEditorStates = timeStampedEditorStates.length;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (isPlaying) {\n      let timeoutId;\n      const play = () => {\n        const currentIndex = playingIndexRef.current;\n        if (currentIndex === totalEditorStates - 1) {\n          setIsPlaying(false);\n          return;\n        }\n        const currentTime = timeStampedEditorStates[currentIndex][0];\n        const nextTime = timeStampedEditorStates[currentIndex + 1][0];\n        const timeDiff = nextTime - currentTime;\n        timeoutId = setTimeout(() => {\n          playingIndexRef.current++;\n          const index = playingIndexRef.current;\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setEditorState(timeStampedEditorStates[index][1]);\n          play();\n        }, timeDiff);\n      };\n      play();\n      return () => {\n        clearTimeout(timeoutId);\n      };\n    }\n  }, [timeStampedEditorStates, isPlaying, totalEditorStates, setEditorState]);\n  const handleExportModeToggleClick = () => {\n    generateTree(!showExportDOM);\n    setShowExportDOM(!showExportDOM);\n  };\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", {\n    className: viewClassName,\n    children: [!showLimited && isLimited ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", {\n      style: {\n        padding: 20\n      },\n      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n        style: {\n          marginRight: 20\n        },\n        children: \"Detected large EditorState, this can impact debugging performance.\"\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        onClick: () => {\n          setShowLimited(true);\n        },\n        style: {\n          background: 'transparent',\n          border: '1px solid white',\n          color: 'white',\n          cursor: 'pointer',\n          padding: 5\n        },\n        children: \"Show full tree\"\n      })]\n    }) : null, !showLimited ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n      onClick: () => handleExportModeToggleClick(),\n      className: treeTypeButtonClassName,\n      type: \"button\",\n      children: showExportDOM ? 'Tree' : 'Export DOM'\n    }) : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n      onClick: () => {\n        setEditorReadOnly(true);\n        playingIndexRef.current = totalEditorStates - 1;\n        setTimeTravelEnabled(true);\n      },\n      className: timeTravelButtonClassName,\n      type: \"button\",\n      children: \"Time Travel\"\n    }), (showLimited || !isLimited) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"pre\", {\n      ref: ref,\n      children: content\n    }), timeTravelEnabled && (showLimited || !isLimited) && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"div\", {\n      className: timeTravelPanelClassName,\n      children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          if (playingIndexRef.current === totalEditorStates - 1) {\n            playingIndexRef.current = 1;\n          }\n          setIsPlaying(!isPlaying);\n        },\n        type: \"button\",\n        children: isPlaying ? 'Pause' : 'Play'\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"input\", {\n        className: timeTravelPanelSliderClassName,\n        ref: inputRef,\n        onChange: event => {\n          const editorStateIndex = Number(event.target.value);\n          const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];\n          if (timeStampedEditorState) {\n            playingIndexRef.current = editorStateIndex;\n            setEditorState(timeStampedEditorState[1]);\n          }\n        },\n        type: \"range\",\n        min: \"1\",\n        max: totalEditorStates - 1\n      }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n        className: timeTravelPanelButtonClassName,\n        onClick: () => {\n          setEditorReadOnly(false);\n          const index = timeStampedEditorStates.length - 1;\n          const timeStampedEditorState = timeStampedEditorStates[index];\n          setEditorState(timeStampedEditorState[1]);\n          const input = inputRef.current;\n          if (input !== null) {\n            input.value = String(index);\n          }\n          setTimeTravelEnabled(false);\n          setIsPlaying(false);\n        },\n        type: \"button\",\n        children: \"Exit\"\n      })]\n    })]\n  });\n});\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerLexicalCommandLogger(editor, setLoggedCommands) {\n  const unregisterCommandListeners = new Set();\n  let i = 0;\n  for (const [command] of editor._commands) {\n    unregisterCommandListeners.add(editor.registerCommand(command, payload => {\n      setLoggedCommands(state => {\n        i += 1;\n        const newState = [...state];\n        newState.push({\n          index: i,\n          payload,\n          type: command.type ? command.type : 'UNKNOWN'\n        });\n        if (newState.length > 10) {\n          newState.shift();\n        }\n        return newState;\n      });\n      return false;\n    }, lexical__WEBPACK_IMPORTED_MODULE_3__.COMMAND_PRIORITY_CRITICAL));\n  }\n  return () => unregisterCommandListeners.forEach(unregister => unregister());\n}\nfunction useLexicalCommandsLog(editor) {\n  const [loggedCommands, setLoggedCommands] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    return registerLexicalCommandLogger(editor, setLoggedCommands);\n  }, [editor]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => loggedCommands, [loggedCommands]);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZGV2dG9vbHMtY29yZS9MZXhpY2FsRGV2dG9vbHNDb3JlLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUQ7QUFDWDtBQUNBO0FBQ087QUFDOEc7QUFDM0U7QUFDeEM7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxRUFBc0I7QUFDekQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLGNBQWMsaURBQVE7QUFDdEI7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QyxFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBRSxnREFBZ0Q7QUFDaEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLDJDQUEyQywwREFBaUIsK0NBQStDLGlFQUFpQjtBQUM1SCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLE1BQU0sSUFBSSxRQUFRLEtBQUssYUFBYSxnRUFBZ0U7QUFDMUg7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUJBQXVCLGdCQUFnQixRQUFRLFFBQVE7QUFDdkQsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QixFQUFFLGFBQWEsUUFBUSxFQUFFLDRCQUE0QixTQUFTLG1CQUFtQixPQUFPO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sV0FBVyxZQUFZLDhDQUE4QyxVQUFVLGNBQWM7QUFDN0gsd0JBQXdCLE9BQU8sVUFBVSxZQUFZLDRDQUE0QyxVQUFVLGFBQWE7QUFDeEg7QUFDQTtBQUNBO0FBQ0EsT0FBTyx5REFBZ0I7QUFDdkI7QUFDQTtBQUNBLHlCQUF5Qix3Q0FBd0M7QUFDakU7QUFDQTtBQUNBLHlCQUF5QixTQUFTLG1CQUFtQixnQkFBZ0IscUJBQXFCLGVBQWUsc0JBQXNCO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQSxzREFBc0QsK0JBQStCO0FBQ3JGO0FBQ0EsZ0RBQWdELEVBQUUsYUFBYTtBQUMvRCxJQUFJLFNBQVMsMERBQVc7QUFDeEI7QUFDQSxzREFBc0QsK0JBQStCO0FBQ3JGO0FBQ0EsZ0RBQWdELEVBQUUsYUFBYTtBQUMvRCxJQUFJLFNBQVMsMERBQVc7QUFDeEIscUJBQXFCLDBCQUEwQjtBQUMvQyxJQUFJLFNBQVMseURBQWdCO0FBQzdCO0FBQ0EsK0NBQStDLEVBQUUsYUFBYTtBQUM5RCx3Q0FBd0MsYUFBYTtBQUNyRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWMsSUFBSSxVQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxPQUFPLG9EQUFXLFdBQVcsMERBQWlCLDhCQUE4Qix1REFBYztBQUMxRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx5REFBZ0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsaURBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnRUFBZ0UsK0NBQVE7QUFDeEUsZ0NBQWdDLCtDQUFRO0FBQ3hDLG9EQUFvRCwrQ0FBUTtBQUM1RCw0Q0FBNEMsK0NBQVE7QUFDcEQsMEJBQTBCLDZDQUFNO0FBQ2hDLG1CQUFtQiw2Q0FBTTtBQUN6QixvQ0FBb0MsK0NBQVE7QUFDNUMsb0NBQW9DLCtDQUFRO0FBQzVDLHdDQUF3QywrQ0FBUTtBQUNoRCw2QkFBNkIsNkNBQU07QUFDbkMsNkJBQTZCLDZDQUFNO0FBQ25DLDJCQUEyQiw2Q0FBTTtBQUNqQyx1QkFBdUIsa0RBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRDQUE0QyxZQUFZLGNBQWMsVUFBVTtBQUNoRjtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsdURBQUk7QUFDMUI7QUFDQSx3REFBd0QsdURBQUk7QUFDNUQ7QUFDQTtBQUNBLE9BQU87QUFDUCw4QkFBOEIsc0RBQUc7QUFDakM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU8sZ0JBQWdCLHNEQUFHO0FBQzFCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLEtBQUssc0NBQXNDLHNEQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxxR0FBcUcsc0RBQUc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQ0FBK0Msc0RBQUc7QUFDdkQ7QUFDQTtBQUNBLEtBQUssb0VBQW9FLHVEQUFJO0FBQzdFO0FBQ0EsOEJBQThCLHNEQUFHO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTyxnQkFBZ0Isc0RBQUc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU8sZ0JBQWdCLHNEQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLLEVBQUUsOERBQXlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLCtDQUFRO0FBQ3RELEVBQUUsZ0RBQVM7QUFDWDtBQUNBLEdBQUc7QUFDSCxTQUFTLDhDQUFPO0FBQ2hCOztBQUUwRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZGV2dG9vbHMtY29yZS9MZXhpY2FsRGV2dG9vbHNDb3JlLmRldi5tanM/NTA1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMgfSBmcm9tICdAbGV4aWNhbC9odG1sJztcbmltcG9ydCB7ICRpc0xpbmtOb2RlIH0gZnJvbSAnQGxleGljYWwvbGluayc7XG5pbXBvcnQgeyAkaXNNYXJrTm9kZSB9IGZyb20gJ0BsZXhpY2FsL21hcmsnO1xuaW1wb3J0IHsgJGlzVGFibGVTZWxlY3Rpb24gfSBmcm9tICdAbGV4aWNhbC90YWJsZSc7XG5pbXBvcnQgeyAkZ2V0U2VsZWN0aW9uLCAkZ2V0Um9vdCwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc05vZGVTZWxlY3Rpb24sICRpc0VsZW1lbnROb2RlLCAkaXNUZXh0Tm9kZSwgJGlzUGFyYWdyYXBoTm9kZSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeHMsIGpzeCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBOT05fU0lOR0xFX1dJRFRIX0NIQVJTX1JFUExBQ0VNRU5UID0gT2JqZWN0LmZyZWV6ZSh7XG4gICdcXHQnOiAnXFxcXHQnLFxuICAnXFxuJzogJ1xcXFxuJ1xufSk7XG5jb25zdCBOT05fU0lOR0xFX1dJRFRIX0NIQVJTX1JFR0VYID0gbmV3IFJlZ0V4cChPYmplY3Qua2V5cyhOT05fU0lOR0xFX1dJRFRIX0NIQVJTX1JFUExBQ0VNRU5UKS5qb2luKCd8JyksICdnJyk7XG5jb25zdCBTWU1CT0xTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGFuY2VzdG9ySGFzTmV4dFNpYmxpbmc6ICd8JyxcbiAgYW5jZXN0b3JJc0xhc3RDaGlsZDogJyAnLFxuICBoYXNOZXh0U2libGluZzogJ+KUnCcsXG4gIGlzTGFzdENoaWxkOiAn4pSUJyxcbiAgc2VsZWN0ZWRDaGFyOiAnXicsXG4gIHNlbGVjdGVkTGluZTogJz4nXG59KTtcbmNvbnN0IEZPUk1BVF9QUkVESUNBVEVTID0gW25vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ2JvbGQnKSAmJiAnQm9sZCcsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ2NvZGUnKSAmJiAnQ29kZScsIG5vZGUgPT4gbm9kZS5oYXNGb3JtYXQoJ2l0YWxpYycpICYmICdJdGFsaWMnLCBub2RlID0+IG5vZGUuaGFzRm9ybWF0KCdzdHJpa2V0aHJvdWdoJykgJiYgJ1N0cmlrZXRocm91Z2gnLCBub2RlID0+IG5vZGUuaGFzRm9ybWF0KCdzdWJzY3JpcHQnKSAmJiAnU3Vic2NyaXB0Jywgbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnc3VwZXJzY3JpcHQnKSAmJiAnU3VwZXJzY3JpcHQnLCBub2RlID0+IG5vZGUuaGFzRm9ybWF0KCd1bmRlcmxpbmUnKSAmJiAnVW5kZXJsaW5lJywgbm9kZSA9PiBub2RlLmhhc0Zvcm1hdCgnaGlnaGxpZ2h0JykgJiYgJ0hpZ2hsaWdodCddO1xuY29uc3QgRk9STUFUX1BSRURJQ0FURVNfUEFSQUdSQVBIID0gW25vZGUgPT4gbm9kZS5oYXNUZXh0Rm9ybWF0KCdib2xkJykgJiYgJ0JvbGQnLCBub2RlID0+IG5vZGUuaGFzVGV4dEZvcm1hdCgnY29kZScpICYmICdDb2RlJywgbm9kZSA9PiBub2RlLmhhc1RleHRGb3JtYXQoJ2l0YWxpYycpICYmICdJdGFsaWMnLCBub2RlID0+IG5vZGUuaGFzVGV4dEZvcm1hdCgnc3RyaWtldGhyb3VnaCcpICYmICdTdHJpa2V0aHJvdWdoJywgbm9kZSA9PiBub2RlLmhhc1RleHRGb3JtYXQoJ3N1YnNjcmlwdCcpICYmICdTdWJzY3JpcHQnLCBub2RlID0+IG5vZGUuaGFzVGV4dEZvcm1hdCgnc3VwZXJzY3JpcHQnKSAmJiAnU3VwZXJzY3JpcHQnLCBub2RlID0+IG5vZGUuaGFzVGV4dEZvcm1hdCgndW5kZXJsaW5lJykgJiYgJ1VuZGVybGluZScsIG5vZGUgPT4gbm9kZS5oYXNUZXh0Rm9ybWF0KCdoaWdobGlnaHQnKSAmJiAnSGlnaGxpZ2h0J107XG5jb25zdCBERVRBSUxfUFJFRElDQVRFUyA9IFtub2RlID0+IG5vZGUuaXNEaXJlY3Rpb25sZXNzKCkgJiYgJ0RpcmVjdGlvbmxlc3MnLCBub2RlID0+IG5vZGUuaXNVbm1lcmdlYWJsZSgpICYmICdVbm1lcmdlYWJsZSddO1xuY29uc3QgTU9ERV9QUkVESUNBVEVTID0gW25vZGUgPT4gbm9kZS5pc1Rva2VuKCkgJiYgJ1Rva2VuJywgbm9kZSA9PiBub2RlLmlzU2VnbWVudGVkKCkgJiYgJ1NlZ21lbnRlZCddO1xuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50KGVkaXRvciwgY29tbWFuZHNMb2csIGV4cG9ydERPTSwgY3VzdG9tUHJpbnROb2RlLCBvYmZ1c2NhdGVUZXh0ID0gZmFsc2UpIHtcbiAgY29uc3QgZWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgZWRpdG9yQ29uZmlnID0gZWRpdG9yLl9jb25maWc7XG4gIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gZWRpdG9yLl9jb21wb3NpdGlvbktleTtcbiAgY29uc3QgZWRpdGFibGUgPSBlZGl0b3IuX2VkaXRhYmxlO1xuICBpZiAoZXhwb3J0RE9NKSB7XG4gICAgbGV0IGh0bWxTdHJpbmcgPSAnJztcbiAgICBlZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHtcbiAgICAgIGh0bWxTdHJpbmcgPSBwcmludFByZXR0eUhUTUwoJGdlbmVyYXRlSHRtbEZyb21Ob2RlcyhlZGl0b3IpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaHRtbFN0cmluZztcbiAgfVxuICBsZXQgcmVzID0gJyByb290XFxuJztcbiAgY29uc3Qgc2VsZWN0aW9uU3RyaW5nID0gZWRpdG9yU3RhdGUucmVhZCgoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIHZpc2l0VHJlZSgkZ2V0Um9vdCgpLCAobm9kZSwgaW5kZW50KSA9PiB7XG4gICAgICBjb25zdCBub2RlS2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IG5vZGVLZXlEaXNwbGF5ID0gYCgke25vZGVLZXl9KWA7XG4gICAgICBjb25zdCB0eXBlRGlzcGxheSA9IG5vZGUuZ2V0VHlwZSgpIHx8ICcnO1xuICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IG5vZGUuaXNTZWxlY3RlZCgpO1xuICAgICAgcmVzICs9IGAke2lzU2VsZWN0ZWQgPyBTWU1CT0xTLnNlbGVjdGVkTGluZSA6ICcgJ30gJHtpbmRlbnQuam9pbignICcpfSAke25vZGVLZXlEaXNwbGF5fSAke3R5cGVEaXNwbGF5fSAke3ByaW50Tm9kZShub2RlLCBjdXN0b21QcmludE5vZGUsIG9iZnVzY2F0ZVRleHQpfVxcbmA7XG4gICAgICByZXMgKz0gJHByaW50U2VsZWN0ZWRDaGFyc0xpbmUoe1xuICAgICAgICBpbmRlbnQsXG4gICAgICAgIGlzU2VsZWN0ZWQsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIG5vZGVLZXlEaXNwbGF5LFxuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIHR5cGVEaXNwbGF5XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2VsZWN0aW9uID09PSBudWxsID8gJzogbnVsbCcgOiAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pID8gcHJpbnRSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIDogJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSA/IHByaW50VGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSA6IHByaW50Tm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICB9KTtcbiAgcmVzICs9ICdcXG4gc2VsZWN0aW9uJyArIHNlbGVjdGlvblN0cmluZztcbiAgcmVzICs9ICdcXG5cXG4gY29tbWFuZHM6JztcbiAgaWYgKGNvbW1hbmRzTG9nLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgaW5kZXgsXG4gICAgICB0eXBlLFxuICAgICAgcGF5bG9hZFxuICAgIH0gb2YgY29tbWFuZHNMb2cpIHtcbiAgICAgIHJlcyArPSBgXFxuICDilJQgJHtpbmRleH0uIHsgdHlwZTogJHt0eXBlfSwgcGF5bG9hZDogJHtwYXlsb2FkIGluc3RhbmNlb2YgRXZlbnQgPyBwYXlsb2FkLmNvbnN0cnVjdG9yLm5hbWUgOiBwYXlsb2FkfSB9YDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzICs9ICdcXG4gIOKUlCBOb25lIGRpc3BhdGNoZWQuJztcbiAgfVxuICBjb25zdCB7XG4gICAgdmVyc2lvblxuICB9ID0gZWRpdG9yLmNvbnN0cnVjdG9yO1xuICByZXMgKz0gYFxcblxcbiBlZGl0b3Ike3ZlcnNpb24gPyBgICh2JHt2ZXJzaW9ufSlgIDogJyd9OmA7XG4gIHJlcyArPSBgXFxuICDilJQgbmFtZXNwYWNlICR7ZWRpdG9yQ29uZmlnLm5hbWVzcGFjZX1gO1xuICBpZiAoY29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICByZXMgKz0gYFxcbiAg4pSUIGNvbXBvc2l0aW9uS2V5ICR7Y29tcG9zaXRpb25LZXl9YDtcbiAgfVxuICByZXMgKz0gYFxcbiAg4pSUIGVkaXRhYmxlICR7U3RyaW5nKGVkaXRhYmxlKX1gO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gcHJpbnRSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgbGV0IHJlcyA9ICcnO1xuICBjb25zdCBmb3JtYXRUZXh0ID0gcHJpbnRGb3JtYXRQcm9wZXJ0aWVzKHNlbGVjdGlvbik7XG4gIHJlcyArPSBgOiByYW5nZSAke2Zvcm1hdFRleHQgIT09ICcnID8gYHsgJHtmb3JtYXRUZXh0fSB9YCA6ICcnfSAke3NlbGVjdGlvbi5zdHlsZSAhPT0gJycgPyBgeyBzdHlsZTogJHtzZWxlY3Rpb24uc3R5bGV9IH0gYCA6ICcnfWA7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBmb2N1c09mZnNldCA9IGZvY3VzLm9mZnNldDtcbiAgcmVzICs9IGBcXG4gIOKUnCBhbmNob3IgeyBrZXk6ICR7YW5jaG9yLmtleX0sIG9mZnNldDogJHthbmNob3JPZmZzZXQgPT09IG51bGwgPyAnbnVsbCcgOiBhbmNob3JPZmZzZXR9LCB0eXBlOiAke2FuY2hvci50eXBlfSB9YDtcbiAgcmVzICs9IGBcXG4gIOKUlCBmb2N1cyB7IGtleTogJHtmb2N1cy5rZXl9LCBvZmZzZXQ6ICR7Zm9jdXNPZmZzZXQgPT09IG51bGwgPyAnbnVsbCcgOiBmb2N1c09mZnNldH0sIHR5cGU6ICR7Zm9jdXMudHlwZX0gfWA7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBwcmludE5vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIGlmICghJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBgOiBub2RlXFxuICDilJQgWyR7QXJyYXkuZnJvbShzZWxlY3Rpb24uX25vZGVzKS5qb2luKCcsICcpfV1gO1xufVxuZnVuY3Rpb24gcHJpbnRUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgcmV0dXJuIGA6IHRhYmxlXFxuICDilJQgeyB0YWJsZTogJHtzZWxlY3Rpb24udGFibGVLZXl9LCBhbmNob3JDZWxsOiAke3NlbGVjdGlvbi5hbmNob3Iua2V5fSwgZm9jdXNDZWxsOiAke3NlbGVjdGlvbi5mb2N1cy5rZXl9IH1gO1xufVxuZnVuY3Rpb24gdmlzaXRUcmVlKGN1cnJlbnROb2RlLCB2aXNpdG9yLCBpbmRlbnQgPSBbXSkge1xuICBjb25zdCBjaGlsZE5vZGVzID0gY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICBjaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkTm9kZSwgaSkgPT4ge1xuICAgIHZpc2l0b3IoY2hpbGROb2RlLCBpbmRlbnQuY29uY2F0KGkgPT09IGNoaWxkTm9kZXNMZW5ndGggLSAxID8gU1lNQk9MUy5pc0xhc3RDaGlsZCA6IFNZTUJPTFMuaGFzTmV4dFNpYmxpbmcpKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGROb2RlKSkge1xuICAgICAgdmlzaXRUcmVlKGNoaWxkTm9kZSwgdmlzaXRvciwgaW5kZW50LmNvbmNhdChpID09PSBjaGlsZE5vZGVzTGVuZ3RoIC0gMSA/IFNZTUJPTFMuYW5jZXN0b3JJc0xhc3RDaGlsZCA6IFNZTUJPTFMuYW5jZXN0b3JIYXNOZXh0U2libGluZykpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpemUodGV4dCwgb2JmdXNjYXRlVGV4dCA9IGZhbHNlKSB7XG4gIGNvbnN0IHRleHRUb1ByaW50ID0gT2JqZWN0LmVudHJpZXMoTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRVBMQUNFTUVOVCkucmVkdWNlKChhY2MsIFtrZXksIHZhbHVlXSkgPT4gYWNjLnJlcGxhY2UobmV3IFJlZ0V4cChrZXksICdnJyksIFN0cmluZyh2YWx1ZSkpLCB0ZXh0KTtcbiAgaWYgKG9iZnVzY2F0ZVRleHQpIHtcbiAgICByZXR1cm4gdGV4dFRvUHJpbnQucmVwbGFjZSgvW15cXHNdL2csICcqJyk7XG4gIH1cbiAgcmV0dXJuIHRleHRUb1ByaW50O1xufVxuZnVuY3Rpb24gcHJpbnROb2RlKG5vZGUsIGN1c3RvbVByaW50Tm9kZSwgb2JmdXNjYXRlVGV4dCA9IGZhbHNlKSB7XG4gIGNvbnN0IGN1c3RvbVByaW50ID0gY3VzdG9tUHJpbnROb2RlID8gY3VzdG9tUHJpbnROb2RlKG5vZGUsIG9iZnVzY2F0ZVRleHQpIDogdW5kZWZpbmVkO1xuICBpZiAoY3VzdG9tUHJpbnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b21QcmludC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGN1c3RvbVByaW50O1xuICB9XG4gIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3QgdGl0bGUgPSB0ZXh0Lmxlbmd0aCA9PT0gMCA/ICcoZW1wdHkpJyA6IGBcIiR7bm9ybWFsaXplKHRleHQsIG9iZnVzY2F0ZVRleHQpfVwiYDtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gcHJpbnRBbGxUZXh0Tm9kZVByb3BlcnRpZXMobm9kZSk7XG4gICAgcmV0dXJuIFt0aXRsZSwgcHJvcGVydGllcy5sZW5ndGggIT09IDAgPyBgeyAke3Byb3BlcnRpZXN9IH1gIDogbnVsbF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKS50cmltKCk7XG4gIH0gZWxzZSBpZiAoJGlzTGlua05vZGUobm9kZSkpIHtcbiAgICBjb25zdCBsaW5rID0gbm9kZS5nZXRVUkwoKTtcbiAgICBjb25zdCB0aXRsZSA9IGxpbmsubGVuZ3RoID09PSAwID8gJyhlbXB0eSknIDogYFwiJHtub3JtYWxpemUobGluaywgb2JmdXNjYXRlVGV4dCl9XCJgO1xuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBwcmludEFsbExpbmtOb2RlUHJvcGVydGllcyhub2RlKTtcbiAgICByZXR1cm4gW3RpdGxlLCBwcm9wZXJ0aWVzLmxlbmd0aCAhPT0gMCA/IGB7ICR7cHJvcGVydGllc30gfWAgOiBudWxsXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpLnRyaW0oKTtcbiAgfSBlbHNlIGlmICgkaXNNYXJrTm9kZShub2RlKSkge1xuICAgIHJldHVybiBgaWRzOiBbICR7bm9kZS5nZXRJRHMoKS5qb2luKCcsICcpfSBdYDtcbiAgfSBlbHNlIGlmICgkaXNQYXJhZ3JhcGhOb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgZm9ybWF0VGV4dCA9IHByaW50VGV4dEZvcm1hdFByb3BlcnRpZXMobm9kZSk7XG4gICAgbGV0IHBhcmFncmFwaERhdGEgPSBmb3JtYXRUZXh0ICE9PSAnJyA/IGB7ICR7Zm9ybWF0VGV4dH0gfWAgOiAnJztcbiAgICBwYXJhZ3JhcGhEYXRhICs9IG5vZGUuX19zdHlsZSA/IGAoJHtub2RlLl9fc3R5bGV9KWAgOiAnJztcbiAgICByZXR1cm4gcGFyYWdyYXBoRGF0YTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbmZ1bmN0aW9uIHByaW50VGV4dEZvcm1hdFByb3BlcnRpZXMobm9kZU9yU2VsZWN0aW9uKSB7XG4gIGxldCBzdHIgPSBGT1JNQVRfUFJFRElDQVRFU19QQVJBR1JBUEgubWFwKHByZWRpY2F0ZSA9PiBwcmVkaWNhdGUobm9kZU9yU2VsZWN0aW9uKSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgaWYgKHN0ciAhPT0gJycpIHtcbiAgICBzdHIgPSAnZm9ybWF0OiAnICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBwcmludEFsbFRleHROb2RlUHJvcGVydGllcyhub2RlKSB7XG4gIHJldHVybiBbcHJpbnRGb3JtYXRQcm9wZXJ0aWVzKG5vZGUpLCBwcmludERldGFpbFByb3BlcnRpZXMobm9kZSksIHByaW50TW9kZVByb3BlcnRpZXMobm9kZSksIHByaW50U3RhdGVQcm9wZXJ0aWVzKG5vZGUpXS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKTtcbn1cbmZ1bmN0aW9uIHByaW50QWxsTGlua05vZGVQcm9wZXJ0aWVzKG5vZGUpIHtcbiAgcmV0dXJuIFtwcmludFRhcmdldFByb3BlcnRpZXMobm9kZSksIHByaW50UmVsUHJvcGVydGllcyhub2RlKSwgcHJpbnRUaXRsZVByb3BlcnRpZXMobm9kZSksIHByaW50U3RhdGVQcm9wZXJ0aWVzKG5vZGUpXS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKTtcbn1cbmZ1bmN0aW9uIHByaW50RGV0YWlsUHJvcGVydGllcyhub2RlT3JTZWxlY3Rpb24pIHtcbiAgbGV0IHN0ciA9IERFVEFJTF9QUkVESUNBVEVTLm1hcChwcmVkaWNhdGUgPT4gcHJlZGljYXRlKG5vZGVPclNlbGVjdGlvbikpLmZpbHRlcihCb29sZWFuKS5qb2luKCcsICcpLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gIGlmIChzdHIgIT09ICcnKSB7XG4gICAgc3RyID0gJ2RldGFpbDogJyArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gcHJpbnRNb2RlUHJvcGVydGllcyhub2RlT3JTZWxlY3Rpb24pIHtcbiAgbGV0IHN0ciA9IE1PREVfUFJFRElDQVRFUy5tYXAocHJlZGljYXRlID0+IHByZWRpY2F0ZShub2RlT3JTZWxlY3Rpb24pKS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICBpZiAoc3RyICE9PSAnJykge1xuICAgIHN0ciA9ICdtb2RlOiAnICsgc3RyO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBwcmludEZvcm1hdFByb3BlcnRpZXMobm9kZU9yU2VsZWN0aW9uKSB7XG4gIGxldCBzdHIgPSBGT1JNQVRfUFJFRElDQVRFUy5tYXAocHJlZGljYXRlID0+IHByZWRpY2F0ZShub2RlT3JTZWxlY3Rpb24pKS5maWx0ZXIoQm9vbGVhbikuam9pbignLCAnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICBpZiAoc3RyICE9PSAnJykge1xuICAgIHN0ciA9ICdmb3JtYXQ6ICcgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHByaW50VGFyZ2V0UHJvcGVydGllcyhub2RlKSB7XG4gIGxldCBzdHIgPSBub2RlLmdldFRhcmdldCgpO1xuICAvLyBUT0RPIEZpeCBudWxsaXNoIG9uIExpbmtOb2RlXG4gIGlmIChzdHIgIT0gbnVsbCkge1xuICAgIHN0ciA9ICd0YXJnZXQ6ICcgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHByaW50UmVsUHJvcGVydGllcyhub2RlKSB7XG4gIGxldCBzdHIgPSBub2RlLmdldFJlbCgpO1xuICAvLyBUT0RPIEZpeCBudWxsaXNoIG9uIExpbmtOb2RlXG4gIGlmIChzdHIgIT0gbnVsbCkge1xuICAgIHN0ciA9ICdyZWw6ICcgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHByaW50VGl0bGVQcm9wZXJ0aWVzKG5vZGUpIHtcbiAgbGV0IHN0ciA9IG5vZGUuZ2V0VGl0bGUoKTtcbiAgLy8gVE9ETyBGaXggbnVsbGlzaCBvbiBMaW5rTm9kZVxuICBpZiAoc3RyICE9IG51bGwpIHtcbiAgICBzdHIgPSAndGl0bGU6ICcgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIHByaW50U3RhdGVQcm9wZXJ0aWVzKG5vZGUpIHtcbiAgaWYgKCFub2RlLl9fc3RhdGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc3RhdGVzID0gW107XG4gIGZvciAoY29uc3QgW3N0YXRlVHlwZSwgdmFsdWVdIG9mIG5vZGUuX19zdGF0ZS5rbm93blN0YXRlLmVudHJpZXMoKSkge1xuICAgIGlmIChzdGF0ZVR5cGUuaXNFcXVhbCh2YWx1ZSwgc3RhdGVUeXBlLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VmFsdWUgPSBKU09OLnN0cmluZ2lmeShzdGF0ZVR5cGUudW5wYXJzZSh2YWx1ZSkpO1xuICAgIHN0YXRlcy5wdXNoKGBbJHtzdGF0ZVR5cGUua2V5fTogJHt0ZXh0VmFsdWV9XWApO1xuICB9XG4gIGxldCBzdHIgPSBzdGF0ZXMuam9pbignLCcpO1xuICBpZiAoc3RyICE9PSAnJykge1xuICAgIHN0ciA9ICdzdGF0ZTogJyArIHN0cjtcbiAgfVxuICByZXR1cm4gc3RyO1xufVxuZnVuY3Rpb24gJHByaW50U2VsZWN0ZWRDaGFyc0xpbmUoe1xuICBpbmRlbnQsXG4gIGlzU2VsZWN0ZWQsXG4gIG5vZGUsXG4gIG5vZGVLZXlEaXNwbGF5LFxuICBzZWxlY3Rpb24sXG4gIHR5cGVEaXNwbGF5XG59KSB7XG4gIC8vIE5vIHNlbGVjdGlvbiBvciBub2RlIGlzIG5vdCBzZWxlY3RlZC5cbiAgaWYgKCEkaXNUZXh0Tm9kZShub2RlKSB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhaXNTZWxlY3RlZCB8fCAkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8vIE5vIHNlbGVjdGVkIGNoYXJhY3RlcnMuXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBpZiAobm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnJyB8fCBhbmNob3IuZ2V0Tm9kZSgpID09PSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpICYmIGFuY2hvci5vZmZzZXQgPT09IGZvY3VzLm9mZnNldCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBbc3RhcnQsIGVuZF0gPSAkZ2V0U2VsZWN0aW9uU3RhcnRFbmQobm9kZSwgc2VsZWN0aW9uKTtcbiAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uTGFzdEluZGVudCA9IGluZGVudFtpbmRlbnQubGVuZ3RoIC0gMV0gPT09IFNZTUJPTFMuaGFzTmV4dFNpYmxpbmcgPyBTWU1CT0xTLmFuY2VzdG9ySGFzTmV4dFNpYmxpbmcgOiBTWU1CT0xTLmFuY2VzdG9ySXNMYXN0Q2hpbGQ7XG4gIGNvbnN0IGluZGVudGlvbkNoYXJzID0gWy4uLmluZGVudC5zbGljZSgwLCBpbmRlbnQubGVuZ3RoIC0gMSksIHNlbGVjdGlvbkxhc3RJbmRlbnRdO1xuICBjb25zdCB1bnNlbGVjdGVkQ2hhcnMgPSBBcnJheShzdGFydCArIDEpLmZpbGwoJyAnKTtcbiAgY29uc3Qgc2VsZWN0ZWRDaGFycyA9IEFycmF5KGVuZCAtIHN0YXJ0KS5maWxsKFNZTUJPTFMuc2VsZWN0ZWRDaGFyKTtcbiAgY29uc3QgcGFkZGluZ0xlbmd0aCA9IHR5cGVEaXNwbGF5Lmxlbmd0aCArIDI7IC8vIDEgZm9yIHRoZSBzcGFjZSBhZnRlciArIDEgZm9yIHRoZSBkb3VibGUgcXVvdGUuXG5cbiAgY29uc3Qgbm9kZVByaW50U3BhY2VzID0gQXJyYXkobm9kZUtleURpc3BsYXkubGVuZ3RoICsgcGFkZGluZ0xlbmd0aCkuZmlsbCgnICcpO1xuICByZXR1cm4gW1NZTUJPTFMuc2VsZWN0ZWRMaW5lLCBpbmRlbnRpb25DaGFycy5qb2luKCcgJyksIFsuLi5ub2RlUHJpbnRTcGFjZXMsIC4uLnVuc2VsZWN0ZWRDaGFycywgLi4uc2VsZWN0ZWRDaGFyc10uam9pbignJyldLmpvaW4oJyAnKSArICdcXG4nO1xufVxuZnVuY3Rpb24gcHJpbnRQcmV0dHlIVE1MKHN0cikge1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlubmVySFRNTCA9IHN0ci50cmltKCk7XG4gIHJldHVybiBwcmV0dGlmeUhUTUwoZGl2LCAwKS5pbm5lckhUTUw7XG59XG5mdW5jdGlvbiBwcmV0dGlmeUhUTUwobm9kZSwgbGV2ZWwpIHtcbiAgY29uc3QgaW5kZW50QmVmb3JlID0gbmV3IEFycmF5KGxldmVsKysgKyAxKS5qb2luKCcgICcpO1xuICBjb25zdCBpbmRlbnRBZnRlciA9IG5ldyBBcnJheShsZXZlbCAtIDEpLmpvaW4oJyAgJyk7XG4gIGxldCB0ZXh0Tm9kZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFxuJyArIGluZGVudEJlZm9yZSk7XG4gICAgbm9kZS5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIG5vZGUuY2hpbGRyZW5baV0pO1xuICAgIHByZXR0aWZ5SFRNTChub2RlLmNoaWxkcmVuW2ldLCBsZXZlbCk7XG4gICAgaWYgKG5vZGUubGFzdEVsZW1lbnRDaGlsZCA9PT0gbm9kZS5jaGlsZHJlbltpXSkge1xuICAgICAgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFxuJyArIGluZGVudEFmdGVyKTtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uICRnZXRTZWxlY3Rpb25TdGFydEVuZChub2RlLCBzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBhbmNob3JBbmRGb2N1cyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbLTEsIC0xXTtcbiAgfVxuICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBhbmNob3JBbmRGb2N1cztcbiAgY29uc3QgdGV4dENvbnRlbnQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Q29udGVudC5sZW5ndGg7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG5cbiAgLy8gT25seSBvbmUgbm9kZSBpcyBiZWluZyBzZWxlY3RlZC5cbiAgaWYgKGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmIChhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgbm9kZSA9PT0gYW5jaG9yTm9kZSAmJiBhbmNob3Iub2Zmc2V0ICE9PSBmb2N1cy5vZmZzZXQpIHtcbiAgICAgIFtzdGFydCwgZW5kXSA9IGFuY2hvci5vZmZzZXQgPCBmb2N1cy5vZmZzZXQgPyBbYW5jaG9yLm9mZnNldCwgZm9jdXMub2Zmc2V0XSA6IFtmb2N1cy5vZmZzZXQsIGFuY2hvci5vZmZzZXRdO1xuICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSkge1xuICAgICAgW3N0YXJ0LCBlbmRdID0gYW5jaG9yTm9kZS5pc0JlZm9yZShmb2N1c05vZGUpID8gW2FuY2hvci5vZmZzZXQsIHRleHRMZW5ndGhdIDogWzAsIGFuY2hvci5vZmZzZXRdO1xuICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gZm9jdXNOb2RlKSB7XG4gICAgICBbc3RhcnQsIGVuZF0gPSBmb2N1c05vZGUuaXNCZWZvcmUoYW5jaG9yTm9kZSkgPyBbZm9jdXMub2Zmc2V0LCB0ZXh0TGVuZ3RoXSA6IFswLCBmb2N1cy5vZmZzZXRdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOb2RlIGlzIHdpdGhpbiBzZWxlY3Rpb24gYnV0IG5vdCB0aGUgYW5jaG9yIG5vciBmb2N1cy5cbiAgICAgIFtzdGFydCwgZW5kXSA9IFswLCB0ZXh0TGVuZ3RoXTtcbiAgICB9XG4gIH1cblxuICAvLyBBY2NvdW50IGZvciBub24tc2luZ2xlIHdpZHRoIGNoYXJhY3RlcnMuXG4gIGNvbnN0IG51bU5vblNpbmdsZVdpZHRoQ2hhckJlZm9yZVNlbGVjdGlvbiA9ICh0ZXh0Q29udGVudC5zbGljZSgwLCBzdGFydCkubWF0Y2goTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRUdFWCkgfHwgW10pLmxlbmd0aDtcbiAgY29uc3QgbnVtTm9uU2luZ2xlV2lkdGhDaGFySW5TZWxlY3Rpb24gPSAodGV4dENvbnRlbnQuc2xpY2Uoc3RhcnQsIGVuZCkubWF0Y2goTk9OX1NJTkdMRV9XSURUSF9DSEFSU19SRUdFWCkgfHwgW10pLmxlbmd0aDtcbiAgcmV0dXJuIFtzdGFydCArIG51bU5vblNpbmdsZVdpZHRoQ2hhckJlZm9yZVNlbGVjdGlvbiwgZW5kICsgbnVtTm9uU2luZ2xlV2lkdGhDaGFyQmVmb3JlU2VsZWN0aW9uICsgbnVtTm9uU2luZ2xlV2lkdGhDaGFySW5TZWxlY3Rpb25dO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IExBUkdFX0VESVRPUl9TVEFURV9TSVpFID0gMTAwMDtcbmNvbnN0IFRyZWVWaWV3ID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gVHJlZVZpZXdXcmFwcGVkKHtcbiAgdHJlZVR5cGVCdXR0b25DbGFzc05hbWUsXG4gIHRpbWVUcmF2ZWxCdXR0b25DbGFzc05hbWUsXG4gIHRpbWVUcmF2ZWxQYW5lbFNsaWRlckNsYXNzTmFtZSxcbiAgdGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lLFxuICB2aWV3Q2xhc3NOYW1lLFxuICB0aW1lVHJhdmVsUGFuZWxDbGFzc05hbWUsXG4gIGVkaXRvclN0YXRlLFxuICBzZXRFZGl0b3JTdGF0ZSxcbiAgc2V0RWRpdG9yUmVhZE9ubHksXG4gIGdlbmVyYXRlQ29udGVudCxcbiAgY29tbWFuZHNMb2cgPSBbXVxufSwgcmVmKSB7XG4gIGNvbnN0IFt0aW1lU3RhbXBlZEVkaXRvclN0YXRlcywgc2V0VGltZVN0YW1wZWRFZGl0b3JTdGF0ZXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbY29udGVudCwgc2V0Q29udGVudF0gPSB1c2VTdGF0ZSgnJyk7XG4gIGNvbnN0IFt0aW1lVHJhdmVsRW5hYmxlZCwgc2V0VGltZVRyYXZlbEVuYWJsZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc2hvd0V4cG9ydERPTSwgc2V0U2hvd0V4cG9ydERPTV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHBsYXlpbmdJbmRleFJlZiA9IHVzZVJlZigwKTtcbiAgY29uc3QgaW5wdXRSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IFtpc1BsYXlpbmcsIHNldElzUGxheWluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtpc0xpbWl0ZWQsIHNldElzTGltaXRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzaG93TGltaXRlZCwgc2V0U2hvd0xpbWl0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBsYXN0RWRpdG9yU3RhdGVSZWYgPSB1c2VSZWYoKTtcbiAgY29uc3QgbGFzdENvbW1hbmRzTG9nUmVmID0gdXNlUmVmKFtdKTtcbiAgY29uc3QgbGFzdEdlbmVyYXRpb25JRCA9IHVzZVJlZigwKTtcbiAgY29uc3QgZ2VuZXJhdGVUcmVlID0gdXNlQ2FsbGJhY2soZXhwb3J0RE9NID0+IHtcbiAgICBjb25zdCBteUlEID0gKytsYXN0R2VuZXJhdGlvbklELmN1cnJlbnQ7XG4gICAgZ2VuZXJhdGVDb250ZW50KGV4cG9ydERPTSkudGhlbih0cmVlVGV4dCA9PiB7XG4gICAgICBpZiAobXlJRCA9PT0gbGFzdEdlbmVyYXRpb25JRC5jdXJyZW50KSB7XG4gICAgICAgIHNldENvbnRlbnQodHJlZVRleHQpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICBpZiAobXlJRCA9PT0gbGFzdEdlbmVyYXRpb25JRC5jdXJyZW50KSB7XG4gICAgICAgIHNldENvbnRlbnQoYEVycm9yIHJlbmRlcmluZyB0cmVlOiAke2Vyci5tZXNzYWdlfVxcblxcblN0YWNrOlxcbiR7ZXJyLnN0YWNrfWApO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbZ2VuZXJhdGVDb250ZW50XSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFzaG93TGltaXRlZCAmJiBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5zaXplID4gTEFSR0VfRURJVE9SX1NUQVRFX1NJWkUpIHtcbiAgICAgIHNldElzTGltaXRlZCh0cnVlKTtcbiAgICAgIGlmICghc2hvd0xpbWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB2aWV3IHdoZW4gZWl0aGVyIGVkaXRvciBzdGF0ZSBjaGFuZ2VzIG9yIG5ldyBjb21tYW5kcyBhcmUgbG9nZ2VkXG4gICAgY29uc3Qgc2hvdWxkVXBkYXRlID0gbGFzdEVkaXRvclN0YXRlUmVmLmN1cnJlbnQgIT09IGVkaXRvclN0YXRlIHx8IGxhc3RDb21tYW5kc0xvZ1JlZi5jdXJyZW50ICE9PSBjb21tYW5kc0xvZztcbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGEgcmVhbCBlZGl0b3Igc3RhdGUgY2hhbmdlXG4gICAgICBjb25zdCBpc0VkaXRvclN0YXRlQ2hhbmdlID0gbGFzdEVkaXRvclN0YXRlUmVmLmN1cnJlbnQgIT09IGVkaXRvclN0YXRlO1xuICAgICAgbGFzdEVkaXRvclN0YXRlUmVmLmN1cnJlbnQgPSBlZGl0b3JTdGF0ZTtcbiAgICAgIGxhc3RDb21tYW5kc0xvZ1JlZi5jdXJyZW50ID0gY29tbWFuZHNMb2c7XG4gICAgICBnZW5lcmF0ZVRyZWUoc2hvd0V4cG9ydERPTSk7XG5cbiAgICAgIC8vIE9ubHkgcmVjb3JkIGluIHRpbWUgdHJhdmVsIGlmIHRoZXJlIHdhcyBhbiBhY3R1YWwgZWRpdG9yIHN0YXRlIGNoYW5nZVxuICAgICAgaWYgKCF0aW1lVHJhdmVsRW5hYmxlZCAmJiBpc0VkaXRvclN0YXRlQ2hhbmdlKSB7XG4gICAgICAgIHNldFRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzKGN1cnJlbnRFZGl0b3JTdGF0ZXMgPT4gWy4uLmN1cnJlbnRFZGl0b3JTdGF0ZXMsIFtEYXRlLm5vdygpLCBlZGl0b3JTdGF0ZV1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtlZGl0b3JTdGF0ZSwgZ2VuZXJhdGVUcmVlLCBzaG93RXhwb3J0RE9NLCBzaG93TGltaXRlZCwgdGltZVRyYXZlbEVuYWJsZWQsIGNvbW1hbmRzTG9nXSk7XG4gIGNvbnN0IHRvdGFsRWRpdG9yU3RhdGVzID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXMubGVuZ3RoO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChpc1BsYXlpbmcpIHtcbiAgICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgICBjb25zdCBwbGF5ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBwbGF5aW5nSW5kZXhSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gdG90YWxFZGl0b3JTdGF0ZXMgLSAxKSB7XG4gICAgICAgICAgc2V0SXNQbGF5aW5nKGZhbHNlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lU3RhbXBlZEVkaXRvclN0YXRlc1tjdXJyZW50SW5kZXhdWzBdO1xuICAgICAgICBjb25zdCBuZXh0VGltZSA9IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzW2N1cnJlbnRJbmRleCArIDFdWzBdO1xuICAgICAgICBjb25zdCB0aW1lRGlmZiA9IG5leHRUaW1lIC0gY3VycmVudFRpbWU7XG4gICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHBsYXlpbmdJbmRleFJlZi5jdXJyZW50Kys7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBwbGF5aW5nSW5kZXhSZWYuY3VycmVudDtcbiAgICAgICAgICBjb25zdCBpbnB1dCA9IGlucHV0UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgaWYgKGlucHV0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldEVkaXRvclN0YXRlKHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVzW2luZGV4XVsxXSk7XG4gICAgICAgICAgcGxheSgpO1xuICAgICAgICB9LCB0aW1lRGlmZik7XG4gICAgICB9O1xuICAgICAgcGxheSgpO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3RpbWVTdGFtcGVkRWRpdG9yU3RhdGVzLCBpc1BsYXlpbmcsIHRvdGFsRWRpdG9yU3RhdGVzLCBzZXRFZGl0b3JTdGF0ZV0pO1xuICBjb25zdCBoYW5kbGVFeHBvcnRNb2RlVG9nZ2xlQ2xpY2sgPSAoKSA9PiB7XG4gICAgZ2VuZXJhdGVUcmVlKCFzaG93RXhwb3J0RE9NKTtcbiAgICBzZXRTaG93RXhwb3J0RE9NKCFzaG93RXhwb3J0RE9NKTtcbiAgfTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hzKFwiZGl2XCIsIHtcbiAgICBjbGFzc05hbWU6IHZpZXdDbGFzc05hbWUsXG4gICAgY2hpbGRyZW46IFshc2hvd0xpbWl0ZWQgJiYgaXNMaW1pdGVkID8gLyojX19QVVJFX18qL2pzeHMoXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgcGFkZGluZzogMjBcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogWy8qI19fUFVSRV9fKi9qc3goXCJzcGFuXCIsIHtcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICBtYXJnaW5SaWdodDogMjBcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFwiRGV0ZWN0ZWQgbGFyZ2UgRWRpdG9yU3RhdGUsIHRoaXMgY2FuIGltcGFjdCBkZWJ1Z2dpbmcgcGVyZm9ybWFuY2UuXCJcbiAgICAgIH0pLCAvKiNfX1BVUkVfXyovanN4KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICAgIHNldFNob3dMaW1pdGVkKHRydWUpO1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGJhY2tncm91bmQ6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkIHdoaXRlJyxcbiAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICBwYWRkaW5nOiA1XG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuOiBcIlNob3cgZnVsbCB0cmVlXCJcbiAgICAgIH0pXVxuICAgIH0pIDogbnVsbCwgIXNob3dMaW1pdGVkID8gLyojX19QVVJFX18qL2pzeChcImJ1dHRvblwiLCB7XG4gICAgICBvbkNsaWNrOiAoKSA9PiBoYW5kbGVFeHBvcnRNb2RlVG9nZ2xlQ2xpY2soKSxcbiAgICAgIGNsYXNzTmFtZTogdHJlZVR5cGVCdXR0b25DbGFzc05hbWUsXG4gICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgY2hpbGRyZW46IHNob3dFeHBvcnRET00gPyAnVHJlZScgOiAnRXhwb3J0IERPTSdcbiAgICB9KSA6IG51bGwsICF0aW1lVHJhdmVsRW5hYmxlZCAmJiAoc2hvd0xpbWl0ZWQgfHwgIWlzTGltaXRlZCkgJiYgdG90YWxFZGl0b3JTdGF0ZXMgPiAyICYmIC8qI19fUFVSRV9fKi9qc3goXCJidXR0b25cIiwge1xuICAgICAgb25DbGljazogKCkgPT4ge1xuICAgICAgICBzZXRFZGl0b3JSZWFkT25seSh0cnVlKTtcbiAgICAgICAgcGxheWluZ0luZGV4UmVmLmN1cnJlbnQgPSB0b3RhbEVkaXRvclN0YXRlcyAtIDE7XG4gICAgICAgIHNldFRpbWVUcmF2ZWxFbmFibGVkKHRydWUpO1xuICAgICAgfSxcbiAgICAgIGNsYXNzTmFtZTogdGltZVRyYXZlbEJ1dHRvbkNsYXNzTmFtZSxcbiAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICBjaGlsZHJlbjogXCJUaW1lIFRyYXZlbFwiXG4gICAgfSksIChzaG93TGltaXRlZCB8fCAhaXNMaW1pdGVkKSAmJiAvKiNfX1BVUkVfXyovanN4KFwicHJlXCIsIHtcbiAgICAgIHJlZjogcmVmLFxuICAgICAgY2hpbGRyZW46IGNvbnRlbnRcbiAgICB9KSwgdGltZVRyYXZlbEVuYWJsZWQgJiYgKHNob3dMaW1pdGVkIHx8ICFpc0xpbWl0ZWQpICYmIC8qI19fUFVSRV9fKi9qc3hzKFwiZGl2XCIsIHtcbiAgICAgIGNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsQ2xhc3NOYW1lLFxuICAgICAgY2hpbGRyZW46IFsvKiNfX1BVUkVfXyovanN4KFwiYnV0dG9uXCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiB0aW1lVHJhdmVsUGFuZWxCdXR0b25DbGFzc05hbWUsXG4gICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICBpZiAocGxheWluZ0luZGV4UmVmLmN1cnJlbnQgPT09IHRvdGFsRWRpdG9yU3RhdGVzIC0gMSkge1xuICAgICAgICAgICAgcGxheWluZ0luZGV4UmVmLmN1cnJlbnQgPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXRJc1BsYXlpbmcoIWlzUGxheWluZyk7XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIGNoaWxkcmVuOiBpc1BsYXlpbmcgPyAnUGF1c2UnIDogJ1BsYXknXG4gICAgICB9KSwgLyojX19QVVJFX18qL2pzeChcImlucHV0XCIsIHtcbiAgICAgICAgY2xhc3NOYW1lOiB0aW1lVHJhdmVsUGFuZWxTbGlkZXJDbGFzc05hbWUsXG4gICAgICAgIHJlZjogaW5wdXRSZWYsXG4gICAgICAgIG9uQ2hhbmdlOiBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3QgZWRpdG9yU3RhdGVJbmRleCA9IE51bWJlcihldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IHRpbWVTdGFtcGVkRWRpdG9yU3RhdGUgPSB0aW1lU3RhbXBlZEVkaXRvclN0YXRlc1tlZGl0b3JTdGF0ZUluZGV4XTtcbiAgICAgICAgICBpZiAodGltZVN0YW1wZWRFZGl0b3JTdGF0ZSkge1xuICAgICAgICAgICAgcGxheWluZ0luZGV4UmVmLmN1cnJlbnQgPSBlZGl0b3JTdGF0ZUluZGV4O1xuICAgICAgICAgICAgc2V0RWRpdG9yU3RhdGUodGltZVN0YW1wZWRFZGl0b3JTdGF0ZVsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiBcInJhbmdlXCIsXG4gICAgICAgIG1pbjogXCIxXCIsXG4gICAgICAgIG1heDogdG90YWxFZGl0b3JTdGF0ZXMgLSAxXG4gICAgICB9KSwgLyojX19QVVJFX18qL2pzeChcImJ1dHRvblwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogdGltZVRyYXZlbFBhbmVsQnV0dG9uQ2xhc3NOYW1lLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgc2V0RWRpdG9yUmVhZE9ubHkoZmFsc2UpO1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICBjb25zdCB0aW1lU3RhbXBlZEVkaXRvclN0YXRlID0gdGltZVN0YW1wZWRFZGl0b3JTdGF0ZXNbaW5kZXhdO1xuICAgICAgICAgIHNldEVkaXRvclN0YXRlKHRpbWVTdGFtcGVkRWRpdG9yU3RhdGVbMV0pO1xuICAgICAgICAgIGNvbnN0IGlucHV0ID0gaW5wdXRSZWYuY3VycmVudDtcbiAgICAgICAgICBpZiAoaW5wdXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gU3RyaW5nKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0VGltZVRyYXZlbEVuYWJsZWQoZmFsc2UpO1xuICAgICAgICAgIHNldElzUGxheWluZyhmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgIGNoaWxkcmVuOiBcIkV4aXRcIlxuICAgICAgfSldXG4gICAgfSldXG4gIH0pO1xufSk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJMZXhpY2FsQ29tbWFuZExvZ2dlcihlZGl0b3IsIHNldExvZ2dlZENvbW1hbmRzKSB7XG4gIGNvbnN0IHVucmVnaXN0ZXJDb21tYW5kTGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoY29uc3QgW2NvbW1hbmRdIG9mIGVkaXRvci5fY29tbWFuZHMpIHtcbiAgICB1bnJlZ2lzdGVyQ29tbWFuZExpc3RlbmVycy5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChjb21tYW5kLCBwYXlsb2FkID0+IHtcbiAgICAgIHNldExvZ2dlZENvbW1hbmRzKHN0YXRlID0+IHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IFsuLi5zdGF0ZV07XG4gICAgICAgIG5ld1N0YXRlLnB1c2goe1xuICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgdHlwZTogY29tbWFuZC50eXBlID8gY29tbWFuZC50eXBlIDogJ1VOS05PV04nXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobmV3U3RhdGUubGVuZ3RoID4gMTApIHtcbiAgICAgICAgICBuZXdTdGF0ZS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgfVxuICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlckNvbW1hbmRMaXN0ZW5lcnMuZm9yRWFjaCh1bnJlZ2lzdGVyID0+IHVucmVnaXN0ZXIoKSk7XG59XG5mdW5jdGlvbiB1c2VMZXhpY2FsQ29tbWFuZHNMb2coZWRpdG9yKSB7XG4gIGNvbnN0IFtsb2dnZWRDb21tYW5kcywgc2V0TG9nZ2VkQ29tbWFuZHNdID0gdXNlU3RhdGUoW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiByZWdpc3RlckxleGljYWxDb21tYW5kTG9nZ2VyKGVkaXRvciwgc2V0TG9nZ2VkQ29tbWFuZHMpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiB1c2VNZW1vKCgpID0+IGxvZ2dlZENvbW1hbmRzLCBbbG9nZ2VkQ29tbWFuZHNdKTtcbn1cblxuZXhwb3J0IHsgVHJlZVZpZXcsIGdlbmVyYXRlQ29udGVudCwgcmVnaXN0ZXJMZXhpY2FsQ29tbWFuZExvZ2dlciwgdXNlTGV4aWNhbENvbW1hbmRzTG9nIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/dragon/LexicalDragon.dev.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@lexical/dragon/LexicalDragon.dev.mjs ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   registerDragonSupport: function() { return /* binding */ registerDragonSupport; }\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction registerDragonSupport(editor) {\n  const origin = window.location.origin;\n  const handler = event => {\n    if (event.origin !== origin) {\n      return;\n    }\n    const rootElement = editor.getRootElement();\n    if (document.activeElement !== rootElement) {\n      return;\n    }\n    const data = event.data;\n    if (typeof data === 'string') {\n      let parsedData;\n      try {\n        parsedData = JSON.parse(data);\n      } catch (e) {\n        return;\n      }\n      if (parsedData && parsedData.protocol === 'nuanria_messaging' && parsedData.type === 'request') {\n        const payload = parsedData.payload;\n        if (payload && payload.functionId === 'makeChanges') {\n          const args = payload.args;\n          if (args) {\n            const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;\n            editor.update(() => {\n              const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n              if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n                const anchor = selection.anchor;\n                let anchorNode = anchor.getNode();\n                let setSelStart = 0;\n                let setSelEnd = 0;\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n                  // set initial selection\n                  if (elementStart >= 0 && elementLength >= 0) {\n                    setSelStart = elementStart;\n                    setSelEnd = elementStart + elementLength;\n                    // If the offset is more than the end, make it the end\n                    selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                  }\n                }\n                if (setSelStart !== setSelEnd || text !== '') {\n                  selection.insertRawText(text);\n                  anchorNode = anchor.getNode();\n                }\n                if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n                  // set final selection\n                  setSelStart = selStart;\n                  setSelEnd = selStart + selLength;\n                  const anchorNodeTextLength = anchorNode.getTextContentSize();\n                  // If the offset is more than the end, make it the end\n                  setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;\n                  setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;\n                  selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);\n                }\n\n                // block the chrome extension from handling this event\n                event.stopImmediatePropagation();\n              }\n            });\n          }\n        }\n      }\n    }\n  };\n  window.addEventListener('message', handler, true);\n  return () => {\n    window.removeEventListener('message', handler, true);\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBYTtBQUM3QyxrQkFBa0IsMERBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvZHJhZ29uL0xleGljYWxEcmFnb24uZGV2Lm1qcz83N2FlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdldFNlbGVjdGlvbiwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc1RleHROb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gcmVnaXN0ZXJEcmFnb25TdXBwb3J0KGVkaXRvcikge1xuICBjb25zdCBvcmlnaW4gPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luO1xuICBjb25zdCBoYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5vcmlnaW4gIT09IG9yaWdpbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSByb290RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgcGFyc2VkRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZERhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkRGF0YSAmJiBwYXJzZWREYXRhLnByb3RvY29sID09PSAnbnVhbnJpYV9tZXNzYWdpbmcnICYmIHBhcnNlZERhdGEudHlwZSA9PT0gJ3JlcXVlc3QnKSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBwYXJzZWREYXRhLnBheWxvYWQ7XG4gICAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuZnVuY3Rpb25JZCA9PT0gJ21ha2VDaGFuZ2VzJykge1xuICAgICAgICAgIGNvbnN0IGFyZ3MgPSBwYXlsb2FkLmFyZ3M7XG4gICAgICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IFtlbGVtZW50U3RhcnQsIGVsZW1lbnRMZW5ndGgsIHRleHQsIHNlbFN0YXJ0LCBzZWxMZW5ndGgsIGZvcm1hdENvbW1hbmRdID0gYXJncztcbiAgICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgICAgICAgICBsZXQgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgICAgICAgbGV0IHNldFNlbFN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBsZXQgc2V0U2VsRW5kID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgIC8vIHNldCBpbml0aWFsIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRTdGFydCA+PSAwICYmIGVsZW1lbnRMZW5ndGggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IGVsZW1lbnRTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gZWxlbWVudFN0YXJ0ICsgZWxlbWVudExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9mZnNldCBpcyBtb3JlIHRoYW4gdGhlIGVuZCwgbWFrZSBpdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKGFuY2hvck5vZGUsIHNldFNlbFN0YXJ0LCBhbmNob3JOb2RlLCBzZXRTZWxFbmQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0U2VsU3RhcnQgIT09IHNldFNlbEVuZCB8fCB0ZXh0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmluc2VydFJhd1RleHQodGV4dCk7XG4gICAgICAgICAgICAgICAgICBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBzZXQgZmluYWwgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICBzZXRTZWxTdGFydCA9IHNlbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgc2V0U2VsRW5kID0gc2VsU3RhcnQgKyBzZWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhbmNob3JOb2RlVGV4dExlbmd0aCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2Zmc2V0IGlzIG1vcmUgdGhhbiB0aGUgZW5kLCBtYWtlIGl0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgIHNldFNlbFN0YXJ0ID0gc2V0U2VsU3RhcnQgPiBhbmNob3JOb2RlVGV4dExlbmd0aCA/IGFuY2hvck5vZGVUZXh0TGVuZ3RoIDogc2V0U2VsU3RhcnQ7XG4gICAgICAgICAgICAgICAgICBzZXRTZWxFbmQgPSBzZXRTZWxFbmQgPiBhbmNob3JOb2RlVGV4dExlbmd0aCA/IGFuY2hvck5vZGVUZXh0TGVuZ3RoIDogc2V0U2VsRW5kO1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2UoYW5jaG9yTm9kZSwgc2V0U2VsU3RhcnQsIGFuY2hvck5vZGUsIHNldFNlbEVuZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYmxvY2sgdGhlIGNocm9tZSBleHRlbnNpb24gZnJvbSBoYW5kbGluZyB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVyLCB0cnVlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZXIsIHRydWUpO1xuICB9O1xufVxuXG5leHBvcnQgeyByZWdpc3RlckRyYWdvblN1cHBvcnQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lexical/dragon/LexicalDragon.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/headless/LexicalHeadless.dev.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/headless/LexicalHeadless.dev.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHeadlessEditor: function() { return /* binding */ createHeadlessEditor; }\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * Generates a headless editor that allows lexical to be used without the need for a DOM, eg in Node.js.\n * Throws an error when unsupported methods are used.\n * @param editorConfig - The optional lexical editor configuration.\n * @returns - The configured headless editor.\n */\nfunction createHeadlessEditor(editorConfig) {\n  const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createEditor)(editorConfig);\n  editor._headless = true;\n  const unsupportedMethods = ['registerDecoratorListener', 'registerRootListener', 'registerMutationListener', 'getRootElement', 'setRootElement', 'getElementByKey', 'focus', 'blur'];\n  unsupportedMethods.forEach(method => {\n    editor[method] = () => {\n      throw new Error(`${method} is not supported in headless mode`);\n    };\n  });\n  return editor;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGVhZGxlc3MvTGV4aWNhbEhlYWRsZXNzLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxREFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oZWFkbGVzcy9MZXhpY2FsSGVhZGxlc3MuZGV2Lm1qcz8yZjhiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgY3JlYXRlRWRpdG9yIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGhlYWRsZXNzIGVkaXRvciB0aGF0IGFsbG93cyBsZXhpY2FsIHRvIGJlIHVzZWQgd2l0aG91dCB0aGUgbmVlZCBmb3IgYSBET00sIGVnIGluIE5vZGUuanMuXG4gKiBUaHJvd3MgYW4gZXJyb3Igd2hlbiB1bnN1cHBvcnRlZCBtZXRob2RzIGFyZSB1c2VkLlxuICogQHBhcmFtIGVkaXRvckNvbmZpZyAtIFRoZSBvcHRpb25hbCBsZXhpY2FsIGVkaXRvciBjb25maWd1cmF0aW9uLlxuICogQHJldHVybnMgLSBUaGUgY29uZmlndXJlZCBoZWFkbGVzcyBlZGl0b3IuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRsZXNzRWRpdG9yKGVkaXRvckNvbmZpZykge1xuICBjb25zdCBlZGl0b3IgPSBjcmVhdGVFZGl0b3IoZWRpdG9yQ29uZmlnKTtcbiAgZWRpdG9yLl9oZWFkbGVzcyA9IHRydWU7XG4gIGNvbnN0IHVuc3VwcG9ydGVkTWV0aG9kcyA9IFsncmVnaXN0ZXJEZWNvcmF0b3JMaXN0ZW5lcicsICdyZWdpc3RlclJvb3RMaXN0ZW5lcicsICdyZWdpc3Rlck11dGF0aW9uTGlzdGVuZXInLCAnZ2V0Um9vdEVsZW1lbnQnLCAnc2V0Um9vdEVsZW1lbnQnLCAnZ2V0RWxlbWVudEJ5S2V5JywgJ2ZvY3VzJywgJ2JsdXInXTtcbiAgdW5zdXBwb3J0ZWRNZXRob2RzLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICBlZGl0b3JbbWV0aG9kXSA9ICgpID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHttZXRob2R9IGlzIG5vdCBzdXBwb3J0ZWQgaW4gaGVhZGxlc3MgbW9kZWApO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gZWRpdG9yO1xufVxuXG5leHBvcnQgeyBjcmVhdGVIZWFkbGVzc0VkaXRvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lexical/headless/LexicalHeadless.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/history/LexicalHistory.dev.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@lexical/history/LexicalHistory.dev.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEmptyHistoryState: function() { return /* binding */ createEmptyHistoryState; },\n/* harmony export */   registerHistory: function() { return /* binding */ registerHistory; }\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n    if (dirtyElement !== undefined && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n  return nodes;\n}\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  }\n\n  // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n    return OTHER;\n  }\n  const nextDirtyNode = dirtyNodes[0];\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevDirtyNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n  if (prevText === nextText) {\n    return OTHER;\n  }\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n  return OTHER;\n}\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n  const nextNode = nextEditorState._nodeMap.get(key);\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  const isDeletingLine = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(nextSelection) && prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  if (!isDeletingLine && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextNode) && prevNode.__parent === nextNode.__parent) {\n    // This has the assumption that object key order won't change if the\n    // content did not change, which should normally be safe given\n    // the manner in which nodes and exportJSON are typically implemented.\n    return JSON.stringify(prevEditorState.read(() => prevNode.exportJSON())) === JSON.stringify(nextEditorState.read(() => nextNode.exportJSON()));\n  }\n  return false;\n}\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now();\n\n    // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n    if (tags.has(lexical__WEBPACK_IMPORTED_MODULE_0__.HISTORIC_TAG)) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has(lexical__WEBPACK_IMPORTED_MODULE_0__.HISTORY_PUSH_TAG);\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has(lexical__WEBPACK_IMPORTED_MODULE_0__.HISTORY_MERGE_TAG);\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      }\n\n      // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n      return HISTORY_PUSH;\n    })();\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n    }\n    const historyStateEntry = redoStack.pop();\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: lexical__WEBPACK_IMPORTED_MODULE_0__.HISTORIC_TAG\n      });\n    }\n  }\n}\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, true);\n    }\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    }\n    historyState.current = historyStateEntry || null;\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: lexical__WEBPACK_IMPORTED_MODULE_0__.HISTORIC_TAG\n      });\n    }\n  }\n}\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n      }\n      if (current !== null) {\n        undoStack.push({\n          ...current\n        });\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    }\n\n    // Else we merge\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n  const unregister = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  return unregister;\n}\n\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaGlzdG9yeS9MZXhpY2FsSGlzdG9yeS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0M7QUFDZ047O0FBRS9QO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLG9EQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLDBEQUFpQixvQkFBb0IsMERBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtR0FBbUcsb0RBQVc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxvREFBVyxvQkFBb0Isb0RBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMERBQWlCLG1CQUFtQiwwREFBaUI7QUFDOUUseUJBQXlCLG9EQUFXLGNBQWMsb0RBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsaURBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMscURBQWdCO0FBQ3pELGdGQUFnRixzREFBaUI7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpREFBWTtBQUN6QixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFEQUFnQjtBQUM3QztBQUNBO0FBQ0EsNkJBQTZCLHFEQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaURBQVk7QUFDekIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFEQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwrQkFBK0IscURBQWdCO0FBQy9DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFhLHdCQUF3QixpREFBWTtBQUN0RTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsaURBQVk7QUFDbEU7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHlEQUFvQjtBQUMxRTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsMERBQXFCO0FBQzNFO0FBQ0EsMkJBQTJCLHFEQUFnQjtBQUMzQywyQkFBMkIscURBQWdCO0FBQzNDO0FBQ0EsR0FBRyxFQUFFLDREQUF1QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9oaXN0b3J5L0xleGljYWxIaXN0b3J5LmRldi5tanM/YzM2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IG1lcmdlUmVnaXN0ZXIgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBVTkRPX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SLCBSRURPX0NPTU1BTkQsIENMRUFSX0VESVRPUl9DT01NQU5ELCBDTEVBUl9ISVNUT1JZX0NPTU1BTkQsIENBTl9SRURPX0NPTU1BTkQsIENBTl9VTkRPX0NPTU1BTkQsIEhJU1RPUklDX1RBRywgSElTVE9SWV9QVVNIX1RBRywgSElTVE9SWV9NRVJHRV9UQUcsICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNUZXh0Tm9kZSwgJGlzUm9vdE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBISVNUT1JZX01FUkdFID0gMDtcbmNvbnN0IEhJU1RPUllfUFVTSCA9IDE7XG5jb25zdCBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFID0gMjtcbmNvbnN0IE9USEVSID0gMDtcbmNvbnN0IENPTVBPU0lOR19DSEFSQUNURVIgPSAxO1xuY29uc3QgSU5TRVJUX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT04gPSAyO1xuY29uc3QgREVMRVRFX0NIQVJBQ1RFUl9CRUZPUkVfU0VMRUNUSU9OID0gMztcbmNvbnN0IERFTEVURV9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OID0gNDtcbmZ1bmN0aW9uIGdldERpcnR5Tm9kZXMoZWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzLCBkaXJ0eUVsZW1lbnRzKSB7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZm9yIChjb25zdCBkaXJ0eUxlYWZLZXkgb2YgZGlydHlMZWF2ZXMpIHtcbiAgICBjb25zdCBkaXJ0eUxlYWYgPSBub2RlTWFwLmdldChkaXJ0eUxlYWZLZXkpO1xuICAgIGlmIChkaXJ0eUxlYWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbm9kZXMucHVzaChkaXJ0eUxlYWYpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtkaXJ0eUVsZW1lbnRLZXksIGludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5XSBvZiBkaXJ0eUVsZW1lbnRzKSB7XG4gICAgaWYgKCFpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGRpcnR5RWxlbWVudCA9IG5vZGVNYXAuZ2V0KGRpcnR5RWxlbWVudEtleSk7XG4gICAgaWYgKGRpcnR5RWxlbWVudCAhPT0gdW5kZWZpbmVkICYmICEkaXNSb290Tm9kZShkaXJ0eUVsZW1lbnQpKSB7XG4gICAgICBub2Rlcy5wdXNoKGRpcnR5RWxlbWVudCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGdldENoYW5nZVR5cGUocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGRpcnR5TGVhdmVzU2V0LCBkaXJ0eUVsZW1lbnRzU2V0LCBpc0NvbXBvc2luZykge1xuICBpZiAocHJldkVkaXRvclN0YXRlID09PSBudWxsIHx8IGRpcnR5TGVhdmVzU2V0LnNpemUgPT09IDAgJiYgZGlydHlFbGVtZW50c1NldC5zaXplID09PSAwICYmICFpc0NvbXBvc2luZykge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBwcmV2RWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIENPTVBPU0lOR19DSEFSQUNURVI7XG4gIH1cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgfHwgIXByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhbmV4dFNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgcmV0dXJuIE9USEVSO1xuICB9XG4gIGNvbnN0IGRpcnR5Tm9kZXMgPSBnZXREaXJ0eU5vZGVzKG5leHRFZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXNTZXQsIGRpcnR5RWxlbWVudHNTZXQpO1xuICBpZiAoZGlydHlOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cblxuICAvLyBDYXRjaGluZyB0aGUgY2FzZSB3aGVuIGluc2VydGluZyBuZXcgdGV4dCBub2RlIGludG8gYW4gZWxlbWVudCAoZS5nLiBmaXJzdCBjaGFyIGluIHBhcmFncmFwaC9saXN0KSxcbiAgLy8gb3IgYWZ0ZXIgZXhpc3Rpbmcgbm9kZS5cbiAgaWYgKGRpcnR5Tm9kZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG5leHROb2RlTWFwID0gbmV4dEVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAgIGNvbnN0IG5leHRBbmNob3JOb2RlID0gbmV4dE5vZGVNYXAuZ2V0KG5leHRTZWxlY3Rpb24uYW5jaG9yLmtleSk7XG4gICAgY29uc3QgcHJldkFuY2hvck5vZGUgPSBuZXh0Tm9kZU1hcC5nZXQocHJldlNlbGVjdGlvbi5hbmNob3Iua2V5KTtcbiAgICBpZiAobmV4dEFuY2hvck5vZGUgJiYgcHJldkFuY2hvck5vZGUgJiYgIXByZXZFZGl0b3JTdGF0ZS5fbm9kZU1hcC5oYXMobmV4dEFuY2hvck5vZGUuX19rZXkpICYmICRpc1RleHROb2RlKG5leHRBbmNob3JOb2RlKSAmJiBuZXh0QW5jaG9yTm9kZS5fX3RleHQubGVuZ3RoID09PSAxICYmIG5leHRTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMSkge1xuICAgICAgcmV0dXJuIElOU0VSVF9DSEFSQUNURVJfQUZURVJfU0VMRUNUSU9OO1xuICAgIH1cbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgbmV4dERpcnR5Tm9kZSA9IGRpcnR5Tm9kZXNbMF07XG4gIGNvbnN0IHByZXZEaXJ0eU5vZGUgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXAuZ2V0KG5leHREaXJ0eU5vZGUuX19rZXkpO1xuICBpZiAoISRpc1RleHROb2RlKHByZXZEaXJ0eU5vZGUpIHx8ICEkaXNUZXh0Tm9kZShuZXh0RGlydHlOb2RlKSB8fCBwcmV2RGlydHlOb2RlLl9fbW9kZSAhPT0gbmV4dERpcnR5Tm9kZS5fX21vZGUpIHtcbiAgICByZXR1cm4gT1RIRVI7XG4gIH1cbiAgY29uc3QgcHJldlRleHQgPSBwcmV2RGlydHlOb2RlLl9fdGV4dDtcbiAgY29uc3QgbmV4dFRleHQgPSBuZXh0RGlydHlOb2RlLl9fdGV4dDtcbiAgaWYgKHByZXZUZXh0ID09PSBuZXh0VGV4dCkge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0QW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IHByZXZBbmNob3IgPSBwcmV2U2VsZWN0aW9uLmFuY2hvcjtcbiAgaWYgKG5leHRBbmNob3Iua2V5ICE9PSBwcmV2QW5jaG9yLmtleSB8fCBuZXh0QW5jaG9yLnR5cGUgIT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBPVEhFUjtcbiAgfVxuICBjb25zdCBuZXh0QW5jaG9yT2Zmc2V0ID0gbmV4dEFuY2hvci5vZmZzZXQ7XG4gIGNvbnN0IHByZXZBbmNob3JPZmZzZXQgPSBwcmV2QW5jaG9yLm9mZnNldDtcbiAgY29uc3QgdGV4dERpZmYgPSBuZXh0VGV4dC5sZW5ndGggLSBwcmV2VGV4dC5sZW5ndGg7XG4gIGlmICh0ZXh0RGlmZiA9PT0gMSAmJiBwcmV2QW5jaG9yT2Zmc2V0ID09PSBuZXh0QW5jaG9yT2Zmc2V0IC0gMSkge1xuICAgIHJldHVybiBJTlNFUlRfQ0hBUkFDVEVSX0FGVEVSX1NFTEVDVElPTjtcbiAgfVxuICBpZiAodGV4dERpZmYgPT09IC0xICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQgKyAxKSB7XG4gICAgcmV0dXJuIERFTEVURV9DSEFSQUNURVJfQkVGT1JFX1NFTEVDVElPTjtcbiAgfVxuICBpZiAodGV4dERpZmYgPT09IC0xICYmIHByZXZBbmNob3JPZmZzZXQgPT09IG5leHRBbmNob3JPZmZzZXQpIHtcbiAgICByZXR1cm4gREVMRVRFX0NIQVJBQ1RFUl9BRlRFUl9TRUxFQ1RJT047XG4gIH1cbiAgcmV0dXJuIE9USEVSO1xufVxuZnVuY3Rpb24gaXNUZXh0Tm9kZVVuY2hhbmdlZChrZXksIHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IHByZXZOb2RlID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwLmdldChrZXkpO1xuICBjb25zdCBuZXh0Tm9kZSA9IG5leHRFZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoa2V5KTtcbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IGlzRGVsZXRpbmdMaW5lID0gJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHByZXZTZWxlY3Rpb24uZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIG5leHRTZWxlY3Rpb24uYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJiBuZXh0U2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICd0ZXh0JztcbiAgaWYgKCFpc0RlbGV0aW5nTGluZSAmJiAkaXNUZXh0Tm9kZShwcmV2Tm9kZSkgJiYgJGlzVGV4dE5vZGUobmV4dE5vZGUpICYmIHByZXZOb2RlLl9fcGFyZW50ID09PSBuZXh0Tm9kZS5fX3BhcmVudCkge1xuICAgIC8vIFRoaXMgaGFzIHRoZSBhc3N1bXB0aW9uIHRoYXQgb2JqZWN0IGtleSBvcmRlciB3b24ndCBjaGFuZ2UgaWYgdGhlXG4gICAgLy8gY29udGVudCBkaWQgbm90IGNoYW5nZSwgd2hpY2ggc2hvdWxkIG5vcm1hbGx5IGJlIHNhZmUgZ2l2ZW5cbiAgICAvLyB0aGUgbWFubmVyIGluIHdoaWNoIG5vZGVzIGFuZCBleHBvcnRKU09OIGFyZSB0eXBpY2FsbHkgaW1wbGVtZW50ZWQuXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHByZXZFZGl0b3JTdGF0ZS5yZWFkKCgpID0+IHByZXZOb2RlLmV4cG9ydEpTT04oKSkpID09PSBKU09OLnN0cmluZ2lmeShuZXh0RWRpdG9yU3RhdGUucmVhZCgoKSA9PiBuZXh0Tm9kZS5leHBvcnRKU09OKCkpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KSB7XG4gIGxldCBwcmV2Q2hhbmdlVGltZSA9IERhdGUubm93KCk7XG4gIGxldCBwcmV2Q2hhbmdlVHlwZSA9IE9USEVSO1xuICByZXR1cm4gKHByZXZFZGl0b3JTdGF0ZSwgbmV4dEVkaXRvclN0YXRlLCBjdXJyZW50SGlzdG9yeUVudHJ5LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncykgPT4ge1xuICAgIGNvbnN0IGNoYW5nZVRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gSWYgYXBwbHlpbmcgY2hhbmdlcyBmcm9tIGhpc3Rvcnkgc3RhY2sgdGhlcmUncyBubyBuZWVkXG4gICAgLy8gdG8gcnVuIGhpc3RvcnkgbG9naWMgYWdhaW4sIGFzIGhpc3RvcnkgZW50cmllcyBhbHJlYWR5IGNhbGN1bGF0ZWRcbiAgICBpZiAodGFncy5oYXMoSElTVE9SSUNfVEFHKSkge1xuICAgICAgcHJldkNoYW5nZVR5cGUgPSBPVEhFUjtcbiAgICAgIHByZXZDaGFuZ2VUaW1lID0gY2hhbmdlVGltZTtcbiAgICAgIHJldHVybiBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VUeXBlID0gZ2V0Q2hhbmdlVHlwZShwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMsIGVkaXRvci5pc0NvbXBvc2luZygpKTtcbiAgICBjb25zdCBtZXJnZUFjdGlvbiA9ICgoKSA9PiB7XG4gICAgICBjb25zdCBpc1NhbWVFZGl0b3IgPSBjdXJyZW50SGlzdG9yeUVudHJ5ID09PSBudWxsIHx8IGN1cnJlbnRIaXN0b3J5RW50cnkuZWRpdG9yID09PSBlZGl0b3I7XG4gICAgICBjb25zdCBzaG91bGRQdXNoSGlzdG9yeSA9IHRhZ3MuaGFzKEhJU1RPUllfUFVTSF9UQUcpO1xuICAgICAgY29uc3Qgc2hvdWxkTWVyZ2VIaXN0b3J5ID0gIXNob3VsZFB1c2hIaXN0b3J5ICYmIGlzU2FtZUVkaXRvciAmJiB0YWdzLmhhcyhISVNUT1JZX01FUkdFX1RBRyk7XG4gICAgICBpZiAoc2hvdWxkTWVyZ2VIaXN0b3J5KSB7XG4gICAgICAgIHJldHVybiBISVNUT1JZX01FUkdFO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9QVVNIO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgICBjb25zdCBoYXNEaXJ0eU5vZGVzID0gZGlydHlMZWF2ZXMuc2l6ZSA+IDAgfHwgZGlydHlFbGVtZW50cy5zaXplID4gMDtcbiAgICAgIGlmICghaGFzRGlydHlOb2Rlcykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIEhJU1RPUllfTUVSR0U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERJU0NBUkRfSElTVE9SWV9DQU5ESURBVEU7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkUHVzaEhpc3RvcnkgPT09IGZhbHNlICYmIGNoYW5nZVR5cGUgIT09IE9USEVSICYmIGNoYW5nZVR5cGUgPT09IHByZXZDaGFuZ2VUeXBlICYmIGNoYW5nZVRpbWUgPCBwcmV2Q2hhbmdlVGltZSArIGRlbGF5ICYmIGlzU2FtZUVkaXRvcikge1xuICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgIH1cblxuICAgICAgLy8gQSBzaW5nbGUgbm9kZSBtaWdodCBoYXZlIGJlZW4gbWFya2VkIGFzIGRpcnR5LCBidXQgbm90IGhhdmUgY2hhbmdlZFxuICAgICAgLy8gZHVlIHRvIHNvbWUgbm9kZSB0cmFuc2Zvcm0gcmV2ZXJ0aW5nIHRoZSBjaGFuZ2UuXG4gICAgICBpZiAoZGlydHlMZWF2ZXMuc2l6ZSA9PT0gMSkge1xuICAgICAgICBjb25zdCBkaXJ0eUxlYWZLZXkgPSBBcnJheS5mcm9tKGRpcnR5TGVhdmVzKVswXTtcbiAgICAgICAgaWYgKGlzVGV4dE5vZGVVbmNoYW5nZWQoZGlydHlMZWFmS2V5LCBwcmV2RWRpdG9yU3RhdGUsIG5leHRFZGl0b3JTdGF0ZSkpIHtcbiAgICAgICAgICByZXR1cm4gSElTVE9SWV9NRVJHRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIEhJU1RPUllfUFVTSDtcbiAgICB9KSgpO1xuICAgIHByZXZDaGFuZ2VUaW1lID0gY2hhbmdlVGltZTtcbiAgICBwcmV2Q2hhbmdlVHlwZSA9IGNoYW5nZVR5cGU7XG4gICAgcmV0dXJuIG1lcmdlQWN0aW9uO1xuICB9O1xufVxuZnVuY3Rpb24gcmVkbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSkge1xuICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICBjb25zdCB1bmRvU3RhY2sgPSBoaXN0b3J5U3RhdGUudW5kb1N0YWNrO1xuICBpZiAocmVkb1N0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdW5kb1N0YWNrLnB1c2goY3VycmVudCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKENBTl9VTkRPX0NPTU1BTkQsIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBoaXN0b3J5U3RhdGVFbnRyeSA9IHJlZG9TdGFjay5wb3AoKTtcbiAgICBpZiAocmVkb1N0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgfVxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0gaGlzdG9yeVN0YXRlRW50cnkgfHwgbnVsbDtcbiAgICBpZiAoaGlzdG9yeVN0YXRlRW50cnkpIHtcbiAgICAgIGhpc3RvcnlTdGF0ZUVudHJ5LmVkaXRvci5zZXRFZGl0b3JTdGF0ZShoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3JTdGF0ZSwge1xuICAgICAgICB0YWc6IEhJU1RPUklDX1RBR1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1bmRvKGVkaXRvciwgaGlzdG9yeVN0YXRlKSB7XG4gIGNvbnN0IHJlZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2s7XG4gIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG4gIGNvbnN0IHVuZG9TdGFja0xlbmd0aCA9IHVuZG9TdGFjay5sZW5ndGg7XG4gIGlmICh1bmRvU3RhY2tMZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBjdXJyZW50ID0gaGlzdG9yeVN0YXRlLmN1cnJlbnQ7XG4gICAgY29uc3QgaGlzdG9yeVN0YXRlRW50cnkgPSB1bmRvU3RhY2sucG9wKCk7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHJlZG9TdGFjay5wdXNoKGN1cnJlbnQpO1xuICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKHVuZG9TdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1VORE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIH1cbiAgICBoaXN0b3J5U3RhdGUuY3VycmVudCA9IGhpc3RvcnlTdGF0ZUVudHJ5IHx8IG51bGw7XG4gICAgaWYgKGhpc3RvcnlTdGF0ZUVudHJ5KSB7XG4gICAgICBoaXN0b3J5U3RhdGVFbnRyeS5lZGl0b3Iuc2V0RWRpdG9yU3RhdGUoaGlzdG9yeVN0YXRlRW50cnkuZWRpdG9yU3RhdGUsIHtcbiAgICAgICAgdGFnOiBISVNUT1JJQ19UQUdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2xlYXJIaXN0b3J5KGhpc3RvcnlTdGF0ZSkge1xuICBoaXN0b3J5U3RhdGUudW5kb1N0YWNrID0gW107XG4gIGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2sgPSBbXTtcbiAgaGlzdG9yeVN0YXRlLmN1cnJlbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBuZWNlc3NhcnkgbGlzdGVuZXJzIHRvIG1hbmFnZSB1bmRvL3JlZG8gaGlzdG9yeSBzdGFjayBhbmQgcmVsYXRlZCBlZGl0b3IgY29tbWFuZHMuXG4gKiBJdCByZXR1cm5zIGB1bnJlZ2lzdGVyYCBjYWxsYmFjayB0aGF0IGNsZWFucyB1cCBhbGwgbGlzdGVuZXJzIGFuZCBzaG91bGQgYmUgY2FsbGVkIG9uIGVkaXRvciB1bm1vdW50LlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBoaXN0b3J5U3RhdGUgLSBUaGUgaGlzdG9yeSBzdGF0ZSwgY29udGFpbmluZyB0aGUgY3VycmVudCBzdGF0ZSBhbmQgdGhlIHVuZG8vcmVkbyBzdGFjay5cbiAqIEBwYXJhbSBkZWxheSAtIFRoZSB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoZSBlZGl0b3Igc2hvdWxkIGRlbGF5IGdlbmVyYXRpbmcgYSBuZXcgaGlzdG9yeSBzdGFjayxcbiAqIGluc3RlYWQgb2YgbWVyZ2luZyB0aGUgY3VycmVudCBjaGFuZ2VzIHdpdGggdGhlIGN1cnJlbnQgc3RhY2suXG4gKiBAcmV0dXJucyBUaGUgbGlzdGVuZXJzIGNsZWFudXAgY2FsbGJhY2sgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVySGlzdG9yeShlZGl0b3IsIGhpc3RvcnlTdGF0ZSwgZGVsYXkpIHtcbiAgY29uc3QgZ2V0TWVyZ2VBY3Rpb24gPSBjcmVhdGVNZXJnZUFjdGlvbkdldHRlcihlZGl0b3IsIGRlbGF5KTtcbiAgY29uc3QgYXBwbHlDaGFuZ2UgPSAoe1xuICAgIGVkaXRvclN0YXRlLFxuICAgIHByZXZFZGl0b3JTdGF0ZSxcbiAgICBkaXJ0eUxlYXZlcyxcbiAgICBkaXJ0eUVsZW1lbnRzLFxuICAgIHRhZ3NcbiAgfSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnQgPSBoaXN0b3J5U3RhdGUuY3VycmVudDtcbiAgICBjb25zdCByZWRvU3RhY2sgPSBoaXN0b3J5U3RhdGUucmVkb1N0YWNrO1xuICAgIGNvbnN0IHVuZG9TdGFjayA9IGhpc3RvcnlTdGF0ZS51bmRvU3RhY2s7XG4gICAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gY3VycmVudCA9PT0gbnVsbCA/IG51bGwgOiBjdXJyZW50LmVkaXRvclN0YXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGVkaXRvclN0YXRlID09PSBjdXJyZW50RWRpdG9yU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VBY3Rpb24gPSBnZXRNZXJnZUFjdGlvbihwcmV2RWRpdG9yU3RhdGUsIGVkaXRvclN0YXRlLCBjdXJyZW50LCBkaXJ0eUxlYXZlcywgZGlydHlFbGVtZW50cywgdGFncyk7XG4gICAgaWYgKG1lcmdlQWN0aW9uID09PSBISVNUT1JZX1BVU0gpIHtcbiAgICAgIGlmIChyZWRvU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGhpc3RvcnlTdGF0ZS5yZWRvU3RhY2sgPSBbXTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fUkVET19DT01NQU5ELCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB1bmRvU3RhY2sucHVzaCh7XG4gICAgICAgICAgLi4uY3VycmVudFxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChDQU5fVU5ET19DT01NQU5ELCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1lcmdlQWN0aW9uID09PSBESVNDQVJEX0hJU1RPUllfQ0FORElEQVRFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRWxzZSB3ZSBtZXJnZVxuICAgIGhpc3RvcnlTdGF0ZS5jdXJyZW50ID0ge1xuICAgICAgZWRpdG9yLFxuICAgICAgZWRpdG9yU3RhdGVcbiAgICB9O1xuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVyID0gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFVORE9fQ09NTUFORCwgKCkgPT4ge1xuICAgIHVuZG8oZWRpdG9yLCBoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoUkVET19DT01NQU5ELCAoKSA9PiB7XG4gICAgcmVkbyhlZGl0b3IsIGhpc3RvcnlTdGF0ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDTEVBUl9FRElUT1JfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENMRUFSX0hJU1RPUllfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNsZWFySGlzdG9yeShoaXN0b3J5U3RhdGUpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1JFRE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoQ0FOX1VORE9fQ09NTUFORCwgZmFsc2UpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKGFwcGx5Q2hhbmdlKSk7XG4gIHJldHVybiB1bnJlZ2lzdGVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgaGlzdG9yeSBzdGF0ZS5cbiAqIEByZXR1cm5zIC0gVGhlIGVtcHR5IGhpc3Rvcnkgc3RhdGUsIGFzIGFuIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUoKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogbnVsbCxcbiAgICByZWRvU3RhY2s6IFtdLFxuICAgIHVuZG9TdGFjazogW11cbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUsIHJlZ2lzdGVySGlzdG9yeSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lexical/history/LexicalHistory.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/html/LexicalHtml.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/html/LexicalHtml.dev.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $generateHtmlFromNodes: function() { return /* binding */ $generateHtmlFromNodes; },\n/* harmony export */   $generateNodesFromDOM: function() { return /* binding */ $generateNodesFromDOM; }\n/* harmony export */ });\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivalent library and pass in the document here.\n */\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n  const allArtificialNodes = [];\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor, allArtificialNodes, false);\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n  $unwrapArtificialNodes(allArtificialNodes);\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined' && typeof global.window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n  const container = document.createElement('div');\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const topLevelChildren = root.getChildren();\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n  return container.innerHTML;\n}\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection = null) {\n  let shouldInclude = selection !== null ? currentNode.isSelected(selection) : true;\n  const shouldExclude = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n  if (selection !== null) {\n    let clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(currentNode);\n    clone = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(clone) && selection !== null ? (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.$sliceSelectedTextNodeContent)(selection, clone) : clone;\n    target = clone;\n  }\n  const children = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target) ? target.getChildren() : [];\n  const registeredNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getRegisteredNode)(editor, target.getType());\n  let exportOutput;\n\n  // Use HTMLConfig overrides, if available.\n  if (registeredNode && registeredNode.exportDOM !== undefined) {\n    exportOutput = registeredNode.exportDOM(editor, target);\n  } else {\n    exportOutput = target.exportDOM(editor);\n  }\n  const {\n    element,\n    after\n  } = exportOutput;\n  if (!element) {\n    return false;\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection);\n    if (!shouldInclude && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection, 'html')) {\n      shouldInclude = true;\n    }\n  }\n  if (shouldInclude && !shouldExclude) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_2__.isHTMLElement)(element) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDocumentFragment)(element)) {\n      element.append(fragment);\n    }\n    parentElement.append(element);\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) {\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDocumentFragment)(element)) {\n          element.replaceChildren(newElement);\n        } else {\n          element.replaceWith(newElement);\n        }\n      }\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n  return shouldInclude;\n}\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n  let currentConversion = null;\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n      if (domConversion !== null && (currentConversion === null ||\n      // Given equal priority, prefer the last registered importer\n      // which is typically an application custom node or HTMLConfig['import']\n      (currentConversion.priority || 0) <= (domConversion.priority || 0))) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\nfunction $createNodesFromDOM(node, editor, allArtificialNodes, hasBlockAncestorLexicalNode, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  }\n\n  // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n  const hasBlockAncestorLexicalNodeForChildren = currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(currentLexicalNode) ? false : currentLexicalNode != null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(currentLexicalNode) || hasBlockAncestorLexicalNode;\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, allArtificialNodes, hasBlockAncestorLexicalNodeForChildren, new Map(forChildMap), currentLexicalNode));\n  }\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n  if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_2__.isBlockDomNode)(node)) {\n    if (!hasBlockAncestorLexicalNodeForChildren) {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode);\n    } else {\n      childLexicalNodes = wrapContinuousInlines(node, childLexicalNodes, () => {\n        const artificialNode = new lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE();\n        allArtificialNodes.push(artificialNode);\n        return artificialNode;\n      });\n    }\n  }\n  if (currentLexicalNode == null) {\n    if (childLexicalNodes.length > 0) {\n      // If it hasn't been converted to a LexicalNode, we hoist its children\n      // up to the same level as it.\n      lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n    } else {\n      if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_2__.isBlockDomNode)(node) && isDomNodeBetweenTwoInlineNodes(node)) {\n        // Empty block dom node that hasnt been converted, we replace it with a linebreak if its between inline nodes\n        lexicalNodes = lexicalNodes.concat((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)());\n      }\n    }\n  } else {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n  return lexicalNodes;\n}\nfunction wrapContinuousInlines(domNode, nodes, createWrapperFn) {\n  const textAlign = domNode.style.textAlign;\n  const out = [];\n  let continuousInlines = [];\n  // wrap contiguous inline child nodes in para\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(node)) {\n      if (textAlign && !node.getFormat()) {\n        node.setFormat(textAlign);\n      }\n      out.push(node);\n    } else {\n      continuousInlines.push(node);\n      if (i === nodes.length - 1 || i < nodes.length - 1 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isBlockElementNode)(nodes[i + 1])) {\n        const wrapper = createWrapperFn();\n        wrapper.setFormat(textAlign);\n        wrapper.append(...continuousInlines);\n        out.push(wrapper);\n        continuousInlines = [];\n      }\n    }\n  }\n  return out;\n}\nfunction $unwrapArtificialNodes(allArtificialNodes) {\n  for (const node of allArtificialNodes) {\n    if (node.getNextSibling() instanceof lexical__WEBPACK_IMPORTED_MODULE_0__.ArtificialNode__DO_NOT_USE) {\n      node.insertAfter((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createLineBreakNode)());\n    }\n  }\n  // Replace artificial node with it's children\n  for (const node of allArtificialNodes) {\n    const children = node.getChildren();\n    for (const child of children) {\n      node.insertBefore(child);\n    }\n    node.remove();\n  }\n}\nfunction isDomNodeBetweenTwoInlineNodes(node) {\n  if (node.nextSibling == null || node.previousSibling == null) {\n    return false;\n  }\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode)(node.nextSibling) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode)(node.previousSibling);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1FO0FBQ0o7QUFDaU07O0FBRWhRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBLGtCQUFrQiw2QkFBNkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdURBQWM7QUFDdEM7QUFDQTtBQUNBLGdCQUFnQiw2REFBb0I7QUFDcEMsWUFBWSxvREFBVyxnQ0FBZ0MsaUZBQTZCO0FBQ3BGO0FBQ0E7QUFDQSxtQkFBbUIsdURBQWM7QUFDakMseUJBQXlCLDBEQUFpQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLDBCQUEwQix1REFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkRBQWEsYUFBYSwyREFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyREFBa0I7QUFDOUI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSw0REFBbUIsNkRBQTZELDREQUFtQjtBQUNsTCxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhEQUFjO0FBQ3BCO0FBQ0EseUVBQXlFLHlEQUFvQjtBQUM3RixNQUFNO0FBQ047QUFDQSxtQ0FBbUMsK0RBQTBCO0FBQzdEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSw4REFBYztBQUN4QjtBQUNBLDJDQUEyQyw2REFBb0I7QUFDL0Q7QUFDQTtBQUNBLElBQUk7QUFDSixRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSxRQUFRLDREQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDREQUE0RCw0REFBbUI7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLCtEQUEwQjtBQUNuRSx1QkFBdUIsNkRBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0RBQWUsc0JBQXNCLHdEQUFlO0FBQzdEOztBQUV5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvaHRtbC9MZXhpY2FsSHRtbC5kZXYubWpzPzNjYjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkc2xpY2VTZWxlY3RlZFRleHROb2RlQ29udGVudCB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc0Jsb2NrRG9tTm9kZSB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7ICRnZXRSb290LCAkaXNFbGVtZW50Tm9kZSwgJGNsb25lV2l0aFByb3BlcnRpZXMsICRpc1RleHROb2RlLCBnZXRSZWdpc3RlcmVkTm9kZSwgaXNEb2N1bWVudEZyYWdtZW50LCAkaXNSb290T3JTaGFkb3dSb290LCAkaXNCbG9ja0VsZW1lbnROb2RlLCAkY3JlYXRlTGluZUJyZWFrTm9kZSwgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UsIGlzSW5saW5lRG9tTm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUgfSBmcm9tICdsZXhpY2FsJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8qKlxuICogSG93IHlvdSBwYXJzZSB5b3VyIGh0bWwgc3RyaW5nIHRvIGdldCBhIGRvY3VtZW50IGlzIGxlZnQgdXAgdG8geW91LiBJbiB0aGUgYnJvd3NlciB5b3UgY2FuIHVzZSB0aGUgbmF0aXZlXG4gKiBET01QYXJzZXIgQVBJIHRvIGdlbmVyYXRlIGEgZG9jdW1lbnQgKHNlZSBjbGlwYm9hcmQudHMpLCBidXQgdG8gdXNlIGluIGEgaGVhZGxlc3MgZW52aXJvbm1lbnQgeW91IGNhbiB1c2UgSlNEb21cbiAqIG9yIGFuIGVxdWl2YWxlbnQgbGlicmFyeSBhbmQgcGFzcyBpbiB0aGUgZG9jdW1lbnQgaGVyZS5cbiAqL1xuZnVuY3Rpb24gJGdlbmVyYXRlTm9kZXNGcm9tRE9NKGVkaXRvciwgZG9tKSB7XG4gIGNvbnN0IGVsZW1lbnRzID0gZG9tLmJvZHkgPyBkb20uYm9keS5jaGlsZE5vZGVzIDogW107XG4gIGxldCBsZXhpY2FsTm9kZXMgPSBbXTtcbiAgY29uc3QgYWxsQXJ0aWZpY2lhbE5vZGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgaWYgKCFJR05PUkVfVEFHUy5oYXMoZWxlbWVudC5ub2RlTmFtZSkpIHtcbiAgICAgIGNvbnN0IGxleGljYWxOb2RlID0gJGNyZWF0ZU5vZGVzRnJvbURPTShlbGVtZW50LCBlZGl0b3IsIGFsbEFydGlmaWNpYWxOb2RlcywgZmFsc2UpO1xuICAgICAgaWYgKGxleGljYWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGxleGljYWxOb2RlcyA9IGxleGljYWxOb2Rlcy5jb25jYXQobGV4aWNhbE5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAkdW53cmFwQXJ0aWZpY2lhbE5vZGVzKGFsbEFydGlmaWNpYWxOb2Rlcyk7XG4gIHJldHVybiBsZXhpY2FsTm9kZXM7XG59XG5mdW5jdGlvbiAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzKGVkaXRvciwgc2VsZWN0aW9uKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBnbG9iYWwud2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcignVG8gdXNlICRnZW5lcmF0ZUh0bWxGcm9tTm9kZXMgaW4gaGVhZGxlc3MgbW9kZSBwbGVhc2UgaW5pdGlhbGl6ZSBhIGhlYWRsZXNzIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gc3VjaCBhcyBKU0RvbSBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLicpO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgY29uc3QgdG9wTGV2ZWxDaGlsZHJlbiA9IHJvb3QuZ2V0Q2hpbGRyZW4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3BMZXZlbENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9wTGV2ZWxOb2RlID0gdG9wTGV2ZWxDaGlsZHJlbltpXTtcbiAgICAkYXBwZW5kTm9kZXNUb0hUTUwoZWRpdG9yLCB0b3BMZXZlbE5vZGUsIGNvbnRhaW5lciwgc2VsZWN0aW9uKTtcbiAgfVxuICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbn1cbmZ1bmN0aW9uICRhcHBlbmROb2Rlc1RvSFRNTChlZGl0b3IsIGN1cnJlbnROb2RlLCBwYXJlbnRFbGVtZW50LCBzZWxlY3Rpb24gPSBudWxsKSB7XG4gIGxldCBzaG91bGRJbmNsdWRlID0gc2VsZWN0aW9uICE9PSBudWxsID8gY3VycmVudE5vZGUuaXNTZWxlY3RlZChzZWxlY3Rpb24pIDogdHJ1ZTtcbiAgY29uc3Qgc2hvdWxkRXhjbHVkZSA9ICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiBjdXJyZW50Tm9kZS5leGNsdWRlRnJvbUNvcHkoJ2h0bWwnKTtcbiAgbGV0IHRhcmdldCA9IGN1cnJlbnROb2RlO1xuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgbGV0IGNsb25lID0gJGNsb25lV2l0aFByb3BlcnRpZXMoY3VycmVudE5vZGUpO1xuICAgIGNsb25lID0gJGlzVGV4dE5vZGUoY2xvbmUpICYmIHNlbGVjdGlvbiAhPT0gbnVsbCA/ICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgY2xvbmUpIDogY2xvbmU7XG4gICAgdGFyZ2V0ID0gY2xvbmU7XG4gIH1cbiAgY29uc3QgY2hpbGRyZW4gPSAkaXNFbGVtZW50Tm9kZSh0YXJnZXQpID8gdGFyZ2V0LmdldENoaWxkcmVuKCkgOiBbXTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBnZXRSZWdpc3RlcmVkTm9kZShlZGl0b3IsIHRhcmdldC5nZXRUeXBlKCkpO1xuICBsZXQgZXhwb3J0T3V0cHV0O1xuXG4gIC8vIFVzZSBIVE1MQ29uZmlnIG92ZXJyaWRlcywgaWYgYXZhaWxhYmxlLlxuICBpZiAocmVnaXN0ZXJlZE5vZGUgJiYgcmVnaXN0ZXJlZE5vZGUuZXhwb3J0RE9NICE9PSB1bmRlZmluZWQpIHtcbiAgICBleHBvcnRPdXRwdXQgPSByZWdpc3RlcmVkTm9kZS5leHBvcnRET00oZWRpdG9yLCB0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydE91dHB1dCA9IHRhcmdldC5leHBvcnRET00oZWRpdG9yKTtcbiAgfVxuICBjb25zdCB7XG4gICAgZWxlbWVudCxcbiAgICBhZnRlclxuICB9ID0gZXhwb3J0T3V0cHV0O1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZE5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICBjb25zdCBzaG91bGRJbmNsdWRlQ2hpbGQgPSAkYXBwZW5kTm9kZXNUb0hUTUwoZWRpdG9yLCBjaGlsZE5vZGUsIGZyYWdtZW50LCBzZWxlY3Rpb24pO1xuICAgIGlmICghc2hvdWxkSW5jbHVkZSAmJiAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkgJiYgc2hvdWxkSW5jbHVkZUNoaWxkICYmIGN1cnJlbnROb2RlLmV4dHJhY3RXaXRoQ2hpbGQoY2hpbGROb2RlLCBzZWxlY3Rpb24sICdodG1sJykpIHtcbiAgICAgIHNob3VsZEluY2x1ZGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoc2hvdWxkSW5jbHVkZSAmJiAhc2hvdWxkRXhjbHVkZSkge1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGlzRG9jdW1lbnRGcmFnbWVudChlbGVtZW50KSkge1xuICAgICAgZWxlbWVudC5hcHBlbmQoZnJhZ21lbnQpO1xuICAgIH1cbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgIGNvbnN0IG5ld0VsZW1lbnQgPSBhZnRlci5jYWxsKHRhcmdldCwgZWxlbWVudCk7XG4gICAgICBpZiAobmV3RWxlbWVudCkge1xuICAgICAgICBpZiAoaXNEb2N1bWVudEZyYWdtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgZWxlbWVudC5yZXBsYWNlQ2hpbGRyZW4obmV3RWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudC5yZXBsYWNlV2l0aChuZXdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJlbnRFbGVtZW50LmFwcGVuZChmcmFnbWVudCk7XG4gIH1cbiAgcmV0dXJuIHNob3VsZEluY2x1ZGU7XG59XG5mdW5jdGlvbiBnZXRDb252ZXJzaW9uRnVuY3Rpb24oZG9tTm9kZSwgZWRpdG9yKSB7XG4gIGNvbnN0IHtcbiAgICBub2RlTmFtZVxuICB9ID0gZG9tTm9kZTtcbiAgY29uc3QgY2FjaGVkQ29udmVyc2lvbnMgPSBlZGl0b3IuX2h0bWxDb252ZXJzaW9ucy5nZXQobm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIGxldCBjdXJyZW50Q29udmVyc2lvbiA9IG51bGw7XG4gIGlmIChjYWNoZWRDb252ZXJzaW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZWRDb252ZXJzaW9uIG9mIGNhY2hlZENvbnZlcnNpb25zKSB7XG4gICAgICBjb25zdCBkb21Db252ZXJzaW9uID0gY2FjaGVkQ29udmVyc2lvbihkb21Ob2RlKTtcbiAgICAgIGlmIChkb21Db252ZXJzaW9uICE9PSBudWxsICYmIChjdXJyZW50Q29udmVyc2lvbiA9PT0gbnVsbCB8fFxuICAgICAgLy8gR2l2ZW4gZXF1YWwgcHJpb3JpdHksIHByZWZlciB0aGUgbGFzdCByZWdpc3RlcmVkIGltcG9ydGVyXG4gICAgICAvLyB3aGljaCBpcyB0eXBpY2FsbHkgYW4gYXBwbGljYXRpb24gY3VzdG9tIG5vZGUgb3IgSFRNTENvbmZpZ1snaW1wb3J0J11cbiAgICAgIChjdXJyZW50Q29udmVyc2lvbi5wcmlvcml0eSB8fCAwKSA8PSAoZG9tQ29udmVyc2lvbi5wcmlvcml0eSB8fCAwKSkpIHtcbiAgICAgICAgY3VycmVudENvbnZlcnNpb24gPSBkb21Db252ZXJzaW9uO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY3VycmVudENvbnZlcnNpb24gIT09IG51bGwgPyBjdXJyZW50Q29udmVyc2lvbi5jb252ZXJzaW9uIDogbnVsbDtcbn1cbmNvbnN0IElHTk9SRV9UQUdTID0gbmV3IFNldChbJ1NUWUxFJywgJ1NDUklQVCddKTtcbmZ1bmN0aW9uICRjcmVhdGVOb2Rlc0Zyb21ET00obm9kZSwgZWRpdG9yLCBhbGxBcnRpZmljaWFsTm9kZXMsIGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZSwgZm9yQ2hpbGRNYXAgPSBuZXcgTWFwKCksIHBhcmVudExleGljYWxOb2RlKSB7XG4gIGxldCBsZXhpY2FsTm9kZXMgPSBbXTtcbiAgaWYgKElHTk9SRV9UQUdTLmhhcyhub2RlLm5vZGVOYW1lKSkge1xuICAgIHJldHVybiBsZXhpY2FsTm9kZXM7XG4gIH1cbiAgbGV0IGN1cnJlbnRMZXhpY2FsTm9kZSA9IG51bGw7XG4gIGNvbnN0IHRyYW5zZm9ybUZ1bmN0aW9uID0gZ2V0Q29udmVyc2lvbkZ1bmN0aW9uKG5vZGUsIGVkaXRvcik7XG4gIGNvbnN0IHRyYW5zZm9ybU91dHB1dCA9IHRyYW5zZm9ybUZ1bmN0aW9uID8gdHJhbnNmb3JtRnVuY3Rpb24obm9kZSkgOiBudWxsO1xuICBsZXQgcG9zdFRyYW5zZm9ybSA9IG51bGw7XG4gIGlmICh0cmFuc2Zvcm1PdXRwdXQgIT09IG51bGwpIHtcbiAgICBwb3N0VHJhbnNmb3JtID0gdHJhbnNmb3JtT3V0cHV0LmFmdGVyO1xuICAgIGNvbnN0IHRyYW5zZm9ybU5vZGVzID0gdHJhbnNmb3JtT3V0cHV0Lm5vZGU7XG4gICAgY3VycmVudExleGljYWxOb2RlID0gQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1Ob2RlcykgPyB0cmFuc2Zvcm1Ob2Rlc1t0cmFuc2Zvcm1Ob2Rlcy5sZW5ndGggLSAxXSA6IHRyYW5zZm9ybU5vZGVzO1xuICAgIGlmIChjdXJyZW50TGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgWywgZm9yQ2hpbGRGdW5jdGlvbl0gb2YgZm9yQ2hpbGRNYXApIHtcbiAgICAgICAgY3VycmVudExleGljYWxOb2RlID0gZm9yQ2hpbGRGdW5jdGlvbihjdXJyZW50TGV4aWNhbE5vZGUsIHBhcmVudExleGljYWxOb2RlKTtcbiAgICAgICAgaWYgKCFjdXJyZW50TGV4aWNhbE5vZGUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRMZXhpY2FsTm9kZSkge1xuICAgICAgICBsZXhpY2FsTm9kZXMucHVzaCguLi4oQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1Ob2RlcykgPyB0cmFuc2Zvcm1Ob2RlcyA6IFtjdXJyZW50TGV4aWNhbE5vZGVdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1PdXRwdXQuZm9yQ2hpbGQgIT0gbnVsbCkge1xuICAgICAgZm9yQ2hpbGRNYXAuc2V0KG5vZGUubm9kZU5hbWUsIHRyYW5zZm9ybU91dHB1dC5mb3JDaGlsZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIERPTSBub2RlIGRvZXNuJ3QgaGF2ZSBhIHRyYW5zZm9ybWVyLCB3ZSBkb24ndCBrbm93IHdoYXRcbiAgLy8gdG8gZG8gd2l0aCBpdCBidXQgd2Ugc3RpbGwgbmVlZCB0byBwcm9jZXNzIGFueSBjaGlsZE5vZGVzLlxuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgbGV0IGNoaWxkTGV4aWNhbE5vZGVzID0gW107XG4gIGNvbnN0IGhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZUZvckNoaWxkcmVuID0gY3VycmVudExleGljYWxOb2RlICE9IG51bGwgJiYgJGlzUm9vdE9yU2hhZG93Um9vdChjdXJyZW50TGV4aWNhbE5vZGUpID8gZmFsc2UgOiBjdXJyZW50TGV4aWNhbE5vZGUgIT0gbnVsbCAmJiAkaXNCbG9ja0VsZW1lbnROb2RlKGN1cnJlbnRMZXhpY2FsTm9kZSkgfHwgaGFzQmxvY2tBbmNlc3RvckxleGljYWxOb2RlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY2hpbGRMZXhpY2FsTm9kZXMucHVzaCguLi4kY3JlYXRlTm9kZXNGcm9tRE9NKGNoaWxkcmVuW2ldLCBlZGl0b3IsIGFsbEFydGlmaWNpYWxOb2RlcywgaGFzQmxvY2tBbmNlc3RvckxleGljYWxOb2RlRm9yQ2hpbGRyZW4sIG5ldyBNYXAoZm9yQ2hpbGRNYXApLCBjdXJyZW50TGV4aWNhbE5vZGUpKTtcbiAgfVxuICBpZiAocG9zdFRyYW5zZm9ybSAhPSBudWxsKSB7XG4gICAgY2hpbGRMZXhpY2FsTm9kZXMgPSBwb3N0VHJhbnNmb3JtKGNoaWxkTGV4aWNhbE5vZGVzKTtcbiAgfVxuICBpZiAoaXNCbG9ja0RvbU5vZGUobm9kZSkpIHtcbiAgICBpZiAoIWhhc0Jsb2NrQW5jZXN0b3JMZXhpY2FsTm9kZUZvckNoaWxkcmVuKSB7XG4gICAgICBjaGlsZExleGljYWxOb2RlcyA9IHdyYXBDb250aW51b3VzSW5saW5lcyhub2RlLCBjaGlsZExleGljYWxOb2RlcywgJGNyZWF0ZVBhcmFncmFwaE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZExleGljYWxOb2RlcyA9IHdyYXBDb250aW51b3VzSW5saW5lcyhub2RlLCBjaGlsZExleGljYWxOb2RlcywgKCkgPT4ge1xuICAgICAgICBjb25zdCBhcnRpZmljaWFsTm9kZSA9IG5ldyBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSgpO1xuICAgICAgICBhbGxBcnRpZmljaWFsTm9kZXMucHVzaChhcnRpZmljaWFsTm9kZSk7XG4gICAgICAgIHJldHVybiBhcnRpZmljaWFsTm9kZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoY3VycmVudExleGljYWxOb2RlID09IG51bGwpIHtcbiAgICBpZiAoY2hpbGRMZXhpY2FsTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gSWYgaXQgaGFzbid0IGJlZW4gY29udmVydGVkIHRvIGEgTGV4aWNhbE5vZGUsIHdlIGhvaXN0IGl0cyBjaGlsZHJlblxuICAgICAgLy8gdXAgdG8gdGhlIHNhbWUgbGV2ZWwgYXMgaXQuXG4gICAgICBsZXhpY2FsTm9kZXMgPSBsZXhpY2FsTm9kZXMuY29uY2F0KGNoaWxkTGV4aWNhbE5vZGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQmxvY2tEb21Ob2RlKG5vZGUpICYmIGlzRG9tTm9kZUJldHdlZW5Ud29JbmxpbmVOb2Rlcyhub2RlKSkge1xuICAgICAgICAvLyBFbXB0eSBibG9jayBkb20gbm9kZSB0aGF0IGhhc250IGJlZW4gY29udmVydGVkLCB3ZSByZXBsYWNlIGl0IHdpdGggYSBsaW5lYnJlYWsgaWYgaXRzIGJldHdlZW4gaW5saW5lIG5vZGVzXG4gICAgICAgIGxleGljYWxOb2RlcyA9IGxleGljYWxOb2Rlcy5jb25jYXQoJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50TGV4aWNhbE5vZGUpKSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIGlzIGEgRWxlbWVudE5vZGUgYWZ0ZXIgY29udmVyc2lvbixcbiAgICAgIC8vIHdlIGNhbiBhcHBlbmQgYWxsIHRoZSBjaGlsZHJlbiB0byBpdC5cbiAgICAgIGN1cnJlbnRMZXhpY2FsTm9kZS5hcHBlbmQoLi4uY2hpbGRMZXhpY2FsTm9kZXMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGV4aWNhbE5vZGVzO1xufVxuZnVuY3Rpb24gd3JhcENvbnRpbnVvdXNJbmxpbmVzKGRvbU5vZGUsIG5vZGVzLCBjcmVhdGVXcmFwcGVyRm4pIHtcbiAgY29uc3QgdGV4dEFsaWduID0gZG9tTm9kZS5zdHlsZS50ZXh0QWxpZ247XG4gIGNvbnN0IG91dCA9IFtdO1xuICBsZXQgY29udGludW91c0lubGluZXMgPSBbXTtcbiAgLy8gd3JhcCBjb250aWd1b3VzIGlubGluZSBjaGlsZCBub2RlcyBpbiBwYXJhXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCRpc0Jsb2NrRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGlmICh0ZXh0QWxpZ24gJiYgIW5vZGUuZ2V0Rm9ybWF0KCkpIHtcbiAgICAgICAgbm9kZS5zZXRGb3JtYXQodGV4dEFsaWduKTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250aW51b3VzSW5saW5lcy5wdXNoKG5vZGUpO1xuICAgICAgaWYgKGkgPT09IG5vZGVzLmxlbmd0aCAtIDEgfHwgaSA8IG5vZGVzLmxlbmd0aCAtIDEgJiYgJGlzQmxvY2tFbGVtZW50Tm9kZShub2Rlc1tpICsgMV0pKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSBjcmVhdGVXcmFwcGVyRm4oKTtcbiAgICAgICAgd3JhcHBlci5zZXRGb3JtYXQodGV4dEFsaWduKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmQoLi4uY29udGludW91c0lubGluZXMpO1xuICAgICAgICBvdXQucHVzaCh3cmFwcGVyKTtcbiAgICAgICAgY29udGludW91c0lubGluZXMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG91dDtcbn1cbmZ1bmN0aW9uICR1bndyYXBBcnRpZmljaWFsTm9kZXMoYWxsQXJ0aWZpY2lhbE5vZGVzKSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBhbGxBcnRpZmljaWFsTm9kZXMpIHtcbiAgICBpZiAobm9kZS5nZXROZXh0U2libGluZygpIGluc3RhbmNlb2YgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UpIHtcbiAgICAgIG5vZGUuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgfVxuICB9XG4gIC8vIFJlcGxhY2UgYXJ0aWZpY2lhbCBub2RlIHdpdGggaXQncyBjaGlsZHJlblxuICBmb3IgKGNvbnN0IG5vZGUgb2YgYWxsQXJ0aWZpY2lhbE5vZGVzKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQpO1xuICAgIH1cbiAgICBub2RlLnJlbW92ZSgpO1xuICB9XG59XG5mdW5jdGlvbiBpc0RvbU5vZGVCZXR3ZWVuVHdvSW5saW5lTm9kZXMobm9kZSkge1xuICBpZiAobm9kZS5uZXh0U2libGluZyA9PSBudWxsIHx8IG5vZGUucHJldmlvdXNTaWJsaW5nID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzSW5saW5lRG9tTm9kZShub2RlLm5leHRTaWJsaW5nKSAmJiBpc0lubGluZURvbU5vZGUobm9kZS5wcmV2aW91c1NpYmxpbmcpO1xufVxuXG5leHBvcnQgeyAkZ2VuZXJhdGVIdG1sRnJvbU5vZGVzLCAkZ2VuZXJhdGVOb2Rlc0Zyb21ET00gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lexical/html/LexicalHtml.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/link/LexicalLink.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/link/LexicalLink.dev.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createAutoLinkNode: function() { return /* binding */ $createAutoLinkNode; },\n/* harmony export */   $createLinkNode: function() { return /* binding */ $createLinkNode; },\n/* harmony export */   $isAutoLinkNode: function() { return /* binding */ $isAutoLinkNode; },\n/* harmony export */   $isLinkNode: function() { return /* binding */ $isLinkNode; },\n/* harmony export */   $toggleLink: function() { return /* binding */ $toggleLink; },\n/* harmony export */   AutoLinkNode: function() { return /* binding */ AutoLinkNode; },\n/* harmony export */   LinkNode: function() { return /* binding */ LinkNode; },\n/* harmony export */   TOGGLE_LINK_COMMAND: function() { return /* binding */ TOGGLE_LINK_COMMAND; },\n/* harmony export */   formatUrl: function() { return /* binding */ formatUrl; },\n/* harmony export */   toggleLink: function() { return /* binding */ toggleLink; }\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    this.updateLinkDOM(null, element, config);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.link);\n    return element;\n  }\n  updateLinkDOM(prevNode, anchor, config) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLAnchorElement)(anchor)) {\n      if (!prevNode || prevNode.__url !== this.__url) {\n        anchor.href = this.sanitizeUrl(this.__url);\n      }\n      for (const attr of ['target', 'rel', 'title']) {\n        const key = `__${attr}`;\n        const value = this[key];\n        if (!prevNode || prevNode[key] !== value) {\n          if (value) {\n            anchor[attr] = value;\n          } else {\n            anchor.removeAttribute(attr);\n          }\n        }\n      }\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    this.updateLinkDOM(prevNode, anchor, config);\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    url = formatUrl(url);\n    try {\n      const parsedUrl = new URL(formatUrl(url));\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLAnchorElement)(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      formatDevErrorMessage(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(initialSelection)) {\n    return $fn();\n  }\n  const normalized = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection === null || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n    return;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n    const nodes = selection.getNodes();\n    if (nodes.length === 0) {\n      return;\n    }\n\n    // Handle all selected nodes\n    nodes.forEach(node => {\n      if (url === null) {\n        // Remove link\n        const linkParent = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (linkParent) {\n          linkParent.insertBefore(node);\n          if (linkParent.getChildren().length === 0) {\n            linkParent.remove();\n          }\n        }\n      } else {\n        // Add/Update link\n        const existingLink = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (existingLink) {\n          existingLink.setURL(url);\n          if (target !== undefined) {\n            existingLink.setTarget(target);\n          }\n          if (rel !== undefined) {\n            existingLink.setRel(rel);\n          }\n        } else {\n          const linkNode = $createLinkNode(url, {\n            rel,\n            target\n          });\n          node.insertBefore(linkNode);\n          linkNode.append(node);\n        }\n      }\n    });\n    return;\n  }\n\n  // Handle RangeSelection\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parentLink = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n      if (parentLink) {\n        const children = parentLink.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parentLink.insertBefore(children[i]);\n        }\n        parentLink.remove();\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $getAncestor(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $getAncestor(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\nconst PHONE_NUMBER_REGEX = /^\\+?[0-9\\s()-]{5,}$/;\n\n/**\n * Formats a URL string by adding appropriate protocol if missing\n *\n * @param url - URL to format\n * @returns Formatted URL with appropriate protocol\n */\nfunction formatUrl(url) {\n  // Check if URL already has a protocol\n  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {\n    // URL already has a protocol, leave it as is\n    return url;\n  }\n  // Check if it's a relative path (starting with '/', '.', or '#')\n  else if (url.match(/^[/#.]/)) {\n    // Relative path, leave it as is\n    return url;\n  }\n\n  // Check for email address\n  else if (url.includes('@')) {\n    return `mailto:${url}`;\n  }\n\n  // Check for phone number\n  else if (PHONE_NUMBER_REGEX.test(url)) {\n    return `tel:${url}`;\n  }\n\n  // For everything else, return with https:// prefix\n  return `https://${url}`;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGluay9MZXhpY2FsTGluay5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRztBQUNnRzs7QUFFbE07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCLGdEQUFXO0FBQ2xDOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtRUFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsS0FBSztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sbUVBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBcUI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzREFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQSxTQUFTLHVEQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0RBQWE7QUFDeEMsT0FBTywwREFBaUI7QUFDeEI7QUFDQTtBQUNBLHFCQUFxQiwwRUFBaUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixzREFBYTtBQUMxQyxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0RBQWEsQ0FBQywwRUFBaUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLHNEQUFhO0FBQ2pDLDZCQUE2QiwwREFBaUIsZ0JBQWdCLHlEQUFnQjtBQUM5RTtBQUNBO0FBQ0EsTUFBTSx5REFBZ0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbUVBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLDZCQUE2QixtRUFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1FQUFtQjtBQUM1QztBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxHQUFHOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUk7QUFDdEI7O0FBRUE7QUFDQSxvQkFBb0IsSUFBSTtBQUN4Qjs7QUFFK0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpbmsvTGV4aWNhbExpbmsuZGV2Lm1qcz8zYjc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgaXNIVE1MQW5jaG9yRWxlbWVudCwgJGZpbmRNYXRjaGluZ1BhcmVudCB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUNvbW1hbmQsIEVsZW1lbnROb2RlLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCAkaXNFbGVtZW50Tm9kZSwgJGdldFNlbGVjdGlvbiwgJGlzTm9kZVNlbGVjdGlvbiwgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCAkc2V0U2VsZWN0aW9uIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMuXG5cbmZ1bmN0aW9uIGZvcm1hdERldkVycm9yTWVzc2FnZShtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuY29uc3QgU1VQUE9SVEVEX1VSTF9QUk9UT0NPTFMgPSBuZXcgU2V0KFsnaHR0cDonLCAnaHR0cHM6JywgJ21haWx0bzonLCAnc21zOicsICd0ZWw6J10pO1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgTGlua05vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2xpbmsnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5rTm9kZShub2RlLl9fdXJsLCB7XG4gICAgICByZWw6IG5vZGUuX19yZWwsXG4gICAgICB0YXJnZXQ6IG5vZGUuX190YXJnZXQsXG4gICAgICB0aXRsZTogbm9kZS5fX3RpdGxlXG4gICAgfSwgbm9kZS5fX2tleSk7XG4gIH1cbiAgY29uc3RydWN0b3IodXJsID0gJycsIGF0dHJpYnV0ZXMgPSB7fSwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICBjb25zdCB7XG4gICAgICB0YXJnZXQgPSBudWxsLFxuICAgICAgcmVsID0gbnVsbCxcbiAgICAgIHRpdGxlID0gbnVsbFxuICAgIH0gPSBhdHRyaWJ1dGVzO1xuICAgIHRoaXMuX191cmwgPSB1cmw7XG4gICAgdGhpcy5fX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9fcmVsID0gcmVsO1xuICAgIHRoaXMuX190aXRsZSA9IHRpdGxlO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHRoaXMudXBkYXRlTGlua0RPTShudWxsLCBlbGVtZW50LCBjb25maWcpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLmxpbmspO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHVwZGF0ZUxpbmtET00ocHJldk5vZGUsIGFuY2hvciwgY29uZmlnKSB7XG4gICAgaWYgKGlzSFRNTEFuY2hvckVsZW1lbnQoYW5jaG9yKSkge1xuICAgICAgaWYgKCFwcmV2Tm9kZSB8fCBwcmV2Tm9kZS5fX3VybCAhPT0gdGhpcy5fX3VybCkge1xuICAgICAgICBhbmNob3IuaHJlZiA9IHRoaXMuc2FuaXRpemVVcmwodGhpcy5fX3VybCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGF0dHIgb2YgWyd0YXJnZXQnLCAncmVsJywgJ3RpdGxlJ10pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYF9fJHthdHRyfWA7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpc1trZXldO1xuICAgICAgICBpZiAoIXByZXZOb2RlIHx8IHByZXZOb2RlW2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBhbmNob3JbYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBhbmNob3IsIGNvbmZpZykge1xuICAgIHRoaXMudXBkYXRlTGlua0RPTShwcmV2Tm9kZSwgYW5jaG9yLCBjb25maWcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0QW5jaG9yRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlTGlua05vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldFVSTChzZXJpYWxpemVkTm9kZS51cmwpLnNldFJlbChzZXJpYWxpemVkTm9kZS5yZWwgfHwgbnVsbCkuc2V0VGFyZ2V0KHNlcmlhbGl6ZWROb2RlLnRhcmdldCB8fCBudWxsKS5zZXRUaXRsZShzZXJpYWxpemVkTm9kZS50aXRsZSB8fCBudWxsKTtcbiAgfVxuICBzYW5pdGl6ZVVybCh1cmwpIHtcbiAgICB1cmwgPSBmb3JtYXRVcmwodXJsKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkVXJsID0gbmV3IFVSTChmb3JtYXRVcmwodXJsKSk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2NyaXB0LXVybFxuICAgICAgaWYgKCFTVVBQT1JURURfVVJMX1BST1RPQ09MUy5oYXMocGFyc2VkVXJsLnByb3RvY29sKSkge1xuICAgICAgICByZXR1cm4gJ2Fib3V0OmJsYW5rJztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIHJlbDogdGhpcy5nZXRSZWwoKSxcbiAgICAgIHRhcmdldDogdGhpcy5nZXRUYXJnZXQoKSxcbiAgICAgIHRpdGxlOiB0aGlzLmdldFRpdGxlKCksXG4gICAgICB1cmw6IHRoaXMuZ2V0VVJMKClcbiAgICB9O1xuICB9XG4gIGdldFVSTCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3VybDtcbiAgfVxuICBzZXRVUkwodXJsKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX191cmwgPSB1cmw7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9XG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3RhcmdldDtcbiAgfVxuICBzZXRUYXJnZXQodGFyZ2V0KSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX190YXJnZXQgPSB0YXJnZXQ7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9XG4gIGdldFJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3JlbDtcbiAgfVxuICBzZXRSZWwocmVsKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX19yZWwgPSByZWw7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9XG4gIGdldFRpdGxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdGl0bGU7XG4gIH1cbiAgc2V0VGl0bGUodGl0bGUpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX3RpdGxlID0gdGl0bGU7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9XG4gIGluc2VydE5ld0FmdGVyKF8sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUodGhpcy5fX3VybCwge1xuICAgICAgcmVsOiB0aGlzLl9fcmVsLFxuICAgICAgdGFyZ2V0OiB0aGlzLl9fdGFyZ2V0LFxuICAgICAgdGl0bGU6IHRoaXMuX190aXRsZVxuICAgIH0pO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobGlua05vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBsaW5rTm9kZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzSW5saW5lKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihhbmNob3JOb2RlKSAmJiB0aGlzLmlzUGFyZW50T2YoZm9jdXNOb2RlKSAmJiBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggPiAwO1xuICB9XG4gIGlzRW1haWxVUkkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX191cmwuc3RhcnRzV2l0aCgnbWFpbHRvOicpO1xuICB9XG4gIGlzV2ViU2l0ZVVSSSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX3VybC5zdGFydHNXaXRoKCdodHRwczovLycpIHx8IHRoaXMuX191cmwuc3RhcnRzV2l0aCgnaHR0cDovLycpO1xuICB9XG59XG5mdW5jdGlvbiAkY29udmVydEFuY2hvckVsZW1lbnQoZG9tTm9kZSkge1xuICBsZXQgbm9kZSA9IG51bGw7XG4gIGlmIChpc0hUTUxBbmNob3JFbGVtZW50KGRvbU5vZGUpKSB7XG4gICAgY29uc3QgY29udGVudCA9IGRvbU5vZGUudGV4dENvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgIT09IG51bGwgJiYgY29udGVudCAhPT0gJycgfHwgZG9tTm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBub2RlID0gJGNyZWF0ZUxpbmtOb2RlKGRvbU5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgJycsIHtcbiAgICAgICAgcmVsOiBkb21Ob2RlLmdldEF0dHJpYnV0ZSgncmVsJyksXG4gICAgICAgIHRhcmdldDogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3RhcmdldCcpLFxuICAgICAgICB0aXRsZTogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3RpdGxlJylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIFVSTCBhbmQgY3JlYXRlcyBhIExpbmtOb2RlLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhlIExpbmtOb2RlIHNob3VsZCBkaXJlY3QgdG8uXG4gKiBAcGFyYW0gYXR0cmlidXRlcyAtIE9wdGlvbmFsIEhUTUwgYSB0YWcgYXR0cmlidXRlcyBcXFxceyB0YXJnZXQsIHJlbCwgdGl0bGUgXFxcXH1cbiAqIEByZXR1cm5zIFRoZSBMaW5rTm9kZS5cbiAqL1xuZnVuY3Rpb24gJGNyZWF0ZUxpbmtOb2RlKHVybCA9ICcnLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpbmtOb2RlKHVybCwgYXR0cmlidXRlcykpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbm9kZSBpcyBhIExpbmtOb2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGEgTGlua05vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlua05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpbmtOb2RlO1xufVxuLy8gQ3VzdG9tIG5vZGUgdHlwZSB0byBvdmVycmlkZSBgY2FuSW5zZXJ0VGV4dEFmdGVyYCB0aGF0IHdpbGxcbi8vIGFsbG93IHR5cGluZyB3aXRoaW4gdGhlIGxpbmtcbmNsYXNzIEF1dG9MaW5rTm9kZSBleHRlbmRzIExpbmtOb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGF1dG9saW5rIHdhcyBldmVyIHVubGlua2VkLiAqKi9cblxuICBjb25zdHJ1Y3Rvcih1cmwgPSAnJywgYXR0cmlidXRlcyA9IHt9LCBrZXkpIHtcbiAgICBzdXBlcih1cmwsIGF0dHJpYnV0ZXMsIGtleSk7XG4gICAgdGhpcy5fX2lzVW5saW5rZWQgPSBhdHRyaWJ1dGVzLmlzVW5saW5rZWQgIT09IHVuZGVmaW5lZCAmJiBhdHRyaWJ1dGVzLmlzVW5saW5rZWQgIT09IG51bGwgPyBhdHRyaWJ1dGVzLmlzVW5saW5rZWQgOiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2F1dG9saW5rJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgQXV0b0xpbmtOb2RlKG5vZGUuX191cmwsIHtcbiAgICAgIGlzVW5saW5rZWQ6IG5vZGUuX19pc1VubGlua2VkLFxuICAgICAgcmVsOiBub2RlLl9fcmVsLFxuICAgICAgdGFyZ2V0OiBub2RlLl9fdGFyZ2V0LFxuICAgICAgdGl0bGU6IG5vZGUuX190aXRsZVxuICAgIH0sIG5vZGUuX19rZXkpO1xuICB9XG4gIGdldElzVW5saW5rZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19pc1VubGlua2VkO1xuICB9XG4gIHNldElzVW5saW5rZWQodmFsdWUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19pc1VubGlua2VkID0gdmFsdWU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGlmICh0aGlzLl9faXNVbmxpbmtlZCkge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZURPTShjb25maWcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGFuY2hvciwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZURPTShwcmV2Tm9kZSwgYW5jaG9yLCBjb25maWcpIHx8IHByZXZOb2RlLl9faXNVbmxpbmtlZCAhPT0gdGhpcy5fX2lzVW5saW5rZWQ7XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUF1dG9MaW5rTm9kZSgpLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKTtcbiAgfVxuICB1cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiBzdXBlci51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkuc2V0SXNVbmxpbmtlZChzZXJpYWxpemVkTm9kZS5pc1VubGlua2VkIHx8IGZhbHNlKTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIC8vIFRPRE86IFNob3VsZCBsaW5rIG5vZGUgc2hvdWxkIGhhbmRsZSB0aGUgaW1wb3J0IG92ZXIgYXV0b2xpbms/XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgaXNVbmxpbmtlZDogdGhpcy5fX2lzVW5saW5rZWRcbiAgICB9O1xuICB9XG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGxpbmtOb2RlID0gJGNyZWF0ZUF1dG9MaW5rTm9kZSh0aGlzLl9fdXJsLCB7XG4gICAgICAgIGlzVW5saW5rZWQ6IHRoaXMuX19pc1VubGlua2VkLFxuICAgICAgICByZWw6IHRoaXMuX19yZWwsXG4gICAgICAgIHRhcmdldDogdGhpcy5fX3RhcmdldCxcbiAgICAgICAgdGl0bGU6IHRoaXMuX190aXRsZVxuICAgICAgfSk7XG4gICAgICBlbGVtZW50LmFwcGVuZChsaW5rTm9kZSk7XG4gICAgICByZXR1cm4gbGlua05vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogVGFrZXMgYSBVUkwgYW5kIGNyZWF0ZXMgYW4gQXV0b0xpbmtOb2RlLiBBdXRvTGlua05vZGVzIGFyZSBnZW5lcmFsbHkgYXV0b21hdGljYWxseSBnZW5lcmF0ZWRcbiAqIGR1cmluZyB0eXBpbmcsIHdoaWNoIGlzIGVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gYSBidXR0b24gdG8gZ2VuZXJhdGUgYSBMaW5rTm9kZSBpcyBub3QgcHJhY3RpY2FsLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhlIExpbmtOb2RlIHNob3VsZCBkaXJlY3QgdG8uXG4gKiBAcGFyYW0gYXR0cmlidXRlcyAtIE9wdGlvbmFsIEhUTUwgYSB0YWcgYXR0cmlidXRlcy4gXFxcXHsgdGFyZ2V0LCByZWwsIHRpdGxlIFxcXFx9XG4gKiBAcmV0dXJucyBUaGUgTGlua05vZGUuXG4gKi9cbmZ1bmN0aW9uICRjcmVhdGVBdXRvTGlua05vZGUodXJsID0gJycsIGF0dHJpYnV0ZXMpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgQXV0b0xpbmtOb2RlKHVybCwgYXR0cmlidXRlcykpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgbm9kZSBpcyBhbiBBdXRvTGlua05vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgYW4gQXV0b0xpbmtOb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0F1dG9MaW5rTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgQXV0b0xpbmtOb2RlO1xufVxuY29uc3QgVE9HR0xFX0xJTktfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1RPR0dMRV9MSU5LX0NPTU1BTkQnKTtcbmZ1bmN0aW9uICRnZXRQb2ludE5vZGUocG9pbnQsIG9mZnNldCkge1xuICBpZiAocG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3Qgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRnZXRQb2ludE5vZGU6IGVsZW1lbnQgcG9pbnQgaXMgbm90IGFuIEVsZW1lbnROb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkTm9kZSA9IG5vZGUuZ2V0Q2hpbGRyZW4oKVtwb2ludC5vZmZzZXQgKyBvZmZzZXRdO1xuICAgIHJldHVybiBjaGlsZE5vZGUgfHwgbnVsbDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBQcmVzZXJ2ZSB0aGUgbG9naWNhbCBzdGFydC9lbmQgb2YgYSBSYW5nZVNlbGVjdGlvbiBpbiBzaXR1YXRpb25zIHdoZXJlXG4gKiB0aGUgcG9pbnQgaXMgYW4gZWxlbWVudCB0aGF0IG1heSBiZSByZXBhcmVudGVkIGluIHRoZSBjYWxsYmFjay5cbiAqXG4gKiBAcGFyYW0gJGZuIFRoZSBmdW5jdGlvbiB0byBydW5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uICR3aXRoU2VsZWN0ZWROb2RlcygkZm4pIHtcbiAgY29uc3QgaW5pdGlhbFNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihpbml0aWFsU2VsZWN0aW9uKSkge1xuICAgIHJldHVybiAkZm4oKTtcbiAgfVxuICBjb25zdCBub3JtYWxpemVkID0gJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMKGluaXRpYWxTZWxlY3Rpb24pO1xuICBjb25zdCBpc0JhY2t3YXJkcyA9IG5vcm1hbGl6ZWQuaXNCYWNrd2FyZCgpO1xuICBjb25zdCBhbmNob3JOb2RlID0gJGdldFBvaW50Tm9kZShub3JtYWxpemVkLmFuY2hvciwgaXNCYWNrd2FyZHMgPyAtMSA6IDApO1xuICBjb25zdCBmb2N1c05vZGUgPSAkZ2V0UG9pbnROb2RlKG5vcm1hbGl6ZWQuZm9jdXMsIGlzQmFja3dhcmRzID8gMCA6IC0xKTtcbiAgY29uc3QgcnZhbCA9ICRmbigpO1xuICBpZiAoYW5jaG9yTm9kZSB8fCBmb2N1c05vZGUpIHtcbiAgICBjb25zdCB1cGRhdGVkU2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbih1cGRhdGVkU2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgZmluYWxTZWxlY3Rpb24gPSB1cGRhdGVkU2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICBpZiAoYW5jaG9yTm9kZSkge1xuICAgICAgICBjb25zdCBhbmNob3JQYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoYW5jaG9yUGFyZW50KSB7XG4gICAgICAgICAgZmluYWxTZWxlY3Rpb24uYW5jaG9yLnNldChhbmNob3JQYXJlbnQuZ2V0S2V5KCksIGFuY2hvck5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIChpc0JhY2t3YXJkcyA/IDEgOiAwKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvY3VzTm9kZSkge1xuICAgICAgICBjb25zdCBmb2N1c1BhcmVudCA9IGZvY3VzTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKGZvY3VzUGFyZW50KSB7XG4gICAgICAgICAgZmluYWxTZWxlY3Rpb24uZm9jdXMuc2V0KGZvY3VzUGFyZW50LmdldEtleSgpLCBmb2N1c05vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIChpc0JhY2t3YXJkcyA/IDAgOiAxKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgJHNldFNlbGVjdGlvbigkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwoZmluYWxTZWxlY3Rpb24pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIG9yIHVwZGF0ZXMgYSBMaW5rTm9kZS4gSXQgY2FuIGFsc28gZGVsZXRlIGEgTGlua05vZGUgaWYgdGhlIFVSTCBpcyBudWxsLFxuICogYnV0IHNhdmVzIGFueSBjaGlsZHJlbiBhbmQgYnJpbmdzIHRoZW0gdXAgdG8gdGhlIHBhcmVudCBub2RlLlxuICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdGhlIGxpbmsgZGlyZWN0cyB0by5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIC0gT3B0aW9uYWwgSFRNTCBhIHRhZyBhdHRyaWJ1dGVzLiBcXFxceyB0YXJnZXQsIHJlbCwgdGl0bGUgXFxcXH1cbiAqL1xuZnVuY3Rpb24gJHRvZ2dsZUxpbmsodXJsLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHRhcmdldCxcbiAgICB0aXRsZVxuICB9ID0gYXR0cmlidXRlcztcbiAgY29uc3QgcmVsID0gYXR0cmlidXRlcy5yZWwgPT09IHVuZGVmaW5lZCA/ICdub3JlZmVycmVyJyA6IGF0dHJpYnV0ZXMucmVsO1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwgfHwgISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgISRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGFsbCBzZWxlY3RlZCBub2Rlc1xuICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICBpZiAodXJsID09PSBudWxsKSB7XG4gICAgICAgIC8vIFJlbW92ZSBsaW5rXG4gICAgICAgIGNvbnN0IGxpbmtQYXJlbnQgPSAkZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsIHBhcmVudCA9PiAhJGlzQXV0b0xpbmtOb2RlKHBhcmVudCkgJiYgJGlzTGlua05vZGUocGFyZW50KSk7XG4gICAgICAgIGlmIChsaW5rUGFyZW50KSB7XG4gICAgICAgICAgbGlua1BhcmVudC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gICAgICAgICAgaWYgKGxpbmtQYXJlbnQuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxpbmtQYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGQvVXBkYXRlIGxpbmtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdMaW5rID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCBwYXJlbnQgPT4gISRpc0F1dG9MaW5rTm9kZShwYXJlbnQpICYmICRpc0xpbmtOb2RlKHBhcmVudCkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdMaW5rKSB7XG4gICAgICAgICAgZXhpc3RpbmdMaW5rLnNldFVSTCh1cmwpO1xuICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXhpc3RpbmdMaW5rLnNldFRhcmdldCh0YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nTGluay5zZXRSZWwocmVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUodXJsLCB7XG4gICAgICAgICAgICByZWwsXG4gICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShsaW5rTm9kZSk7XG4gICAgICAgICAgbGlua05vZGUuYXBwZW5kKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSGFuZGxlIFJhbmdlU2VsZWN0aW9uXG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmV4dHJhY3QoKTtcbiAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgIC8vIFJlbW92ZSBMaW5rTm9kZXNcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgY29uc3QgcGFyZW50TGluayA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgcGFyZW50ID0+ICEkaXNBdXRvTGlua05vZGUocGFyZW50KSAmJiAkaXNMaW5rTm9kZShwYXJlbnQpKTtcbiAgICAgIGlmIChwYXJlbnRMaW5rKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50TGluay5nZXRDaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGFyZW50TGluay5pbnNlcnRCZWZvcmUoY2hpbGRyZW5baV0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudExpbmsucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVwZGF0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgdXBkYXRlTGlua05vZGUgPSBsaW5rTm9kZSA9PiB7XG4gICAgaWYgKHVwZGF0ZWROb2Rlcy5oYXMobGlua05vZGUuZ2V0S2V5KCkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHVwZGF0ZWROb2Rlcy5hZGQobGlua05vZGUuZ2V0S2V5KCkpO1xuICAgIGxpbmtOb2RlLnNldFVSTCh1cmwpO1xuICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGlua05vZGUuc2V0VGFyZ2V0KHRhcmdldCk7XG4gICAgfVxuICAgIGlmIChyZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGlua05vZGUuc2V0UmVsKHJlbCk7XG4gICAgfVxuICAgIGlmICh0aXRsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsaW5rTm9kZS5zZXRUaXRsZSh0aXRsZSk7XG4gICAgfVxuICB9O1xuICAvLyBBZGQgb3IgbWVyZ2UgTGlua05vZGVzXG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBmaXJzdE5vZGUgPSBub2Rlc1swXTtcbiAgICAvLyBpZiB0aGUgZmlyc3Qgbm9kZSBpcyBhIExpbmtOb2RlIG9yIGlmIGl0c1xuICAgIC8vIHBhcmVudCBpcyBhIExpbmtOb2RlLCB3ZSB1cGRhdGUgdGhlIFVSTCwgdGFyZ2V0IGFuZCByZWwuXG4gICAgY29uc3QgbGlua05vZGUgPSAkZ2V0QW5jZXN0b3IoZmlyc3ROb2RlLCAkaXNMaW5rTm9kZSk7XG4gICAgaWYgKGxpbmtOb2RlICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdXBkYXRlTGlua05vZGUobGlua05vZGUpO1xuICAgIH1cbiAgfVxuICAkd2l0aFNlbGVjdGVkTm9kZXMoKCkgPT4ge1xuICAgIGxldCBsaW5rTm9kZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBpZiAoIW5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50TGlua05vZGUgPSAkZ2V0QW5jZXN0b3Iobm9kZSwgJGlzTGlua05vZGUpO1xuICAgICAgaWYgKHBhcmVudExpbmtOb2RlKSB7XG4gICAgICAgIHVwZGF0ZUxpbmtOb2RlKHBhcmVudExpbmtOb2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAvLyBJZ25vcmUgYmxvY2sgbm9kZXMsIGlmIHRoZXJlIGFyZSBhbnkgY2hpbGRyZW4gd2Ugd2lsbCBzZWUgdGhlbVxuICAgICAgICAgIC8vIGxhdGVyIGFuZCB3cmFwIGluIGEgbmV3IExpbmtOb2RlXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRpc0xpbmtOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBub3QgYW4gYXV0b2xpbmsgbm9kZSBhbmQgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGEgTGlua05vZGVcbiAgICAgICAgICAvLyBpbiB0aGlzIGJsb2NrIHRoZW4gd2UgY2FuIHVwZGF0ZSBpdCBhbmQgcmUtdXNlIGl0XG4gICAgICAgICAgaWYgKCEkaXNBdXRvTGlua05vZGUobm9kZSkgJiYgKGxpbmtOb2RlID09PSBudWxsIHx8ICFsaW5rTm9kZS5nZXRQYXJlbnRPclRocm93KCkuaXNQYXJlbnRPZihub2RlKSkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUxpbmtOb2RlKG5vZGUpO1xuICAgICAgICAgICAgbGlua05vZGUgPSBub2RlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVud3JhcCBMaW5rTm9kZSwgd2UgYWxyZWFkeSBoYXZlIG9uZSBvciBpdCdzIGFuIEF1dG9MaW5rTm9kZVxuICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2Ygbm9kZS5nZXRDaGlsZHJlbigpKSB7XG4gICAgICAgICAgICBub2RlLmluc2VydEJlZm9yZShjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZMaW5rTm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzTGlua05vZGUocHJldkxpbmtOb2RlKSAmJiBwcmV2TGlua05vZGUuaXMobGlua05vZGUpKSB7XG4gICAgICAgIHByZXZMaW5rTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGlua05vZGUgPSAkY3JlYXRlTGlua05vZGUodXJsLCB7XG4gICAgICAgIHJlbCxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB0aXRsZVxuICAgICAgfSk7XG4gICAgICBub2RlLmluc2VydEFmdGVyKGxpbmtOb2RlKTtcbiAgICAgIGxpbmtOb2RlLmFwcGVuZChub2RlKTtcbiAgICB9XG4gIH0pO1xufVxuLyoqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICR0b2dnbGVMaW5rfSBieSBAbGV4aWNhbC9lc2xpbnQtcGx1Z2luIHJ1bGVzLW9mLWxleGljYWwgKi9cbmNvbnN0IHRvZ2dsZUxpbmsgPSAkdG9nZ2xlTGluaztcbmZ1bmN0aW9uICRnZXRBbmNlc3Rvcihub2RlLCBwcmVkaWNhdGUpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGU7XG4gIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LmdldFBhcmVudCgpICE9PSBudWxsICYmICFwcmVkaWNhdGUocGFyZW50KSkge1xuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gIH1cbiAgcmV0dXJuIHByZWRpY2F0ZShwYXJlbnQpID8gcGFyZW50IDogbnVsbDtcbn1cbmNvbnN0IFBIT05FX05VTUJFUl9SRUdFWCA9IC9eXFwrP1swLTlcXHMoKS1dezUsfSQvO1xuXG4vKipcbiAqIEZvcm1hdHMgYSBVUkwgc3RyaW5nIGJ5IGFkZGluZyBhcHByb3ByaWF0ZSBwcm90b2NvbCBpZiBtaXNzaW5nXG4gKlxuICogQHBhcmFtIHVybCAtIFVSTCB0byBmb3JtYXRcbiAqIEByZXR1cm5zIEZvcm1hdHRlZCBVUkwgd2l0aCBhcHByb3ByaWF0ZSBwcm90b2NvbFxuICovXG5mdW5jdGlvbiBmb3JtYXRVcmwodXJsKSB7XG4gIC8vIENoZWNrIGlmIFVSTCBhbHJlYWR5IGhhcyBhIHByb3RvY29sXG4gIGlmICh1cmwubWF0Y2goL15bYS16XVthLXowLTkrLi1dKjovaSkpIHtcbiAgICAvLyBVUkwgYWxyZWFkeSBoYXMgYSBwcm90b2NvbCwgbGVhdmUgaXQgYXMgaXNcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIC8vIENoZWNrIGlmIGl0J3MgYSByZWxhdGl2ZSBwYXRoIChzdGFydGluZyB3aXRoICcvJywgJy4nLCBvciAnIycpXG4gIGVsc2UgaWYgKHVybC5tYXRjaCgvXlsvIy5dLykpIHtcbiAgICAvLyBSZWxhdGl2ZSBwYXRoLCBsZWF2ZSBpdCBhcyBpc1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgZW1haWwgYWRkcmVzc1xuICBlbHNlIGlmICh1cmwuaW5jbHVkZXMoJ0AnKSkge1xuICAgIHJldHVybiBgbWFpbHRvOiR7dXJsfWA7XG4gIH1cblxuICAvLyBDaGVjayBmb3IgcGhvbmUgbnVtYmVyXG4gIGVsc2UgaWYgKFBIT05FX05VTUJFUl9SRUdFWC50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gYHRlbDoke3VybH1gO1xuICB9XG5cbiAgLy8gRm9yIGV2ZXJ5dGhpbmcgZWxzZSwgcmV0dXJuIHdpdGggaHR0cHM6Ly8gcHJlZml4XG4gIHJldHVybiBgaHR0cHM6Ly8ke3VybH1gO1xufVxuXG5leHBvcnQgeyAkY3JlYXRlQXV0b0xpbmtOb2RlLCAkY3JlYXRlTGlua05vZGUsICRpc0F1dG9MaW5rTm9kZSwgJGlzTGlua05vZGUsICR0b2dnbGVMaW5rLCBBdXRvTGlua05vZGUsIExpbmtOb2RlLCBUT0dHTEVfTElOS19DT01NQU5ELCBmb3JtYXRVcmwsIHRvZ2dsZUxpbmsgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lexical/link/LexicalLink.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/list/LexicalList.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/list/LexicalList.dev.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createListItemNode: function() { return /* binding */ $createListItemNode; },\n/* harmony export */   $createListNode: function() { return /* binding */ $createListNode; },\n/* harmony export */   $getListDepth: function() { return /* binding */ $getListDepth; },\n/* harmony export */   $handleListInsertParagraph: function() { return /* binding */ $handleListInsertParagraph; },\n/* harmony export */   $insertList: function() { return /* binding */ $insertList; },\n/* harmony export */   $isListItemNode: function() { return /* binding */ $isListItemNode; },\n/* harmony export */   $isListNode: function() { return /* binding */ $isListNode; },\n/* harmony export */   $removeList: function() { return /* binding */ $removeList; },\n/* harmony export */   INSERT_CHECK_LIST_COMMAND: function() { return /* binding */ INSERT_CHECK_LIST_COMMAND; },\n/* harmony export */   INSERT_ORDERED_LIST_COMMAND: function() { return /* binding */ INSERT_ORDERED_LIST_COMMAND; },\n/* harmony export */   INSERT_UNORDERED_LIST_COMMAND: function() { return /* binding */ INSERT_UNORDERED_LIST_COMMAND; },\n/* harmony export */   ListItemNode: function() { return /* binding */ ListItemNode; },\n/* harmony export */   ListNode: function() { return /* binding */ ListNode; },\n/* harmony export */   REMOVE_LIST_COMMAND: function() { return /* binding */ REMOVE_LIST_COMMAND; },\n/* harmony export */   UPDATE_LIST_START_COMMAND: function() { return /* binding */ UPDATE_LIST_START_COMMAND; },\n/* harmony export */   insertList: function() { return /* binding */ insertList; },\n/* harmony export */   registerCheckList: function() { return /* binding */ registerCheckList; },\n/* harmony export */   registerList: function() { return /* binding */ registerList; },\n/* harmony export */   registerListStrictIndentTransform: function() { return /* binding */ registerListStrictIndentTransform; },\n/* harmony export */   removeList: function() { return /* binding */ removeList; }\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction $insertList(listType) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection !== null) {\n    let nodes = selection.getNodes();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        formatDevErrorMessage(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNode)) {\n        const firstChild = anchorNode.getFirstChild();\n        if (firstChild) {\n          nodes = firstChild.selectStart().getNodes();\n        } else {\n          const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n          anchorNode.append(paragraph);\n          nodes = paragraph.select().getNodes();\n        }\n      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      }\n    }\n    const handled = new Set();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n        $createListOrMerge(node, listType);\n        continue;\n      }\n      let parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;\n      while (parent != null) {\n        const parentKey = parent.getKey();\n        if ($isListNode(parent)) {\n          if (!handled.has(parentKey)) {\n            const newListNode = $createListNode(listType);\n            append(newListNode, parent.getChildren());\n            parent.replace(newListNode);\n            handled.add(parentKey);\n          }\n          break;\n        } else {\n          const nextParent = parent.getParent();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(nextParent) && !handled.has(parentKey)) {\n            handled.add(parentKey);\n            $createListOrMerge(parent, listType);\n            break;\n          }\n          parent = nextParent;\n        }\n      }\n    }\n  }\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n */\nfunction $removeList() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const listNodes = new Set();\n    const nodes = selection.getNodes();\n    const anchorNode = selection.anchor.getNode();\n    if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n      listNodes.add($getTopListNode(anchorNode));\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node)) {\n          const listItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestNodeOfType)(node, ListItemNode);\n          if (listItemNode != null) {\n            listNodes.add($getTopListNode(listItemNode));\n          }\n        }\n      }\n    }\n    for (const listNode of listNodes) {\n      let insertionPoint = listNode;\n      const listItems = $getAllListItems(listNode);\n      for (const listItemNode of listItems) {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().setTextStyle(selection.style).setTextFormat(selection.format);\n        append(paragraph, listItemNode.getChildren());\n        insertionPoint.insertAfter(paragraph);\n        insertionPoint = paragraph;\n\n        // When the anchor and focus fall on the textNode\n        // we don't have to change the selection because the textNode will be appended to\n        // the newly generated paragraph.\n        // When selection is in empty nested list item, selection is actually on the listItemNode.\n        // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n        // we should manually set the selection's focus and anchor to the newly generated paragraph.\n        if (listItemNode.__key === selection.anchor.key) {\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(paragraph, 'next')));\n        }\n        if (listItemNode.__key === selection.focus.key) {\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(paragraph, 'next')));\n        }\n        listItemNode.remove();\n      }\n      listNode.remove();\n    }\n  }\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());\n      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted successfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(grandparent)) {\n    replacementNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\nfunction applyMarkerStyles(dom, node, prevNode) {\n  const styles = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.getStyleObjectFromCSS)(node.__textStyle);\n  for (const k in styles) {\n    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);\n  }\n  if (prevNode) {\n    for (const k in (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.getStyleObjectFromCSS)(prevNode.__textStyle)) {\n      if (!(k in styles)) {\n        dom.style.removeProperty(`--listitem-marker-${k}`);\n      }\n    }\n  }\n}\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('listitem', {\n      $transform: node => {\n        if (node.__checked == null) {\n          return;\n        }\n        const parent = node.getParent();\n        if ($isListNode(parent)) {\n          if (parent.getListType() !== 'check' && node.getChecked() != null) {\n            node.setChecked(undefined);\n          }\n        }\n      },\n      extends: lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode,\n      importDOM: (0,lexical__WEBPACK_IMPORTED_MODULE_0__.buildImportMap)({\n        li: () => ({\n          conversion: $convertListItemElement,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(value = 1, checked = undefined, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__value = prevNode.__value;\n    this.__checked = prevNode.__checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    this.updateListItemDOM(null, element, config);\n    return element;\n  }\n  updateListItemDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    const prevStyle = prevNode ? prevNode.__style : '';\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      if (nextStyle === '') {\n        dom.removeAttribute('style');\n      } else {\n        dom.style.cssText = nextStyle;\n      }\n    }\n    applyMarkerStyles(dom, this, prevNode);\n  }\n  updateDOM(prevNode, dom, config) {\n    // @ts-expect-error - this is always HTMLListItemElement\n    const element = dom;\n    this.updateListItemDOM(prevNode, element, config);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    const formatType = this.getFormatType();\n    if (formatType) {\n      element.style.textAlign = formatType;\n    }\n    const direction = this.getDirection();\n    if (direction) {\n      element.dir = direction;\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(replaceWithNode)) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null || !this.isAttached()) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      formatDevErrorMessage(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      formatDevErrorMessage(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node);\n  }\n  extractWithChild(child, selection) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('list', {\n      $transform: node => {\n        mergeNextSiblingListIfSameType(node);\n        updateChildrenListItemValue(node);\n      },\n      extends: lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode,\n      importDOM: (0,lexical__WEBPACK_IMPORTED_MODULE_0__.buildImportMap)({\n        ol: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        }),\n        ul: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__listType = prevNode.__listType;\n    this.__tag = prevNode.__tag;\n    this.__start = prevNode.__start;\n  }\n  getTag() {\n    return this.getLatest().__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.getLatest().__listType;\n  }\n  getStart() {\n    return this.getLatest().__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    let listItemNodesToInsert = nodesToInsert;\n    for (let i = 0; i < nodesToInsert.length; i++) {\n      const node = nodesToInsert[i];\n      if (!$isListItemNode(node)) {\n        if (listItemNodesToInsert === nodesToInsert) {\n          listItemNodesToInsert = [...nodesToInsert];\n        }\n        listItemNodesToInsert[i] = $createListItemNode().append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !($isListNode(node) || node.isInline()) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent()) : node);\n      }\n    }\n    return super.splice(start, deleteCount, listItemNodesToInsert);\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_CHECK_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_CHECK_LIST_COMMAND');\nfunction registerCheckList(editor) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {\n    $insertList('check');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, () => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null) {\n      const rootElement = editor.getRootElement();\n      if (rootElement != null) {\n        rootElement.focus();\n      }\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_SPACE_COMMAND, event => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null && editor.isEditable()) {\n      editor.update(() => {\n        const listItemNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(activeItem);\n        if ($isListItemNode(listItemNode)) {\n          event.preventDefault();\n          listItemNode.toggleChecked();\n        }\n      });\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => {\n    return editor.getEditorState().read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n        const {\n          anchor\n        } = selection;\n        const isElement = anchor.type === 'element';\n        if (isElement || anchor.offset === 0) {\n          const anchorNode = anchor.getNode();\n          const elementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n          if ($isListItemNode(elementNode)) {\n            const parent = elementNode.getParent();\n            if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n              const domNode = editor.getElementByKey(elementNode.__key);\n              if (domNode != null && document.activeElement !== domNode) {\n                domNode.focus();\n                event.preventDefault();\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', handleClick);\n      rootElement.addEventListener('pointerdown', handlePointerDown);\n    }\n    if (prevElement !== null) {\n      prevElement.removeEventListener('click', handleClick);\n      prevElement.removeEventListener('pointerdown', handlePointerDown);\n    }\n  }));\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (!(0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const zoom = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.calculateZoomLevel)(target);\n  const clientX = event.clientX / zoom;\n\n  // Use getComputedStyle if available, otherwise fallback to 0px width\n  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {\n    width: '0px'\n  };\n  const beforeWidthInPixels = parseFloat(beforeStyles.width);\n\n  // Make click area slightly larger for touch devices to improve accessibility\n  const isTouchEvent = event.pointerType === 'touch';\n  const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events\n\n  if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(event.target)) {\n      const domNode = event.target;\n      const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getNearestEditorFromDOMNode)(domNode);\n      if (editor != null && editor.isEditable()) {\n        editor.update(() => {\n          const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domNode);\n          if ($isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        });\n      }\n    }\n  });\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!$isListNode(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrowUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(activeItem);\n      if (!$isListItemNode(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst UPDATE_LIST_START_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('UPDATE_LIST_START_COMMAND');\nconst INSERT_UNORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_ORDERED_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    $insertList('number');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(UPDATE_LIST_START_COMMAND, payload => {\n    const {\n      listNodeKey,\n      newStart\n    } = payload;\n    const listNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(listNodeKey);\n    if (!$isListNode(listNode)) {\n      return false;\n    }\n    if (listNode.getListType() === 'number') {\n      listNode.setStart(newStart);\n      updateChildrenListItemValue(listNode);\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList('bullet');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    $removeList();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => $handleListInsertParagraph(), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerNodeTransform(ListItemNode, node => {\n    const firstChild = node.getFirstChild();\n    if (firstChild) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild)) {\n        const style = firstChild.getStyle();\n        const format = firstChild.getFormat();\n        if (node.getTextStyle() !== style) {\n          node.setTextStyle(style);\n        }\n        if (node.getTextFormat() !== format) {\n          node.setTextFormat(format);\n        }\n      }\n    } else {\n      // If it's empty, check the selection\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {\n        node.setTextStyle(selection.style).setTextFormat(selection.format);\n      }\n    }\n  }), editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, node => {\n    const listItemParentNode = node.getParent();\n    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {\n      const style = node.getStyle();\n      const format = node.getFormat();\n      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {\n        listItemParentNode.setTextStyle(style).setTextFormat(format);\n      }\n    }\n  }));\n  return removeListener;\n}\nfunction registerListStrictIndentTransform(editor) {\n  const $formatListIndentStrict = listItemNode => {\n    const listNode = listItemNode.getParent();\n    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {\n      return;\n    }\n    const startingListItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(listItemNode, node => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));\n    if (startingListItemNode === null && listItemNode.getIndent() > 0) {\n      listItemNode.setIndent(0);\n    } else if ($isListItemNode(startingListItemNode)) {\n      const prevListItemNode = startingListItemNode.getPreviousSibling();\n      if ($isListItemNode(prevListItemNode)) {\n        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);\n        const endListNode = endListItemNode.getParent();\n        if ($isListNode(endListNode)) {\n          const prevDepth = $getListDepth(endListNode);\n          const depth = $getListDepth(listNode);\n          if (prevDepth + 1 < depth) {\n            listItemNode.setIndent(prevDepth);\n          }\n        }\n      }\n    }\n  };\n  const $processListWithStrictIndent = listNode => {\n    const queue = [listNode];\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (!$isListNode(node)) {\n        continue;\n      }\n      for (const child of node.getChildren()) {\n        if ($isListItemNode(child)) {\n          $formatListIndentStrict(child);\n          const firstChild = child.getFirstChild();\n          if ($isListNode(firstChild)) {\n            queue.push(firstChild);\n          }\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);\n}\nfunction $findChildrenEndListItemNode(listItemNode) {\n  let current = listItemNode;\n  let firstChild = current.getFirstChild();\n  while ($isListNode(firstChild)) {\n    const lastChild = firstChild.getLastChild();\n    if ($isListItemNode(lastChild)) {\n      current = lastChild;\n      firstChild = current.getFirstChild();\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n\n/**\n * @deprecated use {@link $insertList} from an update or command listener.\n *\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => $insertList(listType));\n}\n\n/**\n * @deprecated use {@link $removeList} from an update or command listener.\n *\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => $removeList());\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbGlzdC9MZXhpY2FsTGlzdC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1MO0FBQ3VXO0FBQy9kOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFhO0FBQ2pDO0FBQ0E7QUFDQSxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw0QkFBNEIsNkRBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFlBQVksNERBQW1CO0FBQy9CO0FBQ0E7QUFDQSxjQUFjLHVEQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsVUFBVSx1REFBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQVc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxjQUFjLDREQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFhO0FBQ2pDLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBLFlBQVksb0RBQVc7QUFDdkIsK0JBQStCLHFFQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2REFBb0I7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyREFBa0IsbUJBQW1CLHdEQUFlLENBQUMsdURBQWM7QUFDN0U7QUFDQTtBQUNBLFVBQVUsMkRBQWtCLGtCQUFrQix3REFBZSxDQUFDLHVEQUFjO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQyxPQUFPLDBEQUFpQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw0REFBbUI7QUFDekIsc0JBQXNCLDZEQUFvQjtBQUMxQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIseUVBQXFCO0FBQ3RDO0FBQ0EsK0NBQStDLEVBQUU7QUFDakQ7QUFDQTtBQUNBLG9CQUFvQix5RUFBcUI7QUFDekM7QUFDQSxzREFBc0QsRUFBRTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixnREFBVztBQUN0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxlQUFlLGdEQUFXO0FBQzFCLGlCQUFpQix1REFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EsVUFBVSx1REFBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx1REFBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDZEQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHlEQUFnQjtBQUNwRDtBQUNBO0FBQ0EsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJFQUEyQjtBQUMvQjtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGdEQUFXO0FBQ2xDOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxlQUFlLGdEQUFXO0FBQzFCLGlCQUFpQix1REFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkRBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHVEQUFjLG9EQUFvRCx3REFBZTtBQUNqSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDJFQUEyQjtBQUMvQjtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw2REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxzREFBYTtBQUMvQztBQUNBLFNBQVMsNkRBQWE7QUFDdEI7QUFDQTtBQUNBLEdBQUcsRUFBRSx5REFBb0IsMEJBQTBCLDJEQUFzQjtBQUN6RTtBQUNBLEdBQUcsRUFBRSx5REFBb0IsMEJBQTBCLHlEQUFvQjtBQUN2RTtBQUNBLEdBQUcsRUFBRSx5REFBb0IsMEJBQTBCLHVEQUFrQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUseURBQW9CLDBCQUEwQixzREFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1FQUEwQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUseURBQW9CLDBCQUEwQiwyREFBc0I7QUFDekU7QUFDQSx3QkFBd0Isc0RBQWE7QUFDckMsVUFBVSwwREFBaUI7QUFDM0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUVBQW1CLHFCQUFxQix1REFBYztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsRUFBRSx5REFBb0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxPQUFPLDZEQUFhO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sNkRBQWE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtFQUFrQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkRBQWE7QUFDckI7QUFDQSxxQkFBcUIsb0VBQTJCO0FBQ2hEO0FBQ0E7QUFDQSx1QkFBdUIsbUVBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUVBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLHNEQUFhO0FBQy9DLHNDQUFzQyxzREFBYTtBQUNuRCxvQ0FBb0Msc0RBQWE7QUFDakQsNEJBQTRCLHNEQUFhO0FBQ3pDO0FBQ0EseUJBQXlCLDZEQUFhO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHLEVBQUUseURBQW9CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQkFBcUIsc0RBQWE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSx5REFBb0I7QUFDekI7QUFDQTtBQUNBLEdBQUcsRUFBRSx5REFBb0I7QUFDekI7QUFDQTtBQUNBLEdBQUcsRUFBRSx5REFBb0IsMEJBQTBCLDZEQUF3QixzQ0FBc0MseURBQW9CO0FBQ3JJO0FBQ0E7QUFDQSxVQUFVLG9EQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHdCQUF3QixzREFBYTtBQUNyQyxVQUFVLDBEQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdDQUFnQyw2Q0FBUTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUVBQW1CO0FBQ3BEO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOFkiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpc3QvTGV4aWNhbExpc3QuZGV2Lm1qcz9hMzM2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdldE5lYXJlc3ROb2RlT2ZUeXBlLCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIG1lcmdlUmVnaXN0ZXIsICRmaW5kTWF0Y2hpbmdQYXJlbnQsIGNhbGN1bGF0ZVpvb21MZXZlbCB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7ICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNSb290T3JTaGFkb3dSb290LCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGlzRWxlbWVudE5vZGUsICRpc0xlYWZOb2RlLCAkc2V0UG9pbnRGcm9tQ2FyZXQsICRub3JtYWxpemVDYXJldCwgJGdldENoaWxkQ2FyZXQsIEVsZW1lbnROb2RlLCBidWlsZEltcG9ydE1hcCwgJGlzUGFyYWdyYXBoTm9kZSwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCAkY3JlYXRlVGV4dE5vZGUsIGNyZWF0ZUNvbW1hbmQsIENPTU1BTkRfUFJJT1JJVFlfTE9XLCBLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBLRVlfQVJST1dfVVBfQ09NTUFORCwgS0VZX0VTQ0FQRV9DT01NQU5ELCBLRVlfU1BBQ0VfQ09NTUFORCwgJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUsIEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGdldE5lYXJlc3RFZGl0b3JGcm9tRE9NTm9kZSwgJGdldE5vZGVCeUtleSwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAkaXNUZXh0Tm9kZSwgVGV4dE5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IGdldFN0eWxlT2JqZWN0RnJvbUNTUyB9IGZyb20gJ0BsZXhpY2FsL3NlbGVjdGlvbic7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMuXG5cbmZ1bmN0aW9uIGZvcm1hdERldkVycm9yTWVzc2FnZShtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdGhlIGRlcHRoIG9mIGxpc3ROb2RlIGZyb20gdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBsaXN0Tm9kZSAtIFRoZSBMaXN0Tm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVGhlIGRlcHRoIG9mIHRoZSBMaXN0Tm9kZS5cbiAqL1xuZnVuY3Rpb24gJGdldExpc3REZXB0aChsaXN0Tm9kZSkge1xuICBsZXQgZGVwdGggPSAxO1xuICBsZXQgcGFyZW50ID0gbGlzdE5vZGUuZ2V0UGFyZW50KCk7XG4gIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocGFyZW50KSkge1xuICAgICAgY29uc3QgcGFyZW50TGlzdCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnRMaXN0KSkge1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnRMaXN0LmdldFBhcmVudCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZXB0aDtcbiAgfVxuICByZXR1cm4gZGVwdGg7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5lYXJlc3QgYW5jZXN0cmFsIExpc3ROb2RlIGFuZCByZXR1cm5zIGl0LCB0aHJvd3MgYW4gaW52YXJpYW50IGlmIGxpc3RJdGVtIGlzIG5vdCBhIExpc3RJdGVtTm9kZS5cbiAqIEBwYXJhbSBsaXN0SXRlbSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyBUaGUgTGlzdE5vZGUgZm91bmQuXG4gKi9cbmZ1bmN0aW9uICRnZXRUb3BMaXN0Tm9kZShsaXN0SXRlbSkge1xuICBsZXQgbGlzdCA9IGxpc3RJdGVtLmdldFBhcmVudCgpO1xuICBpZiAoISRpc0xpc3ROb2RlKGxpc3QpKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gICAgfVxuICB9XG4gIGxldCBwYXJlbnQgPSBsaXN0O1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBsaXN0ID0gcGFyZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBBIHJlY3Vyc2l2ZSBEZXB0aC1GaXJzdCBTZWFyY2ggKFBvc3RvcmRlciBUcmF2ZXJzYWwpIHRoYXQgZmluZHMgYWxsIG9mIGEgbm9kZSdzIGNoaWxkcmVuXG4gKiB0aGF0IGFyZSBvZiB0eXBlIExpc3RJdGVtTm9kZSBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5LlxuICogQHBhcmFtIG5vZGUgLSBUaGUgTGlzdE5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG5vZGVzIG9mIHR5cGUgTGlzdEl0ZW1Ob2RlIGZvdW5kLlxuICovXG4vLyBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSAkZ2V0QWxsQ2hpbGRyZW5PZlR5cGVcbmZ1bmN0aW9uICRnZXRBbGxMaXN0SXRlbXMobm9kZSkge1xuICBsZXQgbGlzdEl0ZW1Ob2RlcyA9IFtdO1xuICBjb25zdCBsaXN0Q2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCkuZmlsdGVyKCRpc0xpc3RJdGVtTm9kZSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbGlzdEl0ZW1Ob2RlID0gbGlzdENoaWxkcmVuW2ldO1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgbGlzdEl0ZW1Ob2RlcyA9IGxpc3RJdGVtTm9kZXMuY29uY2F0KCRnZXRBbGxMaXN0SXRlbXMoZmlyc3RDaGlsZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0SXRlbU5vZGVzLnB1c2gobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3RJdGVtTm9kZXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgcGFzc2VkIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUgYW5kIGhhcyBhIExpc3ROb2RlIGFzIGEgY2hpbGQuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlIGFuZCBoYXMgYSBMaXN0Tm9kZSBjaGlsZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc05lc3RlZExpc3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiAkaXNMaXN0Tm9kZShub2RlLmdldEZpcnN0Q2hpbGQoKSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBkZWVwbHkgbmVzdGVkIExpc3ROb2RlIG9yIExpc3RJdGVtTm9kZSBhbmQgdHJhdmVyc2VzIHVwIHRoZSBicmFuY2ggdG8gZGVsZXRlIHRoZSBmaXJzdFxuICogYW5jZXN0cmFsIExpc3ROb2RlICh3aGljaCBjb3VsZCBiZSB0aGUgcm9vdCBMaXN0Tm9kZSkgb3IgTGlzdEl0ZW1Ob2RlIHdpdGggc2libGluZ3MsIGVzc2VudGlhbGx5XG4gKiBicmluZ2luZyB0aGUgZGVlcGx5IG5lc3RlZCBub2RlIHVwIHRoZSBicmFuY2ggb25jZS4gV291bGQgcmVtb3ZlIHN1Ymxpc3QgaWYgaXQgaGFzIHNpYmxpbmdzLlxuICogU2hvdWxkIG5vdCBicmVhayBMaXN0SXRlbSAtPiBMaXN0IC0+IExpc3RJdGVtIGNoYWluIGFzIGVtcHR5IExpc3QvSXRlbU5vZGVzIHNob3VsZCBiZSByZW1vdmVkIG9uIC5yZW1vdmUoKS5cbiAqIEBwYXJhbSBzdWJsaXN0IC0gVGhlIG5lc3RlZCBMaXN0Tm9kZSBvciBMaXN0SXRlbU5vZGUgdG8gYmUgYnJvdWdodCB1cCB0aGUgYnJhbmNoLlxuICovXG5mdW5jdGlvbiAkcmVtb3ZlSGlnaGVzdEVtcHR5TGlzdFBhcmVudChzdWJsaXN0KSB7XG4gIC8vIE5vZGVzIG1heSBiZSByZXBlYXRlZGx5IGluZGVudGVkLCB0byBjcmVhdGUgZGVlcGx5IG5lc3RlZCBsaXN0cyB0aGF0IGVhY2hcbiAgLy8gY29udGFpbiBqdXN0IG9uZSBidWxsZXQuXG4gIC8vIE91ciBnb2FsIGlzIHRvIHJlbW92ZSB0aGVzZSAoZW1wdHkpIGRlZXBseSBuZXN0ZWQgbGlzdHMuIFRoZSBlYXNpZXN0XG4gIC8vIHdheSB0byBkbyB0aGF0IGlzIGNyYXdsIGJhY2sgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIG5vZGUgdGhhdCBoYXMgc2libGluZ3NcbiAgLy8gKGUuZy4gaXMgYWN0dWFsbHkgcGFydCBvZiB0aGUgbGlzdCBjb250ZW50cykgYW5kIGRlbGV0ZSB0aGF0LCBvciBkZWxldGVcbiAgLy8gdGhlIHJvb3Qgb2YgdGhlIGxpc3QgKGlmIG5vIGxpc3Qgbm9kZXMgaGF2ZSBzaWJsaW5ncy4pXG4gIGxldCBlbXB0eUxpc3RQdHIgPSBzdWJsaXN0O1xuICB3aGlsZSAoZW1wdHlMaXN0UHRyLmdldE5leHRTaWJsaW5nKCkgPT0gbnVsbCAmJiBlbXB0eUxpc3RQdHIuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT0gbnVsbCkge1xuICAgIGNvbnN0IHBhcmVudCA9IGVtcHR5TGlzdFB0ci5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09IG51bGwgfHwgISgkaXNMaXN0SXRlbU5vZGUocGFyZW50KSB8fCAkaXNMaXN0Tm9kZShwYXJlbnQpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVtcHR5TGlzdFB0ciA9IHBhcmVudDtcbiAgfVxuICBlbXB0eUxpc3RQdHIucmVtb3ZlKCk7XG59XG5cbi8qKlxuICogV3JhcHMgYSBub2RlIGludG8gYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIHdyYXBwZWQgaW50byBhIExpc3RJdGVtTm9kZVxuICogQHJldHVybnMgVGhlIExpc3RJdGVtTm9kZSB3aGljaCB0aGUgcGFzc2VkIG5vZGUgaXMgd3JhcHBlZCBpbi5cbiAqL1xuZnVuY3Rpb24gJHdyYXBJbkxpc3RJdGVtKG5vZGUpIHtcbiAgY29uc3QgbGlzdEl0ZW1XcmFwcGVyID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICByZXR1cm4gbGlzdEl0ZW1XcmFwcGVyLmFwcGVuZChub2RlKTtcbn1cblxuZnVuY3Rpb24gJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2Rlcykge1xuICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKGFuY2hvck5vZGUpICYmIChub2Rlcy5sZW5ndGggPT09IDAgfHwgbm9kZXMubGVuZ3RoID09PSAxICYmIGFuY2hvck5vZGUuaXMobm9kZXNbMF0pICYmIGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApO1xufVxuXG4vKipcbiAqIEluc2VydHMgYSBuZXcgTGlzdE5vZGUuIElmIHRoZSBzZWxlY3Rpb24ncyBhbmNob3Igbm9kZSBpcyBhbiBlbXB0eSBMaXN0SXRlbU5vZGUgYW5kIGlzIGEgY2hpbGQgb2ZcbiAqIHRoZSByb290L3NoYWRvdyByb290LCBpdCB3aWxsIHJlcGxhY2UgdGhlIExpc3RJdGVtTm9kZSB3aXRoIGEgTGlzdE5vZGUgYW5kIHRoZSBvbGQgTGlzdEl0ZW1Ob2RlLlxuICogT3RoZXJ3aXNlIGl0IHdpbGwgcmVwbGFjZSBpdHMgcGFyZW50IHdpdGggYSBuZXcgTGlzdE5vZGUgYW5kIHJlLWluc2VydCB0aGUgTGlzdEl0ZW1Ob2RlIGFuZCBhbnkgcHJldmlvdXMgY2hpbGRyZW4uXG4gKiBJZiB0aGUgc2VsZWN0aW9uJ3MgYW5jaG9yIG5vZGUgaXMgbm90IGFuIGVtcHR5IExpc3RJdGVtTm9kZSwgaXQgd2lsbCBhZGQgYSBuZXcgTGlzdE5vZGUgb3IgbWVyZ2UgYW4gZXhpc3RpbmcgTGlzdE5vZGUsXG4gKiB1bmxlc3MgdGhlIHRoZSBub2RlIGlzIGEgbGVhZiBub2RlLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgYXR0ZW1wdCB0byBmaW5kIGEgTGlzdE5vZGUgdXAgdGhlIGJyYW5jaCBhbmQgcmVwbGFjZSBpdCB3aXRoXG4gKiBhIG5ldyBMaXN0Tm9kZSwgb3IgY3JlYXRlIGEgbmV3IExpc3ROb2RlIGF0IHRoZSBuZWFyZXN0IHJvb3Qvc2hhZG93IHJvb3QuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0LCBcIm51bWJlclwiIHwgXCJidWxsZXRcIiB8IFwiY2hlY2tcIi5cbiAqL1xuZnVuY3Rpb24gJGluc2VydExpc3QobGlzdFR5cGUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgbGV0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gICAgICBpZiAoIShhbmNob3JBbmRGb2N1cyAhPT0gbnVsbCkpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbnNlcnRMaXN0OiBhbmNob3Igc2hvdWxkIGJlIGRlZmluZWRgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFthbmNob3JdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGFuY2hvck5vZGVQYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGFuY2hvck5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgICAgIG5vZGVzID0gZmlyc3RDaGlsZC5zZWxlY3RTdGFydCgpLmdldE5vZGVzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICBhbmNob3JOb2RlLmFwcGVuZChwYXJhZ3JhcGgpO1xuICAgICAgICAgIG5vZGVzID0gcGFyYWdyYXBoLnNlbGVjdCgpLmdldE5vZGVzKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2RlcykpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KGFuY2hvck5vZGVQYXJlbnQpKSB7XG4gICAgICAgICAgYW5jaG9yTm9kZS5yZXBsYWNlKGxpc3QpO1xuICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgbGlzdEl0ZW0uc2V0Rm9ybWF0KGFuY2hvck5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgICAgICAgIGxpc3RJdGVtLnNldEluZGVudChhbmNob3JOb2RlLmdldEluZGVudCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGlzdC5hcHBlbmQobGlzdEl0ZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKCRpc0xpc3RJdGVtTm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICAgIGFwcGVuZChsaXN0LCBwYXJlbnQuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgICAgcGFyZW50LnJlcGxhY2UobGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBoYW5kbGVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzRW1wdHkoKSAmJiAhJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpICYmICFoYW5kbGVkLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgICAkY3JlYXRlTGlzdE9yTWVyZ2Uobm9kZSwgbGlzdFR5cGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBwYXJlbnQgPSAkaXNMZWFmTm9kZShub2RlKSA/IG5vZGUuZ2V0UGFyZW50KCkgOiAkaXNMaXN0SXRlbU5vZGUobm9kZSkgJiYgbm9kZS5pc0VtcHR5KCkgPyBub2RlIDogbnVsbDtcbiAgICAgIHdoaWxlIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnQuZ2V0S2V5KCk7XG4gICAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgaWYgKCFoYW5kbGVkLmhhcyhwYXJlbnRLZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdMaXN0Tm9kZSA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICAgICAgICBhcHBlbmQobmV3TGlzdE5vZGUsIHBhcmVudC5nZXRDaGlsZHJlbigpKTtcbiAgICAgICAgICAgIHBhcmVudC5yZXBsYWNlKG5ld0xpc3ROb2RlKTtcbiAgICAgICAgICAgIGhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IG5leHRQYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QobmV4dFBhcmVudCkgJiYgIWhhbmRsZWQuaGFzKHBhcmVudEtleSkpIHtcbiAgICAgICAgICAgIGhhbmRsZWQuYWRkKHBhcmVudEtleSk7XG4gICAgICAgICAgICAkY3JlYXRlTGlzdE9yTWVyZ2UocGFyZW50LCBsaXN0VHlwZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gbmV4dFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKG5vZGUsIG5vZGVzVG9BcHBlbmQpIHtcbiAgbm9kZS5zcGxpY2Uobm9kZS5nZXRDaGlsZHJlblNpemUoKSwgMCwgbm9kZXNUb0FwcGVuZCk7XG59XG5mdW5jdGlvbiAkY3JlYXRlTGlzdE9yTWVyZ2Uobm9kZSwgbGlzdFR5cGUpIHtcbiAgaWYgKCRpc0xpc3ROb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIGNvbnN0IGxpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICBhcHBlbmQobGlzdEl0ZW0sIG5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gIGxldCB0YXJnZXRMaXN0O1xuICBpZiAoJGlzTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gcHJldmlvdXNTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBwcmV2aW91c1NpYmxpbmcuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAvLyBpZiB0aGUgc2FtZSB0eXBlIG9mIGxpc3QgaXMgb24gYm90aCBzaWRlcywgbWVyZ2UgdGhlbS5cbiAgICBpZiAoJGlzTGlzdE5vZGUobmV4dFNpYmxpbmcpICYmIGxpc3RUeXBlID09PSBuZXh0U2libGluZy5nZXRMaXN0VHlwZSgpKSB7XG4gICAgICBhcHBlbmQocHJldmlvdXNTaWJsaW5nLCBuZXh0U2libGluZy5nZXRDaGlsZHJlbigpKTtcbiAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgIH1cbiAgICB0YXJnZXRMaXN0ID0gcHJldmlvdXNTaWJsaW5nO1xuICB9IGVsc2UgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgIG5leHRTaWJsaW5nLmdldEZpcnN0Q2hpbGRPclRocm93KCkuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtKTtcbiAgICB0YXJnZXRMaXN0ID0gbmV4dFNpYmxpbmc7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgbGlzdC5hcHBlbmQobGlzdEl0ZW0pO1xuICAgIG5vZGUucmVwbGFjZShsaXN0KTtcbiAgICB0YXJnZXRMaXN0ID0gbGlzdDtcbiAgfVxuICAvLyBsaXN0SXRlbSBuZWVkcyB0byBiZSBhdHRhY2hlZCB0byByb290IHByaW9yIHRvIHNldHRpbmcgaW5kZW50XG4gIGxpc3RJdGVtLnNldEZvcm1hdChub2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gIGxpc3RJdGVtLnNldEluZGVudChub2RlLmdldEluZGVudCgpKTtcbiAgbm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIHRhcmdldExpc3Q7XG59XG5cbi8qKlxuICogQSByZWN1cnNpdmUgZnVuY3Rpb24gdGhhdCBnb2VzIHRocm91Z2ggZWFjaCBsaXN0IGFuZCB0aGVpciBjaGlsZHJlbiwgaW5jbHVkaW5nIG5lc3RlZCBsaXN0cyxcbiAqIGFwcGVuZGluZyBsaXN0MiBjaGlsZHJlbiBhZnRlciBsaXN0MSBjaGlsZHJlbiBhbmQgdXBkYXRpbmcgTGlzdEl0ZW1Ob2RlIHZhbHVlcy5cbiAqIEBwYXJhbSBsaXN0MSAtIFRoZSBmaXJzdCBsaXN0IHRvIGJlIG1lcmdlZC5cbiAqIEBwYXJhbSBsaXN0MiAtIFRoZSBzZWNvbmQgbGlzdCB0byBiZSBtZXJnZWQuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTGlzdHMobGlzdDEsIGxpc3QyKSB7XG4gIGNvbnN0IGxpc3RJdGVtMSA9IGxpc3QxLmdldExhc3RDaGlsZCgpO1xuICBjb25zdCBsaXN0SXRlbTIgPSBsaXN0Mi5nZXRGaXJzdENoaWxkKCk7XG4gIGlmIChsaXN0SXRlbTEgJiYgbGlzdEl0ZW0yICYmIGlzTmVzdGVkTGlzdE5vZGUobGlzdEl0ZW0xKSAmJiBpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtMikpIHtcbiAgICBtZXJnZUxpc3RzKGxpc3RJdGVtMS5nZXRGaXJzdENoaWxkKCksIGxpc3RJdGVtMi5nZXRGaXJzdENoaWxkKCkpO1xuICAgIGxpc3RJdGVtMi5yZW1vdmUoKTtcbiAgfVxuICBjb25zdCB0b01lcmdlID0gbGlzdDIuZ2V0Q2hpbGRyZW4oKTtcbiAgaWYgKHRvTWVyZ2UubGVuZ3RoID4gMCkge1xuICAgIGxpc3QxLmFwcGVuZCguLi50b01lcmdlKTtcbiAgfVxuICBsaXN0Mi5yZW1vdmUoKTtcbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0cmFsIExpc3ROb2RlIGFuZCByZW1vdmVzIGl0LiBJZiBzZWxlY3Rpb24gaXMgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlXG4gKiBpdCB3aWxsIHJlbW92ZSB0aGUgd2hvbGUgbGlzdCwgaW5jbHVkaW5nIHRoZSBMaXN0SXRlbU5vZGUuIEZvciBlYWNoIExpc3RJdGVtTm9kZSBpbiB0aGUgTGlzdE5vZGUsXG4gKiByZW1vdmVMaXN0IHdpbGwgYWxzbyBnZW5lcmF0ZSBuZXcgUGFyYWdyYXBoTm9kZXMgaW4gdGhlIHJlbW92ZWQgTGlzdE5vZGUncyBwbGFjZS4gQW55IGNoaWxkIG5vZGVcbiAqIGluc2lkZSBhIExpc3RJdGVtTm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBuZXcgUGFyYWdyYXBoTm9kZXMuXG4gKi9cbmZ1bmN0aW9uICRyZW1vdmVMaXN0KCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3QgbGlzdE5vZGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGlmICgkaXNTZWxlY3RpbmdFbXB0eUxpc3RJdGVtKGFuY2hvck5vZGUsIG5vZGVzKSkge1xuICAgICAgbGlzdE5vZGVzLmFkZCgkZ2V0VG9wTGlzdE5vZGUoYW5jaG9yTm9kZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKCRpc0xlYWZOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgbGlzdEl0ZW1Ob2RlID0gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIExpc3RJdGVtTm9kZSk7XG4gICAgICAgICAgaWYgKGxpc3RJdGVtTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsaXN0Tm9kZXMuYWRkKCRnZXRUb3BMaXN0Tm9kZShsaXN0SXRlbU5vZGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBsaXN0Tm9kZSBvZiBsaXN0Tm9kZXMpIHtcbiAgICAgIGxldCBpbnNlcnRpb25Qb2ludCA9IGxpc3ROb2RlO1xuICAgICAgY29uc3QgbGlzdEl0ZW1zID0gJGdldEFsbExpc3RJdGVtcyhsaXN0Tm9kZSk7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RJdGVtTm9kZSBvZiBsaXN0SXRlbXMpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKS5zZXRUZXh0U3R5bGUoc2VsZWN0aW9uLnN0eWxlKS5zZXRUZXh0Rm9ybWF0KHNlbGVjdGlvbi5mb3JtYXQpO1xuICAgICAgICBhcHBlbmQocGFyYWdyYXBoLCBsaXN0SXRlbU5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgIGluc2VydGlvblBvaW50Lmluc2VydEFmdGVyKHBhcmFncmFwaCk7XG4gICAgICAgIGluc2VydGlvblBvaW50ID0gcGFyYWdyYXBoO1xuXG4gICAgICAgIC8vIFdoZW4gdGhlIGFuY2hvciBhbmQgZm9jdXMgZmFsbCBvbiB0aGUgdGV4dE5vZGVcbiAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byBjaGFuZ2UgdGhlIHNlbGVjdGlvbiBiZWNhdXNlIHRoZSB0ZXh0Tm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRvXG4gICAgICAgIC8vIHRoZSBuZXdseSBnZW5lcmF0ZWQgcGFyYWdyYXBoLlxuICAgICAgICAvLyBXaGVuIHNlbGVjdGlvbiBpcyBpbiBlbXB0eSBuZXN0ZWQgbGlzdCBpdGVtLCBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgb24gdGhlIGxpc3RJdGVtTm9kZS5cbiAgICAgICAgLy8gV2hlbiB0aGUgY29ycmVzcG9uZGluZyBsaXN0SXRlbU5vZGUgaXMgZGVsZXRlZCBhbmQgcmVwbGFjZWQgYnkgdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGhcbiAgICAgICAgLy8gd2Ugc2hvdWxkIG1hbnVhbGx5IHNldCB0aGUgc2VsZWN0aW9uJ3MgZm9jdXMgYW5kIGFuY2hvciB0byB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaC5cbiAgICAgICAgaWYgKGxpc3RJdGVtTm9kZS5fX2tleSA9PT0gc2VsZWN0aW9uLmFuY2hvci5rZXkpIHtcbiAgICAgICAgICAkc2V0UG9pbnRGcm9tQ2FyZXQoc2VsZWN0aW9uLmFuY2hvciwgJG5vcm1hbGl6ZUNhcmV0KCRnZXRDaGlsZENhcmV0KHBhcmFncmFwaCwgJ25leHQnKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0SXRlbU5vZGUuX19rZXkgPT09IHNlbGVjdGlvbi5mb2N1cy5rZXkpIHtcbiAgICAgICAgICAkc2V0UG9pbnRGcm9tQ2FyZXQoc2VsZWN0aW9uLmZvY3VzLCAkbm9ybWFsaXplQ2FyZXQoJGdldENoaWxkQ2FyZXQocGFyYWdyYXBoLCAnbmV4dCcpKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlzdEl0ZW1Ob2RlLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgbGlzdE5vZGUucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGFrZXMgdGhlIHZhbHVlIG9mIGEgY2hpbGQgTGlzdEl0ZW1Ob2RlIGFuZCBtYWtlcyBpdCB0aGUgdmFsdWUgdGhlIExpc3RJdGVtTm9kZVxuICogc2hvdWxkIGJlIGlmIGl0IGlzbid0IGFscmVhZHkuIEFsc28gZW5zdXJlcyB0aGF0IGNoZWNrZWQgaXMgdW5kZWZpbmVkIGlmIHRoZVxuICogcGFyZW50IGRvZXMgbm90IGhhdmUgYSBsaXN0IHR5cGUgb2YgJ2NoZWNrJy5cbiAqIEBwYXJhbSBsaXN0IC0gVGhlIGxpc3Qgd2hvc2UgY2hpbGRyZW4gYXJlIHVwZGF0ZWQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuTGlzdEl0ZW1WYWx1ZShsaXN0KSB7XG4gIGNvbnN0IGlzTm90Q2hlY2tsaXN0ID0gbGlzdC5nZXRMaXN0VHlwZSgpICE9PSAnY2hlY2snO1xuICBsZXQgdmFsdWUgPSBsaXN0LmdldFN0YXJ0KCk7XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgbGlzdC5nZXRDaGlsZHJlbigpKSB7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShjaGlsZCkpIHtcbiAgICAgIGlmIChjaGlsZC5nZXRWYWx1ZSgpICE9PSB2YWx1ZSkge1xuICAgICAgICBjaGlsZC5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNOb3RDaGVja2xpc3QgJiYgY2hpbGQuZ2V0TGF0ZXN0KCkuX19jaGVja2VkICE9IG51bGwpIHtcbiAgICAgICAgY2hpbGQuc2V0Q2hlY2tlZCh1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgaWYgKCEkaXNMaXN0Tm9kZShjaGlsZC5nZXRGaXJzdENoaWxkKCkpKSB7XG4gICAgICAgIHZhbHVlKys7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWVyZ2UgdGhlIG5leHQgc2libGluZyBsaXN0IGlmIHNhbWUgdHlwZS5cbiAqIDx1bD4gd2lsbCBtZXJnZSB3aXRoIDx1bD4sIGJ1dCBOT1QgPHVsPiB3aXRoIDxvbD4uXG4gKiBAcGFyYW0gbGlzdCAtIFRoZSBsaXN0IHdob3NlIG5leHQgc2libGluZyBzaG91bGQgYmUgcG90ZW50aWFsbHkgbWVyZ2VkXG4gKi9cbmZ1bmN0aW9uIG1lcmdlTmV4dFNpYmxpbmdMaXN0SWZTYW1lVHlwZShsaXN0KSB7XG4gIGNvbnN0IG5leHRTaWJsaW5nID0gbGlzdC5nZXROZXh0U2libGluZygpO1xuICBpZiAoJGlzTGlzdE5vZGUobmV4dFNpYmxpbmcpICYmIGxpc3QuZ2V0TGlzdFR5cGUoKSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgIG1lcmdlTGlzdHMobGlzdCwgbmV4dFNpYmxpbmcpO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBhbiBlbXB0eSBMaXN0Tm9kZS9MaXN0SXRlbU5vZGUgY2hhaW4gYXQgbGlzdEl0ZW1Ob2RlLCBzbyBhcyB0b1xuICogY3JlYXRlIGFuIGluZGVudCBlZmZlY3QuIFdvbid0IGluZGVudCBMaXN0SXRlbU5vZGVzIHRoYXQgaGF2ZSBhIExpc3ROb2RlIGFzXG4gKiBhIGNoaWxkLCBidXQgZG9lcyBtZXJnZSBzaWJsaW5nIExpc3RJdGVtTm9kZXMgaWYgb25lIGhhcyBhIG5lc3RlZCBMaXN0Tm9kZS5cbiAqIEBwYXJhbSBsaXN0SXRlbU5vZGUgLSBUaGUgTGlzdEl0ZW1Ob2RlIHRvIGJlIGluZGVudGVkLlxuICovXG5mdW5jdGlvbiAkaGFuZGxlSW5kZW50KGxpc3RJdGVtTm9kZSkge1xuICAvLyBnbyB0aHJvdWdoIGVhY2ggbm9kZSBhbmQgZGVjaWRlIHdoZXJlIHRvIG1vdmUgaXQuXG4gIGNvbnN0IHJlbW92ZWQgPSBuZXcgU2V0KCk7XG4gIGlmIChpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtTm9kZSkgfHwgcmVtb3ZlZC5oYXMobGlzdEl0ZW1Ob2RlLmdldEtleSgpKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYXJlbnQgPSBsaXN0SXRlbU5vZGUuZ2V0UGFyZW50KCk7XG5cbiAgLy8gV2UgY2FuIGNhc3QgYm90aCBvZiB0aGUgYmVsb3cgYGlzTmVzdGVkTGlzdE5vZGVgIG9ubHkgcmV0dXJucyBhIGJvb2xlYW4gdHlwZSBpbnN0ZWFkIG9mIGEgdXNlci1kZWZpbmVkIHR5cGUgZ3VhcmRzXG4gIGNvbnN0IG5leHRTaWJsaW5nID0gbGlzdEl0ZW1Ob2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIGNvbnN0IHByZXZpb3VzU2libGluZyA9IGxpc3RJdGVtTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgLy8gaWYgdGhlcmUgYXJlIG5lc3RlZCBsaXN0cyBvbiBlaXRoZXIgc2lkZSwgbWVyZ2UgdGhlbSBhbGwgdG9nZXRoZXIuXG5cbiAgaWYgKGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpICYmIGlzTmVzdGVkTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgIGNvbnN0IGlubmVyTGlzdCA9IHByZXZpb3VzU2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGlubmVyTGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGNvbnN0IG5leHRJbm5lckxpc3QgPSBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoJGlzTGlzdE5vZGUobmV4dElubmVyTGlzdCkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBuZXh0SW5uZXJMaXN0LmdldENoaWxkcmVuKCk7XG4gICAgICAgIGFwcGVuZChpbm5lckxpc3QsIGNoaWxkcmVuKTtcbiAgICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlKCk7XG4gICAgICAgIHJlbW92ZWQuYWRkKG5leHRTaWJsaW5nLmdldEtleSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAvLyBpZiB0aGUgTGlzdEl0ZW1Ob2RlIGlzIG5leHQgdG8gYSBuZXN0ZWQgTGlzdE5vZGUsIG1lcmdlIHRoZW1cbiAgICBjb25zdCBpbm5lckxpc3QgPSBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBpbm5lckxpc3QuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShwcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgY29uc3QgaW5uZXJMaXN0ID0gcHJldmlvdXNTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUoaW5uZXJMaXN0KSkge1xuICAgICAgaW5uZXJMaXN0LmFwcGVuZChsaXN0SXRlbU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBvdGhlcndpc2UsIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IG5lc3RlZCBMaXN0Tm9kZVxuXG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IG5ld0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpLnNldFRleHRGb3JtYXQobGlzdEl0ZW1Ob2RlLmdldFRleHRGb3JtYXQoKSkuc2V0VGV4dFN0eWxlKGxpc3RJdGVtTm9kZS5nZXRUZXh0U3R5bGUoKSk7XG4gICAgICBjb25zdCBuZXdMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKHBhcmVudC5nZXRMaXN0VHlwZSgpKS5zZXRUZXh0Rm9ybWF0KHBhcmVudC5nZXRUZXh0Rm9ybWF0KCkpLnNldFRleHRTdHlsZShwYXJlbnQuZ2V0VGV4dFN0eWxlKCkpO1xuICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kKG5ld0xpc3QpO1xuICAgICAgbmV3TGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nLmluc2VydEFmdGVyKG5ld0xpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbmV4dFNpYmxpbmcuaW5zZXJ0QmVmb3JlKG5ld0xpc3RJdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudC5hcHBlbmQobmV3TGlzdEl0ZW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYW4gaW5kZW50IGJ5IHJlbW92aW5nIGFuIGVtcHR5IExpc3ROb2RlL0xpc3RJdGVtTm9kZSBjaGFpbi4gQW4gaW5kZW50ZWQgTGlzdEl0ZW1Ob2RlXG4gKiBoYXMgYSBncmVhdCBncmFuZHBhcmVudCBub2RlIG9mIHR5cGUgTGlzdE5vZGUsIHdoaWNoIGlzIHdoZXJlIHRoZSBMaXN0SXRlbU5vZGUgd2lsbCByZXNpZGVcbiAqIHdpdGhpbiBhcyBhIGNoaWxkLlxuICogQHBhcmFtIGxpc3RJdGVtTm9kZSAtIFRoZSBMaXN0SXRlbU5vZGUgdG8gcmVtb3ZlIHRoZSBpbmRlbnQgKG91dGRlbnQpLlxuICovXG5mdW5jdGlvbiAkaGFuZGxlT3V0ZGVudChsaXN0SXRlbU5vZGUpIHtcbiAgLy8gZ28gdGhyb3VnaCBlYWNoIG5vZGUgYW5kIGRlY2lkZSB3aGVyZSB0byBtb3ZlIGl0LlxuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50TGlzdCA9IGxpc3RJdGVtTm9kZS5nZXRQYXJlbnQoKTtcbiAgY29uc3QgZ3JhbmRwYXJlbnRMaXN0SXRlbSA9IHBhcmVudExpc3QgPyBwYXJlbnRMaXN0LmdldFBhcmVudCgpIDogdW5kZWZpbmVkO1xuICBjb25zdCBncmVhdEdyYW5kcGFyZW50TGlzdCA9IGdyYW5kcGFyZW50TGlzdEl0ZW0gPyBncmFuZHBhcmVudExpc3RJdGVtLmdldFBhcmVudCgpIDogdW5kZWZpbmVkO1xuICAvLyBJZiBpdCBkb2Vzbid0IGhhdmUgdGhlc2UgYW5jZXN0b3JzLCBpdCdzIG5vdCBpbmRlbnRlZC5cblxuICBpZiAoJGlzTGlzdE5vZGUoZ3JlYXRHcmFuZHBhcmVudExpc3QpICYmICRpc0xpc3RJdGVtTm9kZShncmFuZHBhcmVudExpc3RJdGVtKSAmJiAkaXNMaXN0Tm9kZShwYXJlbnRMaXN0KSkge1xuICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0IGNoaWxkIGluIGl0J3MgcGFyZW50IGxpc3QsIGluc2VydCBpdCBpbnRvIHRoZVxuICAgIC8vIGdyZWF0IGdyYW5kcGFyZW50IGxpc3QgYmVmb3JlIHRoZSBncmFuZHBhcmVudFxuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnRMaXN0ID8gcGFyZW50TGlzdC5nZXRGaXJzdENoaWxkKCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3QgbGFzdENoaWxkID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0TGFzdENoaWxkKCkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGxpc3RJdGVtTm9kZS5pcyhmaXJzdENoaWxkKSkge1xuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRCZWZvcmUobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwYXJlbnRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgLy8gaWYgaXQncyB0aGUgbGFzdCBjaGlsZCBpbiBpdCdzIHBhcmVudCBsaXN0LCBpbnNlcnQgaXQgaW50byB0aGVcbiAgICAgIC8vIGdyZWF0IGdyYW5kcGFyZW50IGxpc3QgYWZ0ZXIgdGhlIGdyYW5kcGFyZW50LlxuICAgIH0gZWxzZSBpZiAobGlzdEl0ZW1Ob2RlLmlzKGxhc3RDaGlsZCkpIHtcbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QWZ0ZXIobGlzdEl0ZW1Ob2RlKTtcbiAgICAgIGlmIChwYXJlbnRMaXN0LmlzRW1wdHkoKSkge1xuICAgICAgICBncmFuZHBhcmVudExpc3RJdGVtLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UsIHdlIG5lZWQgdG8gc3BsaXQgdGhlIHNpYmxpbmdzIGludG8gdHdvIG5ldyBuZXN0ZWQgbGlzdHNcbiAgICAgIGNvbnN0IGxpc3RUeXBlID0gcGFyZW50TGlzdC5nZXRMaXN0VHlwZSgpO1xuICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nc0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgcHJldmlvdXNTaWJsaW5nc0xpc3RJdGVtLmFwcGVuZChwcmV2aW91c1NpYmxpbmdzTGlzdCk7XG4gICAgICBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5ncygpLmZvckVhY2goc2libGluZyA9PiBwcmV2aW91c1NpYmxpbmdzTGlzdC5hcHBlbmQoc2libGluZykpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICBjb25zdCBuZXh0U2libGluZ3NMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgIG5leHRTaWJsaW5nc0xpc3RJdGVtLmFwcGVuZChuZXh0U2libGluZ3NMaXN0KTtcbiAgICAgIGFwcGVuZChuZXh0U2libGluZ3NMaXN0LCBsaXN0SXRlbU5vZGUuZ2V0TmV4dFNpYmxpbmdzKCkpO1xuICAgICAgLy8gcHV0IHRoZSBzaWJsaW5nIG5lc3RlZCBsaXN0cyBvbiBlaXRoZXIgc2lkZSBvZiB0aGUgZ3JhbmRwYXJlbnQgbGlzdCBpdGVtIGluIHRoZSBncmVhdCBncmFuZHBhcmVudC5cbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QmVmb3JlKHByZXZpb3VzU2libGluZ3NMaXN0SXRlbSk7XG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEFmdGVyKG5leHRTaWJsaW5nc0xpc3RJdGVtKTtcbiAgICAgIC8vIHJlcGxhY2UgdGhlIGdyYW5kcGFyZW50IGxpc3QgaXRlbSAobm93IGJldHdlZW4gdGhlIHNpYmxpbmdzKSB3aXRoIHRoZSBvdXRkZW50ZWQgbGlzdCBpdGVtLlxuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZXBsYWNlKGxpc3RJdGVtTm9kZSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gaW5zZXJ0IGEgUGFyYWdyYXBoTm9kZSBhdCBzZWxlY3Rpb24gYW5kIHNlbGVjdHMgdGhlIG5ldyBub2RlLiBUaGUgc2VsZWN0aW9uIG11c3QgY29udGFpbiBhIExpc3RJdGVtTm9kZVxuICogb3IgYSBub2RlIHRoYXQgZG9lcyBub3QgYWxyZWFkeSBjb250YWluIHRleHQuIElmIGl0cyBncmFuZHBhcmVudCBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCwgaXQgd2lsbCBnZXQgdGhlIExpc3ROb2RlXG4gKiAod2hpY2ggc2hvdWxkIGJlIHRoZSBwYXJlbnQgbm9kZSkgYW5kIGluc2VydCB0aGUgUGFyYWdyYXBoTm9kZSBhcyBhIHNpYmxpbmcgdG8gdGhlIExpc3ROb2RlLiBJZiB0aGUgTGlzdE5vZGUgaXNcbiAqIG5lc3RlZCBpbiBhIExpc3RJdGVtTm9kZSBpbnN0ZWFkLCBpdCB3aWxsIGFkZCB0aGUgUGFyYWdyYXBoTm9kZSBhZnRlciB0aGUgZ3JhbmRwYXJlbnQgTGlzdEl0ZW1Ob2RlLlxuICogVGhyb3dzIGFuIGludmFyaWFudCBpZiB0aGUgc2VsZWN0aW9uIGlzIG5vdCBhIGNoaWxkIG9mIGEgTGlzdE5vZGUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIGEgUGFyYWdyYXBoTm9kZSB3YXMgaW5zZXJ0ZWQgc3VjY2Vzc2Z1bGx5LCBmYWxzZSBpZiB0aGVyZSBpcyBubyBzZWxlY3Rpb25cbiAqIG9yIHRoZSBzZWxlY3Rpb24gZG9lcyBub3QgY29udGFpbiBhIExpc3RJdGVtTm9kZSBvciB0aGUgbm9kZSBhbHJlYWR5IGhvbGRzIHRleHQuXG4gKi9cbmZ1bmN0aW9uICRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gT25seSBydW4gdGhpcyBjb2RlIG9uIGVtcHR5IGxpc3QgaXRlbXNcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGlmICghJGlzTGlzdEl0ZW1Ob2RlKGFuY2hvcikgfHwgYW5jaG9yLmdldENoaWxkcmVuU2l6ZSgpICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHRvcExpc3ROb2RlID0gJGdldFRvcExpc3ROb2RlKGFuY2hvcik7XG4gIGNvbnN0IHBhcmVudCA9IGFuY2hvci5nZXRQYXJlbnQoKTtcbiAgaWYgKCEkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBBIExpc3RJdGVtTm9kZSBtdXN0IGhhdmUgYSBMaXN0Tm9kZSBmb3IgYSBwYXJlbnQuYCk7XG4gIH1cbiAgY29uc3QgZ3JhbmRwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gIGxldCByZXBsYWNlbWVudE5vZGU7XG4gIGlmICgkaXNSb290T3JTaGFkb3dSb290KGdyYW5kcGFyZW50KSkge1xuICAgIHJlcGxhY2VtZW50Tm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgdG9wTGlzdE5vZGUuaW5zZXJ0QWZ0ZXIocmVwbGFjZW1lbnROb2RlKTtcbiAgfSBlbHNlIGlmICgkaXNMaXN0SXRlbU5vZGUoZ3JhbmRwYXJlbnQpKSB7XG4gICAgcmVwbGFjZW1lbnROb2RlID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgIGdyYW5kcGFyZW50Lmluc2VydEFmdGVyKHJlcGxhY2VtZW50Tm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlcGxhY2VtZW50Tm9kZS5zZXRUZXh0U3R5bGUoc2VsZWN0aW9uLnN0eWxlKS5zZXRUZXh0Rm9ybWF0KHNlbGVjdGlvbi5mb3JtYXQpLnNlbGVjdCgpO1xuICBjb25zdCBuZXh0U2libGluZ3MgPSBhbmNob3IuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gIGlmIChuZXh0U2libGluZ3MubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUocGFyZW50LmdldExpc3RUeXBlKCkpO1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocmVwbGFjZW1lbnROb2RlKSkge1xuICAgICAgY29uc3QgbmV3TGlzdEl0ZW0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCk7XG4gICAgICBuZXdMaXN0SXRlbS5hcHBlbmQobmV3TGlzdCk7XG4gICAgICByZXBsYWNlbWVudE5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdEl0ZW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlbWVudE5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdCk7XG4gICAgfVxuICAgIG5ld0xpc3QuYXBwZW5kKC4uLm5leHRTaWJsaW5ncyk7XG4gIH1cblxuICAvLyBEb24ndCBsZWF2ZSBoYW5naW5nIG5lc3RlZCBlbXB0eSBsaXN0c1xuICAkcmVtb3ZlSGlnaGVzdEVtcHR5TGlzdFBhcmVudChhbmNob3IpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgcnZhbCA9IFtdO1xuICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAgaWYgKGNsYXNzTmFtZSAmJiB0eXBlb2YgY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgZm9yIChjb25zdCBbc10gb2YgY2xhc3NOYW1lLm1hdGNoQWxsKC9cXFMrL2cpKSB7XG4gICAgICAgIHJ2YWwucHVzaChzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJ2YWw7XG59XG5cbmZ1bmN0aW9uIGFwcGx5TWFya2VyU3R5bGVzKGRvbSwgbm9kZSwgcHJldk5vZGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKG5vZGUuX190ZXh0U3R5bGUpO1xuICBmb3IgKGNvbnN0IGsgaW4gc3R5bGVzKSB7XG4gICAgZG9tLnN0eWxlLnNldFByb3BlcnR5KGAtLWxpc3RpdGVtLW1hcmtlci0ke2t9YCwgc3R5bGVzW2tdKTtcbiAgfVxuICBpZiAocHJldk5vZGUpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKHByZXZOb2RlLl9fdGV4dFN0eWxlKSkge1xuICAgICAgaWYgKCEoayBpbiBzdHlsZXMpKSB7XG4gICAgICAgIGRvbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShgLS1saXN0aXRlbS1tYXJrZXItJHtrfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgTGlzdEl0ZW1Ob2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgJGNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcoJ2xpc3RpdGVtJywge1xuICAgICAgJHRyYW5zZm9ybTogbm9kZSA9PiB7XG4gICAgICAgIGlmIChub2RlLl9fY2hlY2tlZCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5nZXRMaXN0VHlwZSgpICE9PSAnY2hlY2snICYmIG5vZGUuZ2V0Q2hlY2tlZCgpICE9IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuc2V0Q2hlY2tlZCh1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV4dGVuZHM6IEVsZW1lbnROb2RlLFxuICAgICAgaW1wb3J0RE9NOiBidWlsZEltcG9ydE1hcCh7XG4gICAgICAgIGxpOiAoKSA9PiAoe1xuICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0TGlzdEl0ZW1FbGVtZW50LFxuICAgICAgICAgIHByaW9yaXR5OiAwXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIGNvbnN0cnVjdG9yKHZhbHVlID0gMSwgY2hlY2tlZCA9IHVuZGVmaW5lZCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlO1xuICAgIHRoaXMuX19jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuICBhZnRlckNsb25lRnJvbShwcmV2Tm9kZSkge1xuICAgIHN1cGVyLmFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKTtcbiAgICB0aGlzLl9fdmFsdWUgPSBwcmV2Tm9kZS5fX3ZhbHVlO1xuICAgIHRoaXMuX19jaGVja2VkID0gcHJldk5vZGUuX19jaGVja2VkO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICB0aGlzLnVwZGF0ZUxpc3RJdGVtRE9NKG51bGwsIGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlTGlzdEl0ZW1ET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSAmJiBwYXJlbnQuZ2V0TGlzdFR5cGUoKSA9PT0gJ2NoZWNrJykge1xuICAgICAgdXBkYXRlTGlzdEl0ZW1DaGVja2VkKGRvbSwgdGhpcywgcHJldk5vZGUpO1xuICAgIH1cbiAgICBkb20udmFsdWUgPSB0aGlzLl9fdmFsdWU7XG4gICAgJHNldExpc3RJdGVtVGhlbWVDbGFzc05hbWVzKGRvbSwgY29uZmlnLnRoZW1lLCB0aGlzKTtcbiAgICBjb25zdCBwcmV2U3R5bGUgPSBwcmV2Tm9kZSA/IHByZXZOb2RlLl9fc3R5bGUgOiAnJztcbiAgICBjb25zdCBuZXh0U3R5bGUgPSB0aGlzLl9fc3R5bGU7XG4gICAgaWYgKHByZXZTdHlsZSAhPT0gbmV4dFN0eWxlKSB7XG4gICAgICBpZiAobmV4dFN0eWxlID09PSAnJykge1xuICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBuZXh0U3R5bGU7XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGx5TWFya2VyU3R5bGVzKGRvbSwgdGhpcywgcHJldk5vZGUpO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gdGhpcyBpcyBhbHdheXMgSFRNTExpc3RJdGVtRWxlbWVudFxuICAgIGNvbnN0IGVsZW1lbnQgPSBkb207XG4gICAgdGhpcy51cGRhdGVMaXN0SXRlbURPTShwcmV2Tm9kZSwgZWxlbWVudCwgY29uZmlnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldFZhbHVlKHNlcmlhbGl6ZWROb2RlLnZhbHVlKS5zZXRDaGVja2VkKHNlcmlhbGl6ZWROb2RlLmNoZWNrZWQpO1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5jcmVhdGVET00oZWRpdG9yLl9jb25maWcpO1xuICAgIGNvbnN0IGZvcm1hdFR5cGUgPSB0aGlzLmdldEZvcm1hdFR5cGUoKTtcbiAgICBpZiAoZm9ybWF0VHlwZSkge1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBmb3JtYXRUeXBlO1xuICAgIH1cbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgIGVsZW1lbnQuZGlyID0gZGlyZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgY2hlY2tlZDogdGhpcy5nZXRDaGVja2VkKCksXG4gICAgICB2YWx1ZTogdGhpcy5nZXRWYWx1ZSgpXG4gICAgfTtcbiAgfVxuICBhcHBlbmQoLi4ubm9kZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgdGhpcy5jYW5NZXJnZVdpdGgobm9kZSkpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuYXBwZW5kKC4uLmNoaWxkcmVuKTtcbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1cGVyLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVwbGFjZShyZXBsYWNlV2l0aE5vZGUsIGluY2x1ZGVDaGlsZHJlbikge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocmVwbGFjZVdpdGhOb2RlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UocmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9XG4gICAgdGhpcy5zZXRJbmRlbnQoMCk7XG4gICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdCkpIHtcbiAgICAgIHJldHVybiByZXBsYWNlV2l0aE5vZGU7XG4gICAgfVxuICAgIGlmIChsaXN0Ll9fZmlyc3QgPT09IHRoaXMuZ2V0S2V5KCkpIHtcbiAgICAgIGxpc3QuaW5zZXJ0QmVmb3JlKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfSBlbHNlIGlmIChsaXN0Ll9fbGFzdCA9PT0gdGhpcy5nZXRLZXkoKSkge1xuICAgICAgbGlzdC5pbnNlcnRBZnRlcihyZXBsYWNlV2l0aE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTcGxpdCB0aGUgbGlzdFxuICAgICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0LmdldExpc3RUeXBlKCkpO1xuICAgICAgbGV0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgICAgd2hpbGUgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIGNvbnN0IG5vZGVUb0FwcGVuZCA9IG5leHRTaWJsaW5nO1xuICAgICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgIG5ld0xpc3QuYXBwZW5kKG5vZGVUb0FwcGVuZCk7XG4gICAgICB9XG4gICAgICBsaXN0Lmluc2VydEFmdGVyKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgICByZXBsYWNlV2l0aE5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdCk7XG4gICAgfVxuICAgIGlmIChpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICAgIGlmICghJGlzRWxlbWVudE5vZGUocmVwbGFjZVdpdGhOb2RlKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGluY2x1ZGVDaGlsZHJlbiBzaG91bGQgb25seSBiZSB0cnVlIGZvciBFbGVtZW50Tm9kZXNgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgcmVwbGFjZVdpdGhOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmUoKTtcbiAgICBpZiAobGlzdC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgICAgbGlzdC5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VXaXRoTm9kZTtcbiAgfVxuICBpbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxpc3ROb2RlID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0Tm9kZSkpIHtcbiAgICAgIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbnNlcnRBZnRlcjogbGlzdCBub2RlIGlzIG5vdCBwYXJlbnQgb2YgbGlzdCBpdGVtIG5vZGVgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmluc2VydEFmdGVyKG5vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBjb25zdCBzaWJsaW5ncyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmdzKCk7XG5cbiAgICAvLyBTcGxpdCB0aGUgbGlzdHMgYW5kIGluc2VydCB0aGUgbm9kZSBpbiBiZXR3ZWVuIHRoZW1cbiAgICBsaXN0Tm9kZS5pbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICBpZiAoc2libGluZ3MubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBuZXdMaXN0Tm9kZSA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0Tm9kZS5nZXRMaXN0VHlwZSgpKTtcbiAgICAgIHNpYmxpbmdzLmZvckVhY2goc2libGluZyA9PiBuZXdMaXN0Tm9kZS5hcHBlbmQoc2libGluZykpO1xuICAgICAgbm9kZS5pbnNlcnRBZnRlcihuZXdMaXN0Tm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJlbW92ZShwcmVzZXJ2ZUVtcHR5UGFyZW50KSB7XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSB0aGlzLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIHN1cGVyLnJlbW92ZShwcmVzZXJ2ZUVtcHR5UGFyZW50KTtcbiAgICBpZiAocHJldlNpYmxpbmcgJiYgbmV4dFNpYmxpbmcgJiYgaXNOZXN0ZWRMaXN0Tm9kZShwcmV2U2libGluZykgJiYgaXNOZXN0ZWRMaXN0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIG1lcmdlTGlzdHMocHJldlNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpLCBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkKCkpO1xuICAgICAgbmV4dFNpYmxpbmcucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGluc2VydE5ld0FmdGVyKF8sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKS51cGRhdGVGcm9tSlNPTih0aGlzLmV4cG9ydEpTT04oKSkuc2V0Q2hlY2tlZCh0aGlzLmdldENoZWNrZWQoKSA/IGZhbHNlIDogdW5kZWZpbmVkKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG4gIGNvbGxhcHNlQXRTdGFydChzZWxlY3Rpb24pIHtcbiAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gcGFyYWdyYXBoLmFwcGVuZChjaGlsZCkpO1xuICAgIGNvbnN0IGxpc3ROb2RlID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgY29uc3QgbGlzdE5vZGVQYXJlbnQgPSBsaXN0Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgY29uc3QgaXNJbmRlbnRlZCA9ICRpc0xpc3RJdGVtTm9kZShsaXN0Tm9kZVBhcmVudCk7XG4gICAgaWYgKGxpc3ROb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAxKSB7XG4gICAgICBpZiAoaXNJbmRlbnRlZCkge1xuICAgICAgICAvLyBpZiB0aGUgbGlzdCBub2RlIGlzIG5lc3RlZCwgd2UganVzdCB3YW50IHRvIHJlbW92ZSBpdCxcbiAgICAgICAgLy8gZWZmZWN0aXZlbHkgdW5pbmRlbnRpbmcgaXQuXG4gICAgICAgIGxpc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgICBsaXN0Tm9kZVBhcmVudC5zZWxlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3ROb2RlLmluc2VydEJlZm9yZShwYXJhZ3JhcGgpO1xuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBzZWxlY3Rpb24gb24gdGhlIGxpc3QgaXRlbSwgd2UnbGwgbmVlZCB0byBtb3ZlIGl0XG4gICAgICAgIC8vIHRvIHRoZSBwYXJhZ3JhcGhcbiAgICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhcmFncmFwaC5nZXRLZXkoKTtcbiAgICAgICAgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmdldE5vZGUoKS5pcyh0aGlzKSkge1xuICAgICAgICAgIGFuY2hvci5zZXQoa2V5LCBhbmNob3Iub2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgZm9jdXMuZ2V0Tm9kZSgpLmlzKHRoaXMpKSB7XG4gICAgICAgICAgZm9jdXMuc2V0KGtleSwgZm9jdXMub2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3ROb2RlLmluc2VydEJlZm9yZShwYXJhZ3JhcGgpO1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0VmFsdWUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX192YWx1ZTtcbiAgfVxuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3ZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0Q2hlY2tlZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBsZXQgbGlzdFR5cGU7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgbGlzdFR5cGUgPSBwYXJlbnQuZ2V0TGlzdFR5cGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3RUeXBlID09PSAnY2hlY2snID8gQm9vbGVhbihzZWxmLl9fY2hlY2tlZCkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fY2hlY2tlZCA9IGNoZWNrZWQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgdG9nZ2xlQ2hlY2tlZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHJldHVybiBzZWxmLnNldENoZWNrZWQoIXNlbGYuX19jaGVja2VkKTtcbiAgfVxuICBnZXRJbmRlbnQoKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHBhcmVudCwgd2UgYXJlIGxpa2VseSBzZXJpYWxpemluZ1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCB8fCAhdGhpcy5pc0F0dGFjaGVkKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faW5kZW50O1xuICAgIH1cbiAgICAvLyBMaXN0SXRlbU5vZGUgc2hvdWxkIGFsd2F5cyBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LlxuICAgIGxldCBsaXN0Tm9kZVBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgbGV0IGluZGVudExldmVsID0gMDtcbiAgICB3aGlsZSAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3ROb2RlUGFyZW50KSkge1xuICAgICAgbGlzdE5vZGVQYXJlbnQgPSBsaXN0Tm9kZVBhcmVudC5nZXRQYXJlbnRPclRocm93KCkuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgaW5kZW50TGV2ZWwrKztcbiAgICB9XG4gICAgcmV0dXJuIGluZGVudExldmVsO1xuICB9XG4gIHNldEluZGVudChpbmRlbnQpIHtcbiAgICBpZiAoISh0eXBlb2YgaW5kZW50ID09PSAnbnVtYmVyJykpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgSW52YWxpZCBpbmRlbnQgdmFsdWUuYCk7XG4gICAgfVxuICAgIGluZGVudCA9IE1hdGguZmxvb3IoaW5kZW50KTtcbiAgICBpZiAoIShpbmRlbnQgPj0gMCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgSW5kZW50IHZhbHVlIG11c3QgYmUgbm9uLW5lZ2F0aXZlLmApO1xuICAgIH1cbiAgICBsZXQgY3VycmVudEluZGVudCA9IHRoaXMuZ2V0SW5kZW50KCk7XG4gICAgd2hpbGUgKGN1cnJlbnRJbmRlbnQgIT09IGluZGVudCkge1xuICAgICAgaWYgKGN1cnJlbnRJbmRlbnQgPCBpbmRlbnQpIHtcbiAgICAgICAgJGhhbmRsZUluZGVudCh0aGlzKTtcbiAgICAgICAgY3VycmVudEluZGVudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGhhbmRsZU91dGRlbnQodGhpcyk7XG4gICAgICAgIGN1cnJlbnRJbmRlbnQtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgQGludGVybmFsICovXG4gIGNhbkluc2VydEFmdGVyKG5vZGUpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIEBpbnRlcm5hbCAqL1xuICBjYW5SZXBsYWNlV2l0aChyZXBsYWNlbWVudCkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUocmVwbGFjZW1lbnQpO1xuICB9XG4gIGNhbk1lcmdlV2l0aChub2RlKSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKSB8fCAkaXNQYXJhZ3JhcGhOb2RlKG5vZGUpO1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbikge1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICByZXR1cm4gdGhpcy5pc1BhcmVudE9mKGFuY2hvck5vZGUpICYmIHRoaXMuaXNQYXJlbnRPZihmb2N1c05vZGUpICYmIHRoaXMuZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGggPT09IHNlbGVjdGlvbi5nZXRUZXh0Q29udGVudCgpLmxlbmd0aDtcbiAgfVxuICBpc1BhcmVudFJlcXVpcmVkKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNyZWF0ZVBhcmVudEVsZW1lbnROb2RlKCkge1xuICAgIHJldHVybiAkY3JlYXRlTGlzdE5vZGUoJ2J1bGxldCcpO1xuICB9XG4gIGNhbk1lcmdlV2hlbkVtcHR5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiAkc2V0TGlzdEl0ZW1UaGVtZUNsYXNzTmFtZXMoZG9tLCBlZGl0b3JUaGVtZUNsYXNzZXMsIG5vZGUpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gW107XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IFtdO1xuICBjb25zdCBsaXN0VGhlbWUgPSBlZGl0b3JUaGVtZUNsYXNzZXMubGlzdDtcbiAgY29uc3QgbGlzdEl0ZW1DbGFzc05hbWUgPSBsaXN0VGhlbWUgPyBsaXN0VGhlbWUubGlzdGl0ZW0gOiB1bmRlZmluZWQ7XG4gIGxldCBuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZTtcbiAgaWYgKGxpc3RUaGVtZSAmJiBsaXN0VGhlbWUubmVzdGVkKSB7XG4gICAgbmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUgPSBsaXN0VGhlbWUubmVzdGVkLmxpc3RpdGVtO1xuICB9XG4gIGlmIChsaXN0SXRlbUNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubm9ybWFsaXplQ2xhc3NOYW1lcyhsaXN0SXRlbUNsYXNzTmFtZSkpO1xuICB9XG4gIGlmIChsaXN0VGhlbWUpIHtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBjb25zdCBpc0NoZWNrTGlzdCA9ICRpc0xpc3ROb2RlKHBhcmVudE5vZGUpICYmIHBhcmVudE5vZGUuZ2V0TGlzdFR5cGUoKSA9PT0gJ2NoZWNrJztcbiAgICBjb25zdCBjaGVja2VkID0gbm9kZS5nZXRDaGVja2VkKCk7XG4gICAgaWYgKCFpc0NoZWNrTGlzdCB8fCBjaGVja2VkKSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChsaXN0VGhlbWUubGlzdGl0ZW1VbmNoZWNrZWQpO1xuICAgIH1cbiAgICBpZiAoIWlzQ2hlY2tMaXN0IHx8ICFjaGVja2VkKSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaChsaXN0VGhlbWUubGlzdGl0ZW1DaGVja2VkKTtcbiAgICB9XG4gICAgaWYgKGlzQ2hlY2tMaXN0KSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaChjaGVja2VkID8gbGlzdFRoZW1lLmxpc3RpdGVtQ2hlY2tlZCA6IGxpc3RUaGVtZS5saXN0aXRlbVVuY2hlY2tlZCk7XG4gICAgfVxuICB9XG4gIGlmIChuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbmVzdGVkTGlzdEl0ZW1DbGFzc2VzID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhuZXN0ZWRMaXN0SXRlbUNsYXNzTmFtZSk7XG4gICAgaWYgKG5vZGUuZ2V0Q2hpbGRyZW4oKS5zb21lKGNoaWxkID0+ICRpc0xpc3ROb2RlKGNoaWxkKSkpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgfVxuICB9XG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RJdGVtQ2hlY2tlZChkb20sIGxpc3RJdGVtTm9kZSwgcHJldkxpc3RJdGVtTm9kZSwgbGlzdE5vZGUpIHtcbiAgLy8gT25seSBhZGQgYXR0cmlidXRlcyBmb3IgbGVhZiBsaXN0IGl0ZW1zXG4gIGlmICgkaXNMaXN0Tm9kZShsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpKSkge1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCd0YWJJbmRleCcpO1xuICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcpO1xuICB9IGVsc2Uge1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnY2hlY2tib3gnKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCd0YWJJbmRleCcsICctMScpO1xuICAgIGlmICghcHJldkxpc3RJdGVtTm9kZSB8fCBsaXN0SXRlbU5vZGUuX19jaGVja2VkICE9PSBwcmV2TGlzdEl0ZW1Ob2RlLl9fY2hlY2tlZCkge1xuICAgICAgZG9tLnNldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJywgbGlzdEl0ZW1Ob2RlLmdldENoZWNrZWQoKSA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJGNvbnZlcnRMaXN0SXRlbUVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBpc0dpdEh1YkNoZWNrTGlzdCA9IGRvbU5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXNrLWxpc3QtaXRlbScpO1xuICBpZiAoaXNHaXRIdWJDaGVja0xpc3QpIHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGRvbU5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnSU5QVVQnKSB7XG4gICAgICAgIHJldHVybiAkY29udmVydENoZWNrYm94SW5wdXQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBhcmlhQ2hlY2tlZEF0dHIgPSBkb21Ob2RlLmdldEF0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJyk7XG4gIGNvbnN0IGNoZWNrZWQgPSBhcmlhQ2hlY2tlZEF0dHIgPT09ICd0cnVlJyA/IHRydWUgOiBhcmlhQ2hlY2tlZEF0dHIgPT09ICdmYWxzZScgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlTGlzdEl0ZW1Ob2RlKGNoZWNrZWQpXG4gIH07XG59XG5mdW5jdGlvbiAkY29udmVydENoZWNrYm94SW5wdXQoZG9tTm9kZSkge1xuICBjb25zdCBpc0NoZWNrYm94SW5wdXQgPSBkb21Ob2RlLmdldEF0dHJpYnV0ZSgndHlwZScpID09PSAnY2hlY2tib3gnO1xuICBpZiAoIWlzQ2hlY2tib3hJbnB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuICBjb25zdCBjaGVja2VkID0gZG9tTm9kZS5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgcmV0dXJuIHtcbiAgICBub2RlOiAkY3JlYXRlTGlzdEl0ZW1Ob2RlKGNoZWNrZWQpXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBMaXN0IEl0ZW0gbm9kZSwgcGFzc2luZyB0cnVlL2ZhbHNlIHdpbGwgY29udmVydCBpdCB0byBhIGNoZWNrYm94IGlucHV0LlxuICogQHBhcmFtIGNoZWNrZWQgLSBJcyB0aGUgTGlzdCBJdGVtIGEgY2hlY2tib3ggYW5kLCBpZiBzbywgaXMgaXQgY2hlY2tlZD8gdW5kZWZpbmVkL251bGw6IG5vdCBhIGNoZWNrYm94LCB0cnVlL2ZhbHNlIGlzIGEgY2hlY2tib3ggYW5kIGNoZWNrZWQvdW5jaGVja2VkLCByZXNwZWN0aXZlbHkuXG4gKiBAcmV0dXJucyBUaGUgbmV3IExpc3QgSXRlbS5cbiAqL1xuZnVuY3Rpb24gJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpc3RJdGVtTm9kZSh1bmRlZmluZWQsIGNoZWNrZWQpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIExpc3RJdGVtTm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNMaXN0SXRlbU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpc3RJdGVtTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgTGlzdE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgJGNvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcoJ2xpc3QnLCB7XG4gICAgICAkdHJhbnNmb3JtOiBub2RlID0+IHtcbiAgICAgICAgbWVyZ2VOZXh0U2libGluZ0xpc3RJZlNhbWVUeXBlKG5vZGUpO1xuICAgICAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobm9kZSk7XG4gICAgICB9LFxuICAgICAgZXh0ZW5kczogRWxlbWVudE5vZGUsXG4gICAgICBpbXBvcnRET006IGJ1aWxkSW1wb3J0TWFwKHtcbiAgICAgICAgb2w6ICgpID0+ICh7XG4gICAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRMaXN0Tm9kZSxcbiAgICAgICAgICBwcmlvcml0eTogMFxuICAgICAgICB9KSxcbiAgICAgICAgdWw6ICgpID0+ICh7XG4gICAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRMaXN0Tm9kZSxcbiAgICAgICAgICBwcmlvcml0eTogMFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihsaXN0VHlwZSA9ICdudW1iZXInLCBzdGFydCA9IDEsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgY29uc3QgX2xpc3RUeXBlID0gVEFHX1RPX0xJU1RfVFlQRVtsaXN0VHlwZV0gfHwgbGlzdFR5cGU7XG4gICAgdGhpcy5fX2xpc3RUeXBlID0gX2xpc3RUeXBlO1xuICAgIHRoaXMuX190YWcgPSBfbGlzdFR5cGUgPT09ICdudW1iZXInID8gJ29sJyA6ICd1bCc7XG4gICAgdGhpcy5fX3N0YXJ0ID0gc3RhcnQ7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpIHtcbiAgICBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSk7XG4gICAgdGhpcy5fX2xpc3RUeXBlID0gcHJldk5vZGUuX19saXN0VHlwZTtcbiAgICB0aGlzLl9fdGFnID0gcHJldk5vZGUuX190YWc7XG4gICAgdGhpcy5fX3N0YXJ0ID0gcHJldk5vZGUuX19zdGFydDtcbiAgfVxuICBnZXRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX190YWc7XG4gIH1cbiAgc2V0TGlzdFR5cGUodHlwZSkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fbGlzdFR5cGUgPSB0eXBlO1xuICAgIHdyaXRhYmxlLl9fdGFnID0gdHlwZSA9PT0gJ251bWJlcicgPyAnb2wnIDogJ3VsJztcbiAgICByZXR1cm4gd3JpdGFibGU7XG4gIH1cbiAgZ2V0TGlzdFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19saXN0VHlwZTtcbiAgfVxuICBnZXRTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3N0YXJ0O1xuICB9XG4gIHNldFN0YXJ0KHN0YXJ0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fc3RhcnQgPSBzdGFydDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8vIFZpZXdcblxuICBjcmVhdGVET00oY29uZmlnLCBfZWRpdG9yKSB7XG4gICAgY29uc3QgdGFnID0gdGhpcy5fX3RhZztcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKHRoaXMuX19zdGFydCAhPT0gMSkge1xuICAgICAgZG9tLnNldEF0dHJpYnV0ZSgnc3RhcnQnLCBTdHJpbmcodGhpcy5fX3N0YXJ0KSk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSW50ZXJuYWwgZmllbGQuXG4gICAgZG9tLl9fbGV4aWNhbExpc3RUeXBlID0gdGhpcy5fX2xpc3RUeXBlO1xuICAgICRzZXRMaXN0VGhlbWVDbGFzc05hbWVzKGRvbSwgY29uZmlnLnRoZW1lLCB0aGlzKTtcbiAgICByZXR1cm4gZG9tO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBpZiAocHJldk5vZGUuX190YWcgIT09IHRoaXMuX190YWcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAkc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRMaXN0VHlwZShzZXJpYWxpemVkTm9kZS5saXN0VHlwZSkuc2V0U3RhcnQoc2VyaWFsaXplZE5vZGUuc3RhcnQpO1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5jcmVhdGVET00oZWRpdG9yLl9jb25maWcsIGVkaXRvcik7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLl9fc3RhcnQgIT09IDEpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0YXJ0JywgU3RyaW5nKHRoaXMuX19zdGFydCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19saXN0VHlwZSA9PT0gJ2NoZWNrJykge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnX19sZXhpY2FsTGlzdFR5cGUnLCAnY2hlY2snKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGxpc3RUeXBlOiB0aGlzLmdldExpc3RUeXBlKCksXG4gICAgICBzdGFydDogdGhpcy5nZXRTdGFydCgpLFxuICAgICAgdGFnOiB0aGlzLmdldFRhZygpXG4gICAgfTtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIG5vZGVzVG9JbnNlcnQpIHtcbiAgICBsZXQgbGlzdEl0ZW1Ob2Rlc1RvSW5zZXJ0ID0gbm9kZXNUb0luc2VydDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzVG9JbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1RvSW5zZXJ0W2ldO1xuICAgICAgaWYgKCEkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgaWYgKGxpc3RJdGVtTm9kZXNUb0luc2VydCA9PT0gbm9kZXNUb0luc2VydCkge1xuICAgICAgICAgIGxpc3RJdGVtTm9kZXNUb0luc2VydCA9IFsuLi5ub2Rlc1RvSW5zZXJ0XTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0SXRlbU5vZGVzVG9JbnNlcnRbaV0gPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCkuYXBwZW5kKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmICEoJGlzTGlzdE5vZGUobm9kZSkgfHwgbm9kZS5pc0lubGluZSgpKSA/ICRjcmVhdGVUZXh0Tm9kZShub2RlLmdldFRleHRDb250ZW50KCkpIDogbm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBsaXN0SXRlbU5vZGVzVG9JbnNlcnQpO1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKGNoaWxkKTtcbiAgfVxufVxuZnVuY3Rpb24gJHNldExpc3RUaGVtZUNsYXNzTmFtZXMoZG9tLCBlZGl0b3JUaGVtZUNsYXNzZXMsIG5vZGUpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gW107XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IFtdO1xuICBjb25zdCBsaXN0VGhlbWUgPSBlZGl0b3JUaGVtZUNsYXNzZXMubGlzdDtcbiAgaWYgKGxpc3RUaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbGlzdExldmVsc0NsYXNzTmFtZXMgPSBsaXN0VGhlbWVbYCR7bm9kZS5fX3RhZ31EZXB0aGBdIHx8IFtdO1xuICAgIGNvbnN0IGxpc3REZXB0aCA9ICRnZXRMaXN0RGVwdGgobm9kZSkgLSAxO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRMaXN0RGVwdGggPSBsaXN0RGVwdGggJSBsaXN0TGV2ZWxzQ2xhc3NOYW1lcy5sZW5ndGg7XG4gICAgY29uc3QgbGlzdExldmVsQ2xhc3NOYW1lID0gbGlzdExldmVsc0NsYXNzTmFtZXNbbm9ybWFsaXplZExpc3REZXB0aF07XG4gICAgY29uc3QgbGlzdENsYXNzTmFtZSA9IGxpc3RUaGVtZVtub2RlLl9fdGFnXTtcbiAgICBsZXQgbmVzdGVkTGlzdENsYXNzTmFtZTtcbiAgICBjb25zdCBuZXN0ZWRMaXN0VGhlbWUgPSBsaXN0VGhlbWUubmVzdGVkO1xuICAgIGNvbnN0IGNoZWNrbGlzdENsYXNzTmFtZSA9IGxpc3RUaGVtZS5jaGVja2xpc3Q7XG4gICAgaWYgKG5lc3RlZExpc3RUaGVtZSAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZExpc3RUaGVtZS5saXN0KSB7XG4gICAgICBuZXN0ZWRMaXN0Q2xhc3NOYW1lID0gbmVzdGVkTGlzdFRoZW1lLmxpc3Q7XG4gICAgfVxuICAgIGlmIChsaXN0Q2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKGxpc3RDbGFzc05hbWUpO1xuICAgIH1cbiAgICBpZiAoY2hlY2tsaXN0Q2xhc3NOYW1lICE9PSB1bmRlZmluZWQgJiYgbm9kZS5fX2xpc3RUeXBlID09PSAnY2hlY2snKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaChjaGVja2xpc3RDbGFzc05hbWUpO1xuICAgIH1cbiAgICBpZiAobGlzdExldmVsQ2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5vcm1hbGl6ZUNsYXNzTmFtZXMobGlzdExldmVsQ2xhc3NOYW1lKSk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RMZXZlbHNDbGFzc05hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSBub3JtYWxpemVkTGlzdERlcHRoKSB7XG4gICAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobm9kZS5fX3RhZyArIGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXN0ZWRMaXN0Q2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG5lc3RlZExpc3RJdGVtQ2xhc3NlcyA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMobmVzdGVkTGlzdENsYXNzTmFtZSk7XG4gICAgICBpZiAobGlzdERlcHRoID4gMSkge1xuICAgICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2goLi4ubmVzdGVkTGlzdEl0ZW1DbGFzc2VzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgLi4uY2xhc3Nlc1RvUmVtb3ZlKTtcbiAgfVxuICBpZiAoY2xhc3Nlc1RvQWRkLmxlbmd0aCA+IDApIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgLi4uY2xhc3Nlc1RvQWRkKTtcbiAgfVxufVxuXG4vKlxuICogVGhpcyBmdW5jdGlvbiBub3JtYWxpemVzIHRoZSBjaGlsZHJlbiBvZiBhIExpc3ROb2RlIGFmdGVyIHRoZSBjb252ZXJzaW9uIGZyb20gSFRNTCxcbiAqIGVuc3VyaW5nIHRoYXQgdGhleSBhcmUgYWxsIExpc3RJdGVtTm9kZXMgYW5kIGNvbnRhaW4gZWl0aGVyIGEgc2luZ2xlIG5lc3RlZCBMaXN0Tm9kZVxuICogb3Igc29tZSBvdGhlciBpbmxpbmUgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gJG5vcm1hbGl6ZUNoaWxkcmVuKG5vZGVzKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRMaXN0SXRlbXMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpKSB7XG4gICAgICBub3JtYWxpemVkTGlzdEl0ZW1zLnB1c2gobm9kZSk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIGlmICgkaXNMaXN0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRMaXN0SXRlbXMucHVzaCgkd3JhcEluTGlzdEl0ZW0oY2hpbGQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub3JtYWxpemVkTGlzdEl0ZW1zLnB1c2goJHdyYXBJbkxpc3RJdGVtKG5vZGUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZWRMaXN0SXRlbXM7XG59XG5mdW5jdGlvbiBpc0RvbUNoZWNrbGlzdChkb21Ob2RlKSB7XG4gIGlmIChkb21Ob2RlLmdldEF0dHJpYnV0ZSgnX19sZXhpY2FsbGlzdHR5cGUnKSA9PT0gJ2NoZWNrJyB8fFxuICAvLyBpcyBnaXRodWIgY2hlY2tsaXN0XG4gIGRvbU5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdjb250YWlucy10YXNrLWxpc3QnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIGlmIGNoaWxkcmVuIGFyZSBjaGVja2xpc3QgaXRlbXMsIHRoZSBub2RlIGlzIGEgY2hlY2tsaXN0IHVsLiBBcHBsaWNhYmxlIGZvciBnb29nbGVkb2MgY2hlY2tsaXN0IHBhc3RpbmcuXG4gIGZvciAoY29uc3QgY2hpbGQgb2YgZG9tTm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLmhhc0F0dHJpYnV0ZSgnYXJpYS1jaGVja2VkJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkY29udmVydExpc3ROb2RlKGRvbU5vZGUpIHtcbiAgY29uc3Qgbm9kZU5hbWUgPSBkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIGxldCBub2RlID0gbnVsbDtcbiAgaWYgKG5vZGVOYW1lID09PSAnb2wnKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHN0YXJ0ID0gZG9tTm9kZS5zdGFydDtcbiAgICBub2RlID0gJGNyZWF0ZUxpc3ROb2RlKCdudW1iZXInLCBzdGFydCk7XG4gIH0gZWxzZSBpZiAobm9kZU5hbWUgPT09ICd1bCcpIHtcbiAgICBpZiAoaXNEb21DaGVja2xpc3QoZG9tTm9kZSkpIHtcbiAgICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ2NoZWNrJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSAkY3JlYXRlTGlzdE5vZGUoJ2J1bGxldCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGFmdGVyOiAkbm9ybWFsaXplQ2hpbGRyZW4sXG4gICAgbm9kZVxuICB9O1xufVxuY29uc3QgVEFHX1RPX0xJU1RfVFlQRSA9IHtcbiAgb2w6ICdudW1iZXInLFxuICB1bDogJ2J1bGxldCdcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIExpc3ROb2RlIG9mIGxpc3RUeXBlLlxuICogQHBhcmFtIGxpc3RUeXBlIC0gVGhlIHR5cGUgb2YgbGlzdCB0byBiZSBjcmVhdGVkLiBDYW4gYmUgJ251bWJlcicsICdidWxsZXQnLCBvciAnY2hlY2snLlxuICogQHBhcmFtIHN0YXJ0IC0gV2hlcmUgYW4gb3JkZXJlZCBsaXN0IHN0YXJ0cyBpdHMgY291bnQsIHN0YXJ0ID0gMSBpZiBsZWZ0IHVuZGVmaW5lZC5cbiAqIEByZXR1cm5zIFRoZSBuZXcgTGlzdE5vZGVcbiAqL1xuZnVuY3Rpb24gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlID0gJ251bWJlcicsIHN0YXJ0ID0gMSkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaXN0Tm9kZShsaXN0VHlwZSwgc3RhcnQpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBub2RlIGlzIGEgTGlzdE5vZGUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHRvIGJlIGNoZWNrZWQuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGEgTGlzdE5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlzdE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIExpc3ROb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IElOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5EJyk7XG5mdW5jdGlvbiByZWdpc3RlckNoZWNrTGlzdChlZGl0b3IpIHtcbiAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgJGluc2VydExpc3QoJ2NoZWNrJyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgcmV0dXJuIGhhbmRsZUFycm93VXBPckRvd24oZXZlbnQsIGVkaXRvciwgZmFsc2UpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICByZXR1cm4gaGFuZGxlQXJyb3dVcE9yRG93bihldmVudCwgZWRpdG9yLCB0cnVlKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9FU0NBUEVfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IGFjdGl2ZUl0ZW0gPSBnZXRBY3RpdmVDaGVja0xpc3RJdGVtKCk7XG4gICAgaWYgKGFjdGl2ZUl0ZW0gIT0gbnVsbCkge1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICAgIGlmIChyb290RWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgIHJvb3RFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX1NQQUNFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBhY3RpdmVJdGVtID0gZ2V0QWN0aXZlQ2hlY2tMaXN0SXRlbSgpO1xuICAgIGlmIChhY3RpdmVJdGVtICE9IG51bGwgJiYgZWRpdG9yLmlzRWRpdGFibGUoKSkge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGFjdGl2ZUl0ZW0pO1xuICAgICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtTm9kZSkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGxpc3RJdGVtTm9kZS50b2dnbGVDaGVja2VkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICByZXR1cm4gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYW5jaG9yXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGlzRWxlbWVudCA9IGFuY2hvci50eXBlID09PSAnZWxlbWVudCc7XG4gICAgICAgIGlmIChpc0VsZW1lbnQgfHwgYW5jaG9yLm9mZnNldCA9PT0gMCkge1xuICAgICAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IGVsZW1lbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3JOb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICAgICAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoZWxlbWVudE5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpICYmIHBhcmVudC5nZXRMaXN0VHlwZSgpID09PSAnY2hlY2snICYmIChpc0VsZW1lbnQgfHwgZWxlbWVudE5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCkgPT09IGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRvbU5vZGUgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGVsZW1lbnROb2RlLl9fa2V5KTtcbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGUgIT0gbnVsbCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJSb290TGlzdGVuZXIoKHJvb3RFbGVtZW50LCBwcmV2RWxlbWVudCkgPT4ge1xuICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICB9XG4gICAgaWYgKHByZXZFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICBwcmV2RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZUNsaWNrKTtcbiAgICAgIHByZXZFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgIH1cbiAgfSkpO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2hlY2tJdGVtRXZlbnQoZXZlbnQsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KHRhcmdldCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZ25vcmUgY2xpY2tzIG9uIExJIHRoYXQgaGF2ZSBuZXN0ZWQgbGlzdHNcbiAgY29uc3QgZmlyc3RDaGlsZCA9IHRhcmdldC5maXJzdENoaWxkO1xuICBpZiAoaXNIVE1MRWxlbWVudChmaXJzdENoaWxkKSAmJiAoZmlyc3RDaGlsZC50YWdOYW1lID09PSAnVUwnIHx8IGZpcnN0Q2hpbGQudGFnTmFtZSA9PT0gJ09MJykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50Tm9kZSA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgZmllbGRcbiAgaWYgKCFwYXJlbnROb2RlIHx8IHBhcmVudE5vZGUuX19sZXhpY2FsTGlzdFR5cGUgIT09ICdjaGVjaycpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVjdCA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgY29uc3Qgem9vbSA9IGNhbGN1bGF0ZVpvb21MZXZlbCh0YXJnZXQpO1xuICBjb25zdCBjbGllbnRYID0gZXZlbnQuY2xpZW50WCAvIHpvb207XG5cbiAgLy8gVXNlIGdldENvbXB1dGVkU3R5bGUgaWYgYXZhaWxhYmxlLCBvdGhlcndpc2UgZmFsbGJhY2sgdG8gMHB4IHdpZHRoXG4gIGNvbnN0IGJlZm9yZVN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0LCAnOjpiZWZvcmUnKSA6IHtcbiAgICB3aWR0aDogJzBweCdcbiAgfTtcbiAgY29uc3QgYmVmb3JlV2lkdGhJblBpeGVscyA9IHBhcnNlRmxvYXQoYmVmb3JlU3R5bGVzLndpZHRoKTtcblxuICAvLyBNYWtlIGNsaWNrIGFyZWEgc2xpZ2h0bHkgbGFyZ2VyIGZvciB0b3VjaCBkZXZpY2VzIHRvIGltcHJvdmUgYWNjZXNzaWJpbGl0eVxuICBjb25zdCBpc1RvdWNoRXZlbnQgPSBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbiAgY29uc3QgY2xpY2tBcmVhUGFkZGluZyA9IGlzVG91Y2hFdmVudCA/IDMyIDogMDsgLy8gQWRkIDMycHggcGFkZGluZyBmb3IgdG91Y2ggZXZlbnRzXG5cbiAgaWYgKHRhcmdldC5kaXIgPT09ICdydGwnID8gY2xpZW50WCA8IHJlY3QucmlnaHQgKyBjbGlja0FyZWFQYWRkaW5nICYmIGNsaWVudFggPiByZWN0LnJpZ2h0IC0gYmVmb3JlV2lkdGhJblBpeGVscyAtIGNsaWNrQXJlYVBhZGRpbmcgOiBjbGllbnRYID4gcmVjdC5sZWZ0IC0gY2xpY2tBcmVhUGFkZGluZyAmJiBjbGllbnRYIDwgcmVjdC5sZWZ0ICsgYmVmb3JlV2lkdGhJblBpeGVscyArIGNsaWNrQXJlYVBhZGRpbmcpIHtcbiAgICBjYWxsYmFjaygpO1xuICB9XG59XG5mdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICBoYW5kbGVDaGVja0l0ZW1FdmVudChldmVudCwgKCkgPT4ge1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIGNvbnN0IGRvbU5vZGUgPSBldmVudC50YXJnZXQ7XG4gICAgICBjb25zdCBlZGl0b3IgPSBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUoZG9tTm9kZSk7XG4gICAgICBpZiAoZWRpdG9yICE9IG51bGwgJiYgZWRpdG9yLmlzRWRpdGFibGUoKSkge1xuICAgICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZG9tTm9kZSk7XG4gICAgICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShub2RlKSkge1xuICAgICAgICAgICAgZG9tTm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgbm9kZS50b2dnbGVDaGVja2VkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgaGFuZGxlQ2hlY2tJdGVtRXZlbnQoZXZlbnQsICgpID0+IHtcbiAgICAvLyBQcmV2ZW50cyBjYXJldCBtb3Zpbmcgd2hlbiBjbGlja2luZyBvbiBjaGVjayBtYXJrXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRBY3RpdmVDaGVja0xpc3RJdGVtKCkge1xuICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoYWN0aXZlRWxlbWVudCkgJiYgYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnTEknICYmIGFjdGl2ZUVsZW1lbnQucGFyZW50Tm9kZSAhPSBudWxsICYmXG4gIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgZmllbGRcbiAgYWN0aXZlRWxlbWVudC5wYXJlbnROb2RlLl9fbGV4aWNhbExpc3RUeXBlID09PSAnY2hlY2snID8gYWN0aXZlRWxlbWVudCA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQ2hlY2tMaXN0SXRlbVNpYmxpbmcobm9kZSwgYmFja3dhcmQpIHtcbiAgbGV0IHNpYmxpbmcgPSBiYWNrd2FyZCA/IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuXG4gIC8vIEdvaW5nIHVwIGluIGEgdHJlZSB0byBnZXQgbm9uLW51bGwgc2libGluZ1xuICB3aGlsZSAoc2libGluZyA9PSBudWxsICYmICRpc0xpc3RJdGVtTm9kZShwYXJlbnQpKSB7XG4gICAgLy8gR2V0IGxpIC0+IHBhcmVudCB1bC9vbCAtPiBwYXJlbnQgbGlcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgIT0gbnVsbCkge1xuICAgICAgc2libGluZyA9IGJhY2t3YXJkID8gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpIDogcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gR29pbmcgZG93biBpbiBhIHRyZWUgdG8gZ2V0IGZpcnN0IG5vbi1uZXN0ZWQgbGlzdCBpdGVtXG4gIHdoaWxlICgkaXNMaXN0SXRlbU5vZGUoc2libGluZykpIHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gYmFja3dhcmQgPyBzaWJsaW5nLmdldExhc3RDaGlsZCgpIDogc2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCEkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgcmV0dXJuIHNpYmxpbmc7XG4gICAgfVxuICAgIHNpYmxpbmcgPSBiYWNrd2FyZCA/IGZpcnN0Q2hpbGQuZ2V0TGFzdENoaWxkKCkgOiBmaXJzdENoaWxkLmdldEZpcnN0Q2hpbGQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGhhbmRsZUFycm93VXBPckRvd24oZXZlbnQsIGVkaXRvciwgYmFja3dhcmQpIHtcbiAgY29uc3QgYWN0aXZlSXRlbSA9IGdldEFjdGl2ZUNoZWNrTGlzdEl0ZW0oKTtcbiAgaWYgKGFjdGl2ZUl0ZW0gIT0gbnVsbCkge1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3QgbGlzdEl0ZW0gPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhY3RpdmVJdGVtKTtcbiAgICAgIGlmICghJGlzTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0TGlzdEl0ZW0gPSBmaW5kQ2hlY2tMaXN0SXRlbVNpYmxpbmcobGlzdEl0ZW0sIGJhY2t3YXJkKTtcbiAgICAgIGlmIChuZXh0TGlzdEl0ZW0gIT0gbnVsbCkge1xuICAgICAgICBuZXh0TGlzdEl0ZW0uc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgY29uc3QgZG9tID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShuZXh0TGlzdEl0ZW0uX19rZXkpO1xuICAgICAgICBpZiAoZG9tICE9IG51bGwpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZG9tLmZvY3VzKCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgVVBEQVRFX0xJU1RfU1RBUlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1VQREFURV9MSVNUX1NUQVJUX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCcpO1xuY29uc3QgUkVNT1ZFX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1JFTU9WRV9MSVNUX0NPTU1BTkQnKTtcbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdChlZGl0b3IpIHtcbiAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgJGluc2VydExpc3QoJ251bWJlcicpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoVVBEQVRFX0xJU1RfU1RBUlRfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbGlzdE5vZGVLZXksXG4gICAgICBuZXdTdGFydFxuICAgIH0gPSBwYXlsb2FkO1xuICAgIGNvbnN0IGxpc3ROb2RlID0gJGdldE5vZGVCeUtleShsaXN0Tm9kZUtleSk7XG4gICAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0Tm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGxpc3ROb2RlLmdldExpc3RUeXBlKCkgPT09ICdudW1iZXInKSB7XG4gICAgICBsaXN0Tm9kZS5zZXRTdGFydChuZXdTdGFydCk7XG4gICAgICB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobGlzdE5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgJGluc2VydExpc3QoJ2J1bGxldCcpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoUkVNT1ZFX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICRyZW1vdmVMaXN0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICgpID0+ICRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoKCksIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShMaXN0SXRlbU5vZGUsIG5vZGUgPT4ge1xuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoZmlyc3RDaGlsZCkge1xuICAgICAgaWYgKCRpc1RleHROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZmlyc3RDaGlsZC5nZXRTdHlsZSgpO1xuICAgICAgICBjb25zdCBmb3JtYXQgPSBmaXJzdENoaWxkLmdldEZvcm1hdCgpO1xuICAgICAgICBpZiAobm9kZS5nZXRUZXh0U3R5bGUoKSAhPT0gc3R5bGUpIHtcbiAgICAgICAgICBub2RlLnNldFRleHRTdHlsZShzdHlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuZ2V0VGV4dEZvcm1hdCgpICE9PSBmb3JtYXQpIHtcbiAgICAgICAgICBub2RlLnNldFRleHRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGVtcHR5LCBjaGVjayB0aGUgc2VsZWN0aW9uXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAoc2VsZWN0aW9uLnN0eWxlICE9PSBub2RlLmdldFRleHRTdHlsZSgpIHx8IHNlbGVjdGlvbi5mb3JtYXQgIT09IG5vZGUuZ2V0VGV4dEZvcm1hdCgpKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBub2RlLmlzKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKSkge1xuICAgICAgICBub2RlLnNldFRleHRTdHlsZShzZWxlY3Rpb24uc3R5bGUpLnNldFRleHRGb3JtYXQoc2VsZWN0aW9uLmZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICB9KSwgZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShUZXh0Tm9kZSwgbm9kZSA9PiB7XG4gICAgY29uc3QgbGlzdEl0ZW1QYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtUGFyZW50Tm9kZSkgJiYgbm9kZS5pcyhsaXN0SXRlbVBhcmVudE5vZGUuZ2V0Rmlyc3RDaGlsZCgpKSkge1xuICAgICAgY29uc3Qgc3R5bGUgPSBub2RlLmdldFN0eWxlKCk7XG4gICAgICBjb25zdCBmb3JtYXQgPSBub2RlLmdldEZvcm1hdCgpO1xuICAgICAgaWYgKHN0eWxlICE9PSBsaXN0SXRlbVBhcmVudE5vZGUuZ2V0VGV4dFN0eWxlKCkgfHwgZm9ybWF0ICE9PSBsaXN0SXRlbVBhcmVudE5vZGUuZ2V0VGV4dEZvcm1hdCgpKSB7XG4gICAgICAgIGxpc3RJdGVtUGFyZW50Tm9kZS5zZXRUZXh0U3R5bGUoc3R5bGUpLnNldFRleHRGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pKTtcbiAgcmV0dXJuIHJlbW92ZUxpc3RlbmVyO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJMaXN0U3RyaWN0SW5kZW50VHJhbnNmb3JtKGVkaXRvcikge1xuICBjb25zdCAkZm9ybWF0TGlzdEluZGVudFN0cmljdCA9IGxpc3RJdGVtTm9kZSA9PiB7XG4gICAgY29uc3QgbGlzdE5vZGUgPSBsaXN0SXRlbU5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGxpc3RJdGVtTm9kZS5nZXRGaXJzdENoaWxkKCkpIHx8ICEkaXNMaXN0Tm9kZShsaXN0Tm9kZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRpbmdMaXN0SXRlbU5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGxpc3RJdGVtTm9kZSwgbm9kZSA9PiAkaXNMaXN0SXRlbU5vZGUobm9kZSkgJiYgJGlzTGlzdE5vZGUobm9kZS5nZXRQYXJlbnQoKSkgJiYgJGlzTGlzdEl0ZW1Ob2RlKG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkpKTtcbiAgICBpZiAoc3RhcnRpbmdMaXN0SXRlbU5vZGUgPT09IG51bGwgJiYgbGlzdEl0ZW1Ob2RlLmdldEluZGVudCgpID4gMCkge1xuICAgICAgbGlzdEl0ZW1Ob2RlLnNldEluZGVudCgwKTtcbiAgICB9IGVsc2UgaWYgKCRpc0xpc3RJdGVtTm9kZShzdGFydGluZ0xpc3RJdGVtTm9kZSkpIHtcbiAgICAgIGNvbnN0IHByZXZMaXN0SXRlbU5vZGUgPSBzdGFydGluZ0xpc3RJdGVtTm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUocHJldkxpc3RJdGVtTm9kZSkpIHtcbiAgICAgICAgY29uc3QgZW5kTGlzdEl0ZW1Ob2RlID0gJGZpbmRDaGlsZHJlbkVuZExpc3RJdGVtTm9kZShwcmV2TGlzdEl0ZW1Ob2RlKTtcbiAgICAgICAgY29uc3QgZW5kTGlzdE5vZGUgPSBlbmRMaXN0SXRlbU5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmICgkaXNMaXN0Tm9kZShlbmRMaXN0Tm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2RGVwdGggPSAkZ2V0TGlzdERlcHRoKGVuZExpc3ROb2RlKTtcbiAgICAgICAgICBjb25zdCBkZXB0aCA9ICRnZXRMaXN0RGVwdGgobGlzdE5vZGUpO1xuICAgICAgICAgIGlmIChwcmV2RGVwdGggKyAxIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIGxpc3RJdGVtTm9kZS5zZXRJbmRlbnQocHJldkRlcHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0ICRwcm9jZXNzTGlzdFdpdGhTdHJpY3RJbmRlbnQgPSBsaXN0Tm9kZSA9PiB7XG4gICAgY29uc3QgcXVldWUgPSBbbGlzdE5vZGVdO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBub2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgIGlmICghJGlzTGlzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuZ2V0Q2hpbGRyZW4oKSkge1xuICAgICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGNoaWxkKSkge1xuICAgICAgICAgICRmb3JtYXRMaXN0SW5kZW50U3RyaWN0KGNoaWxkKTtcbiAgICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gY2hpbGQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgICAgIGlmICgkaXNMaXN0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICAgICAgcXVldWUucHVzaChmaXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKExpc3ROb2RlLCAkcHJvY2Vzc0xpc3RXaXRoU3RyaWN0SW5kZW50KTtcbn1cbmZ1bmN0aW9uICRmaW5kQ2hpbGRyZW5FbmRMaXN0SXRlbU5vZGUobGlzdEl0ZW1Ob2RlKSB7XG4gIGxldCBjdXJyZW50ID0gbGlzdEl0ZW1Ob2RlO1xuICBsZXQgZmlyc3RDaGlsZCA9IGN1cnJlbnQuZ2V0Rmlyc3RDaGlsZCgpO1xuICB3aGlsZSAoJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICBjb25zdCBsYXN0Q2hpbGQgPSBmaXJzdENoaWxkLmdldExhc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobGFzdENoaWxkKSkge1xuICAgICAgY3VycmVudCA9IGxhc3RDaGlsZDtcbiAgICAgIGZpcnN0Q2hpbGQgPSBjdXJyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjdXJyZW50O1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSB7QGxpbmsgJGluc2VydExpc3R9IGZyb20gYW4gdXBkYXRlIG9yIGNvbW1hbmQgbGlzdGVuZXIuXG4gKlxuICogSW5zZXJ0cyBhIG5ldyBMaXN0Tm9kZS4gSWYgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBub2RlIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZSBhbmQgaXMgYSBjaGlsZCBvZlxuICogdGhlIHJvb3Qvc2hhZG93IHJvb3QsIGl0IHdpbGwgcmVwbGFjZSB0aGUgTGlzdEl0ZW1Ob2RlIHdpdGggYSBMaXN0Tm9kZSBhbmQgdGhlIG9sZCBMaXN0SXRlbU5vZGUuXG4gKiBPdGhlcndpc2UgaXQgd2lsbCByZXBsYWNlIGl0cyBwYXJlbnQgd2l0aCBhIG5ldyBMaXN0Tm9kZSBhbmQgcmUtaW5zZXJ0IHRoZSBMaXN0SXRlbU5vZGUgYW5kIGFueSBwcmV2aW91cyBjaGlsZHJlbi5cbiAqIElmIHRoZSBzZWxlY3Rpb24ncyBhbmNob3Igbm9kZSBpcyBub3QgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlLCBpdCB3aWxsIGFkZCBhIG5ldyBMaXN0Tm9kZSBvciBtZXJnZSBhbiBleGlzdGluZyBMaXN0Tm9kZSxcbiAqIHVubGVzcyB0aGUgdGhlIG5vZGUgaXMgYSBsZWFmIG5vZGUsIGluIHdoaWNoIGNhc2UgaXQgd2lsbCBhdHRlbXB0IHRvIGZpbmQgYSBMaXN0Tm9kZSB1cCB0aGUgYnJhbmNoIGFuZCByZXBsYWNlIGl0IHdpdGhcbiAqIGEgbmV3IExpc3ROb2RlLCBvciBjcmVhdGUgYSBuZXcgTGlzdE5vZGUgYXQgdGhlIG5lYXJlc3Qgcm9vdC9zaGFkb3cgcm9vdC5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gbGlzdFR5cGUgLSBUaGUgdHlwZSBvZiBsaXN0LCBcIm51bWJlclwiIHwgXCJidWxsZXRcIiB8IFwiY2hlY2tcIi5cbiAqL1xuZnVuY3Rpb24gaW5zZXJ0TGlzdChlZGl0b3IsIGxpc3RUeXBlKSB7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4gJGluc2VydExpc3QobGlzdFR5cGUpKTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rICRyZW1vdmVMaXN0fSBmcm9tIGFuIHVwZGF0ZSBvciBjb21tYW5kIGxpc3RlbmVyLlxuICpcbiAqIFNlYXJjaGVzIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RyYWwgTGlzdE5vZGUgYW5kIHJlbW92ZXMgaXQuIElmIHNlbGVjdGlvbiBpcyBhbiBlbXB0eSBMaXN0SXRlbU5vZGVcbiAqIGl0IHdpbGwgcmVtb3ZlIHRoZSB3aG9sZSBsaXN0LCBpbmNsdWRpbmcgdGhlIExpc3RJdGVtTm9kZS4gRm9yIGVhY2ggTGlzdEl0ZW1Ob2RlIGluIHRoZSBMaXN0Tm9kZSxcbiAqIHJlbW92ZUxpc3Qgd2lsbCBhbHNvIGdlbmVyYXRlIG5ldyBQYXJhZ3JhcGhOb2RlcyBpbiB0aGUgcmVtb3ZlZCBMaXN0Tm9kZSdzIHBsYWNlLiBBbnkgY2hpbGQgbm9kZVxuICogaW5zaWRlIGEgTGlzdEl0ZW1Ob2RlIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIG5ldyBQYXJhZ3JhcGhOb2Rlcy5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUxpc3QoZWRpdG9yKSB7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4gJHJlbW92ZUxpc3QoKSk7XG59XG5cbmV4cG9ydCB7ICRjcmVhdGVMaXN0SXRlbU5vZGUsICRjcmVhdGVMaXN0Tm9kZSwgJGdldExpc3REZXB0aCwgJGhhbmRsZUxpc3RJbnNlcnRQYXJhZ3JhcGgsICRpbnNlcnRMaXN0LCAkaXNMaXN0SXRlbU5vZGUsICRpc0xpc3ROb2RlLCAkcmVtb3ZlTGlzdCwgSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCwgSU5TRVJUX09SREVSRURfTElTVF9DT01NQU5ELCBJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCwgTGlzdEl0ZW1Ob2RlLCBMaXN0Tm9kZSwgUkVNT1ZFX0xJU1RfQ09NTUFORCwgVVBEQVRFX0xJU1RfU1RBUlRfQ09NTUFORCwgaW5zZXJ0TGlzdCwgcmVnaXN0ZXJDaGVja0xpc3QsIHJlZ2lzdGVyTGlzdCwgcmVnaXN0ZXJMaXN0U3RyaWN0SW5kZW50VHJhbnNmb3JtLCByZW1vdmVMaXN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lexical/list/LexicalList.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/mark/LexicalMark.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/mark/LexicalMark.dev.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createMarkNode: function() { return /* binding */ $createMarkNode; },\n/* harmony export */   $getMarkIDs: function() { return /* binding */ $getMarkIDs; },\n/* harmony export */   $isMarkNode: function() { return /* binding */ $isMarkNode; },\n/* harmony export */   $unwrapMarkNode: function() { return /* binding */ $unwrapMarkNode; },\n/* harmony export */   $wrapSelectionInMarkNode: function() { return /* binding */ $wrapSelectionInMarkNode; },\n/* harmony export */   MarkNode: function() { return /* binding */ MarkNode; }\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NO_IDS = [];\n\n/** @noInheritDoc */\nclass MarkNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(node.__ids, node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    return $createMarkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIDs(serializedNode.ids);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs()\n    };\n  }\n  constructor(ids = NO_IDS, key) {\n    super(key);\n    this.__ids = ids;\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    return this.getIDs().includes(id);\n  }\n  getIDs() {\n    return Array.from(this.getLatest().__ids);\n  }\n  setIDs(ids) {\n    const self = this.getWritable();\n    self.__ids = ids;\n    return self;\n  }\n  addID(id) {\n    const self = this.getWritable();\n    return self.__ids.includes(id) ? self : self.setIDs([...self.__ids, id]);\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    const idx = self.__ids.indexOf(id);\n    if (idx === -1) {\n      return self;\n    }\n    const ids = Array.from(self.__ids);\n    ids.splice(idx, 1);\n    return self.setIDs(ids);\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const markNode = $createMarkNode(this.__ids);\n    this.insertAfter(markNode, restoreSelection);\n    return markNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids = NO_IDS) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  // Force a forwards selection since append is used, ignore the argument.\n  // A new selection is used to avoid side-effects of flipping the given\n  // selection\n  const forwardSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n  const [startPoint, endPoint] = selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];\n  forwardSelection.anchor.set(startPoint.key, startPoint.offset, startPoint.type);\n  forwardSelection.focus.set(endPoint.key, endPoint.offset, endPoint.type);\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // Note that extract will split text nodes at the boundaries\n  const nodes = forwardSelection.extract();\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (const node of nodes) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    let targetNode = null;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      // Case 1: The node is a text node and we can include it\n      targetNode = node;\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may ultimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n      continue;\n    } else if (((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) && node.isInline()) {\n      // Case 3: inline element/decorator nodes can be added in their entirety\n      // to the new mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvbWFyay9MZXhpY2FsTWFyay5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNKO0FBQ2pFOztBQUVyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixnREFBVztBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBLE1BQU0sc0VBQXNCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0VBQXNCO0FBQ2hDO0FBQ0EsUUFBUTtBQUNSLFFBQVEsMkVBQTJCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4REFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxVQUFVLHVEQUFjLFVBQVUseURBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUyxvREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrL0xleGljYWxNYXJrLmRldi5tanM/ZDQ4YSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IEVsZW1lbnROb2RlLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24sICRpc0VsZW1lbnROb2RlLCAkaXNUZXh0Tm9kZSwgJGlzRGVjb3JhdG9yTm9kZSB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50IH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IE5PX0lEUyA9IFtdO1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgTWFya05vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ21hcmsnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBNYXJrTm9kZShub2RlLl9faWRzLCBub2RlLl9fa2V5KTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVNYXJrTm9kZSgpLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKTtcbiAgfVxuICB1cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiBzdXBlci51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkuc2V0SURzKHNlcmlhbGl6ZWROb2RlLmlkcyk7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgaWRzOiB0aGlzLmdldElEcygpXG4gICAgfTtcbiAgfVxuICBjb25zdHJ1Y3RvcihpZHMgPSBOT19JRFMsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX2lkcyA9IGlkcztcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21hcmsnKTtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5tYXJrKTtcbiAgICBpZiAodGhpcy5fX2lkcy5sZW5ndGggPiAxKSB7XG4gICAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5tYXJrT3ZlcmxhcCk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZWxlbWVudCwgY29uZmlnKSB7XG4gICAgY29uc3QgcHJldklEcyA9IHByZXZOb2RlLl9faWRzO1xuICAgIGNvbnN0IG5leHRJRHMgPSB0aGlzLl9faWRzO1xuICAgIGNvbnN0IHByZXZJRHNDb3VudCA9IHByZXZJRHMubGVuZ3RoO1xuICAgIGNvbnN0IG5leHRJRHNDb3VudCA9IG5leHRJRHMubGVuZ3RoO1xuICAgIGNvbnN0IG92ZXJsYXBUaGVtZSA9IGNvbmZpZy50aGVtZS5tYXJrT3ZlcmxhcDtcbiAgICBpZiAocHJldklEc0NvdW50ICE9PSBuZXh0SURzQ291bnQpIHtcbiAgICAgIGlmIChwcmV2SURzQ291bnQgPT09IDEpIHtcbiAgICAgICAgaWYgKG5leHRJRHNDb3VudCA9PT0gMikge1xuICAgICAgICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgb3ZlcmxhcFRoZW1lKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXh0SURzQ291bnQgPT09IDEpIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIG92ZXJsYXBUaGVtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBoYXNJRChpZCkge1xuICAgIHJldHVybiB0aGlzLmdldElEcygpLmluY2x1ZGVzKGlkKTtcbiAgfVxuICBnZXRJRHMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5nZXRMYXRlc3QoKS5fX2lkcyk7XG4gIH1cbiAgc2V0SURzKGlkcykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2lkcyA9IGlkcztcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBhZGRJRChpZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgcmV0dXJuIHNlbGYuX19pZHMuaW5jbHVkZXMoaWQpID8gc2VsZiA6IHNlbGYuc2V0SURzKFsuLi5zZWxmLl9faWRzLCBpZF0pO1xuICB9XG4gIGRlbGV0ZUlEKGlkKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBpZHggPSBzZWxmLl9faWRzLmluZGV4T2YoaWQpO1xuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgY29uc3QgaWRzID0gQXJyYXkuZnJvbShzZWxmLl9faWRzKTtcbiAgICBpZHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgcmV0dXJuIHNlbGYuc2V0SURzKGlkcyk7XG4gIH1cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IG1hcmtOb2RlID0gJGNyZWF0ZU1hcmtOb2RlKHRoaXMuX19pZHMpO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobWFya05vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBtYXJrTm9kZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzSW5saW5lKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgZGVzdGluYXRpb24gPT09ICdodG1sJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICBjb25zdCBzZWxlY3Rpb25MZW5ndGggPSBpc0JhY2t3YXJkID8gYW5jaG9yLm9mZnNldCAtIGZvY3VzLm9mZnNldCA6IGZvY3VzLm9mZnNldCAtIGFuY2hvci5vZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihhbmNob3JOb2RlKSAmJiB0aGlzLmlzUGFyZW50T2YoZm9jdXNOb2RlKSAmJiB0aGlzLmdldFRleHRDb250ZW50KCkubGVuZ3RoID09PSBzZWxlY3Rpb25MZW5ndGg7XG4gIH1cbiAgZXhjbHVkZUZyb21Db3B5KGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uICE9PSAnY2xvbmUnO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlTWFya05vZGUoaWRzID0gTk9fSURTKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IE1hcmtOb2RlKGlkcykpO1xufVxuZnVuY3Rpb24gJGlzTWFya05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE1hcmtOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uICR1bndyYXBNYXJrTm9kZShub2RlKSB7XG4gIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICBsZXQgdGFyZ2V0ID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuaW5zZXJ0QWZ0ZXIoY2hpbGQpO1xuICAgIH1cbiAgICB0YXJnZXQgPSBjaGlsZDtcbiAgfVxuICBub2RlLnJlbW92ZSgpO1xufVxuZnVuY3Rpb24gJHdyYXBTZWxlY3Rpb25Jbk1hcmtOb2RlKHNlbGVjdGlvbiwgaXNCYWNrd2FyZCwgaWQsIGNyZWF0ZU5vZGUpIHtcbiAgLy8gRm9yY2UgYSBmb3J3YXJkcyBzZWxlY3Rpb24gc2luY2UgYXBwZW5kIGlzIHVzZWQsIGlnbm9yZSB0aGUgYXJndW1lbnQuXG4gIC8vIEEgbmV3IHNlbGVjdGlvbiBpcyB1c2VkIHRvIGF2b2lkIHNpZGUtZWZmZWN0cyBvZiBmbGlwcGluZyB0aGUgZ2l2ZW5cbiAgLy8gc2VsZWN0aW9uXG4gIGNvbnN0IGZvcndhcmRTZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcbiAgY29uc3QgW3N0YXJ0UG9pbnQsIGVuZFBvaW50XSA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCkgPyBbc2VsZWN0aW9uLmZvY3VzLCBzZWxlY3Rpb24uYW5jaG9yXSA6IFtzZWxlY3Rpb24uYW5jaG9yLCBzZWxlY3Rpb24uZm9jdXNdO1xuICBmb3J3YXJkU2VsZWN0aW9uLmFuY2hvci5zZXQoc3RhcnRQb2ludC5rZXksIHN0YXJ0UG9pbnQub2Zmc2V0LCBzdGFydFBvaW50LnR5cGUpO1xuICBmb3J3YXJkU2VsZWN0aW9uLmZvY3VzLnNldChlbmRQb2ludC5rZXksIGVuZFBvaW50Lm9mZnNldCwgZW5kUG9pbnQudHlwZSk7XG4gIGxldCBjdXJyZW50Tm9kZVBhcmVudDtcbiAgbGV0IGxhc3RDcmVhdGVkTWFya05vZGU7XG5cbiAgLy8gTm90ZSB0aGF0IGV4dHJhY3Qgd2lsbCBzcGxpdCB0ZXh0IG5vZGVzIGF0IHRoZSBib3VuZGFyaWVzXG4gIGNvbnN0IG5vZGVzID0gZm9yd2FyZFNlbGVjdGlvbi5leHRyYWN0KCk7XG4gIC8vIFdlIG9ubHkgd2FudCB3cmFwIGFkamFjZW50IHRleHQgbm9kZXMsIGxpbmUgYnJlYWsgbm9kZXNcbiAgLy8gYW5kIGlubGluZSBlbGVtZW50IG5vZGVzLiBGb3IgZGVjb3JhdG9yIG5vZGVzIGFuZCBibG9ja1xuICAvLyBlbGVtZW50IG5vZGVzLCB3ZSBzdGVwIG91dCBvZiB0aGVpciBib3VuZGFyeSBhbmQgc3RhcnRcbiAgLy8gYWdhaW4gYWZ0ZXIsIGlmIHRoZXJlIGFyZSBtb3JlIG5vZGVzLlxuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdENyZWF0ZWRNYXJrTm9kZSkgJiYgbGFzdENyZWF0ZWRNYXJrTm9kZS5pc1BhcmVudE9mKG5vZGUpKSB7XG4gICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIGlzIGEgY2hpbGQgb2YgdGhlIGxhc3QgY3JlYXRlZCBtYXJrIG5vZGUsIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8gaGVyZVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCB0YXJnZXROb2RlID0gbnVsbDtcbiAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIC8vIENhc2UgMTogVGhlIG5vZGUgaXMgYSB0ZXh0IG5vZGUgYW5kIHdlIGNhbiBpbmNsdWRlIGl0XG4gICAgICB0YXJnZXROb2RlID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKCRpc01hcmtOb2RlKG5vZGUpKSB7XG4gICAgICAvLyBDYXNlIDI6IHRoZSBub2RlIGlzIGEgbWFyayBub2RlIGFuZCB3ZSBjYW4gaWdub3JlIGl0IGFzIGEgdGFyZ2V0LFxuICAgICAgLy8gbW92aW5nIG9uIHRvIGl0cyBjaGlsZHJlbi4gTm90ZSB0aGF0IHdoZW4gd2UgbWFrZSBhIG1hcmsgaW5zaWRlXG4gICAgICAvLyBhbm90aGVyIG1hcmssIGl0IG1heSB1bHRpbWF0ZWx5IGJlIHVubmVzdGVkIGJ5IGEgY2FsbCB0b1xuICAgICAgLy8gYHJlZ2lzdGVyTmVzdGVkRWxlbWVudFJlc29sdmVyPE1hcmtOb2RlPmAgc29tZXdoZXJlIGVsc2UgaW4gdGhlXG4gICAgICAvLyBjb2RlYmFzZS5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoKCRpc0VsZW1lbnROb2RlKG5vZGUpIHx8ICRpc0RlY29yYXRvck5vZGUobm9kZSkpICYmIG5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgLy8gQ2FzZSAzOiBpbmxpbmUgZWxlbWVudC9kZWNvcmF0b3Igbm9kZXMgY2FuIGJlIGFkZGVkIGluIHRoZWlyIGVudGlyZXR5XG4gICAgICAvLyB0byB0aGUgbmV3IG1hcmtcbiAgICAgIHRhcmdldE5vZGUgPSBub2RlO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgLy8gTm93IHRoYXQgd2UgaGF2ZSBhIHRhcmdldCBub2RlIGZvciB3cmFwcGluZyB3aXRoIGEgbWFyaywgd2UgY2FuIHJ1blxuICAgICAgLy8gdGhyb3VnaCBzcGVjaWFsIGNhc2VzLlxuICAgICAgaWYgKHRhcmdldE5vZGUgJiYgdGFyZ2V0Tm9kZS5pcyhjdXJyZW50Tm9kZVBhcmVudCkpIHtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgbm9kZSBpcyBhIGNoaWxkIG9mIHRoZSB0YXJnZXQgbm9kZSB0byBiZSB3cmFwcGVkLCB0aGVyZVxuICAgICAgICAvLyBpcyBub3RoaW5nIHRvIGRvIGhlcmUuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRhcmdldE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAocGFyZW50Tm9kZSA9PSBudWxsIHx8ICFwYXJlbnROb2RlLmlzKGN1cnJlbnROb2RlUGFyZW50KSkge1xuICAgICAgICAvLyBJZiB0aGUgcGFyZW50IG5vZGUgaXMgbm90IHRoZSBjdXJyZW50IG5vZGUncyBwYXJlbnQgbm9kZSwgd2UgY2FuXG4gICAgICAgIC8vIGNsZWFyIHRoZSBsYXN0IGNyZWF0ZWQgbWFyayBub2RlLlxuICAgICAgICBsYXN0Q3JlYXRlZE1hcmtOb2RlID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY3VycmVudE5vZGVQYXJlbnQgPSBwYXJlbnROb2RlO1xuICAgICAgaWYgKGxhc3RDcmVhdGVkTWFya05vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY3JlYXRlZCBtYXJrIG5vZGUsIHdlIGNhbiBtYWtlIG9uZVxuICAgICAgICBjb25zdCBjcmVhdGVNYXJrTm9kZSA9IGNyZWF0ZU5vZGUgfHwgJGNyZWF0ZU1hcmtOb2RlO1xuICAgICAgICBsYXN0Q3JlYXRlZE1hcmtOb2RlID0gY3JlYXRlTWFya05vZGUoW2lkXSk7XG4gICAgICAgIHRhcmdldE5vZGUuaW5zZXJ0QmVmb3JlKGxhc3RDcmVhdGVkTWFya05vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIHRhcmdldCBub2RlIHRvIGJlIHdyYXBwZWQgaW4gdGhlIGxhdGVzdCBjcmVhdGVkIG1hcmsgbm9kZVxuICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZS5hcHBlbmQodGFyZ2V0Tm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSB0YXJnZXQgbm9kZSB0byB3cmFwIHdlIGNhbiBjbGVhciBvdXIgc3RhdGUgYW5kXG4gICAgICAvLyBjb250aW51ZSBvbiB3aXRoIHRoZSBuZXh0IG5vZGVcbiAgICAgIGN1cnJlbnROb2RlUGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgLy8gTWFrZSBzZWxlY3Rpb24gY29sbGFwc2VkIGF0IHRoZSBlbmRcbiAgaWYgKCRpc0VsZW1lbnROb2RlKGxhc3RDcmVhdGVkTWFya05vZGUpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgIGlzQmFja3dhcmQgPyBsYXN0Q3JlYXRlZE1hcmtOb2RlLnNlbGVjdFN0YXJ0KCkgOiBsYXN0Q3JlYXRlZE1hcmtOb2RlLnNlbGVjdEVuZCgpO1xuICB9XG59XG5mdW5jdGlvbiAkZ2V0TWFya0lEcyhub2RlLCBvZmZzZXQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc01hcmtOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlLmdldElEcygpO1xuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUoY3VycmVudE5vZGUpICYmIG9mZnNldCA9PT0gY3VycmVudE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gY3VycmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmICgkaXNNYXJrTm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgcmV0dXJuIG5leHRTaWJsaW5nLmdldElEcygpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmdldFBhcmVudCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyAkY3JlYXRlTWFya05vZGUsICRnZXRNYXJrSURzLCAkaXNNYXJrTm9kZSwgJHVud3JhcE1hcmtOb2RlLCAkd3JhcFNlbGVjdGlvbkluTWFya05vZGUsIE1hcmtOb2RlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lexical/mark/LexicalMark.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalComposer.dev.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposer.dev.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalComposer: function() { return /* binding */ LexicalComposer; }\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst HISTORY_MERGE_OPTIONS = {\n  tag: lexical__WEBPACK_IMPORTED_MODULE_2__.HISTORY_MERGE_TAG\n};\nfunction LexicalComposer({\n  initialConfig,\n  children\n}) {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const {\n      theme,\n      namespace,\n      nodes,\n      onError,\n      editorState: initialEditorState,\n      html\n    } = initialConfig;\n    const context = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.createLexicalComposerContext)(null, theme);\n    const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.createEditor)({\n      editable: initialConfig.editable,\n      html,\n      namespace,\n      nodes,\n      onError: error => onError(error, editor),\n      theme\n    });\n    initializeEditor(editor, initialEditorState);\n    return [editor, context];\n  },\n  // We only do this for init\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useLayoutEffectImpl(() => {\n    const isEditable = initialConfig.editable;\n    const [editor] = composerContext;\n    editor.setEditable(isEditable !== undefined ? isEditable : true);\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_3__.LexicalComposerContext.Provider, {\n    value: composerContext,\n    children: children\n  });\n}\nfunction initializeEditor(editor, initialEditorState) {\n  if (initialEditorState === null) {\n    return;\n  } else if (initialEditorState === undefined) {\n    editor.update(() => {\n      const root = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.$getRoot)();\n      if (root.isEmpty()) {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.$createParagraphNode)();\n        root.append(paragraph);\n        const activeElement = CAN_USE_DOM ? document.activeElement : null;\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_2__.$getSelection)() !== null || activeElement !== null && activeElement === editor.getRootElement()) {\n          paragraph.select();\n        }\n      }\n    }, HISTORY_MERGE_OPTIONS);\n  } else if (initialEditorState !== null) {\n    switch (typeof initialEditorState) {\n      case 'string':\n        {\n          const parsedEditorState = editor.parseEditorState(initialEditorState);\n          editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'object':\n        {\n          editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n      case 'function':\n        {\n          editor.update(() => {\n            const root = (0,lexical__WEBPACK_IMPORTED_MODULE_2__.$getRoot)();\n            if (root.isEmpty()) {\n              initialEditorState(editor);\n            }\n          }, HISTORY_MERGE_OPTIONS);\n          break;\n        }\n    }\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNkc7QUFDSjtBQUM3QztBQUNwQjs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBZSxHQUFHLDRDQUFTOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sc0RBQWlCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELDBCQUEwQiw4Q0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0IsbUdBQTRCO0FBQ2hELG1CQUFtQixxREFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQixzREFBRyxDQUFDLHlGQUFzQjtBQUNoRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsbUJBQW1CLGlEQUFRO0FBQzNCO0FBQ0EsMEJBQTBCLDZEQUFvQjtBQUM5QztBQUNBO0FBQ0EsWUFBWSxzREFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixpREFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxDb21wb3Nlci5kZXYubWpzPzhmOGEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBjcmVhdGVMZXhpY2FsQ29tcG9zZXJDb250ZXh0LCBMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyBjcmVhdGVFZGl0b3IsICRnZXRSb290LCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGdldFNlbGVjdGlvbiwgSElTVE9SWV9NRVJHRV9UQUcgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IGluIFJlYWN0IDE5LFxuLy8gYnV0IHdlIGN1cnJlbnRseSBzdXBwb3J0IFJlYWN0ID49MTcueFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBISVNUT1JZX01FUkdFX09QVElPTlMgPSB7XG4gIHRhZzogSElTVE9SWV9NRVJHRV9UQUdcbn07XG5mdW5jdGlvbiBMZXhpY2FsQ29tcG9zZXIoe1xuICBpbml0aWFsQ29uZmlnLFxuICBjaGlsZHJlblxufSkge1xuICBjb25zdCBjb21wb3NlckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0aGVtZSxcbiAgICAgIG5hbWVzcGFjZSxcbiAgICAgIG5vZGVzLFxuICAgICAgb25FcnJvcixcbiAgICAgIGVkaXRvclN0YXRlOiBpbml0aWFsRWRpdG9yU3RhdGUsXG4gICAgICBodG1sXG4gICAgfSA9IGluaXRpYWxDb25maWc7XG4gICAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQobnVsbCwgdGhlbWUpO1xuICAgIGNvbnN0IGVkaXRvciA9IGNyZWF0ZUVkaXRvcih7XG4gICAgICBlZGl0YWJsZTogaW5pdGlhbENvbmZpZy5lZGl0YWJsZSxcbiAgICAgIGh0bWwsXG4gICAgICBuYW1lc3BhY2UsXG4gICAgICBub2RlcyxcbiAgICAgIG9uRXJyb3I6IGVycm9yID0+IG9uRXJyb3IoZXJyb3IsIGVkaXRvciksXG4gICAgICB0aGVtZVxuICAgIH0pO1xuICAgIGluaXRpYWxpemVFZGl0b3IoZWRpdG9yLCBpbml0aWFsRWRpdG9yU3RhdGUpO1xuICAgIHJldHVybiBbZWRpdG9yLCBjb250ZXh0XTtcbiAgfSxcbiAgLy8gV2Ugb25seSBkbyB0aGlzIGZvciBpbml0XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgW10pO1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICBjb25zdCBpc0VkaXRhYmxlID0gaW5pdGlhbENvbmZpZy5lZGl0YWJsZTtcbiAgICBjb25zdCBbZWRpdG9yXSA9IGNvbXBvc2VyQ29udGV4dDtcbiAgICBlZGl0b3Iuc2V0RWRpdGFibGUoaXNFZGl0YWJsZSAhPT0gdW5kZWZpbmVkID8gaXNFZGl0YWJsZSA6IHRydWUpO1xuXG4gICAgLy8gV2Ugb25seSBkbyB0aGlzIGZvciBpbml0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KExleGljYWxDb21wb3NlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29tcG9zZXJDb250ZXh0LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbmZ1bmN0aW9uIGluaXRpYWxpemVFZGl0b3IoZWRpdG9yLCBpbml0aWFsRWRpdG9yU3RhdGUpIHtcbiAgaWYgKGluaXRpYWxFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChpbml0aWFsRWRpdG9yU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgICBpZiAocm9vdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgcm9vdC5hcHBlbmQocGFyYWdyYXBoKTtcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IENBTl9VU0VfRE9NID8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA6IG51bGw7XG4gICAgICAgIGlmICgkZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwgfHwgYWN0aXZlRWxlbWVudCAhPT0gbnVsbCAmJiBhY3RpdmVFbGVtZW50ID09PSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKSkge1xuICAgICAgICAgIHBhcmFncmFwaC5zZWxlY3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIEhJU1RPUllfTUVSR0VfT1BUSU9OUyk7XG4gIH0gZWxzZSBpZiAoaW5pdGlhbEVkaXRvclN0YXRlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgaW5pdGlhbEVkaXRvclN0YXRlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkRWRpdG9yU3RhdGUgPSBlZGl0b3IucGFyc2VFZGl0b3JTdGF0ZShpbml0aWFsRWRpdG9yU3RhdGUpO1xuICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZShwYXJzZWRFZGl0b3JTdGF0ZSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAge1xuICAgICAgICAgIGVkaXRvci5zZXRFZGl0b3JTdGF0ZShpbml0aWFsRWRpdG9yU3RhdGUsIEhJU1RPUllfTUVSR0VfT1BUSU9OUyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAge1xuICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gICAgICAgICAgICBpZiAocm9vdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgaW5pdGlhbEVkaXRvclN0YXRlKGVkaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgSElTVE9SWV9NRVJHRV9PUFRJT05TKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBMZXhpY2FsQ29tcG9zZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lexical/react/LexicalComposer.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalComposerContext.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalComposerContext.dev.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalComposerContext: function() { return /* binding */ LexicalComposerContext; },\n/* harmony export */   createLexicalComposerContext: function() { return /* binding */ createLexicalComposerContext; },\n/* harmony export */   useLexicalComposerContext: function() { return /* binding */ useLexicalComposerContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst LexicalComposerContext = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(LexicalComposerContext);\n  if (composerContext == null) {\n    {\n      formatDevErrorMessage(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n  return composerContext;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsb0RBQWE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaURBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0LmRldi5tanM/YTk0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMuXG5cbmZ1bmN0aW9uIGZvcm1hdERldkVycm9yTWVzc2FnZShtZXNzYWdlKSB7XG4gIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuY29uc3QgTGV4aWNhbENvbXBvc2VyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gY3JlYXRlTGV4aWNhbENvbXBvc2VyQ29udGV4dChwYXJlbnQsIHRoZW1lKSB7XG4gIGxldCBwYXJlbnRDb250ZXh0ID0gbnVsbDtcbiAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgcGFyZW50Q29udGV4dCA9IHBhcmVudFsxXTtcbiAgfVxuICBmdW5jdGlvbiBnZXRUaGVtZSgpIHtcbiAgICBpZiAodGhlbWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoZW1lO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50Q29udGV4dCAhPSBudWxsID8gcGFyZW50Q29udGV4dC5nZXRUaGVtZSgpIDogbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldFRoZW1lXG4gIH07XG59XG5mdW5jdGlvbiB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCkge1xuICBjb25zdCBjb21wb3NlckNvbnRleHQgPSB1c2VDb250ZXh0KExleGljYWxDb21wb3NlckNvbnRleHQpO1xuICBpZiAoY29tcG9zZXJDb250ZXh0ID09IG51bGwpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYExleGljYWxDb21wb3NlckNvbnRleHQudXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dDogY2Fubm90IGZpbmQgYSBMZXhpY2FsQ29tcG9zZXJDb250ZXh0YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wb3NlckNvbnRleHQ7XG59XG5cbmV4cG9ydCB7IExleGljYWxDb21wb3NlckNvbnRleHQsIGNyZWF0ZUxleGljYWxDb21wb3NlckNvbnRleHQsIHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalContentEditable.dev.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalContentEditable.dev.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentEditable: function() { return /* binding */ ContentEditable; },\n/* harmony export */   ContentEditableElement: function() { return /* binding */ ContentEditableElement; }\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var _lexical_text__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/text */ \"./node_modules/@lexical/text/LexicalText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n// Source: https://github.com/gregberge/react-merge-refs/blob/main/src/index.tsx\n\nfunction mergeRefs(...refs) {\n  return value => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction ContentEditableElementImpl({\n  editor,\n  ariaActiveDescendant,\n  ariaAutoComplete,\n  ariaControls,\n  ariaDescribedBy,\n  ariaErrorMessage,\n  ariaExpanded,\n  ariaInvalid,\n  ariaLabel,\n  ariaLabelledBy,\n  ariaMultiline,\n  ariaOwns,\n  ariaRequired,\n  autoCapitalize,\n  className,\n  id,\n  role = 'textbox',\n  spellCheck = true,\n  style,\n  tabIndex,\n  'data-testid': testid,\n  ...rest\n}, ref) {\n  const [isEditable, setEditable] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(editor.isEditable());\n  const handleRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(rootElement => {\n    // defaultView is required for a root element.\n    // In multi-window setups, the defaultView may not exist at certain points.\n    if (rootElement && rootElement.ownerDocument && rootElement.ownerDocument.defaultView) {\n      editor.setRootElement(rootElement);\n    } else {\n      editor.setRootElement(null);\n    }\n  }, [editor]);\n  const mergedRefs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => mergeRefs(ref, handleRef), [handleRef, ref]);\n  useLayoutEffectImpl(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    \"aria-activedescendant\": isEditable ? ariaActiveDescendant : undefined,\n    \"aria-autocomplete\": isEditable ? ariaAutoComplete : 'none',\n    \"aria-controls\": isEditable ? ariaControls : undefined,\n    \"aria-describedby\": ariaDescribedBy\n    // for compat, only override aria-errormessage if ariaErrorMessage is defined\n    ,\n    ...(ariaErrorMessage != null ? {\n      'aria-errormessage': ariaErrorMessage\n    } : {}),\n    \"aria-expanded\": isEditable && role === 'combobox' ? !!ariaExpanded : undefined\n    // for compat, only override aria-invalid if ariaInvalid is defined\n    ,\n    ...(ariaInvalid != null ? {\n      'aria-invalid': ariaInvalid\n    } : {}),\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-multiline\": ariaMultiline,\n    \"aria-owns\": isEditable ? ariaOwns : undefined,\n    \"aria-readonly\": isEditable ? undefined : true,\n    \"aria-required\": ariaRequired,\n    autoCapitalize: autoCapitalize,\n    className: className,\n    contentEditable: isEditable,\n    \"data-testid\": testid,\n    id: id,\n    ref: mergedRefs,\n    role: role,\n    spellCheck: spellCheck,\n    style: style,\n    tabIndex: tabIndex,\n    ...rest\n  });\n}\nconst ContentEditableElement = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ContentEditableElementImpl);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read((0,_lexical_text__WEBPACK_IMPORTED_MODULE_2__.$canShowPlaceholderCurry)(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_3__.mergeRegister)(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n/**\n * @deprecated This type has been renamed to `ContentEditableProps` to provide a clearer and more descriptive name.\n * For backward compatibility, this type is still exported as `Props`, but it is recommended to migrate to using `ContentEditableProps` instead.\n *\n * @note This alias is maintained for compatibility purposes but may be removed in future versions.\n * Please update your codebase to use `ContentEditableProps` to ensure long-term maintainability.\n */\n\nconst ContentEditable = /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ContentEditableImpl);\nfunction ContentEditableImpl(props, ref) {\n  const {\n    placeholder,\n    ...rest\n  } = props;\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_4__.useLexicalComposerContext)();\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ContentEditableElement, {\n      editor: editor,\n      ...rest,\n      ref: ref\n    }), placeholder != null && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Placeholder, {\n      editor: editor,\n      content: placeholder\n    })]\n  });\n}\nfunction Placeholder({\n  content,\n  editor\n}) {\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const [isEditable, setEditable] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(editor.isEditable());\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n    setEditable(editor.isEditable());\n    return editor.registerEditableListener(currentIsEditable => {\n      setEditable(currentIsEditable);\n    });\n  }, [editor]);\n  if (!showPlaceholder) {\n    return null;\n  }\n  let placeholder = null;\n  if (typeof content === 'function') {\n    placeholder = content(isEditable);\n  } else if (content !== null) {\n    placeholder = content;\n  }\n  if (placeholder === null) {\n    return null;\n  }\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    \"aria-hidden\": true,\n    children: placeholder\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0Y7QUFDYTtBQUN2QztBQUNDO0FBQ1Y7O0FBRS9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQWUsR0FBRyw0Q0FBUzs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQywrQ0FBUTtBQUM1QyxvQkFBb0Isa0RBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsOENBQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILHNCQUFzQixzREFBRztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFJO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw0Q0FBNEMsaURBQVU7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFLHVFQUF3QjtBQUN6RjtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0NBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2REFBYTtBQUN4QjtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGlEQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLG1CQUFtQixnR0FBeUI7QUFDNUMsc0JBQXNCLHVEQUFJLENBQUMsdURBQVE7QUFDbkMsNEJBQTRCLHNEQUFHO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUssdUNBQXVDLHNEQUFHO0FBQy9DO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esb0NBQW9DLCtDQUFRO0FBQzVDLEVBQUUsc0RBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBRztBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVtRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbnRlbnRFZGl0YWJsZS5kZXYubWpzPzY5MjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4LCBqc3hzLCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcbmltcG9ydCB7ICRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeSB9IGZyb20gJ0BsZXhpY2FsL3RleHQnO1xuaW1wb3J0IHsgbWVyZ2VSZWdpc3RlciB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBpbiBSZWFjdCAxOSxcbi8vIGJ1dCB3ZSBjdXJyZW50bHkgc3VwcG9ydCBSZWFjdCA+PTE3Lnhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbi8vIFNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2dyZWdiZXJnZS9yZWFjdC1tZXJnZS1yZWZzL2Jsb2IvbWFpbi9zcmMvaW5kZXgudHN4XG5cbmZ1bmN0aW9uIG1lcmdlUmVmcyguLi5yZWZzKSB7XG4gIHJldHVybiB2YWx1ZSA9PiB7XG4gICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZWYodmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xuICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIENvbnRlbnRFZGl0YWJsZUVsZW1lbnRJbXBsKHtcbiAgZWRpdG9yLFxuICBhcmlhQWN0aXZlRGVzY2VuZGFudCxcbiAgYXJpYUF1dG9Db21wbGV0ZSxcbiAgYXJpYUNvbnRyb2xzLFxuICBhcmlhRGVzY3JpYmVkQnksXG4gIGFyaWFFcnJvck1lc3NhZ2UsXG4gIGFyaWFFeHBhbmRlZCxcbiAgYXJpYUludmFsaWQsXG4gIGFyaWFMYWJlbCxcbiAgYXJpYUxhYmVsbGVkQnksXG4gIGFyaWFNdWx0aWxpbmUsXG4gIGFyaWFPd25zLFxuICBhcmlhUmVxdWlyZWQsXG4gIGF1dG9DYXBpdGFsaXplLFxuICBjbGFzc05hbWUsXG4gIGlkLFxuICByb2xlID0gJ3RleHRib3gnLFxuICBzcGVsbENoZWNrID0gdHJ1ZSxcbiAgc3R5bGUsXG4gIHRhYkluZGV4LFxuICAnZGF0YS10ZXN0aWQnOiB0ZXN0aWQsXG4gIC4uLnJlc3Rcbn0sIHJlZikge1xuICBjb25zdCBbaXNFZGl0YWJsZSwgc2V0RWRpdGFibGVdID0gdXNlU3RhdGUoZWRpdG9yLmlzRWRpdGFibGUoKSk7XG4gIGNvbnN0IGhhbmRsZVJlZiA9IHVzZUNhbGxiYWNrKHJvb3RFbGVtZW50ID0+IHtcbiAgICAvLyBkZWZhdWx0VmlldyBpcyByZXF1aXJlZCBmb3IgYSByb290IGVsZW1lbnQuXG4gICAgLy8gSW4gbXVsdGktd2luZG93IHNldHVwcywgdGhlIGRlZmF1bHRWaWV3IG1heSBub3QgZXhpc3QgYXQgY2VydGFpbiBwb2ludHMuXG4gICAgaWYgKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQgJiYgcm9vdEVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldykge1xuICAgICAgZWRpdG9yLnNldFJvb3RFbGVtZW50KHJvb3RFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLnNldFJvb3RFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfSwgW2VkaXRvcl0pO1xuICBjb25zdCBtZXJnZWRSZWZzID0gdXNlTWVtbygoKSA9PiBtZXJnZVJlZnMocmVmLCBoYW5kbGVSZWYpLCBbaGFuZGxlUmVmLCByZWZdKTtcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgc2V0RWRpdGFibGUoZWRpdG9yLmlzRWRpdGFibGUoKSk7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoY3VycmVudElzRWRpdGFibGUgPT4ge1xuICAgICAgc2V0RWRpdGFibGUoY3VycmVudElzRWRpdGFibGUpO1xuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICBcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiOiBpc0VkaXRhYmxlID8gYXJpYUFjdGl2ZURlc2NlbmRhbnQgOiB1bmRlZmluZWQsXG4gICAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBpc0VkaXRhYmxlID8gYXJpYUF1dG9Db21wbGV0ZSA6ICdub25lJyxcbiAgICBcImFyaWEtY29udHJvbHNcIjogaXNFZGl0YWJsZSA/IGFyaWFDb250cm9scyA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5XG4gICAgLy8gZm9yIGNvbXBhdCwgb25seSBvdmVycmlkZSBhcmlhLWVycm9ybWVzc2FnZSBpZiBhcmlhRXJyb3JNZXNzYWdlIGlzIGRlZmluZWRcbiAgICAsXG4gICAgLi4uKGFyaWFFcnJvck1lc3NhZ2UgIT0gbnVsbCA/IHtcbiAgICAgICdhcmlhLWVycm9ybWVzc2FnZSc6IGFyaWFFcnJvck1lc3NhZ2VcbiAgICB9IDoge30pLFxuICAgIFwiYXJpYS1leHBhbmRlZFwiOiBpc0VkaXRhYmxlICYmIHJvbGUgPT09ICdjb21ib2JveCcgPyAhIWFyaWFFeHBhbmRlZCA6IHVuZGVmaW5lZFxuICAgIC8vIGZvciBjb21wYXQsIG9ubHkgb3ZlcnJpZGUgYXJpYS1pbnZhbGlkIGlmIGFyaWFJbnZhbGlkIGlzIGRlZmluZWRcbiAgICAsXG4gICAgLi4uKGFyaWFJbnZhbGlkICE9IG51bGwgPyB7XG4gICAgICAnYXJpYS1pbnZhbGlkJzogYXJpYUludmFsaWRcbiAgICB9IDoge30pLFxuICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsXG4gICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogYXJpYUxhYmVsbGVkQnksXG4gICAgXCJhcmlhLW11bHRpbGluZVwiOiBhcmlhTXVsdGlsaW5lLFxuICAgIFwiYXJpYS1vd25zXCI6IGlzRWRpdGFibGUgPyBhcmlhT3ducyA6IHVuZGVmaW5lZCxcbiAgICBcImFyaWEtcmVhZG9ubHlcIjogaXNFZGl0YWJsZSA/IHVuZGVmaW5lZCA6IHRydWUsXG4gICAgXCJhcmlhLXJlcXVpcmVkXCI6IGFyaWFSZXF1aXJlZCxcbiAgICBhdXRvQ2FwaXRhbGl6ZTogYXV0b0NhcGl0YWxpemUsXG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgY29udGVudEVkaXRhYmxlOiBpc0VkaXRhYmxlLFxuICAgIFwiZGF0YS10ZXN0aWRcIjogdGVzdGlkLFxuICAgIGlkOiBpZCxcbiAgICByZWY6IG1lcmdlZFJlZnMsXG4gICAgcm9sZTogcm9sZSxcbiAgICBzcGVsbENoZWNrOiBzcGVsbENoZWNrLFxuICAgIHN0eWxlOiBzdHlsZSxcbiAgICB0YWJJbmRleDogdGFiSW5kZXgsXG4gICAgLi4ucmVzdFxuICB9KTtcbn1cbmNvbnN0IENvbnRlbnRFZGl0YWJsZUVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihDb250ZW50RWRpdGFibGVFbGVtZW50SW1wbCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gY2FuU2hvd1BsYWNlaG9sZGVyRnJvbUN1cnJlbnRFZGl0b3JTdGF0ZShlZGl0b3IpIHtcbiAgY29uc3QgY3VycmVudENhblNob3dQbGFjZWhvbGRlciA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5KGVkaXRvci5pc0NvbXBvc2luZygpKSk7XG4gIHJldHVybiBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyO1xufVxuZnVuY3Rpb24gdXNlQ2FuU2hvd1BsYWNlaG9sZGVyKGVkaXRvcikge1xuICBjb25zdCBbY2FuU2hvd1BsYWNlaG9sZGVyLCBzZXRDYW5TaG93UGxhY2Vob2xkZXJdID0gdXNlU3RhdGUoKCkgPT4gY2FuU2hvd1BsYWNlaG9sZGVyRnJvbUN1cnJlbnRFZGl0b3JTdGF0ZShlZGl0b3IpKTtcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKSB7XG4gICAgICBjb25zdCBjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyID0gY2FuU2hvd1BsYWNlaG9sZGVyRnJvbUN1cnJlbnRFZGl0b3JTdGF0ZShlZGl0b3IpO1xuICAgICAgc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIpO1xuICAgIH1cbiAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgfSksIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoKCkgPT4ge1xuICAgICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICB9KSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgcmV0dXJuIGNhblNob3dQbGFjZWhvbGRlcjtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhpcyB0eXBlIGhhcyBiZWVuIHJlbmFtZWQgdG8gYENvbnRlbnRFZGl0YWJsZVByb3BzYCB0byBwcm92aWRlIGEgY2xlYXJlciBhbmQgbW9yZSBkZXNjcmlwdGl2ZSBuYW1lLlxuICogRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoaXMgdHlwZSBpcyBzdGlsbCBleHBvcnRlZCBhcyBgUHJvcHNgLCBidXQgaXQgaXMgcmVjb21tZW5kZWQgdG8gbWlncmF0ZSB0byB1c2luZyBgQ29udGVudEVkaXRhYmxlUHJvcHNgIGluc3RlYWQuXG4gKlxuICogQG5vdGUgVGhpcyBhbGlhcyBpcyBtYWludGFpbmVkIGZvciBjb21wYXRpYmlsaXR5IHB1cnBvc2VzIGJ1dCBtYXkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gKiBQbGVhc2UgdXBkYXRlIHlvdXIgY29kZWJhc2UgdG8gdXNlIGBDb250ZW50RWRpdGFibGVQcm9wc2AgdG8gZW5zdXJlIGxvbmctdGVybSBtYWludGFpbmFiaWxpdHkuXG4gKi9cblxuY29uc3QgQ29udGVudEVkaXRhYmxlID0gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoQ29udGVudEVkaXRhYmxlSW1wbCk7XG5mdW5jdGlvbiBDb250ZW50RWRpdGFibGVJbXBsKHByb3BzLCByZWYpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlaG9sZGVyLFxuICAgIC4uLnJlc3RcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFsvKiNfX1BVUkVfXyovanN4KENvbnRlbnRFZGl0YWJsZUVsZW1lbnQsIHtcbiAgICAgIGVkaXRvcjogZWRpdG9yLFxuICAgICAgLi4ucmVzdCxcbiAgICAgIHJlZjogcmVmXG4gICAgfSksIHBsYWNlaG9sZGVyICE9IG51bGwgJiYgLyojX19QVVJFX18qL2pzeChQbGFjZWhvbGRlciwge1xuICAgICAgZWRpdG9yOiBlZGl0b3IsXG4gICAgICBjb250ZW50OiBwbGFjZWhvbGRlclxuICAgIH0pXVxuICB9KTtcbn1cbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKHtcbiAgY29udGVudCxcbiAgZWRpdG9yXG59KSB7XG4gIGNvbnN0IHNob3dQbGFjZWhvbGRlciA9IHVzZUNhblNob3dQbGFjZWhvbGRlcihlZGl0b3IpO1xuICBjb25zdCBbaXNFZGl0YWJsZSwgc2V0RWRpdGFibGVdID0gdXNlU3RhdGUoZWRpdG9yLmlzRWRpdGFibGUoKSk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgc2V0RWRpdGFibGUoZWRpdG9yLmlzRWRpdGFibGUoKSk7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIoY3VycmVudElzRWRpdGFibGUgPT4ge1xuICAgICAgc2V0RWRpdGFibGUoY3VycmVudElzRWRpdGFibGUpO1xuICAgIH0pO1xuICB9LCBbZWRpdG9yXSk7XG4gIGlmICghc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IHBsYWNlaG9sZGVyID0gbnVsbDtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcGxhY2Vob2xkZXIgPSBjb250ZW50KGlzRWRpdGFibGUpO1xuICB9IGVsc2UgaWYgKGNvbnRlbnQgIT09IG51bGwpIHtcbiAgICBwbGFjZWhvbGRlciA9IGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHBsYWNlaG9sZGVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIFwiYXJpYS1oaWRkZW5cIjogdHJ1ZSxcbiAgICBjaGlsZHJlbjogcGxhY2Vob2xkZXJcbiAgfSk7XG59XG5cbmV4cG9ydCB7IENvbnRlbnRFZGl0YWJsZSwgQ29udGVudEVkaXRhYmxlRWxlbWVudCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lexical/react/LexicalContentEditable.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LexicalErrorBoundary: function() { return /* binding */ LexicalErrorBoundary; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  _setPrototypeOf(subClass, superClass);\n}\n\nvar changedArray = function changedArray(a, b) {\n  if (a === void 0) {\n    a = [];\n  }\n\n  if (b === void 0) {\n    b = [];\n  }\n\n  return a.length !== b.length || a.some(function (item, index) {\n    return !Object.is(item, b[index]);\n  });\n};\n\nvar initialState = {\n  error: null\n};\n\nvar ErrorBoundary = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;\n    _this.state = initialState;\n\n    _this.resetErrorBoundary = function () {\n      var _this$props;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);\n\n      _this.reset();\n    };\n\n    return _this;\n  }\n\n  ErrorBoundary.getDerivedStateFromError = function getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  };\n\n  var _proto = ErrorBoundary.prototype;\n\n  _proto.reset = function reset() {\n    this.setState(initialState);\n  };\n\n  _proto.componentDidCatch = function componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n\n    (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {\n    var error = this.state.error;\n    var resetKeys = this.props.resetKeys; // There's an edge case where if the thing that triggered the error\n    // happens to *also* be in the resetKeys array, we'd end up resetting\n    // the error boundary immediately. This would likely trigger a second\n    // error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call\n    // of cDU after the error is set\n\n    if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onResetKe, _this$props3;\n\n      (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);\n      this.reset();\n    }\n  };\n\n  _proto.render = function render() {\n    var error = this.state.error;\n    var _this$props4 = this.props,\n        fallbackRender = _this$props4.fallbackRender,\n        FallbackComponent = _this$props4.FallbackComponent,\n        fallback = _this$props4.fallback;\n\n    if (error !== null) {\n      var _props = {\n        error: error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n\n      if ( /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(fallback)) {\n        return fallback;\n      } else if (typeof fallbackRender === 'function') {\n        return fallbackRender(_props);\n      } else if (FallbackComponent) {\n        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(FallbackComponent, _props);\n      } else {\n        throw new Error('react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop');\n      }\n    }\n\n    return this.props.children;\n  };\n\n  return ErrorBoundary;\n}(react__WEBPACK_IMPORTED_MODULE_0__.Component);\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction LexicalErrorBoundary({\n  children,\n  onError\n}) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ErrorBoundary, {\n    fallback: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n      style: {\n        border: '1px solid #f00',\n        color: '#f00',\n        padding: '8px'\n      },\n      children: \"An error was thrown.\"\n    }),\n    onError: onError,\n    children: children\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFK0I7QUFDUzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZFQUE2RSxlQUFlO0FBQzVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0IsaURBQW9CO0FBQzVDO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLDRCQUE0QixnREFBbUI7QUFDL0MsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQyxDQUFDLDRDQUFlOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsc0JBQXNCLHNEQUFHO0FBQ3pCLDJCQUEyQixzREFBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEVycm9yQm91bmRhcnkuZGV2Lm1qcz84MWFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxudmFyIGNoYW5nZWRBcnJheSA9IGZ1bmN0aW9uIGNoYW5nZWRBcnJheShhLCBiKSB7XG4gIGlmIChhID09PSB2b2lkIDApIHtcbiAgICBhID0gW107XG4gIH1cblxuICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgYiA9IFtdO1xuICB9XG5cbiAgcmV0dXJuIGEubGVuZ3RoICE9PSBiLmxlbmd0aCB8fCBhLnNvbWUoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgcmV0dXJuICFPYmplY3QuaXMoaXRlbSwgYltpbmRleF0pO1xuICB9KTtcbn07XG5cbnZhciBpbml0aWFsU3RhdGUgPSB7XG4gIGVycm9yOiBudWxsXG59O1xuXG52YXIgRXJyb3JCb3VuZGFyeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShFcnJvckJvdW5kYXJ5LCBfUmVhY3QkQ29tcG9uZW50KTtcblxuICBmdW5jdGlvbiBFcnJvckJvdW5kYXJ5KCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBfYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoX2FyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuXG4gICAgX3RoaXMucmVzZXRFcnJvckJvdW5kYXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzO1xuXG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5wcm9wcy5vblJlc2V0ID09IG51bGwgPyB2b2lkIDAgOiAoX3RoaXMkcHJvcHMgPSBfdGhpcy5wcm9wcykub25SZXNldC5hcHBseShfdGhpcyRwcm9wcywgYXJncyk7XG5cbiAgICAgIF90aGlzLnJlc2V0KCk7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEVycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IEVycm9yQm91bmRhcnkucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgIHRoaXMuc2V0U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgfTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkQ2F0Y2ggPSBmdW5jdGlvbiBjb21wb25lbnREaWRDYXRjaChlcnJvciwgaW5mbykge1xuICAgIHZhciBfdGhpcyRwcm9wcyRvbkVycm9yLCBfdGhpcyRwcm9wczI7XG5cbiAgICAoX3RoaXMkcHJvcHMkb25FcnJvciA9IChfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzKS5vbkVycm9yKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkb25FcnJvci5jYWxsKF90aGlzJHByb3BzMiwgZXJyb3IsIGluZm8pO1xuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgIHZhciByZXNldEtleXMgPSB0aGlzLnByb3BzLnJlc2V0S2V5czsgLy8gVGhlcmUncyBhbiBlZGdlIGNhc2Ugd2hlcmUgaWYgdGhlIHRoaW5nIHRoYXQgdHJpZ2dlcmVkIHRoZSBlcnJvclxuICAgIC8vIGhhcHBlbnMgdG8gKmFsc28qIGJlIGluIHRoZSByZXNldEtleXMgYXJyYXksIHdlJ2QgZW5kIHVwIHJlc2V0dGluZ1xuICAgIC8vIHRoZSBlcnJvciBib3VuZGFyeSBpbW1lZGlhdGVseS4gVGhpcyB3b3VsZCBsaWtlbHkgdHJpZ2dlciBhIHNlY29uZFxuICAgIC8vIGVycm9yIHRvIGJlIHRocm93bi5cbiAgICAvLyBTbyB3ZSBtYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGVjayB0aGUgcmVzZXRLZXlzIG9uIHRoZSBmaXJzdCBjYWxsXG4gICAgLy8gb2YgY0RVIGFmdGVyIHRoZSBlcnJvciBpcyBzZXRcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCAmJiBwcmV2U3RhdGUuZXJyb3IgIT09IG51bGwgJiYgY2hhbmdlZEFycmF5KHByZXZQcm9wcy5yZXNldEtleXMsIHJlc2V0S2V5cykpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyRvblJlc2V0S2UsIF90aGlzJHByb3BzMztcblxuICAgICAgKF90aGlzJHByb3BzJG9uUmVzZXRLZSA9IChfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzKS5vblJlc2V0S2V5c0NoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJHByb3BzJG9uUmVzZXRLZS5jYWxsKF90aGlzJHByb3BzMywgcHJldlByb3BzLnJlc2V0S2V5cywgcmVzZXRLZXlzKTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgIHZhciBfdGhpcyRwcm9wczQgPSB0aGlzLnByb3BzLFxuICAgICAgICBmYWxsYmFja1JlbmRlciA9IF90aGlzJHByb3BzNC5mYWxsYmFja1JlbmRlcixcbiAgICAgICAgRmFsbGJhY2tDb21wb25lbnQgPSBfdGhpcyRwcm9wczQuRmFsbGJhY2tDb21wb25lbnQsXG4gICAgICAgIGZhbGxiYWNrID0gX3RoaXMkcHJvcHM0LmZhbGxiYWNrO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICB2YXIgX3Byb3BzID0ge1xuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIHJlc2V0RXJyb3JCb3VuZGFyeTogdGhpcy5yZXNldEVycm9yQm91bmRhcnlcbiAgICAgIH07XG5cbiAgICAgIGlmICggLyojX19QVVJFX18qL1JlYWN0LmlzVmFsaWRFbGVtZW50KGZhbGxiYWNrKSkge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmYWxsYmFja1JlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tSZW5kZXIoX3Byb3BzKTtcbiAgICAgIH0gZWxzZSBpZiAoRmFsbGJhY2tDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZhbGxiYWNrQ29tcG9uZW50LCBfcHJvcHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWFjdC1lcnJvci1ib3VuZGFyeSByZXF1aXJlcyBlaXRoZXIgYSBmYWxsYmFjaywgZmFsbGJhY2tSZW5kZXIsIG9yIEZhbGxiYWNrQ29tcG9uZW50IHByb3AnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgfTtcblxuICByZXR1cm4gRXJyb3JCb3VuZGFyeTtcbn0oUmVhY3QuQ29tcG9uZW50KTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBMZXhpY2FsRXJyb3JCb3VuZGFyeSh7XG4gIGNoaWxkcmVuLFxuICBvbkVycm9yXG59KSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEVycm9yQm91bmRhcnksIHtcbiAgICBmYWxsYmFjazogLyojX19QVVJFX18qL2pzeChcImRpdlwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICBib3JkZXI6ICcxcHggc29saWQgI2YwMCcsXG4gICAgICAgIGNvbG9yOiAnI2YwMCcsXG4gICAgICAgIHBhZGRpbmc6ICc4cHgnXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFwiQW4gZXJyb3Igd2FzIHRocm93bi5cIlxuICAgIH0pLFxuICAgIG9uRXJyb3I6IG9uRXJyb3IsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG5leHBvcnQgeyBMZXhpY2FsRXJyb3JCb3VuZGFyeSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lexical/react/LexicalErrorBoundary.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HistoryPlugin: function() { return /* binding */ HistoryPlugin; },\n/* harmony export */   createEmptyHistoryState: function() { return /* reexport safe */ _lexical_history__WEBPACK_IMPORTED_MODULE_0__.createEmptyHistoryState; }\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lexical/history */ \"./node_modules/@lexical/history/LexicalHistory.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => externalHistoryState || (0,_lexical_history__WEBPACK_IMPORTED_MODULE_0__.createEmptyHistoryState)(), [externalHistoryState]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    return (0,_lexical_history__WEBPACK_IMPORTED_MODULE_0__.registerHistory)(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction HistoryPlugin({\n  delay,\n  externalHistoryState\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_2__.useLexicalComposerContext)();\n  useHistory(editor, externalHistoryState, delay);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbEhpc3RvcnlQbHVnaW4uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNOO0FBQ2pCO0FBQ2hCOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qiw4Q0FBTywrQkFBK0IseUVBQXVCO0FBQ3BGLEVBQUUsZ0RBQVM7QUFDWCxXQUFXLGlFQUFlO0FBQzFCLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CLGdHQUF5QjtBQUM1QztBQUNBO0FBQ0E7O0FBRXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yZWFjdC9MZXhpY2FsSGlzdG9yeVBsdWdpbi5kZXYubWpzP2M0OTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSwgcmVnaXN0ZXJIaXN0b3J5IH0gZnJvbSAnQGxleGljYWwvaGlzdG9yeSc7XG5leHBvcnQgeyBjcmVhdGVFbXB0eUhpc3RvcnlTdGF0ZSB9IGZyb20gJ0BsZXhpY2FsL2hpc3RvcnknO1xuaW1wb3J0IHsgdXNlTWVtbywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHVzZUhpc3RvcnkoZWRpdG9yLCBleHRlcm5hbEhpc3RvcnlTdGF0ZSwgZGVsYXkgPSAxMDAwKSB7XG4gIGNvbnN0IGhpc3RvcnlTdGF0ZSA9IHVzZU1lbW8oKCkgPT4gZXh0ZXJuYWxIaXN0b3J5U3RhdGUgfHwgY3JlYXRlRW1wdHlIaXN0b3J5U3RhdGUoKSwgW2V4dGVybmFsSGlzdG9yeVN0YXRlXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIHJlZ2lzdGVySGlzdG9yeShlZGl0b3IsIGhpc3RvcnlTdGF0ZSwgZGVsYXkpO1xuICB9LCBbZGVsYXksIGVkaXRvciwgaGlzdG9yeVN0YXRlXSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gSGlzdG9yeVBsdWdpbih7XG4gIGRlbGF5LFxuICBleHRlcm5hbEhpc3RvcnlTdGF0ZVxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgdXNlSGlzdG9yeShlZGl0b3IsIGV4dGVybmFsSGlzdG9yeVN0YXRlLCBkZWxheSk7XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBIaXN0b3J5UGx1Z2luIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lexical/react/LexicalHistoryPlugin.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalOnChangePlugin.dev.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalOnChangePlugin.dev.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OnChangePlugin: function() { return /* binding */ OnChangePlugin; }\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction OnChangePlugin({\n  ignoreHistoryMergeTagChange = true,\n  ignoreSelectionChange = false,\n  onChange\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n  useLayoutEffectImpl(() => {\n    if (onChange) {\n      return editor.registerUpdateListener(({\n        editorState,\n        dirtyElements,\n        dirtyLeaves,\n        prevEditorState,\n        tags\n      }) => {\n        if (ignoreSelectionChange && dirtyElements.size === 0 && dirtyLeaves.size === 0 || ignoreHistoryMergeTagChange && tags.has(lexical__WEBPACK_IMPORTED_MODULE_2__.HISTORY_MERGE_TAG) || prevEditorState.isEmpty()) {\n          return;\n        }\n        onChange(editorState, editor, tags);\n      });\n    }\n  }, [editor, ignoreHistoryMergeTagChange, ignoreSelectionChange, onChange]);\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE9uQ2hhbmdlUGx1Z2luLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUN0QztBQUNPOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtEQUFlLEdBQUcsNENBQVM7O0FBRXJFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1CQUFtQixnR0FBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxtSUFBbUksc0RBQWlCO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbE9uQ2hhbmdlUGx1Z2luLmRldi5tanM/ZjllOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IEhJU1RPUllfTUVSR0VfVEFHIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBDQU5fVVNFX0RPTSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSBpbiBSZWFjdCAxOSxcbi8vIGJ1dCB3ZSBjdXJyZW50bHkgc3VwcG9ydCBSZWFjdCA+PTE3Lnhcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG5jb25zdCB1c2VMYXlvdXRFZmZlY3RJbXBsID0gQ0FOX1VTRV9ET00gPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gT25DaGFuZ2VQbHVnaW4oe1xuICBpZ25vcmVIaXN0b3J5TWVyZ2VUYWdDaGFuZ2UgPSB0cnVlLFxuICBpZ25vcmVTZWxlY3Rpb25DaGFuZ2UgPSBmYWxzZSxcbiAgb25DaGFuZ2Vcbn0pIHtcbiAgY29uc3QgW2VkaXRvcl0gPSB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0KCk7XG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlclVwZGF0ZUxpc3RlbmVyKCh7XG4gICAgICAgIGVkaXRvclN0YXRlLFxuICAgICAgICBkaXJ0eUVsZW1lbnRzLFxuICAgICAgICBkaXJ0eUxlYXZlcyxcbiAgICAgICAgcHJldkVkaXRvclN0YXRlLFxuICAgICAgICB0YWdzXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVTZWxlY3Rpb25DaGFuZ2UgJiYgZGlydHlFbGVtZW50cy5zaXplID09PSAwICYmIGRpcnR5TGVhdmVzLnNpemUgPT09IDAgfHwgaWdub3JlSGlzdG9yeU1lcmdlVGFnQ2hhbmdlICYmIHRhZ3MuaGFzKEhJU1RPUllfTUVSR0VfVEFHKSB8fCBwcmV2RWRpdG9yU3RhdGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbmdlKGVkaXRvclN0YXRlLCBlZGl0b3IsIHRhZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZWRpdG9yLCBpZ25vcmVIaXN0b3J5TWVyZ2VUYWdDaGFuZ2UsIGlnbm9yZVNlbGVjdGlvbkNoYW5nZSwgb25DaGFuZ2VdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCB7IE9uQ2hhbmdlUGx1Z2luIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lexical/react/LexicalOnChangePlugin.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs":
/*!*******************************************************************!*\
  !*** ./node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RichTextPlugin: function() { return /* binding */ RichTextPlugin; }\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var _lexical_react_useLexicalEditable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @lexical/react/useLexicalEditable */ \"./node_modules/@lexical/react/useLexicalEditable.dev.mjs\");\n/* harmony import */ var _lexical_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/text */ \"./node_modules/@lexical/text/LexicalText.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"./node_modules/react/jsx-runtime.js\");\n/* harmony import */ var _lexical_dragon__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @lexical/dragon */ \"./node_modules/@lexical/dragon/LexicalDragon.dev.mjs\");\n/* harmony import */ var _lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @lexical/rich-text */ \"./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction canShowPlaceholderFromCurrentEditorState(editor) {\n  const currentCanShowPlaceholder = editor.getEditorState().read((0,_lexical_text__WEBPACK_IMPORTED_MODULE_3__.$canShowPlaceholderCurry)(editor.isComposing()));\n  return currentCanShowPlaceholder;\n}\nfunction useCanShowPlaceholder(editor) {\n  const [canShowPlaceholder, setCanShowPlaceholder] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => canShowPlaceholderFromCurrentEditorState(editor));\n  useLayoutEffectImpl(() => {\n    function resetCanShowPlaceholder() {\n      const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);\n      setCanShowPlaceholder(currentCanShowPlaceholder);\n    }\n    resetCanShowPlaceholder();\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)(editor.registerUpdateListener(() => {\n      resetCanShowPlaceholder();\n    }), editor.registerEditableListener(() => {\n      resetCanShowPlaceholder();\n    }));\n  }, [editor]);\n  return canShowPlaceholder;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useDecorators(editor, ErrorBoundary) {\n  const [decorators, setDecorators] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => editor.getDecorators());\n\n  // Subscribe to changes\n  useLayoutEffectImpl(() => {\n    return editor.registerDecoratorListener(nextDecorators => {\n      (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n        setDecorators(nextDecorators);\n      });\n    });\n  }, [editor]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    // If the content editable mounts before the subscription is added, then\n    // nothing will be rendered on initial pass. We can get around that by\n    // ensuring that we set the value.\n    setDecorators(editor.getDecorators());\n  }, [editor]);\n\n  // Return decorators defined as React Portals\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const decoratedPortals = [];\n    const decoratorKeys = Object.keys(decorators);\n    for (let i = 0; i < decoratorKeys.length; i++) {\n      const nodeKey = decoratorKeys[i];\n      const reactDecorator = /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ErrorBoundary, {\n        onError: e => editor._onError(e),\n        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n          fallback: null,\n          children: decorators[nodeKey]\n        })\n      });\n      const element = editor.getElementByKey(nodeKey);\n      if (element !== null) {\n        decoratedPortals.push(/*#__PURE__*/(0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(reactDecorator, element, nodeKey));\n      }\n    }\n    return decoratedPortals;\n  }, [ErrorBoundary, decorators, editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction useRichTextSetup(editor) {\n  useLayoutEffectImpl(() => {\n    return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_4__.mergeRegister)((0,_lexical_rich_text__WEBPACK_IMPORTED_MODULE_5__.registerRichText)(editor), (0,_lexical_dragon__WEBPACK_IMPORTED_MODULE_6__.registerDragonSupport)(editor));\n\n    // We only do this for init\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction RichTextPlugin({\n  contentEditable,\n  // TODO Remove. This property is now part of ContentEditable\n  placeholder = null,\n  ErrorBoundary\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__.useLexicalComposerContext)();\n  const decorators = useDecorators(editor, ErrorBoundary);\n  useRichTextSetup(editor);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, {\n    children: [contentEditable, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Placeholder, {\n      content: placeholder\n    }), decorators]\n  });\n}\n\n// TODO remove\nfunction Placeholder({\n  content\n}) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_7__.useLexicalComposerContext)();\n  const showPlaceholder = useCanShowPlaceholder(editor);\n  const editable = (0,_lexical_react_useLexicalEditable__WEBPACK_IMPORTED_MODULE_8__.useLexicalEditable)();\n  if (!showPlaceholder) {\n    return null;\n  }\n  if (typeof content === 'function') {\n    return content(editable);\n  } else {\n    return content;\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvTGV4aWNhbFJpY2hUZXh0UGx1Z2luLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrRjtBQUNYO0FBQ2Q7QUFDVjtBQUNpQztBQUM1QjtBQUNJO0FBQ0E7QUFDRjs7QUFFdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxrREFBZSxHQUFHLDRDQUFTOztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSx1RUFBd0I7QUFDekY7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELCtDQUFRO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkRBQWE7QUFDeEI7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0MsK0NBQVE7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVM7QUFDZjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxTQUFTLDhDQUFPO0FBQ2hCO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0EsMENBQTBDLHNEQUFHO0FBQzdDO0FBQ0EsK0JBQStCLHNEQUFHLENBQUMsMkNBQVE7QUFDM0M7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLDJDQUEyQyx1REFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsNkRBQWEsQ0FBQyxvRUFBZ0IsVUFBVSxzRUFBcUI7O0FBRXhFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUIsZ0dBQXlCO0FBQzVDO0FBQ0E7QUFDQSxzQkFBc0IsdURBQUksQ0FBQyx1REFBUTtBQUNuQyw2Q0FBNkMsc0RBQUc7QUFDaEQ7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUIsZ0dBQXlCO0FBQzVDO0FBQ0EsbUJBQW1CLHFGQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFMEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3JlYWN0L0xleGljYWxSaWNoVGV4dFBsdWdpbi5kZXYubWpzPzBlNWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyB1c2VMZXhpY2FsQ29tcG9zZXJDb250ZXh0IH0gZnJvbSAnQGxleGljYWwvcmVhY3QvTGV4aWNhbENvbXBvc2VyQ29udGV4dCc7XG5pbXBvcnQgeyB1c2VMZXhpY2FsRWRpdGFibGUgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC91c2VMZXhpY2FsRWRpdGFibGUnO1xuaW1wb3J0IHsgJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5IH0gZnJvbSAnQGxleGljYWwvdGV4dCc7XG5pbXBvcnQgeyBtZXJnZVJlZ2lzdGVyIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0LCB1c2VFZmZlY3QsIHVzZVN0YXRlLCB1c2VNZW1vLCBTdXNwZW5zZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZsdXNoU3luYywgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IGpzeCwganN4cywgRnJhZ21lbnQgfSBmcm9tICdyZWFjdC9qc3gtcnVudGltZSc7XG5pbXBvcnQgeyByZWdpc3RlckRyYWdvblN1cHBvcnQgfSBmcm9tICdAbGV4aWNhbC9kcmFnb24nO1xuaW1wb3J0IHsgcmVnaXN0ZXJSaWNoVGV4dCB9IGZyb20gJ0BsZXhpY2FsL3JpY2gtdGV4dCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gVGhpcyB3b3JrYXJvdW5kIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkgaW4gUmVhY3QgMTksXG4vLyBidXQgd2UgY3VycmVudGx5IHN1cHBvcnQgUmVhY3QgPj0xNy54XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yNjM5NVxuY29uc3QgdXNlTGF5b3V0RWZmZWN0SW1wbCA9IENBTl9VU0VfRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKSB7XG4gIGNvbnN0IGN1cnJlbnRDYW5TaG93UGxhY2Vob2xkZXIgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeShlZGl0b3IuaXNDb21wb3NpbmcoKSkpO1xuICByZXR1cm4gY3VycmVudENhblNob3dQbGFjZWhvbGRlcjtcbn1cbmZ1bmN0aW9uIHVzZUNhblNob3dQbGFjZWhvbGRlcihlZGl0b3IpIHtcbiAgY29uc3QgW2NhblNob3dQbGFjZWhvbGRlciwgc2V0Q2FuU2hvd1BsYWNlaG9sZGVyXSA9IHVzZVN0YXRlKCgpID0+IGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKSk7XG4gIHVzZUxheW91dEVmZmVjdEltcGwoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCkge1xuICAgICAgY29uc3QgY3VycmVudENhblNob3dQbGFjZWhvbGRlciA9IGNhblNob3dQbGFjZWhvbGRlckZyb21DdXJyZW50RWRpdG9yU3RhdGUoZWRpdG9yKTtcbiAgICAgIHNldENhblNob3dQbGFjZWhvbGRlcihjdXJyZW50Q2FuU2hvd1BsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgcmVzZXRDYW5TaG93UGxhY2Vob2xkZXIoKTtcbiAgICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICByZXNldENhblNob3dQbGFjZWhvbGRlcigpO1xuICAgIH0pLCBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKCgpID0+IHtcbiAgICAgIHJlc2V0Q2FuU2hvd1BsYWNlaG9sZGVyKCk7XG4gICAgfSkpO1xuICB9LCBbZWRpdG9yXSk7XG4gIHJldHVybiBjYW5TaG93UGxhY2Vob2xkZXI7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gdXNlRGVjb3JhdG9ycyhlZGl0b3IsIEVycm9yQm91bmRhcnkpIHtcbiAgY29uc3QgW2RlY29yYXRvcnMsIHNldERlY29yYXRvcnNdID0gdXNlU3RhdGUoKCkgPT4gZWRpdG9yLmdldERlY29yYXRvcnMoKSk7XG5cbiAgLy8gU3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgdXNlTGF5b3V0RWZmZWN0SW1wbCgoKSA9PiB7XG4gICAgcmV0dXJuIGVkaXRvci5yZWdpc3RlckRlY29yYXRvckxpc3RlbmVyKG5leHREZWNvcmF0b3JzID0+IHtcbiAgICAgIGZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgIHNldERlY29yYXRvcnMobmV4dERlY29yYXRvcnMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIFtlZGl0b3JdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBJZiB0aGUgY29udGVudCBlZGl0YWJsZSBtb3VudHMgYmVmb3JlIHRoZSBzdWJzY3JpcHRpb24gaXMgYWRkZWQsIHRoZW5cbiAgICAvLyBub3RoaW5nIHdpbGwgYmUgcmVuZGVyZWQgb24gaW5pdGlhbCBwYXNzLiBXZSBjYW4gZ2V0IGFyb3VuZCB0aGF0IGJ5XG4gICAgLy8gZW5zdXJpbmcgdGhhdCB3ZSBzZXQgdGhlIHZhbHVlLlxuICAgIHNldERlY29yYXRvcnMoZWRpdG9yLmdldERlY29yYXRvcnMoKSk7XG4gIH0sIFtlZGl0b3JdKTtcblxuICAvLyBSZXR1cm4gZGVjb3JhdG9ycyBkZWZpbmVkIGFzIFJlYWN0IFBvcnRhbHNcbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGRlY29yYXRlZFBvcnRhbHMgPSBbXTtcbiAgICBjb25zdCBkZWNvcmF0b3JLZXlzID0gT2JqZWN0LmtleXMoZGVjb3JhdG9ycyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvcmF0b3JLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlS2V5ID0gZGVjb3JhdG9yS2V5c1tpXTtcbiAgICAgIGNvbnN0IHJlYWN0RGVjb3JhdG9yID0gLyojX19QVVJFX18qL2pzeChFcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgIG9uRXJyb3I6IGUgPT4gZWRpdG9yLl9vbkVycm9yKGUpLFxuICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChTdXNwZW5zZSwge1xuICAgICAgICAgIGZhbGxiYWNrOiBudWxsLFxuICAgICAgICAgIGNoaWxkcmVuOiBkZWNvcmF0b3JzW25vZGVLZXldXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KG5vZGVLZXkpO1xuICAgICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZGVjb3JhdGVkUG9ydGFscy5wdXNoKC8qI19fUFVSRV9fKi9jcmVhdGVQb3J0YWwocmVhY3REZWNvcmF0b3IsIGVsZW1lbnQsIG5vZGVLZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY29yYXRlZFBvcnRhbHM7XG4gIH0sIFtFcnJvckJvdW5kYXJ5LCBkZWNvcmF0b3JzLCBlZGl0b3JdKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiB1c2VSaWNoVGV4dFNldHVwKGVkaXRvcikge1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICByZXR1cm4gbWVyZ2VSZWdpc3RlcihyZWdpc3RlclJpY2hUZXh0KGVkaXRvciksIHJlZ2lzdGVyRHJhZ29uU3VwcG9ydChlZGl0b3IpKTtcblxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBmb3IgaW5pdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgW2VkaXRvcl0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIFJpY2hUZXh0UGx1Z2luKHtcbiAgY29udGVudEVkaXRhYmxlLFxuICAvLyBUT0RPIFJlbW92ZS4gVGhpcyBwcm9wZXJ0eSBpcyBub3cgcGFydCBvZiBDb250ZW50RWRpdGFibGVcbiAgcGxhY2Vob2xkZXIgPSBudWxsLFxuICBFcnJvckJvdW5kYXJ5XG59KSB7XG4gIGNvbnN0IFtlZGl0b3JdID0gdXNlTGV4aWNhbENvbXBvc2VyQ29udGV4dCgpO1xuICBjb25zdCBkZWNvcmF0b3JzID0gdXNlRGVjb3JhdG9ycyhlZGl0b3IsIEVycm9yQm91bmRhcnkpO1xuICB1c2VSaWNoVGV4dFNldHVwKGVkaXRvcik7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4cyhGcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbY29udGVudEVkaXRhYmxlLCAvKiNfX1BVUkVfXyovanN4KFBsYWNlaG9sZGVyLCB7XG4gICAgICBjb250ZW50OiBwbGFjZWhvbGRlclxuICAgIH0pLCBkZWNvcmF0b3JzXVxuICB9KTtcbn1cblxuLy8gVE9ETyByZW1vdmVcbmZ1bmN0aW9uIFBsYWNlaG9sZGVyKHtcbiAgY29udGVudFxufSkge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3Qgc2hvd1BsYWNlaG9sZGVyID0gdXNlQ2FuU2hvd1BsYWNlaG9sZGVyKGVkaXRvcik7XG4gIGNvbnN0IGVkaXRhYmxlID0gdXNlTGV4aWNhbEVkaXRhYmxlKCk7XG4gIGlmICghc2hvd1BsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQoZWRpdGFibGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG59XG5cbmV4cG9ydCB7IFJpY2hUZXh0UGx1Z2luIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lexical/react/LexicalRichTextPlugin.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/react/useLexicalEditable.dev.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@lexical/react/useLexicalEditable.dev.mjs ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLexicalEditable: function() { return /* binding */ useLexicalEditable; }\n/* harmony export */ });\n/* harmony import */ var _lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/react/LexicalComposerContext */ \"./node_modules/@lexical/react/LexicalComposerContext.dev.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// This workaround is no longer necessary in React 19,\n// but we currently support React >=17.x\n// https://github.com/facebook/react/pull/26395\nconst useLayoutEffectImpl = CAN_USE_DOM ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Shortcut to Lexical subscriptions when values are used for render.\n * @param subscription - The function to create the {@link LexicalSubscription}. This function's identity must be stable (e.g. defined at module scope or with useCallback).\n */\nfunction useLexicalSubscription(subscription) {\n  const [editor] = (0,_lexical_react_LexicalComposerContext__WEBPACK_IMPORTED_MODULE_1__.useLexicalComposerContext)();\n  const initializedSubscription = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => subscription(editor), [editor, subscription]);\n  const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => initializedSubscription.initialValueFn());\n  const valueRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(value);\n  useLayoutEffectImpl(() => {\n    const {\n      initialValueFn,\n      subscribe\n    } = initializedSubscription;\n    const currentValue = initialValueFn();\n    if (valueRef.current !== currentValue) {\n      valueRef.current = currentValue;\n      setValue(currentValue);\n    }\n    return subscribe(newValue => {\n      valueRef.current = newValue;\n      setValue(newValue);\n    });\n  }, [initializedSubscription, subscription]);\n  return value;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction subscription(editor) {\n  return {\n    initialValueFn: () => editor.isEditable(),\n    subscribe: callback => {\n      return editor.registerEditableListener(callback);\n    }\n  };\n}\n\n/**\n * Get the current value for {@link LexicalEditor.isEditable}\n * using {@link useLexicalSubscription}.\n * You should prefer this over manually observing the value with\n * {@link LexicalEditor.registerEditableListener},\n * which is a bit tricky to do correctly, particularly when using\n * React StrictMode (the default for development) or concurrency.\n */\nfunction useLexicalEditable() {\n  return useLexicalSubscription(subscription);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtGO0FBQ0o7O0FBRTlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0RBQWUsR0FBRyw0Q0FBUzs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCwwQkFBMEI7QUFDL0U7QUFDQTtBQUNBLG1CQUFtQixnR0FBeUI7QUFDNUMsa0NBQWtDLDhDQUFPO0FBQ3pDLDRCQUE0QiwrQ0FBUTtBQUNwQyxtQkFBbUIsNkNBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCO0FBQzlCLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0EsSUFBSSw2Q0FBNkM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmVhY3QvdXNlTGV4aWNhbEVkaXRhYmxlLmRldi5tanM/MzZlMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQgfSBmcm9tICdAbGV4aWNhbC9yZWFjdC9MZXhpY2FsQ29tcG9zZXJDb250ZXh0JztcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIFRoaXMgd29ya2Fyb3VuZCBpcyBubyBsb25nZXIgbmVjZXNzYXJ5IGluIFJlYWN0IDE5LFxuLy8gYnV0IHdlIGN1cnJlbnRseSBzdXBwb3J0IFJlYWN0ID49MTcueFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjYzOTVcbmNvbnN0IHVzZUxheW91dEVmZmVjdEltcGwgPSBDQU5fVVNFX0RPTSA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIExleGljYWwgc3Vic2NyaXB0aW9ucyB3aGVuIHZhbHVlcyBhcmUgdXNlZCBmb3IgcmVuZGVyLlxuICogQHBhcmFtIHN1YnNjcmlwdGlvbiAtIFRoZSBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIHtAbGluayBMZXhpY2FsU3Vic2NyaXB0aW9ufS4gVGhpcyBmdW5jdGlvbidzIGlkZW50aXR5IG11c3QgYmUgc3RhYmxlIChlLmcuIGRlZmluZWQgYXQgbW9kdWxlIHNjb3BlIG9yIHdpdGggdXNlQ2FsbGJhY2spLlxuICovXG5mdW5jdGlvbiB1c2VMZXhpY2FsU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbikge1xuICBjb25zdCBbZWRpdG9yXSA9IHVzZUxleGljYWxDb21wb3NlckNvbnRleHQoKTtcbiAgY29uc3QgaW5pdGlhbGl6ZWRTdWJzY3JpcHRpb24gPSB1c2VNZW1vKCgpID0+IHN1YnNjcmlwdGlvbihlZGl0b3IpLCBbZWRpdG9yLCBzdWJzY3JpcHRpb25dKTtcbiAgY29uc3QgW3ZhbHVlLCBzZXRWYWx1ZV0gPSB1c2VTdGF0ZSgoKSA9PiBpbml0aWFsaXplZFN1YnNjcmlwdGlvbi5pbml0aWFsVmFsdWVGbigpKTtcbiAgY29uc3QgdmFsdWVSZWYgPSB1c2VSZWYodmFsdWUpO1xuICB1c2VMYXlvdXRFZmZlY3RJbXBsKCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBpbml0aWFsVmFsdWVGbixcbiAgICAgIHN1YnNjcmliZVxuICAgIH0gPSBpbml0aWFsaXplZFN1YnNjcmlwdGlvbjtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSBpbml0aWFsVmFsdWVGbigpO1xuICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ICE9PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBjdXJyZW50VmFsdWU7XG4gICAgICBzZXRWYWx1ZShjdXJyZW50VmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gc3Vic2NyaWJlKG5ld1ZhbHVlID0+IHtcbiAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXdWYWx1ZTtcbiAgICAgIHNldFZhbHVlKG5ld1ZhbHVlKTtcbiAgICB9KTtcbiAgfSwgW2luaXRpYWxpemVkU3Vic2NyaXB0aW9uLCBzdWJzY3JpcHRpb25dKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHN1YnNjcmlwdGlvbihlZGl0b3IpIHtcbiAgcmV0dXJuIHtcbiAgICBpbml0aWFsVmFsdWVGbjogKCkgPT4gZWRpdG9yLmlzRWRpdGFibGUoKSxcbiAgICBzdWJzY3JpYmU6IGNhbGxiYWNrID0+IHtcbiAgICAgIHJldHVybiBlZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyKGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHZhbHVlIGZvciB7QGxpbmsgTGV4aWNhbEVkaXRvci5pc0VkaXRhYmxlfVxuICogdXNpbmcge0BsaW5rIHVzZUxleGljYWxTdWJzY3JpcHRpb259LlxuICogWW91IHNob3VsZCBwcmVmZXIgdGhpcyBvdmVyIG1hbnVhbGx5IG9ic2VydmluZyB0aGUgdmFsdWUgd2l0aFxuICoge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJFZGl0YWJsZUxpc3RlbmVyfSxcbiAqIHdoaWNoIGlzIGEgYml0IHRyaWNreSB0byBkbyBjb3JyZWN0bHksIHBhcnRpY3VsYXJseSB3aGVuIHVzaW5nXG4gKiBSZWFjdCBTdHJpY3RNb2RlICh0aGUgZGVmYXVsdCBmb3IgZGV2ZWxvcG1lbnQpIG9yIGNvbmN1cnJlbmN5LlxuICovXG5mdW5jdGlvbiB1c2VMZXhpY2FsRWRpdGFibGUoKSB7XG4gIHJldHVybiB1c2VMZXhpY2FsU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbik7XG59XG5cbmV4cG9ydCB7IHVzZUxleGljYWxFZGl0YWJsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lexical/react/useLexicalEditable.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createHeadingNode: function() { return /* binding */ $createHeadingNode; },\n/* harmony export */   $createQuoteNode: function() { return /* binding */ $createQuoteNode; },\n/* harmony export */   $isHeadingNode: function() { return /* binding */ $isHeadingNode; },\n/* harmony export */   $isQuoteNode: function() { return /* binding */ $isQuoteNode; },\n/* harmony export */   DRAG_DROP_PASTE: function() { return /* binding */ DRAG_DROP_PASTE; },\n/* harmony export */   HeadingNode: function() { return /* binding */ HeadingNode; },\n/* harmony export */   QuoteNode: function() { return /* binding */ QuoteNode; },\n/* harmony export */   eventFiles: function() { return /* binding */ eventFiles; },\n/* harmony export */   registerRichText: function() { return /* binding */ registerRichText; }\n/* harmony export */ });\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @lexical/selection */ \"./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    };\n    // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n    if (range === null) {\n      return null;\n    }\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DRAG_DROP_PASTE = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('DRAG_DROP_PASTE_FILE');\n/** @noInheritDoc */\nclass QuoteNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.quote);\n    return element;\n  }\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: $convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createQuoteNode().updateFromJSON(serializedNode);\n  }\n\n  // Mutation\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n  collapseAtStart() {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $createQuoteNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n/** @noInheritDoc */\nclass HeadingNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'heading';\n  }\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n  getTag() {\n    return this.__tag;\n  }\n  setTag(tag) {\n    const self = this.getWritable();\n    this.__tag = tag;\n    return self;\n  }\n\n  // View\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, className);\n    }\n    return element;\n  }\n  updateDOM(prevNode, dom, config) {\n    return prevNode.__tag !== this.__tag;\n  }\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: $convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n        return null;\n      }\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createHeadingNode(serializedNode.tag).updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTag(serializedNode.tag);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      tag: this.getTag()\n    };\n  }\n\n  // Mutation\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const lastDesc = this.getLastDescendant();\n    const isAtEnd = !lastDesc || selection && selection.anchor.key === lastDesc.getKey() && anchorOffet === lastDesc.getTextContentSize();\n    const newElement = isAtEnd || !selection ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)() : $createHeadingNode(this.getTag());\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    if (anchorOffet === 0 && !this.isEmpty() && selection) {\n      const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraph.select();\n      this.replace(paragraph, true);\n    }\n    return newElement;\n  }\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n  extractWithChild() {\n    return true;\n  }\n}\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n  return false;\n}\nfunction $convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n    if (element.style !== null) {\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.setNodeIndentFromDOM)(element, node);\n      node.setFormat(element.style.textAlign);\n    }\n  }\n  return {\n    node\n  };\n}\nfunction $convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.setNodeIndentFromDOM)(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createHeadingNode(headingTag = 'h1') {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const clipboardData = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, InputEvent) || (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, KeyboardEvent) ? null : event.clipboardData;\n    if (clipboardData != null && selection !== null) {\n      (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForRichText)(clipboardData, selection, editor);\n    }\n  }, {\n    tag: lexical__WEBPACK_IMPORTED_MODULE_0__.PASTE_TAG\n  });\n}\nasync function onCutForRichText(event, editor) {\n  await (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      selection.removeText();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n}\n\n// Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain occasions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\nfunction eventFiles(event) {\n  let dataTransfer = null;\n  if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, DragEvent)) {\n    dataTransfer = event.dataTransfer;\n  } else if ((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent)) {\n    dataTransfer = event.clipboardData;\n  }\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\nfunction $handleIndentAndOutdent(indentOrOutdent) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return false;\n  }\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n    const parentBlock = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parentNode => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(parentNode) && !parentNode.isInline());\n    if (parentBlock === null) {\n      continue;\n    }\n    const parentKey = parentBlock.getKey();\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n  return alreadyHandled.size > 0;\n}\nfunction $isTargetWithinDecorator(target) {\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(target);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node);\n}\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)().getChildrenSize();\n}\nfunction $isSelectionCollapsedAtFrontOfIndentedBlock(selection) {\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const {\n    anchor\n  } = selection;\n  if (anchor.offset !== 0) {\n    return false;\n  }\n  const anchorNode = anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode)) {\n    return false;\n  }\n  const element = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestBlockElementAncestorOrThrow)(anchorNode);\n  return element.getIndent() > 0 && (element.is(anchorNode) || anchorNode.is(element.getFirstDescendant()));\n}\n\n/**\n * Resets the capitalization of the selection to default.\n * Called when the user presses space, tab, or enter key.\n * @param selection The selection to reset the capitalization of.\n */\nfunction $resetCapitalization(selection) {\n  for (const format of ['lowercase', 'uppercase', 'capitalize']) {\n    if (selection.hasFormat(format)) {\n      selection.toggleFormat(format);\n    }\n  }\n}\nfunction registerRichText(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLICK_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      selection.clear();\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      selection.deleteCharacter(isBackward);\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      selection.deleteNodes();\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, isBackward => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (typeof eventOrText === 'string') {\n      if (selection !== null) {\n        selection.insertText(eventOrText);\n      }\n    } else {\n      if (selection === null) {\n        return false;\n      }\n      const dataTransfer = eventOrText.dataTransfer;\n      if (dataTransfer != null) {\n        (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$insertDataTransferForRichText)(dataTransfer, selection, editor);\n      } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        const data = eventOrText.data;\n        if (data) {\n          selection.insertText(data);\n        }\n        return true;\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.REMOVE_TEXT_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.removeText();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, format => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.formatText(format);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      return false;\n    }\n    const nodes = selection.getNodes();\n    for (const node of nodes) {\n      const element = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parentNode => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(parentNode) && !parentNode.isInline());\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    selection.insertParagraph();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_TAB_COMMAND, () => {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$insertNodes)([(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTabNode)()]);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.OUTDENT_CONTENT_COMMAND, () => {\n    return $handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      if (indent > 0) {\n        block.setIndent(Math.max(0, indent - 1));\n      }\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, true);\n      if (!event.shiftKey && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n      const possibleNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentNode)(selection.focus, false);\n      if (!event.shiftKey && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, true);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const isHoldingShift = event.shiftKey;\n    if ((0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$shouldOverrideDefaultCharacterSelection)(selection, false)) {\n      event.preventDefault();\n      (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_3__.$moveCharacter)(selection, isHoldingShift, false);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if ($isSelectionCollapsedAtFrontOfIndentedBlock(selection)) {\n        event.preventDefault();\n        return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n      // Exception handling for iOS native behavior instead of Lexical's behavior when using Korean on iOS devices.\n      // more details - https://github.com/facebook/lexical/issues/5841\n      if (IS_IOS && navigator.language === 'ko-KR') {\n        return false;\n      }\n    } else if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection))) {\n      return false;\n    }\n    event.preventDefault();\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ENTER_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    $resetCapitalization(selection);\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n      event.preventDefault();\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n    return editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    editor.blur();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domNode);\n        if (node !== null) {\n          const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n          const normalizedSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(selection);\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(normalizedSelection);\n        }\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n      event.preventDefault();\n      return true;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (isFileTransfer && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (isFileTransfer && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n    if (eventRange !== null) {\n      const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(eventRange.node);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECT_ALL_COMMAND, () => {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$selectAll)();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.COPY_COMMAND, event => {\n    (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    }\n\n    // if inputs then paste within the input ignore creating a new node on paste event\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isSelectionCapturedInDecoratorInput)(event.target)) {\n      return false;\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection !== null) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_SPACE_COMMAND, _ => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      $resetCapitalization(selection);\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_TAB_COMMAND, _ => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      $resetCapitalization(selection);\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvcmljaC10ZXh0L0xleGljYWxSaWNoVGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFcUY7QUFDUztBQUN3RTtBQUN5N0I7O0FBRS9sQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isc0RBQWE7QUFDckM7QUFDQSx3QkFBd0IsZ0RBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFFBQVEsNkRBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsNkRBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw2REFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdEQUFXO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sc0VBQXNCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFFBQVEsNkRBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2REFBb0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkRBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSw2REFBb0I7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSw2REFBb0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNkRBQW9CO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLDBCQUEwQixpRUFBaUIsdUJBQXVCLGlFQUFpQjtBQUNuRjtBQUNBLE1BQU0sa0ZBQThCO0FBQ3BDO0FBQ0EsR0FBRztBQUNILFNBQVMsOENBQVM7QUFDbEIsR0FBRztBQUNIO0FBQ0E7QUFDQSxRQUFRLG1FQUFlLFNBQVMsaUVBQWlCO0FBQ2pEO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0EsTUFBTSxTQUFTLHlEQUFnQjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLGlFQUFpQjtBQUN2QjtBQUNBLElBQUksU0FBUyxpRUFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQyxPQUFPLDBEQUFpQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBbUIscUJBQXFCLHVEQUFjO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQTBCO0FBQ3pDLFNBQVMseURBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxpREFBUTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBLGtCQUFrQixzRkFBc0M7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2REFBYSx3QkFBd0Isa0RBQWE7QUFDM0Usc0JBQXNCLHNEQUFhO0FBQ25DLFFBQVEseURBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsNkRBQXdCO0FBQzlFLHNCQUFzQixzREFBYTtBQUNuQyxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0EsTUFBTSxTQUFTLHlEQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHdEQUFtQjtBQUN6RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix3REFBbUI7QUFDekUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsc0VBQWlDO0FBQ3ZGLHNCQUFzQixzREFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrRkFBOEI7QUFDdEMsUUFBUSxTQUFTLDBEQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsd0RBQW1CO0FBQ3pFLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHdEQUFtQjtBQUN6RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQiwyREFBc0I7QUFDNUUsc0JBQXNCLHNEQUFhO0FBQ25DLFNBQVMsMERBQWlCLGdCQUFnQix5REFBZ0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUVBQW1CLHFCQUFxQix1REFBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsOERBQXlCO0FBQy9FLHNCQUFzQixzREFBYTtBQUNuQyxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLDZEQUF3QjtBQUM5RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix1REFBa0I7QUFDeEUsSUFBSSxxREFBWSxFQUFFLHVEQUFjO0FBQ2hDO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsMkRBQXNCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQiw0REFBdUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQix5REFBb0I7QUFDMUUsc0JBQXNCLHNEQUFhO0FBQ25DLFFBQVEseURBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLDBEQUFpQjtBQUNoQywyQkFBMkIseURBQWdCO0FBQzNDLDZCQUE2Qix5REFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsMkRBQXNCO0FBQzVFLHNCQUFzQixzREFBYTtBQUNuQyxRQUFRLHlEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUywwREFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseURBQWdCO0FBQzNDLDZCQUE2Qix5REFBZ0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsMkRBQXNCO0FBQzVFLHNCQUFzQixzREFBYTtBQUNuQyxRQUFRLHlEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0EsUUFBUSw0RkFBd0M7QUFDaEQ7QUFDQTtBQUNBLE1BQU0sa0VBQWM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsNERBQXVCO0FBQzdFLHNCQUFzQixzREFBYTtBQUNuQyxRQUFRLHlEQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLDRGQUF3QztBQUNoRDtBQUNBLE1BQU0sa0VBQWM7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsMERBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBYTtBQUNuQyxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0Esc0NBQXNDLDREQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFVBQVUseURBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw2REFBd0I7QUFDMUQsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsdURBQWtCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBYTtBQUNuQyxVQUFVLDBEQUFpQixlQUFlLHlEQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNkRBQXdCO0FBQzFELEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHNEQUFpQjtBQUN2RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOERBQXlCO0FBQy9EO0FBQ0E7QUFDQSxrQ0FBa0MsNkRBQXdCO0FBQzFELEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHVEQUFrQjtBQUN4RSxzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQixpREFBWTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YscUJBQXFCLG1FQUEwQjtBQUMvQztBQUNBLDRCQUE0Qiw4REFBcUI7QUFDakQsY0FBYyxvREFBVztBQUN6QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMEVBQWlDO0FBQ3ZFLFVBQVUsc0RBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHNEQUFpQjtBQUN2RTtBQUNBLHNCQUFzQixzREFBYTtBQUNuQywyQkFBMkIsMERBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLHFEQUFnQjtBQUN0RTtBQUNBLHNCQUFzQixzREFBYTtBQUNuQywyQkFBMkIsMERBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBMEI7QUFDN0MsVUFBVSx5REFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsdURBQWtCO0FBQ3hFLElBQUksbURBQVU7QUFDZDtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLGlEQUFZO0FBQ2xFLElBQUksbUVBQWUsU0FBUyxpRUFBaUI7QUFDN0M7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQixnREFBVztBQUNqRTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsa0RBQWE7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsa0RBQVMsa0JBQWtCLDRFQUFtQztBQUN0RTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCLDBCQUEwQixzREFBaUI7QUFDdkUsc0JBQXNCLHNEQUFhO0FBQ25DLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLG9EQUFlO0FBQ3JFLHNCQUFzQixzREFBYTtBQUNuQyxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsNERBQXVCO0FBQzVCO0FBQ0E7O0FBRXFKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9yaWNoLXRleHQvTGV4aWNhbFJpY2hUZXh0LmRldi5tanM/MzIyOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRpbnNlcnREYXRhVHJhbnNmZXJGb3JSaWNoVGV4dCwgY29weVRvQ2xpcGJvYXJkIH0gZnJvbSAnQGxleGljYWwvY2xpcGJvYXJkJztcbmltcG9ydCB7ICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24sICRtb3ZlQ2hhcmFjdGVyIH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIG9iamVjdEtsYXNzRXF1YWxzLCBtZXJnZVJlZ2lzdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdyB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IGNyZWF0ZUNvbW1hbmQsIEVsZW1lbnROb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCBzZXROb2RlSW5kZW50RnJvbURPTSwgQ0xJQ0tfQ09NTUFORCwgJGdldFNlbGVjdGlvbiwgJGlzTm9kZVNlbGVjdGlvbiwgQ09NTUFORF9QUklPUklUWV9FRElUT1IsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgJGlzUmFuZ2VTZWxlY3Rpb24sIERFTEVURV9XT1JEX0NPTU1BTkQsIERFTEVURV9MSU5FX0NPTU1BTkQsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgUkVNT1ZFX1RFWFRfQ09NTUFORCwgRk9STUFUX1RFWFRfQ09NTUFORCwgRk9STUFUX0VMRU1FTlRfQ09NTUFORCwgJGlzRWxlbWVudE5vZGUsIElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgSU5TRVJUX1RBQl9DT01NQU5ELCAkaW5zZXJ0Tm9kZXMsICRjcmVhdGVUYWJOb2RlLCBJTkRFTlRfQ09OVEVOVF9DT01NQU5ELCBPVVRERU5UX0NPTlRFTlRfQ09NTUFORCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsICRnZXRBZGphY2VudE5vZGUsICRpc0RlY29yYXRvck5vZGUsIEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIEtFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIEtFWV9ERUxFVEVfQ09NTUFORCwgS0VZX0VOVEVSX0NPTU1BTkQsIEtFWV9FU0NBUEVfQ09NTUFORCwgRFJPUF9DT01NQU5ELCAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uLCAkaXNUZXh0Tm9kZSwgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCAkc2V0U2VsZWN0aW9uLCBEUkFHU1RBUlRfQ09NTUFORCwgRFJBR09WRVJfQ09NTUFORCwgU0VMRUNUX0FMTF9DT01NQU5ELCAkc2VsZWN0QWxsLCBDT1BZX0NPTU1BTkQsIENVVF9DT01NQU5ELCBQQVNURV9DT01NQU5ELCBpc0RPTU5vZGUsIGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0LCBLRVlfU1BBQ0VfQ09NTUFORCwgS0VZX1RBQl9DT01NQU5ELCBQQVNURV9UQUcsICRnZXRSb290LCAkaXNSb290Tm9kZSB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNhcmV0RnJvbVBvaW50KHgsIHkpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAocmFuZ2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICBvZmZzZXQ6IHJhbmdlLnN0YXJ0T2Zmc2V0XG4gICAgfTtcbiAgICAvLyBAdHMtaWdub3JlXG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBAdHMtaWdub3JlIEZGIC0gbm8gdHlwZXNcbiAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQoeCwgeSk7XG4gICAgaWYgKHJhbmdlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5vZGU6IHJhbmdlLm9mZnNldE5vZGUsXG4gICAgICBvZmZzZXQ6IHJhbmdlLm9mZnNldFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gR3JhY2VmdWxseSBoYW5kbGUgSUVcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCA9IENBTl9VU0VfRE9NICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJID0gQ0FOX1VTRV9ET00gJiYgL1ZlcnNpb25cXC9bXFxkLl0rLipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19JT1MgPSBDQU5fVVNFX0RPTSAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhd2luZG93Lk1TU3RyZWFtO1xuXG4vLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19DSFJPTUUgPSBDQU5fVVNFX0RPTSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0FQUExFX1dFQktJVCA9IENBTl9VU0VfRE9NICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBEUkFHX0RST1BfUEFTVEUgPSBjcmVhdGVDb21tYW5kKCdEUkFHX0RST1BfUEFTVEVfRklMRScpO1xuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFF1b3RlTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdxdW90ZSc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFF1b3RlTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuXG4gIC8vIFZpZXdcblxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Jsb2NrcXVvdGUnKTtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5xdW90ZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmxvY2txdW90ZTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEJsb2NrcXVvdGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBmb3JtYXRUeXBlID0gdGhpcy5nZXRGb3JtYXRUeXBlKCk7XG4gICAgICBpZiAoZm9ybWF0VHlwZSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnRleHRBbGlnbiA9IGZvcm1hdFR5cGU7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBlbGVtZW50LmRpciA9IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVRdW90ZU5vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cblxuICAvLyBNdXRhdGlvblxuXG4gIGluc2VydE5ld0FmdGVyKF8sIHJlc3RvcmVTZWxlY3Rpb24pIHtcbiAgICBjb25zdCBuZXdCbG9jayA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBuZXdCbG9jay5zZXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0Jsb2NrLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3QmxvY2s7XG4gIH1cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiBwYXJhZ3JhcGguYXBwZW5kKGNoaWxkKSk7XG4gICAgdGhpcy5yZXBsYWNlKHBhcmFncmFwaCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuTWVyZ2VXaGVuRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVRdW90ZU5vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFF1b3RlTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc1F1b3RlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgUXVvdGVOb2RlO1xufVxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIEhlYWRpbmdOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdoZWFkaW5nJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgSGVhZGluZ05vZGUobm9kZS5fX3RhZywgbm9kZS5fX2tleSk7XG4gIH1cbiAgY29uc3RydWN0b3IodGFnLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX190YWcgPSB0YWc7XG4gIH1cbiAgZ2V0VGFnKCkge1xuICAgIHJldHVybiB0aGlzLl9fdGFnO1xuICB9XG4gIHNldFRhZyh0YWcpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHRoaXMuX190YWcgPSB0YWc7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvLyBWaWV3XG5cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuX190YWc7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBjb25zdCB0aGVtZSA9IGNvbmZpZy50aGVtZTtcbiAgICBjb25zdCBjbGFzc05hbWVzID0gdGhlbWUuaGVhZGluZztcbiAgICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBjbGFzc05hbWVzW3RhZ107XG4gICAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNsYXNzTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICByZXR1cm4gcHJldk5vZGUuX190YWcgIT09IHRoaXMuX190YWc7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaDE6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDI6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDM6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDQ6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDU6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgaDY6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRIZWFkaW5nRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgcDogbm9kZSA9PiB7XG4gICAgICAgIC8vIGRvbU5vZGUgaXMgYSA8cD4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSBub2RlO1xuICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyYWdyYXBoLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsICYmIGlzR29vZ2xlRG9jc1RpdGxlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb246ICgpID0+ICh7XG4gICAgICAgICAgICAgIG5vZGU6IG51bGxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSxcbiAgICAgIHNwYW46IG5vZGUgPT4ge1xuICAgICAgICBpZiAoaXNHb29nbGVEb2NzVGl0bGUobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udmVyc2lvbjogZG9tTm9kZSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm9kZTogJGNyZWF0ZUhlYWRpbmdOb2RlKCdoMScpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJpb3JpdHk6IDNcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICBlbGVtZW50LmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcm1hdFR5cGUgPSB0aGlzLmdldEZvcm1hdFR5cGUoKTtcbiAgICAgIGlmIChmb3JtYXRUeXBlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gZm9ybWF0VHlwZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0RGlyZWN0aW9uKCk7XG4gICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGVsZW1lbnQuZGlyID0gZGlyZWN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZWxlbWVudFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUhlYWRpbmdOb2RlKHNlcmlhbGl6ZWROb2RlLnRhZykudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRUYWcoc2VyaWFsaXplZE5vZGUudGFnKTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICB0YWc6IHRoaXMuZ2V0VGFnKClcbiAgICB9O1xuICB9XG5cbiAgLy8gTXV0YXRpb25cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGFuY2hvck9mZmV0ID0gc2VsZWN0aW9uID8gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgOiAwO1xuICAgIGNvbnN0IGxhc3REZXNjID0gdGhpcy5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgIGNvbnN0IGlzQXRFbmQgPSAhbGFzdERlc2MgfHwgc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5hbmNob3Iua2V5ID09PSBsYXN0RGVzYy5nZXRLZXkoKSAmJiBhbmNob3JPZmZldCA9PT0gbGFzdERlc2MuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IGlzQXRFbmQgfHwgIXNlbGVjdGlvbiA/ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkgOiAkY3JlYXRlSGVhZGluZ05vZGUodGhpcy5nZXRUYWcoKSk7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBuZXdFbGVtZW50LnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIHRoaXMuaW5zZXJ0QWZ0ZXIobmV3RWxlbWVudCwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgaWYgKGFuY2hvck9mZmV0ID09PSAwICYmICF0aGlzLmlzRW1wdHkoKSAmJiBzZWxlY3Rpb24pIHtcbiAgICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICBwYXJhZ3JhcGguc2VsZWN0KCk7XG4gICAgICB0aGlzLnJlcGxhY2UocGFyYWdyYXBoLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0VsZW1lbnQ7XG4gIH1cbiAgY29sbGFwc2VBdFN0YXJ0KCkge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSAhdGhpcy5pc0VtcHR5KCkgPyAkY3JlYXRlSGVhZGluZ05vZGUodGhpcy5nZXRUYWcoKSkgOiAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gbmV3RWxlbWVudC5hcHBlbmQoY2hpbGQpKTtcbiAgICB0aGlzLnJlcGxhY2UobmV3RWxlbWVudCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNHb29nbGVEb2NzVGl0bGUoZG9tTm9kZSkge1xuICBpZiAoZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3BhbicpIHtcbiAgICByZXR1cm4gZG9tTm9kZS5zdHlsZS5mb250U2l6ZSA9PT0gJzI2cHQnO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0SGVhZGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IG5vZGUgPSBudWxsO1xuICBpZiAobm9kZU5hbWUgPT09ICdoMScgfHwgbm9kZU5hbWUgPT09ICdoMicgfHwgbm9kZU5hbWUgPT09ICdoMycgfHwgbm9kZU5hbWUgPT09ICdoNCcgfHwgbm9kZU5hbWUgPT09ICdoNScgfHwgbm9kZU5hbWUgPT09ICdoNicpIHtcbiAgICBub2RlID0gJGNyZWF0ZUhlYWRpbmdOb2RlKG5vZGVOYW1lKTtcbiAgICBpZiAoZWxlbWVudC5zdHlsZSAhPT0gbnVsbCkge1xuICAgICAgc2V0Tm9kZUluZGVudEZyb21ET00oZWxlbWVudCwgbm9kZSk7XG4gICAgICBub2RlLnNldEZvcm1hdChlbGVtZW50LnN0eWxlLnRleHRBbGlnbik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gJGNvbnZlcnRCbG9ja3F1b3RlRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IG5vZGUgPSAkY3JlYXRlUXVvdGVOb2RlKCk7XG4gIGlmIChlbGVtZW50LnN0eWxlICE9PSBudWxsKSB7XG4gICAgbm9kZS5zZXRGb3JtYXQoZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24pO1xuICAgIHNldE5vZGVJbmRlbnRGcm9tRE9NKGVsZW1lbnQsIG5vZGUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgbm9kZVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZUhlYWRpbmdOb2RlKGhlYWRpbmdUYWcgPSAnaDEnKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IEhlYWRpbmdOb2RlKGhlYWRpbmdUYWcpKTtcbn1cbmZ1bmN0aW9uICRpc0hlYWRpbmdOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBIZWFkaW5nTm9kZTtcbn1cbmZ1bmN0aW9uIG9uUGFzdGVGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBjbGlwYm9hcmREYXRhID0gb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIElucHV0RXZlbnQpIHx8IG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBLZXlib2FyZEV2ZW50KSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGlmIChjbGlwYm9hcmREYXRhICE9IG51bGwgJiYgc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAkaW5zZXJ0RGF0YVRyYW5zZmVyRm9yUmljaFRleHQoY2xpcGJvYXJkRGF0YSwgc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgIH1cbiAgfSwge1xuICAgIHRhZzogUEFTVEVfVEFHXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gb25DdXRGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKSB7XG4gIGF3YWl0IGNvcHlUb0NsaXBib2FyZChlZGl0b3IsIG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBDbGlwYm9hcmRFdmVudCkgPyBldmVudCA6IG51bGwpO1xuICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5yZW1vdmVUZXh0KCk7XG4gICAgfSBlbHNlIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5nZXROb2RlcygpLmZvckVhY2gobm9kZSA9PiBub2RlLnJlbW92ZSgpKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBDbGlwYm9hcmQgbWF5IGNvbnRhaW4gZmlsZXMgdGhhdCB3ZSBhcmVuJ3QgYWxsb3dlZCB0byByZWFkLiBXaGlsZSB0aGUgZXZlbnQgaXMgYXJndWFibHkgdXNlbGVzcyxcbi8vIGluIGNlcnRhaW4gb2NjYXNpb25zLCB3ZSB3YW50IHRvIGtub3cgd2hldGhlciBpdCB3YXMgYSBmaWxlIHRyYW5zZmVyLCBhcyBvcHBvc2VkIHRvIHRleHQuIFdlXG4vLyBjb250cm9sIHRoaXMgd2l0aCB0aGUgZmlyc3QgYm9vbGVhbiBmbGFnLlxuZnVuY3Rpb24gZXZlbnRGaWxlcyhldmVudCkge1xuICBsZXQgZGF0YVRyYW5zZmVyID0gbnVsbDtcbiAgaWYgKG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBEcmFnRXZlbnQpKSB7XG4gICAgZGF0YVRyYW5zZmVyID0gZXZlbnQuZGF0YVRyYW5zZmVyO1xuICB9IGVsc2UgaWYgKG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBDbGlwYm9hcmRFdmVudCkpIHtcbiAgICBkYXRhVHJhbnNmZXIgPSBldmVudC5jbGlwYm9hcmREYXRhO1xuICB9XG4gIGlmIChkYXRhVHJhbnNmZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gW2ZhbHNlLCBbXSwgZmFsc2VdO1xuICB9XG4gIGNvbnN0IHR5cGVzID0gZGF0YVRyYW5zZmVyLnR5cGVzO1xuICBjb25zdCBoYXNGaWxlcyA9IHR5cGVzLmluY2x1ZGVzKCdGaWxlcycpO1xuICBjb25zdCBoYXNDb250ZW50ID0gdHlwZXMuaW5jbHVkZXMoJ3RleHQvaHRtbCcpIHx8IHR5cGVzLmluY2x1ZGVzKCd0ZXh0L3BsYWluJyk7XG4gIHJldHVybiBbaGFzRmlsZXMsIEFycmF5LmZyb20oZGF0YVRyYW5zZmVyLmZpbGVzKSwgaGFzQ29udGVudF07XG59XG5mdW5jdGlvbiAkaGFuZGxlSW5kZW50QW5kT3V0ZGVudChpbmRlbnRPck91dGRlbnQpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWxyZWFkeUhhbmRsZWQgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgY29uc3Qga2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgICBpZiAoYWxyZWFkeUhhbmRsZWQuaGFzKGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRCbG9jayA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgcGFyZW50Tm9kZSA9PiAkaXNFbGVtZW50Tm9kZShwYXJlbnROb2RlKSAmJiAhcGFyZW50Tm9kZS5pc0lubGluZSgpKTtcbiAgICBpZiAocGFyZW50QmxvY2sgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnRCbG9jay5nZXRLZXkoKTtcbiAgICBpZiAocGFyZW50QmxvY2suY2FuSW5kZW50KCkgJiYgIWFscmVhZHlIYW5kbGVkLmhhcyhwYXJlbnRLZXkpKSB7XG4gICAgICBhbHJlYWR5SGFuZGxlZC5hZGQocGFyZW50S2V5KTtcbiAgICAgIGluZGVudE9yT3V0ZGVudChwYXJlbnRCbG9jayk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhbHJlYWR5SGFuZGxlZC5zaXplID4gMDtcbn1cbmZ1bmN0aW9uICRpc1RhcmdldFdpdGhpbkRlY29yYXRvcih0YXJnZXQpIHtcbiAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKHRhcmdldCk7XG4gIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpO1xufVxuZnVuY3Rpb24gJGlzU2VsZWN0aW9uQXRFbmRPZlJvb3Qoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICByZXR1cm4gZm9jdXMua2V5ID09PSAncm9vdCcgJiYgZm9jdXMub2Zmc2V0ID09PSAkZ2V0Um9vdCgpLmdldENoaWxkcmVuU2l6ZSgpO1xufVxuZnVuY3Rpb24gJGlzU2VsZWN0aW9uQ29sbGFwc2VkQXRGcm9udE9mSW5kZW50ZWRCbG9jayhzZWxlY3Rpb24pIHtcbiAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB7XG4gICAgYW5jaG9yXG4gIH0gPSBzZWxlY3Rpb247XG4gIGlmIChhbmNob3Iub2Zmc2V0ICE9PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBpZiAoJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9ICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93KGFuY2hvck5vZGUpO1xuICByZXR1cm4gZWxlbWVudC5nZXRJbmRlbnQoKSA+IDAgJiYgKGVsZW1lbnQuaXMoYW5jaG9yTm9kZSkgfHwgYW5jaG9yTm9kZS5pcyhlbGVtZW50LmdldEZpcnN0RGVzY2VuZGFudCgpKSk7XG59XG5cbi8qKlxuICogUmVzZXRzIHRoZSBjYXBpdGFsaXphdGlvbiBvZiB0aGUgc2VsZWN0aW9uIHRvIGRlZmF1bHQuXG4gKiBDYWxsZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHNwYWNlLCB0YWIsIG9yIGVudGVyIGtleS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gVGhlIHNlbGVjdGlvbiB0byByZXNldCB0aGUgY2FwaXRhbGl6YXRpb24gb2YuXG4gKi9cbmZ1bmN0aW9uICRyZXNldENhcGl0YWxpemF0aW9uKHNlbGVjdGlvbikge1xuICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBbJ2xvd2VyY2FzZScsICd1cHBlcmNhc2UnLCAnY2FwaXRhbGl6ZSddKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5oYXNGb3JtYXQoZm9ybWF0KSkge1xuICAgICAgc2VsZWN0aW9uLnRvZ2dsZUZvcm1hdChmb3JtYXQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJSaWNoVGV4dChlZGl0b3IpIHtcbiAgY29uc3QgcmVtb3ZlTGlzdGVuZXIgPSBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ0xJQ0tfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgaXNCYWNrd2FyZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBzZWxlY3Rpb24uZGVsZXRlQ2hhcmFjdGVyKGlzQmFja3dhcmQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHNlbGVjdGlvbi5kZWxldGVOb2RlcygpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKERFTEVURV9XT1JEX0NPTU1BTkQsIGlzQmFja3dhcmQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmRlbGV0ZVdvcmQoaXNCYWNrd2FyZCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChERUxFVEVfTElORV9DT01NQU5ELCBpc0JhY2t3YXJkID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kZWxldGVMaW5lKGlzQmFja3dhcmQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBldmVudE9yVGV4dCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICh0eXBlb2YgZXZlbnRPclRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIHNlbGVjdGlvbi5pbnNlcnRUZXh0KGV2ZW50T3JUZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhVHJhbnNmZXIgPSBldmVudE9yVGV4dC5kYXRhVHJhbnNmZXI7XG4gICAgICBpZiAoZGF0YVRyYW5zZmVyICE9IG51bGwpIHtcbiAgICAgICAgJGluc2VydERhdGFUcmFuc2ZlckZvclJpY2hUZXh0KGRhdGFUcmFuc2Zlciwgc2VsZWN0aW9uLCBlZGl0b3IpO1xuICAgICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBldmVudE9yVGV4dC5kYXRhO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIHNlbGVjdGlvbi5pbnNlcnRUZXh0KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFJFTU9WRV9URVhUX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGVjdGlvbi5yZW1vdmVUZXh0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChGT1JNQVRfVEVYVF9DT01NQU5ELCBmb3JtYXQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmZvcm1hdFRleHQoZm9ybWF0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsIGZvcm1hdCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCBwYXJlbnROb2RlID0+ICRpc0VsZW1lbnROb2RlKHBhcmVudE5vZGUpICYmICFwYXJlbnROb2RlLmlzSW5saW5lKCkpO1xuICAgICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBzZWxlY3RTdGFydCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uaW5zZXJ0TGluZUJyZWFrKHNlbGVjdFN0YXJ0KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2VsZWN0aW9uLmluc2VydFBhcmFncmFwaCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1RBQl9DT01NQU5ELCAoKSA9PiB7XG4gICAgJGluc2VydE5vZGVzKFskY3JlYXRlVGFiTm9kZSgpXSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTkRFTlRfQ09OVEVOVF9DT01NQU5ELCAoKSA9PiB7XG4gICAgcmV0dXJuICRoYW5kbGVJbmRlbnRBbmRPdXRkZW50KGJsb2NrID0+IHtcbiAgICAgIGNvbnN0IGluZGVudCA9IGJsb2NrLmdldEluZGVudCgpO1xuICAgICAgYmxvY2suc2V0SW5kZW50KGluZGVudCArIDEpO1xuICAgIH0pO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoT1VUREVOVF9DT05URU5UX0NPTU1BTkQsICgpID0+IHtcbiAgICByZXR1cm4gJGhhbmRsZUluZGVudEFuZE91dGRlbnQoYmxvY2sgPT4ge1xuICAgICAgY29uc3QgaW5kZW50ID0gYmxvY2suZ2V0SW5kZW50KCk7XG4gICAgICBpZiAoaW5kZW50ID4gMCkge1xuICAgICAgICBibG9jay5zZXRJbmRlbnQoTWF0aC5tYXgoMCwgaW5kZW50IC0gMSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgLy8gSWYgc2VsZWN0aW9uIGlzIG9uIGEgbm9kZSwgbGV0J3MgdHJ5IGFuZCBtb3ZlIHNlbGVjdGlvblxuICAgICAgLy8gYmFjayB0byBiZWluZyBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBub2Rlc1swXS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc3NpYmxlTm9kZSA9ICRnZXRBZGphY2VudE5vZGUoc2VsZWN0aW9uLmZvY3VzLCB0cnVlKTtcbiAgICAgIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpICYmICFwb3NzaWJsZU5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICBwb3NzaWJsZU5vZGUuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgLy8gSWYgc2VsZWN0aW9uIGlzIG9uIGEgbm9kZSwgbGV0J3MgdHJ5IGFuZCBtb3ZlIHNlbGVjdGlvblxuICAgICAgLy8gYmFjayB0byBiZWluZyBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBpZiAobm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBub2Rlc1swXS5zZWxlY3ROZXh0KDAsIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGlmICgkaXNTZWxlY3Rpb25BdEVuZE9mUm9vdChzZWxlY3Rpb24pKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgcG9zc2libGVOb2RlID0gJGdldEFkamFjZW50Tm9kZShzZWxlY3Rpb24uZm9jdXMsIGZhbHNlKTtcbiAgICAgIGlmICghZXZlbnQuc2hpZnRLZXkgJiYgJGlzRGVjb3JhdG9yTm9kZShwb3NzaWJsZU5vZGUpICYmICFwb3NzaWJsZU5vZGUuaXNJc29sYXRlZCgpICYmICFwb3NzaWJsZU5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICBwb3NzaWJsZU5vZGUuc2VsZWN0TmV4dCgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAvLyBJZiBzZWxlY3Rpb24gaXMgb24gYSBub2RlLCBsZXQncyB0cnkgYW5kIG1vdmUgc2VsZWN0aW9uXG4gICAgICAvLyBiYWNrIHRvIGJlaW5nIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG5vZGVzWzBdLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24oc2VsZWN0aW9uLCB0cnVlKSkge1xuICAgICAgY29uc3QgaXNIb2xkaW5nU2hpZnQgPSBldmVudC5zaGlmdEtleTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAkbW92ZUNoYXJhY3RlcihzZWxlY3Rpb24sIGlzSG9sZGluZ1NoaWZ0LCB0cnVlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAvLyBJZiBzZWxlY3Rpb24gaXMgb24gYSBub2RlLCBsZXQncyB0cnkgYW5kIG1vdmUgc2VsZWN0aW9uXG4gICAgICAvLyBiYWNrIHRvIGJlaW5nIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIG5vZGVzWzBdLnNlbGVjdE5leHQoMCwgMCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaXNIb2xkaW5nU2hpZnQgPSBldmVudC5zaGlmdEtleTtcbiAgICBpZiAoJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbihzZWxlY3Rpb24sIGZhbHNlKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBpZiAoJGlzVGFyZ2V0V2l0aGluRGVjb3JhdG9yKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoJGlzU2VsZWN0aW9uQ29sbGFwc2VkQXRGcm9udE9mSW5kZW50ZWRCbG9jayhzZWxlY3Rpb24pKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKE9VVERFTlRfQ09OVEVOVF9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgLy8gRXhjZXB0aW9uIGhhbmRsaW5nIGZvciBpT1MgbmF0aXZlIGJlaGF2aW9yIGluc3RlYWQgb2YgTGV4aWNhbCdzIGJlaGF2aW9yIHdoZW4gdXNpbmcgS29yZWFuIG9uIGlPUyBkZXZpY2VzLlxuICAgICAgLy8gbW9yZSBkZXRhaWxzIC0gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2xleGljYWwvaXNzdWVzLzU4NDFcbiAgICAgIGlmIChJU19JT1MgJiYgbmF2aWdhdG9yLmxhbmd1YWdlID09PSAna28tS1InKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIHRydWUpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0RFTEVURV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgaWYgKCRpc1RhcmdldFdpdGhpbkRlY29yYXRvcihldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIGZhbHNlKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9FTlRFUl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAkcmVzZXRDYXBpdGFsaXphdGlvbihzZWxlY3Rpb24pO1xuICAgIGlmIChldmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBiZWZvcmVpbnB1dCwgdGhlbiB3ZSBjYW4gYXZvaWQgYmxvY2tpbmdcbiAgICAgIC8vIHRoZSBkZWZhdWx0IGJlaGF2aW9yLiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgaU9TIGNhblxuICAgICAgLy8gaW50ZXJjZXB0IHRoYXQgd2UncmUgYWN0dWFsbHkgaW5zZXJ0aW5nIGEgcGFyYWdyYXBoLFxuICAgICAgLy8gYW5kIGF1dG9jb21wbGV0ZSwgYXV0b2NhcGl0YWxpemUgZXRjIHdvcmsgYXMgaW50ZW5kZWQuXG4gICAgICAvLyBUaGlzIGNhbiBhbHNvIGNhdXNlIGEgc3RyYW5nZSBwZXJmb3JtYW5jZSBpc3N1ZSBpblxuICAgICAgLy8gU2FmYXJpLCB3aGVyZSB0aGVyZSBpcyBhIG5vdGljZWFibGUgcGF1c2UgZHVlIHRvXG4gICAgICAvLyBwcmV2ZW50aW5nIHRoZSBrZXkgZG93biBvZiBlbnRlci5cbiAgICAgIGlmICgoSVNfSU9TIHx8IElTX1NBRkFSSSB8fCBJU19BUFBMRV9XRUJLSVQpICYmIENBTl9VU0VfQkVGT1JFX0lOUFVUKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfRVNDQVBFX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVkaXRvci5ibHVyKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChEUk9QX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBbLCBmaWxlc10gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WTtcbiAgICAgIGNvbnN0IGV2ZW50UmFuZ2UgPSBjYXJldEZyb21Qb2ludCh4LCB5KTtcbiAgICAgIGlmIChldmVudFJhbmdlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBvZmZzZXQ6IGRvbU9mZnNldCxcbiAgICAgICAgICBub2RlOiBkb21Ob2RlXG4gICAgICAgIH0gPSBldmVudFJhbmdlO1xuICAgICAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZG9tTm9kZSk7XG4gICAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLnNldChub2RlLmdldEtleSgpLCBkb21PZmZzZXQsICd0ZXh0Jyk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KG5vZGUuZ2V0S2V5KCksIGRvbU9mZnNldCwgJ3RleHQnKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCkuZ2V0S2V5KCk7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAxO1xuICAgICAgICAgICAgc2VsZWN0aW9uLmFuY2hvci5zZXQocGFyZW50S2V5LCBvZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KHBhcmVudEtleSwgb2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBub3JtYWxpemVkU2VsZWN0aW9uID0gJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMKHNlbGVjdGlvbik7XG4gICAgICAgICAgJHNldFNlbGVjdGlvbihub3JtYWxpemVkU2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKERSQUdfRFJPUF9QQVNURSwgZmlsZXMpO1xuICAgICAgfVxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChEUkFHU1RBUlRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFtpc0ZpbGVUcmFuc2Zlcl0gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKGlzRmlsZVRyYW5zZmVyICYmICEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRFJBR09WRVJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFtpc0ZpbGVUcmFuc2Zlcl0gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKGlzRmlsZVRyYW5zZmVyICYmICEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYO1xuICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZO1xuICAgIGNvbnN0IGV2ZW50UmFuZ2UgPSBjYXJldEZyb21Qb2ludCh4LCB5KTtcbiAgICBpZiAoZXZlbnRSYW5nZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGV2ZW50UmFuZ2Uubm9kZSk7XG4gICAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSkge1xuICAgICAgICAvLyBTaG93IGJyb3dzZXIgY2FyZXQgYXMgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgdGhlIG1lZGlhIGFjcm9zcyB0aGUgc2NyZWVuLiBXb24ndCB3b3JrXG4gICAgICAgIC8vIGZvciBEZWNvcmF0b3JOb2RlIG5vciBpdCdzIHJlbGV2YW50LlxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFNFTEVDVF9BTExfQ09NTUFORCwgKCkgPT4ge1xuICAgICRzZWxlY3RBbGwoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9FRElUT1IpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENPUFlfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvcHlUb0NsaXBib2FyZChlZGl0b3IsIG9iamVjdEtsYXNzRXF1YWxzKGV2ZW50LCBDbGlwYm9hcmRFdmVudCkgPyBldmVudCA6IG51bGwpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ1VUX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBvbkN1dEZvclJpY2hUZXh0KGV2ZW50LCBlZGl0b3IpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoUEFTVEVfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IFssIGZpbGVzLCBoYXNUZXh0Q29udGVudF0gPSBldmVudEZpbGVzKGV2ZW50KTtcbiAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCAmJiAhaGFzVGV4dENvbnRlbnQpIHtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoRFJBR19EUk9QX1BBU1RFLCBmaWxlcyk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBpZiBpbnB1dHMgdGhlbiBwYXN0ZSB3aXRoaW4gdGhlIGlucHV0IGlnbm9yZSBjcmVhdGluZyBhIG5ldyBub2RlIG9uIHBhc3RlIGV2ZW50XG4gICAgaWYgKGlzRE9NTm9kZShldmVudC50YXJnZXQpICYmIGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcklucHV0KGV2ZW50LnRhcmdldCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIG9uUGFzdGVGb3JSaWNoVGV4dChldmVudCwgZWRpdG9yKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfU1BBQ0VfQ09NTUFORCwgXyA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAkcmVzZXRDYXBpdGFsaXphdGlvbihzZWxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfVEFCX0NPTU1BTkQsIF8gPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgJHJlc2V0Q2FwaXRhbGl6YXRpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUikpO1xuICByZXR1cm4gcmVtb3ZlTGlzdGVuZXI7XG59XG5cbmV4cG9ydCB7ICRjcmVhdGVIZWFkaW5nTm9kZSwgJGNyZWF0ZVF1b3RlTm9kZSwgJGlzSGVhZGluZ05vZGUsICRpc1F1b3RlTm9kZSwgRFJBR19EUk9QX1BBU1RFLCBIZWFkaW5nTm9kZSwgUXVvdGVOb2RlLCBldmVudEZpbGVzLCByZWdpc3RlclJpY2hUZXh0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lexical/rich-text/LexicalRichText.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/selection/LexicalSelection.dev.mjs":
/*!******************************************************************!*\
  !*** ./node_modules/@lexical/selection/LexicalSelection.dev.mjs ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addNodeStyle: function() { return /* binding */ $addNodeStyle; },\n/* harmony export */   $cloneWithProperties: function() { return /* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties; },\n/* harmony export */   $copyBlockFormatIndent: function() { return /* binding */ $copyBlockFormatIndent; },\n/* harmony export */   $ensureForwardRangeSelection: function() { return /* binding */ $ensureForwardRangeSelection; },\n/* harmony export */   $forEachSelectedTextNode: function() { return /* binding */ $forEachSelectedTextNode; },\n/* harmony export */   $getSelectionStyleValueForProperty: function() { return /* binding */ $getSelectionStyleValueForProperty; },\n/* harmony export */   $isAtNodeEnd: function() { return /* binding */ $isAtNodeEnd; },\n/* harmony export */   $isParentElementRTL: function() { return /* binding */ $isParentElementRTL; },\n/* harmony export */   $moveCaretSelection: function() { return /* binding */ $moveCaretSelection; },\n/* harmony export */   $moveCharacter: function() { return /* binding */ $moveCharacter; },\n/* harmony export */   $patchStyleText: function() { return /* binding */ $patchStyleText; },\n/* harmony export */   $selectAll: function() { return /* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$selectAll; },\n/* harmony export */   $setBlocksType: function() { return /* binding */ $setBlocksType; },\n/* harmony export */   $shouldOverrideDefaultCharacterSelection: function() { return /* binding */ $shouldOverrideDefaultCharacterSelection; },\n/* harmony export */   $sliceSelectedTextNodeContent: function() { return /* binding */ $sliceSelectedTextNodeContent; },\n/* harmony export */   $trimTextContentFromAnchor: function() { return /* binding */ $trimTextContentFromAnchor; },\n/* harmony export */   $wrapNodes: function() { return /* binding */ $wrapNodes; },\n/* harmony export */   createDOMRange: function() { return /* binding */ createDOMRange; },\n/* harmony export */   createRectsFromDOMRange: function() { return /* binding */ createRectsFromDOMRange; },\n/* harmony export */   getCSSFromStyleObject: function() { return /* binding */ getCSSFromStyleObject; },\n/* harmony export */   getStyleObjectFromCSS: function() { return /* binding */ getStyleObjectFromCSS; },\n/* harmony export */   trimTextContentFromAnchor: function() { return /* binding */ trimTextContentFromAnchor; }\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(textNode) && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCharacterOffsets)(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      // NOTE: This mutates __text directly because the primary use case is to\n      // modify a $cloneWithProperties node that should never be added\n      // to the EditorState so we must not call getWritable via setTextContent\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    formatDevErrorMessage(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\n/**\n * Applies the provided styles to the given TextNode, ElementNode, or\n * collapsed RangeSelection.\n *\n * @param target - The TextNode, ElementNode, or collapsed RangeSelection to apply the styles to\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyle(target, patch) {\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(target) ? target.isCollapsed() : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target))) {\n    formatDevErrorMessage(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);\n  }\n  const prevStyles = getStyleObjectFromCSS((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(target) ? target.style : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target) ? target.getStyle() : target.getTextStyle());\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  });\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(target) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    target.setStyle(newCSSText);\n  } else {\n    target.setTextStyle(newCSSText);\n  }\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    const emptyNode = selection.anchor.getNode();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(emptyNode) && emptyNode.isEmpty()) {\n      $patchStyle(emptyNode, patch);\n    }\n  }\n  $forEachSelectedTextNode(textNode => {\n    $patchStyle(textNode, patch);\n  });\n}\nfunction $forEachSelectedTextNode(fn) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!selection) {\n    return;\n  }\n  const slicedTextNodes = new Map();\n  const getSliceIndices = node => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    for (const slice of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretRangeFromSelection)(selection).getTextSlices()) {\n      if (slice) {\n        slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());\n      }\n    }\n  }\n  const selectedNodes = selection.getNodes();\n  for (const selectedNode of selectedNodes) {\n    if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(selectedNode) && selectedNode.canHaveFormat())) {\n      continue;\n    }\n    const [startOffset, endOffset] = getSliceIndices(selectedNode);\n    // No actual text is selected, so do nothing.\n    if (endOffset === startOffset) {\n      continue;\n    }\n\n    // The entire node is selected or a token/segment, so just format it\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {\n      fn(selectedNode);\n    } else {\n      // The node is partially selected, so split it into two or three nodes\n      // and style the selected one.\n      const splitNodes = selectedNode.splitText(startOffset, endOffset);\n      const replacement = splitNodes[startOffset === 0 ? 0 : 1];\n      fn(replacement);\n    }\n  }\n  // Prior to NodeCaret #7046 this would have been a side-effect\n  // so we do this for test compatibility.\n  // TODO: we may want to consider simplifying by removing this\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.anchor.type === 'text' && selection.focus.type === 'text' && selection.anchor.key === selection.focus.key) {\n    $ensureForwardRangeSelection(selection);\n  }\n}\n\n/**\n * Ensure that the given RangeSelection is not backwards. If it\n * is backwards, then the anchor and focus points will be swapped\n * in-place. Ensuring that the selection is a writable RangeSelection\n * is the responsibility of the caller (e.g. in a read-only context\n * you will want to clone $getSelection() before using this).\n *\n * @param selection a writable RangeSelection\n */\nfunction $ensureForwardRangeSelection(selection) {\n  if (selection.isBackward()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    // stash for the in-place swap\n    const {\n      key,\n      offset,\n      type\n    } = anchor;\n    anchor.set(focus.key, focus.offset, focus.type);\n    focus.set(key, offset, type);\n  }\n}\n\nfunction $copyBlockFormatIndent(srcNode, destNode) {\n  const format = srcNode.getFormatType();\n  const indent = srcNode.getIndent();\n  if (format !== destNode.getFormatType()) {\n    destNode.setFormat(format);\n  }\n  if (indent !== destNode.getIndent()) {\n    destNode.setIndent(indent);\n  }\n}\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param $createElement - The function that creates the node. eg. $createParagraphNode.\n * @param $afterCreateElement - The function that updates the new node based on the previous one ($copyBlockFormatIndent by default)\n */\nfunction $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {\n  if (selection === null) {\n    return;\n  }\n  // Selections tend to not include their containing blocks so we effectively\n  // expand it here\n  const anchorAndFocus = selection.getStartEndPoints();\n  const blockMap = new Map();\n  let newSelection = null;\n  if (anchorAndFocus) {\n    const [anchor, focus] = anchorAndFocus;\n    newSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n    newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);\n    newSelection.focus.set(focus.key, focus.offset, focus.type);\n    const anchorBlock = $getAncestor(anchor.getNode(), lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock);\n    const focusBlock = $getAncestor(focus.getNode(), lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorBlock)) {\n      blockMap.set(anchorBlock.getKey(), anchorBlock);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(focusBlock)) {\n      blockMap.set(focusBlock.getKey(), focusBlock);\n    }\n  }\n  for (const node of selection.getNodes()) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock)(node)) {\n      blockMap.set(node.getKey(), node);\n    } else if (anchorAndFocus === null) {\n      const ancestorBlock = $getAncestor(node, lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(ancestorBlock)) {\n        blockMap.set(ancestorBlock.getKey(), ancestorBlock);\n      }\n    }\n  }\n  for (const [key, prevNode] of blockMap) {\n    const element = $createElement();\n    $afterCreateElement(prevNode, element);\n    prevNode.replace(element, true);\n    if (newSelection) {\n      if (key === newSelection.anchor.key) {\n        newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);\n      }\n      if (key === newSelection.focus.key) {\n        newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);\n      }\n    }\n  }\n  if (newSelection && selection.is((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)())) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated In favor of $setBlockTypes\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$hasAncestor)(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        formatDevErrorMessage(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Tests if the selection's parent element has vertical writing mode.\n * @param selection - The selection whose parent to test.\n * @returns true if the selection's parent has vertical writing mode (writing-mode: vertical-rl), false otherwise.\n */\nfunction $isEditorVerticalOrientation(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)();\n  const domElement = editor.getElementByKey(parent.getKey());\n  if (domElement === null) {\n    return false;\n  }\n  const view = domElement.ownerDocument.defaultView;\n  if (view === null) {\n    return false;\n  }\n  const computedStyle = view.getComputedStyle(domElement);\n  return computedStyle.writingMode === 'vertical-rl';\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical writing mode, we adjust the direction for correct caret movement\n  let adjustedIsBackward = isVertical ? !isBackward : isBackward;\n\n  // In right-to-left writing mode, we invert the direction for correct caret movement\n  if ($isParentElementRTL(selection)) {\n    adjustedIsBackward = !adjustedIsBackward;\n  }\n  const focusCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, adjustedIsBackward ? 'previous' : 'next');\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isExtendableTextPointCaret)(focusCaret)) {\n    return false;\n  }\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(focusCaret)) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(nextCaret)) {\n      return !nextCaret.origin.isInline();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nextCaret.origin)) {\n      continue;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(nextCaret.origin)) {\n      return true;\n    }\n    break;\n  }\n  return false;\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical-rl writing mode, arrow key directions need to be flipped\n  // to match the visual flow of text (top to bottom, right to left)\n  let adjustedIsBackward;\n  if (isVertical) {\n    // In vertical-rl mode, we need to completely invert the direction\n    // Left arrow (backward) should move down (forward)\n    // Right arrow (forward) should move up (backward)\n    adjustedIsBackward = !isBackward;\n  } else if (isRTL) {\n    // In horizontal RTL mode, use the standard RTL behavior\n    adjustedIsBackward = !isBackward;\n  } else {\n    // Standard LTR horizontal text\n    adjustedIsBackward = isBackward;\n  }\n\n  // Apply the direction adjustment to move the caret\n  $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, 'character');\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwYjtBQUMvWDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTSxJQUFJLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDREQUFtQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2REFBb0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdURBQWM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9EQUFXO0FBQ3BCO0FBQ0E7QUFDQSwrREFBK0Qsb0RBQVc7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNEQUFhO0FBQ3RDLFlBQVksb0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4REFBcUI7QUFDbkQ7QUFDQTtBQUNBLDJCQUEyQix3REFBZTtBQUMxQztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZLDBEQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHlCQUF5Qix3REFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsc0JBQXNCO0FBQ2xHO0FBQ0E7QUFDQSxRQUFRLDBEQUFpQixrQ0FBa0Msb0RBQVcsWUFBWSx1REFBYztBQUNoRztBQUNBO0FBQ0EsMkNBQTJDLDBEQUFpQiwwQkFBMEIsb0RBQVc7QUFDakc7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLE1BQU0sMERBQWlCLFlBQVksb0RBQVc7QUFDOUM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxzQkFBc0I7QUFDbEc7QUFDQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkIsd0JBQXdCLGlFQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsb0RBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLDREQUFtQjtBQUMzQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMERBQWlCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4REFBcUI7QUFDeEM7QUFDQTtBQUNBLHVEQUF1RCxzREFBaUI7QUFDeEUscURBQXFELHNEQUFpQjtBQUN0RSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBYyxVQUFVLDBEQUFpQjtBQUNqRDtBQUNBLE1BQU07QUFDTiwrQ0FBK0Msc0RBQWlCO0FBQ2hFLFVBQVUsdURBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxzREFBYTtBQUNoRCxJQUFJLHNEQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDREQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMkRBQTJELHFEQUFZO0FBQzdFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDREQUFtQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvREFBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVEQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsTUFBTTtBQUNOLFdBQVcsdURBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU0sNERBQW1CO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwwQ0FBMEMsUUFBUTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLFVBQVUsdURBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDViwwQkFBMEIscUJBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhEQUFxQjtBQUM3QyxNQUFNLDBEQUFpQjtBQUN2QixJQUFJLHNEQUFhO0FBQ2pCLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQVc7QUFDNUIsaUJBQWlCLG1EQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdEQUFlO0FBQ3BDLE1BQU0sb0VBQTJCO0FBQ2pDO0FBQ0E7QUFDQSwwQkFBMEIsNERBQW1CO0FBQzdDLFFBQVEsc0RBQWE7QUFDckI7QUFDQSxNQUFNLFNBQVMsdURBQWM7QUFDN0I7QUFDQSxNQUFNLFNBQVMseURBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvREFBVztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7O0FBRXlkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9zZWxlY3Rpb24vTGV4aWNhbFNlbGVjdGlvbi5kZXYubWpzPzU3ODUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkaXNUZXh0Tm9kZSwgJGlzVG9rZW5PclNlZ21lbnRlZCwgJGdldENoYXJhY3Rlck9mZnNldHMsICRpc0VsZW1lbnROb2RlLCAkaXNSb290Tm9kZSwgJGdldE5vZGVCeUtleSwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkY3JlYXRlVGV4dE5vZGUsICRpc1JhbmdlU2VsZWN0aW9uLCAkZ2V0U2VsZWN0aW9uLCAkY2FyZXRSYW5nZUZyb21TZWxlY3Rpb24sICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgSU5URVJOQUxfJGlzQmxvY2ssICRzZXRTZWxlY3Rpb24sICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRoYXNBbmNlc3RvciwgJGlzTGVhZk5vZGUsICRjYXJldEZyb21Qb2ludCwgJGlzRXh0ZW5kYWJsZVRleHRQb2ludENhcmV0LCAkZXh0ZW5kQ2FyZXRUb1JhbmdlLCAkaXNDaGlsZENhcmV0LCAkaXNEZWNvcmF0b3JOb2RlLCAkZ2V0RWRpdG9yIH0gZnJvbSAnbGV4aWNhbCc7XG5leHBvcnQgeyAkY2xvbmVXaXRoUHJvcGVydGllcywgJHNlbGVjdEFsbCB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENTU19UT19TVFlMRVMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gZ2V0RE9NVGV4dE5vZGUoZWxlbWVudCkge1xuICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQobm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGhhcHBlbicpO1xuICB9XG4gIHJldHVybiBbcGFyZW50LCBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKS5pbmRleE9mKG5vZGUpXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VsZWN0aW9uIHJhbmdlIGZvciB0aGUgRE9NLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBhbmNob3JOb2RlIC0gVGhlIGFuY2hvciBub2RlIG9mIGEgc2VsZWN0aW9uLlxuICogQHBhcmFtIF9hbmNob3JPZmZzZXQgLSBUaGUgYW1vdW50IG9mIHNwYWNlIG9mZnNldCBmcm9tIHRoZSBhbmNob3IgdG8gdGhlIGZvY3VzLlxuICogQHBhcmFtIGZvY3VzTm9kZSAtIFRoZSBjdXJyZW50IGZvY3VzLlxuICogQHBhcmFtIF9mb2N1c09mZnNldCAtIFRoZSBhbW91bnQgb2Ygc3BhY2Ugb2Zmc2V0IGZyb20gdGhlIGZvY3VzIHRvIHRoZSBhbmNob3IuXG4gKiBAcmV0dXJucyBUaGUgcmFuZ2Ugb2Ygc2VsZWN0aW9uIGZvciB0aGUgRE9NIHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURPTVJhbmdlKGVkaXRvciwgYW5jaG9yTm9kZSwgX2FuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBfZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgZm9jdXNLZXkgPSBmb2N1c05vZGUuZ2V0S2V5KCk7XG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgbGV0IGFuY2hvckRPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yS2V5KTtcbiAgbGV0IGZvY3VzRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShmb2N1c0tleSk7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBfYW5jaG9yT2Zmc2V0O1xuICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG4gIGlmICgkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgIGFuY2hvckRPTSA9IGdldERPTVRleHROb2RlKGFuY2hvckRPTSk7XG4gIH1cbiAgaWYgKCRpc1RleHROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICBmb2N1c0RPTSA9IGdldERPTVRleHROb2RlKGZvY3VzRE9NKTtcbiAgfVxuICBpZiAoYW5jaG9yTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGZvY3VzTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGFuY2hvckRPTSA9PT0gbnVsbCB8fCBmb2N1c0RPTSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChhbmNob3JET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbYW5jaG9yRE9NLCBhbmNob3JPZmZzZXRdID0gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQoYW5jaG9yRE9NKTtcbiAgfVxuICBpZiAoZm9jdXNET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbZm9jdXNET00sIGZvY3VzT2Zmc2V0XSA9IGdldERPTUluZGV4V2l0aGluUGFyZW50KGZvY3VzRE9NKTtcbiAgfVxuICBjb25zdCBmaXJzdENoaWxkID0gYW5jaG9yRE9NLmZpcnN0Q2hpbGQ7XG4gIGlmIChhbmNob3JET00gPT09IGZvY3VzRE9NICYmIGZpcnN0Q2hpbGQgIT0gbnVsbCAmJiBmaXJzdENoaWxkLm5vZGVOYW1lID09PSAnQlInICYmIGFuY2hvck9mZnNldCA9PT0gMCAmJiBmb2N1c09mZnNldCA9PT0gMCkge1xuICAgIGZvY3VzT2Zmc2V0ID0gMTtcbiAgfVxuICB0cnkge1xuICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoZm9jdXNET00sIGZvY3VzT2Zmc2V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyYW5nZS5jb2xsYXBzZWQgJiYgKGFuY2hvck9mZnNldCAhPT0gZm9jdXNPZmZzZXQgfHwgYW5jaG9yS2V5ICE9PSBmb2N1c0tleSkpIHtcbiAgICAvLyBSYW5nZSBpcyBiYWNrd2FyZHMsIHdlIG5lZWQgdG8gcmV2ZXJzZSBpdFxuICAgIHJhbmdlLnNldFN0YXJ0KGZvY3VzRE9NLCBmb2N1c09mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gcmFuZ2U7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBET01SZWN0cywgZ2VuZXJhbGx5IHVzZWQgdG8gaGVscCB0aGUgZWRpdG9yIGZpbmQgYSBzcGVjaWZpYyBsb2NhdGlvbiBvbiB0aGUgc2NyZWVuLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHJhbmdlIC0gQSBmcmFnbWVudCBvZiBhIGRvY3VtZW50IHRoYXQgY2FuIGNvbnRhaW4gbm9kZXMgYW5kIHBhcnRzIG9mIHRleHQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0aW9uUmVjdHMgYXMgYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHJvb3RSZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbGVtZW50KTtcbiAgY29uc3Qgcm9vdFBhZGRpbmcgPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gIGNvbnN0IHNlbGVjdGlvblJlY3RzID0gQXJyYXkuZnJvbShyYW5nZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgbGV0IHNlbGVjdGlvblJlY3RzTGVuZ3RoID0gc2VsZWN0aW9uUmVjdHMubGVuZ3RoO1xuICAvL3NvcnQgcmVjdHMgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gcmlnaHQuXG4gIHNlbGVjdGlvblJlY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB0b3AgPSBhLnRvcCAtIGIudG9wO1xuICAgIC8vIFNvbWUgcmVjdHMgbWF0Y2ggcG9zaXRpb24gY2xvc2VseSwgYnV0IG5vdCBwZXJmZWN0bHksXG4gICAgLy8gc28gd2UgZ2l2ZSBhIDNweCB0b2xlcmFuY2UuXG4gICAgaWYgKE1hdGguYWJzKHRvcCkgPD0gMykge1xuICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIHRvcDtcbiAgfSk7XG4gIGxldCBwcmV2UmVjdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25SZWN0c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblJlY3RzW2ldO1xuICAgIC8vIEV4Y2x1ZGUgcmVjdHMgdGhhdCBvdmVybGFwIHByZWNlZGluZyBSZWN0cyBpbiB0aGUgc29ydGVkIGxpc3QuXG4gICAgY29uc3QgaXNPdmVybGFwcGluZ1JlY3QgPSBwcmV2UmVjdCAmJiBwcmV2UmVjdC50b3AgPD0gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QudG9wICsgcHJldlJlY3QuaGVpZ2h0ID4gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QubGVmdCArIHByZXZSZWN0LndpZHRoID4gc2VsZWN0aW9uUmVjdC5sZWZ0O1xuICAgIC8vIEV4Y2x1ZGUgc2VsZWN0aW9ucyB0aGF0IHNwYW4gdGhlIGVudGlyZSBlbGVtZW50XG4gICAgY29uc3Qgc2VsZWN0aW9uU3BhbnNFbGVtZW50ID0gc2VsZWN0aW9uUmVjdC53aWR0aCArIHJvb3RQYWRkaW5nID09PSByb290UmVjdC53aWR0aDtcbiAgICBpZiAoaXNPdmVybGFwcGluZ1JlY3QgfHwgc2VsZWN0aW9uU3BhbnNFbGVtZW50KSB7XG4gICAgICBzZWxlY3Rpb25SZWN0cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIHNlbGVjdGlvblJlY3RzTGVuZ3RoLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSBzZWxlY3Rpb25SZWN0O1xuICB9XG4gIHJldHVybiBzZWxlY3Rpb25SZWN0cztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMgcHJvdmlkZWQgaW4gdGhlIENTUyBzdHJpbmcuXG4gKiBAcGFyYW0gY3NzIC0gVGhlIENTUyBzdHJpbmcgb2Ygc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gKiBAcmV0dXJucyBUaGUgc3R5bGVPYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoY3NzKSB7XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0ge307XG4gIGlmICghY3NzKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG4gIGNvbnN0IHN0eWxlcyA9IGNzcy5zcGxpdCgnOycpO1xuICBmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHN0eWxlLnNwbGl0KC86KFteXSspLyk7IC8vIHNwbGl0IG9uIGZpcnN0IGNvbG9uXG4gICAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICAgIHN0eWxlT2JqZWN0W2tleS50cmltKCldID0gdmFsdWUudHJpbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBDU1Mgc3RyaW5nLCByZXR1cm5zIGFuIG9iamVjdCBmcm9tIHRoZSBzdHlsZSBjYWNoZS5cbiAqIEBwYXJhbSBjc3MgLSBUaGUgQ1NTIHByb3BlcnR5IGFzIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBDU1MgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpIHtcbiAgbGV0IHZhbHVlID0gQ1NTX1RPX1NUWUxFUy5nZXQoY3NzKTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhjc3MpO1xuICAgIENTU19UT19TVFlMRVMuc2V0KGNzcywgdmFsdWUpO1xuICB9XG4gIHtcbiAgICAvLyBGcmVlemUgdGhlIHZhbHVlIGluIERFViB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb25zXG4gICAgT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIENTUyBzdHlsZXMgZnJvbSB0aGUgc3R5bGUgb2JqZWN0LlxuICogQHBhcmFtIHN0eWxlcyAtIFRoZSBzdHlsZSBvYmplY3QgY29udGFpbmluZyB0aGUgc3R5bGVzIHRvIGdldC5cbiAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIENTUyBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KHN0eWxlcykge1xuICBsZXQgY3NzID0gJyc7XG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjc3MgKz0gYCR7c3R5bGV9OiAke3N0eWxlc1tzdHlsZV19O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiBjc3M7XG59XG5cbi8qKlxuICogR2VuZXJhbGx5IHVzZWQgdG8gYXBwZW5kIHRleHQgY29udGVudCB0byBIVE1MIGFuZCBKU09OLiBHcmFicyB0aGUgdGV4dCBjb250ZW50IGFuZCBcInNsaWNlc1wiXG4gKiBpdCB0byBiZSBnZW5lcmF0ZWQgaW50byB0aGUgbmV3IFRleHROb2RlLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gY29udGFpbmluZyB0aGUgbm9kZSB3aG9zZSBUZXh0Tm9kZSBpcyB0byBiZSBlZGl0ZWQuXG4gKiBAcGFyYW0gdGV4dE5vZGUgLSBUaGUgVGV4dE5vZGUgdG8gYmUgZWRpdGVkLlxuICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dE5vZGUuXG4gKi9cbmZ1bmN0aW9uICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgdGV4dE5vZGUpIHtcbiAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgaWYgKHRleHROb2RlLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKSAmJiAhJGlzVG9rZW5PclNlZ21lbnRlZCh0ZXh0Tm9kZSkgJiYgYW5jaG9yQW5kRm9jdXMgIT09IG51bGwpIHtcbiAgICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBhbmNob3JBbmRGb2N1cztcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNBbmNob3IgPSB0ZXh0Tm9kZS5pcyhhbmNob3JOb2RlKTtcbiAgICBjb25zdCBpc0ZvY3VzID0gdGV4dE5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICBpZiAoaXNBbmNob3IgfHwgaXNGb2N1cykge1xuICAgICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gJGdldENoYXJhY3Rlck9mZnNldHMoc2VsZWN0aW9uKTtcbiAgICAgIGNvbnN0IGlzU2FtZSA9IGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gZm9jdXNOb2RlIDogYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBpc0xhc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gYW5jaG9yTm9kZSA6IGZvY3VzTm9kZSk7XG4gICAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgbGV0IGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpc1NhbWUpIHtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBlbmRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEU6IFRoaXMgbXV0YXRlcyBfX3RleHQgZGlyZWN0bHkgYmVjYXVzZSB0aGUgcHJpbWFyeSB1c2UgY2FzZSBpcyB0b1xuICAgICAgLy8gbW9kaWZ5IGEgJGNsb25lV2l0aFByb3BlcnRpZXMgbm9kZSB0aGF0IHNob3VsZCBuZXZlciBiZSBhZGRlZFxuICAgICAgLy8gdG8gdGhlIEVkaXRvclN0YXRlIHNvIHdlIG11c3Qgbm90IGNhbGwgZ2V0V3JpdGFibGUgdmlhIHNldFRleHRDb250ZW50XG4gICAgICB0ZXh0Tm9kZS5fX3RleHQgPSB0ZXh0Tm9kZS5fX3RleHQuc2xpY2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0Tm9kZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IG9mIHRoZSBzZWxlY3Rpb24gdG8gdGVzdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBvaW50IG9mZnNldCBpcyBpbiB0aGUgbGFzdCBwb3NzaWJsZSBwb3NpdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNBdE5vZGVFbmQocG9pbnQpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IHBvaW50LmdldE5vZGUoKS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgfVxuICBjb25zdCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpc0F0Tm9kZUVuZDogbm9kZSBtdXN0IGJlIGEgVGV4dE5vZGUgb3IgRWxlbWVudE5vZGVgKTtcbiAgfVxuICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBub2RlLmdldENoaWxkcmVuU2l6ZSgpO1xufVxuXG4vKipcbiAqIFRyaW1zIHRleHQgZnJvbSBhIG5vZGUgaW4gb3JkZXIgdG8gc2hvcnRlbiBpdCwgZWcuIHRvIGVuZm9yY2UgYSB0ZXh0J3MgbWF4IGxlbmd0aC4gSWYgaXQgZGVsZXRlcyB0ZXh0XG4gKiB0aGF0IGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBhbmNob3IgdGhlbiBpdCB3aWxsIGxlYXZlIDIgaW5kZW50cywgb3RoZXJ3aXNlLCBpZiBubyB0ZXh0IGNvbnRlbnQgZXhpc3RzLCBpdCBkZWxldGVzXG4gKiB0aGUgVGV4dE5vZGUuIEl0IHdpbGwgbW92ZSB0aGUgZm9jdXMgdG8gZWl0aGVyIHRoZSBlbmQgb2YgYW55IGxlZnQgb3ZlciB0ZXh0IG9yIGJlZ2lubmluZyBvZiBhIG5ldyBUZXh0Tm9kZS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gYW5jaG9yIC0gVGhlIGFuY2hvciBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHdoZXJlIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHBvaW50aW5nLlxuICogQHBhcmFtIGRlbENvdW50IC0gVGhlIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHRvIGRlbGV0ZS4gVXNlZnVsIGFzIGEgZHluYW1pYyB2YXJpYWJsZSBlZy4gdGV4dENvbnRlbnRTaXplIC0gbWF4TGVuZ3RoO1xuICovXG5mdW5jdGlvbiAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcihlZGl0b3IsIGFuY2hvciwgZGVsQ291bnQpIHtcbiAgLy8gV29yayBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhbmNob3IgcG9pbnRcbiAgbGV0IGN1cnJlbnROb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgbGV0IHJlbWFpbmluZyA9IGRlbENvdW50O1xuICBpZiAoJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgZGVzY2VuZGFudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXREZXNjZW5kYW50QnlJbmRleChhbmNob3Iub2Zmc2V0KTtcbiAgICBpZiAoZGVzY2VuZGFudE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnROb2RlID0gZGVzY2VuZGFudE5vZGU7XG4gICAgfVxuICB9XG4gIHdoaWxlIChyZW1haW5pbmcgPiAwICYmIGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgY29uc3QgbGFzdERlc2NlbmRhbnQgPSBjdXJyZW50Tm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgaWYgKGxhc3REZXNjZW5kYW50ICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gbGFzdERlc2NlbmRhbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXh0Tm9kZSA9IGN1cnJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGxldCBhZGRpdGlvbmFsRWxlbWVudFdoaXRlc3BhY2UgPSAwO1xuICAgIGlmIChuZXh0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgd2hpbGUgKHBhcmVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IHBhcmVudC5pc0lubGluZSgpID8gMCA6IDI7XG4gICAgICAgIG5leHROb2RlID0gcGFyZW50U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRleHQgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIC8vIElmIHRoZSB0ZXh0IGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGNvbnNpZGVyIGFkZGluZyBpbiB0d28gbGluZSBicmVha3MgdG8gbWF0Y2hcbiAgICAvLyB0aGUgY29udGVudCBpZiB3ZSB3ZXJlIHRvIGdldCBpdCBmcm9tIGl0cyBwYXJlbnQuXG4gICAgaWYgKHRleHQgPT09ICcnICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgaGFuZGxlZCBpbiBjb3JlP1xuICAgICAgdGV4dCA9ICdcXG5cXG4nO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Tm9kZVNpemUgPSB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoISRpc1RleHROb2RlKGN1cnJlbnROb2RlKSB8fCByZW1haW5pbmcgPj0gY3VycmVudE5vZGVTaXplKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGN1cnJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCAmJiAhJGlzUm9vdE5vZGUocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgLT0gY3VycmVudE5vZGVTaXplICsgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlO1xuICAgICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5ID0gY3VycmVudE5vZGUuZ2V0S2V5KCk7XG4gICAgICAvLyBTZWUgaWYgd2UgY2FuIGp1c3QgcmV2ZXJ0IGl0IHRvIHdoYXQgd2FzIGluIHRoZSBsYXN0IGVkaXRvciBzdGF0ZVxuICAgICAgY29uc3QgcHJldlRleHRDb250ZW50ID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZOb2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUocHJldk5vZGUpICYmIHByZXZOb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZOb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGN1cnJlbnROb2RlU2l6ZSAtIHJlbWFpbmluZztcbiAgICAgIGNvbnN0IHNsaWNlZFRleHQgPSB0ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG4gICAgICBpZiAocHJldlRleHRDb250ZW50ICE9PSBudWxsICYmIHByZXZUZXh0Q29udGVudCAhPT0gdGV4dCkge1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHByZXZUZXh0Q29udGVudCk7XG4gICAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gdGV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE5vZGUuc2V0VGV4dENvbnRlbnQocHJldlRleHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgY29uc3QgcHJldk9mZnNldCA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICB0YXJnZXQuc2VsZWN0KHByZXZPZmZzZXQsIHByZXZPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgIC8vIFNwbGl0IHRleHRcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGFuY2hvci5rZXkgPT09IGtleTtcbiAgICAgICAgbGV0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICAgIC8vIE1vdmUgb2Zmc2V0IHRvIGVuZCBpZiBpdCdzIGxlc3MgdGhhbiB0aGUgcmVtYWluaW5nIG51bWJlciwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlJ2xsIGhhdmUgYSBuZWdhdGl2ZSBzcGxpdFN0YXJ0LlxuICAgICAgICBpZiAoYW5jaG9yT2Zmc2V0IDwgcmVtYWluaW5nKSB7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gY3VycmVudE5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwbGl0U3RhcnQgPSBpc1NlbGVjdGVkID8gYW5jaG9yT2Zmc2V0IC0gcmVtYWluaW5nIDogMDtcbiAgICAgICAgY29uc3Qgc3BsaXRFbmQgPSBpc1NlbGVjdGVkID8gYW5jaG9yT2Zmc2V0IDogb2Zmc2V0O1xuICAgICAgICBpZiAoaXNTZWxlY3RlZCAmJiBzcGxpdFN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgW2V4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IFssIGV4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShzbGljZWRUZXh0KTtcbiAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIFRleHROb2RlJ3Mgc3R5bGUgb2JqZWN0IGFuZCBhZGRzIHRoZSBzdHlsZXMgdG8gdGhlIENTUy5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIFRleHROb2RlIHRvIGFkZCBzdHlsZXMgdG8uXG4gKi9cbmZ1bmN0aW9uICRhZGROb2RlU3R5bGUobm9kZSkge1xuICBjb25zdCBDU1NUZXh0ID0gbm9kZS5nZXRTdHlsZSgpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoQ1NTVGV4dCk7XG4gIENTU19UT19TVFlMRVMuc2V0KENTU1RleHQsIHN0eWxlcyk7XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvdmlkZWQgc3R5bGVzIHRvIHRoZSBnaXZlbiBUZXh0Tm9kZSwgRWxlbWVudE5vZGUsIG9yXG4gKiBjb2xsYXBzZWQgUmFuZ2VTZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSBUZXh0Tm9kZSwgRWxlbWVudE5vZGUsIG9yIGNvbGxhcHNlZCBSYW5nZVNlbGVjdGlvbiB0byBhcHBseSB0aGUgc3R5bGVzIHRvXG4gKiBAcGFyYW0gcGF0Y2ggLSBUaGUgcGF0Y2ggdG8gYXBwbHksIHdoaWNoIGNhbiBpbmNsdWRlIG11bHRpcGxlIHN0eWxlcy4gXFxcXHtDU1NQcm9wZXJ0eTogdmFsdWVcXFxcfSAuIENhbiBhbHNvIGFjY2VwdCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiAkcGF0Y2hTdHlsZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHRhcmdldCkgPyB0YXJnZXQuaXNDb2xsYXBzZWQoKSA6ICRpc1RleHROb2RlKHRhcmdldCkgfHwgJGlzRWxlbWVudE5vZGUodGFyZ2V0KSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRwYXRjaFN0eWxlIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIFRleHROb2RlLCBFbGVtZW50Tm9kZSwgb3IgY29sbGFwc2VkIFJhbmdlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgcHJldlN0eWxlcyA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUygkaXNSYW5nZVNlbGVjdGlvbih0YXJnZXQpID8gdGFyZ2V0LnN0eWxlIDogJGlzVGV4dE5vZGUodGFyZ2V0KSA/IHRhcmdldC5nZXRTdHlsZSgpIDogdGFyZ2V0LmdldFRleHRTdHlsZSgpKTtcbiAgY29uc3QgbmV3U3R5bGVzID0gT2JqZWN0LmVudHJpZXMocGF0Y2gpLnJlZHVjZSgoc3R5bGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlKHByZXZTdHlsZXNba2V5XSwgdGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBkZWxldGUgc3R5bGVzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHtcbiAgICAuLi5wcmV2U3R5bGVzXG4gIH0pO1xuICBjb25zdCBuZXdDU1NUZXh0ID0gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KG5ld1N0eWxlcyk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbih0YXJnZXQpIHx8ICRpc1RleHROb2RlKHRhcmdldCkpIHtcbiAgICB0YXJnZXQuc2V0U3R5bGUobmV3Q1NTVGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnNldFRleHRTdHlsZShuZXdDU1NUZXh0KTtcbiAgfVxuICBDU1NfVE9fU1RZTEVTLnNldChuZXdDU1NUZXh0LCBuZXdTdHlsZXMpO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIHN0eWxlcyB0byB0aGUgVGV4dE5vZGVzIGluIHRoZSBwcm92aWRlZCBTZWxlY3Rpb24uXG4gKiBXaWxsIHVwZGF0ZSBwYXJ0aWFsbHkgc2VsZWN0ZWQgVGV4dE5vZGVzIGJ5IHNwbGl0dGluZyB0aGUgVGV4dE5vZGUgYW5kIGFwcGx5aW5nXG4gKiB0aGUgc3R5bGVzIHRvIHRoZSBhcHByb3ByaWF0ZSBvbmUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIG5vZGUocykgdG8gdXBkYXRlLlxuICogQHBhcmFtIHBhdGNoIC0gVGhlIHBhdGNoIHRvIGFwcGx5LCB3aGljaCBjYW4gaW5jbHVkZSBtdWx0aXBsZSBzdHlsZXMuIFxcXFx7Q1NTUHJvcGVydHk6IHZhbHVlXFxcXH0gLiBDYW4gYWxzbyBhY2NlcHQgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gJHBhdGNoU3R5bGVUZXh0KHNlbGVjdGlvbiwgcGF0Y2gpIHtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAkcGF0Y2hTdHlsZShzZWxlY3Rpb24sIHBhdGNoKTtcbiAgICBjb25zdCBlbXB0eU5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZW1wdHlOb2RlKSAmJiBlbXB0eU5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAkcGF0Y2hTdHlsZShlbXB0eU5vZGUsIHBhdGNoKTtcbiAgICB9XG4gIH1cbiAgJGZvckVhY2hTZWxlY3RlZFRleHROb2RlKHRleHROb2RlID0+IHtcbiAgICAkcGF0Y2hTdHlsZSh0ZXh0Tm9kZSwgcGF0Y2gpO1xuICB9KTtcbn1cbmZ1bmN0aW9uICRmb3JFYWNoU2VsZWN0ZWRUZXh0Tm9kZShmbikge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNsaWNlZFRleHROb2RlcyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZ2V0U2xpY2VJbmRpY2VzID0gbm9kZSA9PiBzbGljZWRUZXh0Tm9kZXMuZ2V0KG5vZGUuZ2V0S2V5KCkpIHx8IFswLCBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpXTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBmb3IgKGNvbnN0IHNsaWNlIG9mICRjYXJldFJhbmdlRnJvbVNlbGVjdGlvbihzZWxlY3Rpb24pLmdldFRleHRTbGljZXMoKSkge1xuICAgICAgaWYgKHNsaWNlKSB7XG4gICAgICAgIHNsaWNlZFRleHROb2Rlcy5zZXQoc2xpY2UuY2FyZXQub3JpZ2luLmdldEtleSgpLCBzbGljZS5nZXRTbGljZUluZGljZXMoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgZm9yIChjb25zdCBzZWxlY3RlZE5vZGUgb2Ygc2VsZWN0ZWROb2Rlcykge1xuICAgIGlmICghKCRpc1RleHROb2RlKHNlbGVjdGVkTm9kZSkgJiYgc2VsZWN0ZWROb2RlLmNhbkhhdmVGb3JtYXQoKSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBbc3RhcnRPZmZzZXQsIGVuZE9mZnNldF0gPSBnZXRTbGljZUluZGljZXMoc2VsZWN0ZWROb2RlKTtcbiAgICAvLyBObyBhY3R1YWwgdGV4dCBpcyBzZWxlY3RlZCwgc28gZG8gbm90aGluZy5cbiAgICBpZiAoZW5kT2Zmc2V0ID09PSBzdGFydE9mZnNldCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gVGhlIGVudGlyZSBub2RlIGlzIHNlbGVjdGVkIG9yIGEgdG9rZW4vc2VnbWVudCwgc28ganVzdCBmb3JtYXQgaXRcbiAgICBpZiAoJGlzVG9rZW5PclNlZ21lbnRlZChzZWxlY3RlZE5vZGUpIHx8IHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCA9PT0gc2VsZWN0ZWROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBmbihzZWxlY3RlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0IGludG8gdHdvIG9yIHRocmVlIG5vZGVzXG4gICAgICAvLyBhbmQgc3R5bGUgdGhlIHNlbGVjdGVkIG9uZS5cbiAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBzZWxlY3RlZE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzcGxpdE5vZGVzW3N0YXJ0T2Zmc2V0ID09PSAwID8gMCA6IDFdO1xuICAgICAgZm4ocmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuICAvLyBQcmlvciB0byBOb2RlQ2FyZXQgIzcwNDYgdGhpcyB3b3VsZCBoYXZlIGJlZW4gYSBzaWRlLWVmZmVjdFxuICAvLyBzbyB3ZSBkbyB0aGlzIGZvciB0ZXN0IGNvbXBhdGliaWxpdHkuXG4gIC8vIFRPRE86IHdlIG1heSB3YW50IHRvIGNvbnNpZGVyIHNpbXBsaWZ5aW5nIGJ5IHJlbW92aW5nIHRoaXNcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAndGV4dCcgJiYgc2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICd0ZXh0JyAmJiBzZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gc2VsZWN0aW9uLmZvY3VzLmtleSkge1xuICAgICRlbnN1cmVGb3J3YXJkUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBnaXZlbiBSYW5nZVNlbGVjdGlvbiBpcyBub3QgYmFja3dhcmRzLiBJZiBpdFxuICogaXMgYmFja3dhcmRzLCB0aGVuIHRoZSBhbmNob3IgYW5kIGZvY3VzIHBvaW50cyB3aWxsIGJlIHN3YXBwZWRcbiAqIGluLXBsYWNlLiBFbnN1cmluZyB0aGF0IHRoZSBzZWxlY3Rpb24gaXMgYSB3cml0YWJsZSBSYW5nZVNlbGVjdGlvblxuICogaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsZXIgKGUuZy4gaW4gYSByZWFkLW9ubHkgY29udGV4dFxuICogeW91IHdpbGwgd2FudCB0byBjbG9uZSAkZ2V0U2VsZWN0aW9uKCkgYmVmb3JlIHVzaW5nIHRoaXMpLlxuICpcbiAqIEBwYXJhbSBzZWxlY3Rpb24gYSB3cml0YWJsZSBSYW5nZVNlbGVjdGlvblxuICovXG5mdW5jdGlvbiAkZW5zdXJlRm9yd2FyZFJhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICBpZiAoc2VsZWN0aW9uLmlzQmFja3dhcmQoKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICAvLyBzdGFzaCBmb3IgdGhlIGluLXBsYWNlIHN3YXBcbiAgICBjb25zdCB7XG4gICAgICBrZXksXG4gICAgICBvZmZzZXQsXG4gICAgICB0eXBlXG4gICAgfSA9IGFuY2hvcjtcbiAgICBhbmNob3Iuc2V0KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKTtcbiAgICBmb2N1cy5zZXQoa2V5LCBvZmZzZXQsIHR5cGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uICRjb3B5QmxvY2tGb3JtYXRJbmRlbnQoc3JjTm9kZSwgZGVzdE5vZGUpIHtcbiAgY29uc3QgZm9ybWF0ID0gc3JjTm9kZS5nZXRGb3JtYXRUeXBlKCk7XG4gIGNvbnN0IGluZGVudCA9IHNyY05vZGUuZ2V0SW5kZW50KCk7XG4gIGlmIChmb3JtYXQgIT09IGRlc3ROb2RlLmdldEZvcm1hdFR5cGUoKSkge1xuICAgIGRlc3ROb2RlLnNldEZvcm1hdChmb3JtYXQpO1xuICB9XG4gIGlmIChpbmRlbnQgIT09IGRlc3ROb2RlLmdldEluZGVudCgpKSB7XG4gICAgZGVzdE5vZGUuc2V0SW5kZW50KGluZGVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbiB0aGF0IGFyZSBvZiBvbmUgYmxvY2sgdHlwZSB0byBhbm90aGVyLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCBibG9ja3MgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtICRjcmVhdGVFbGVtZW50IC0gVGhlIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgbm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtICRhZnRlckNyZWF0ZUVsZW1lbnQgLSBUaGUgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHRoZSBuZXcgbm9kZSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgb25lICgkY29weUJsb2NrRm9ybWF0SW5kZW50IGJ5IGRlZmF1bHQpXG4gKi9cbmZ1bmN0aW9uICRzZXRCbG9ja3NUeXBlKHNlbGVjdGlvbiwgJGNyZWF0ZUVsZW1lbnQsICRhZnRlckNyZWF0ZUVsZW1lbnQgPSAkY29weUJsb2NrRm9ybWF0SW5kZW50KSB7XG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2VsZWN0aW9ucyB0ZW5kIHRvIG5vdCBpbmNsdWRlIHRoZWlyIGNvbnRhaW5pbmcgYmxvY2tzIHNvIHdlIGVmZmVjdGl2ZWx5XG4gIC8vIGV4cGFuZCBpdCBoZXJlXG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGNvbnN0IGJsb2NrTWFwID0gbmV3IE1hcCgpO1xuICBsZXQgbmV3U2VsZWN0aW9uID0gbnVsbDtcbiAgaWYgKGFuY2hvckFuZEZvY3VzKSB7XG4gICAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgbmV3U2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQoYW5jaG9yLmtleSwgYW5jaG9yLm9mZnNldCwgYW5jaG9yLnR5cGUpO1xuICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoZm9jdXMua2V5LCBmb2N1cy5vZmZzZXQsIGZvY3VzLnR5cGUpO1xuICAgIGNvbnN0IGFuY2hvckJsb2NrID0gJGdldEFuY2VzdG9yKGFuY2hvci5nZXROb2RlKCksIElOVEVSTkFMXyRpc0Jsb2NrKTtcbiAgICBjb25zdCBmb2N1c0Jsb2NrID0gJGdldEFuY2VzdG9yKGZvY3VzLmdldE5vZGUoKSwgSU5URVJOQUxfJGlzQmxvY2spO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShhbmNob3JCbG9jaykpIHtcbiAgICAgIGJsb2NrTWFwLnNldChhbmNob3JCbG9jay5nZXRLZXkoKSwgYW5jaG9yQmxvY2spO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZm9jdXNCbG9jaykpIHtcbiAgICAgIGJsb2NrTWFwLnNldChmb2N1c0Jsb2NrLmdldEtleSgpLCBmb2N1c0Jsb2NrKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5nZXROb2RlcygpKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIElOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpKSB7XG4gICAgICBibG9ja01hcC5zZXQobm9kZS5nZXRLZXkoKSwgbm9kZSk7XG4gICAgfSBlbHNlIGlmIChhbmNob3JBbmRGb2N1cyA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5jZXN0b3JCbG9jayA9ICRnZXRBbmNlc3Rvcihub2RlLCBJTlRFUk5BTF8kaXNCbG9jayk7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoYW5jZXN0b3JCbG9jaykpIHtcbiAgICAgICAgYmxvY2tNYXAuc2V0KGFuY2VzdG9yQmxvY2suZ2V0S2V5KCksIGFuY2VzdG9yQmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHByZXZOb2RlXSBvZiBibG9ja01hcCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSAkY3JlYXRlRWxlbWVudCgpO1xuICAgICRhZnRlckNyZWF0ZUVsZW1lbnQocHJldk5vZGUsIGVsZW1lbnQpO1xuICAgIHByZXZOb2RlLnJlcGxhY2UoZWxlbWVudCwgdHJ1ZSk7XG4gICAgaWYgKG5ld1NlbGVjdGlvbikge1xuICAgICAgaWYgKGtleSA9PT0gbmV3U2VsZWN0aW9uLmFuY2hvci5rZXkpIHtcbiAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQoZWxlbWVudC5nZXRLZXkoKSwgbmV3U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQsIG5ld1NlbGVjdGlvbi5hbmNob3IudHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBuZXdTZWxlY3Rpb24uZm9jdXMua2V5KSB7XG4gICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoZWxlbWVudC5nZXRLZXkoKSwgbmV3U2VsZWN0aW9uLmZvY3VzLm9mZnNldCwgbmV3U2VsZWN0aW9uLmZvY3VzLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmV3U2VsZWN0aW9uICYmIHNlbGVjdGlvbi5pcygkZ2V0U2VsZWN0aW9uKCkpKSB7XG4gICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICB9XG59XG5mdW5jdGlvbiBpc1BvaW50QXR0YWNoZWQocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50LmdldE5vZGUoKS5pc0F0dGFjaGVkKCk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlUGFyZW50RW1wdHlFbGVtZW50cyhzdGFydGluZ05vZGUpIHtcbiAgbGV0IG5vZGUgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChub2RlICE9PSBudWxsICYmICEkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgY29uc3QgbGF0ZXN0ID0gbm9kZS5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAobGF0ZXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBub2RlLnJlbW92ZSh0cnVlKTtcbiAgICB9XG4gICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBJbiBmYXZvciBvZiAkc2V0QmxvY2tUeXBlc1xuICogV3JhcHMgYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gaW50byBhbm90aGVyIG5vZGUgb2YgdGhlIHR5cGUgcmV0dXJuZWQgYnkgY3JlYXRlRWxlbWVudC5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIG5vZGVzIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBhbmQgaXRzIGNoaWxkcmVuIHRvLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBjb25zdCBhbmNob3IgPSBhbmNob3JBbmRGb2N1cyA/IGFuY2hvckFuZEZvY3VzWzBdIDogbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3Qgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gIGlmIChhbmNob3IgIT09IG51bGwgJiYgKG5vZGVzTGVuZ3RoID09PSAwIHx8IG5vZGVzTGVuZ3RoID09PSAxICYmIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmdldE5vZGUoKS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKS5nZXRQYXJlbnRPclRocm93KCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmdldENoaWxkcmVuKCk7XG4gICAgbGV0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgZWxlbWVudC5zZXRGb3JtYXQodGFyZ2V0LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgZWxlbWVudC5zZXRJbmRlbnQodGFyZ2V0LmdldEluZGVudCgpKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGVsZW1lbnQuYXBwZW5kKGNoaWxkKSk7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICAgIHRhcmdldC5yZXBsYWNlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgdG9wTGV2ZWxOb2RlID0gbnVsbDtcbiAgbGV0IGRlc2NlbmRhbnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB3cmFwcGluZyBoYXMgdG8gYmUgYnJva2VuIGRvd24gaW50byBtdWx0aXBsZSBjaHVua3MuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGVcbiAgICAvLyB1c2VyIHNlbGVjdGVkIG11bHRpcGxlIFJvb3QtbGlrZSBub2RlcyB0aGF0IGhhdmUgdG8gYmUgdHJlYXRlZCBzZXBhcmF0ZWx5IGFzIGlmIHRoZXkgYXJlXG4gICAgLy8gdGhlaXIgb3duIGJyYW5jaC4gSS5lLiB5b3UgZG9uJ3Qgd2FudCB0byB3cmFwIGEgd2hvbGUgdGFibGUsIGJ1dCByYXRoZXIgdGhlIGNvbnRlbnRzIG9mIGVhY2hcbiAgICAvLyBvZiBlYWNoIG9mIHRoZSBjZWxsIG5vZGVzLlxuICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgdG9wTGV2ZWxOb2RlID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKHRvcExldmVsTm9kZSA9PT0gbnVsbCB8fCB0b3BMZXZlbE5vZGUgIT09IG51bGwgJiYgJGhhc0FuY2VzdG9yKG5vZGUsIHRvcExldmVsTm9kZSkpIHtcbiAgICAgIGRlc2NlbmRhbnRzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW25vZGVdO1xuICAgIH1cbiAgfVxuICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG59XG5cbi8qKlxuICogV3JhcHMgZWFjaCBub2RlIGludG8gYSBuZXcgRWxlbWVudE5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBub2RlcyB0byB3cmFwLlxuICogQHBhcmFtIG5vZGVzIC0gQW4gYXJyYXkgb2Ygbm9kZXMsIGdlbmVyYWxseSB0aGUgZGVzY2VuZGFudHMgb2YgdGhlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBub2Rlc0xlbmd0aCAtIFRoZSBsZW5ndGggb2Ygbm9kZXMuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gd3JhcCBhbGwgdGhlIG5vZGVzIGludG8uXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIG5vZGVzLCBub2Rlc0xlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZpcnN0Tm9kZSA9IG5vZGVzWzBdO1xuICBjb25zdCBlbGVtZW50TWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgLy8gVGhlIGJlbG93IGxvZ2ljIGlzIHRvIGZpbmQgdGhlIHJpZ2h0IHRhcmdldCBmb3IgdXMgdG9cbiAgLy8gZWl0aGVyIGluc2VydEFmdGVyL2luc2VydEJlZm9yZS9hcHBlbmQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgLy8gZWxlbWVudHMgdG8uIFRoaXMgaXMgbWFkZSBtb3JlIGNvbXBsaWNhdGVkIGR1ZSB0byBuZXN0ZWRcbiAgLy8gc3RydWN0dXJlcy5cbiAgbGV0IHRhcmdldCA9ICRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgPyBmaXJzdE5vZGUgOiBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICBpZiAodGFyZ2V0LmlzSW5saW5lKCkpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIGxldCB0YXJnZXRJc1ByZXZTaWJsaW5nID0gZmFsc2U7XG4gIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRhcmdldC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHRhcmdldCA9IHByZXZTaWJsaW5nO1xuICAgICAgdGFyZ2V0SXNQcmV2U2libGluZyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgZW1wdHlFbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuICAvLyBGaW5kIGFueSB0b3AgbGV2ZWwgZW1wdHkgZWxlbWVudHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBlbXB0eUVsZW1lbnRzLmFkZChub2RlLmdldEtleSgpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbW92ZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAvLyBNb3ZlIG91dCBhbGwgbGVhZiBub2RlcyBpbnRvIG91ciBlbGVtZW50cyBhcnJheS5cbiAgLy8gSWYgd2UgZmluZCBhIHRvcCBsZXZlbCBlbXB0eSBlbGVtZW50LCBhbHNvIG1vdmUgbWFrZVxuICAvLyBhbiBlbGVtZW50IGZvciB0aGF0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuaXNJbmxpbmUoKSkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cbiAgICBpZiAocGFyZW50ICE9PSBudWxsICYmICRpc0xlYWZOb2RlKG5vZGUpICYmICFtb3ZlZE5vZGVzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuICAgICAgaWYgKGVsZW1lbnRNYXBwaW5nLmdldChwYXJlbnRLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQocGFyZW50LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KHBhcmVudC5nZXRJbmRlbnQoKSk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnRNYXBwaW5nLnNldChwYXJlbnRLZXksIHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAvLyBNb3ZlIG5vZGUgYW5kIGl0cyBzaWJsaW5ncyB0byB0aGUgbmV3XG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHBhcmVudC5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICBtb3ZlZE5vZGVzLmFkZChjaGlsZC5nZXRLZXkoKSk7XG4gICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgLy8gU2tpcCBuZXN0ZWQgbGVhZiBub2RlcyBpZiB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gbW92ZWRcbiAgICAgICAgICAgIGNoaWxkLmdldENoaWxkcmVuS2V5cygpLmZvckVhY2goa2V5ID0+IG1vdmVkTm9kZXMuYWRkKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbXB0eUVsZW1lbnRzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgaW4gZW1wdHlFbGVtZW50cyB0byBiZSBhbiBFbGVtZW50Tm9kZWApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KG5vZGUuZ2V0SW5kZW50KCkpO1xuICAgICAgZWxlbWVudHMucHVzaCh0YXJnZXRFbGVtZW50KTtcbiAgICAgIG5vZGUucmVtb3ZlKHRydWUpO1xuICAgIH1cbiAgfVxuICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgd3JhcHBpbmdFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgbGV0IGxhc3RFbGVtZW50ID0gbnVsbDtcblxuICAvLyBJZiBvdXIgdGFyZ2V0IGlzIFJvb3QtbGlrZSwgbGV0J3Mgc2VlIGlmIHdlIGNhbiByZS1hZGp1c3RcbiAgLy8gc28gdGhhdCB0aGUgdGFyZ2V0IGlzIHRoZSBmaXJzdCBjaGlsZCBpbnN0ZWFkLlxuICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgaWYgKHRhcmdldElzUHJldlNpYmxpbmcpIHtcbiAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIHRhcmdldCA9IGZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZCh3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHRhcmdldC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShlbGVtZW50KTtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcihlbGVtZW50KTtcbiAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBpc1BvaW50QXR0YWNoZWQocHJldlNlbGVjdGlvbi5hbmNob3IpICYmIGlzUG9pbnRBdHRhY2hlZChwcmV2U2VsZWN0aW9uLmZvY3VzKSkge1xuICAgICRzZXRTZWxlY3Rpb24ocHJldlNlbGVjdGlvbi5jbG9uZSgpKTtcbiAgfSBlbHNlIGlmIChsYXN0RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGxhc3RFbGVtZW50LnNlbGVjdEVuZCgpO1xuICB9IGVsc2Uge1xuICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc2VsZWN0aW9uJ3MgcGFyZW50IGVsZW1lbnQgaGFzIHZlcnRpY2FsIHdyaXRpbmcgbW9kZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIHBhcmVudCB0byB0ZXN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9uJ3MgcGFyZW50IGhhcyB2ZXJ0aWNhbCB3cml0aW5nIG1vZGUgKHdyaXRpbmctbW9kZTogdmVydGljYWwtcmwpLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0VkaXRvclZlcnRpY2FsT3JpZW50YXRpb24oc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgcGFyZW50ID0gJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkgPyBhbmNob3JOb2RlIDogYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIGNvbnN0IGVkaXRvciA9ICRnZXRFZGl0b3IoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkocGFyZW50LmdldEtleSgpKTtcbiAgaWYgKGRvbUVsZW1lbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdmlldyA9IGRvbUVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgaWYgKHZpZXcgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KTtcbiAgcmV0dXJuIGNvbXB1dGVkU3R5bGUud3JpdGluZ01vZGUgPT09ICd2ZXJ0aWNhbC1ybCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgc2VsZWN0aW9uIHNob3VsZCBiZSBvdmVycmlkZGVuLiBVc2VkIHdpdGggRGVjb3JhdG9yTm9kZXNcbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIGRlZmF1bHQgY2hhcmFjdGVyIHNlbGVjdGlvbiBtYXkgbmVlZCB0byBiZSBvdmVycmlkZGVuLlxuICogQHBhcmFtIGlzQmFja3dhcmQgLSBJcyB0aGUgc2VsZWN0aW9uIGJhY2t3YXJkcyAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqIEByZXR1cm5zIHRydWUgaWYgaXQgc2hvdWxkIGJlIG92ZXJyaWRkZW4sIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbihzZWxlY3Rpb24sIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9ICRpc0VkaXRvclZlcnRpY2FsT3JpZW50YXRpb24oc2VsZWN0aW9uKTtcblxuICAvLyBJbiB2ZXJ0aWNhbCB3cml0aW5nIG1vZGUsIHdlIGFkanVzdCB0aGUgZGlyZWN0aW9uIGZvciBjb3JyZWN0IGNhcmV0IG1vdmVtZW50XG4gIGxldCBhZGp1c3RlZElzQmFja3dhcmQgPSBpc1ZlcnRpY2FsID8gIWlzQmFja3dhcmQgOiBpc0JhY2t3YXJkO1xuXG4gIC8vIEluIHJpZ2h0LXRvLWxlZnQgd3JpdGluZyBtb2RlLCB3ZSBpbnZlcnQgdGhlIGRpcmVjdGlvbiBmb3IgY29ycmVjdCBjYXJldCBtb3ZlbWVudFxuICBpZiAoJGlzUGFyZW50RWxlbWVudFJUTChzZWxlY3Rpb24pKSB7XG4gICAgYWRqdXN0ZWRJc0JhY2t3YXJkID0gIWFkanVzdGVkSXNCYWNrd2FyZDtcbiAgfVxuICBjb25zdCBmb2N1c0NhcmV0ID0gJGNhcmV0RnJvbVBvaW50KHNlbGVjdGlvbi5mb2N1cywgYWRqdXN0ZWRJc0JhY2t3YXJkID8gJ3ByZXZpb3VzJyA6ICduZXh0Jyk7XG4gIGlmICgkaXNFeHRlbmRhYmxlVGV4dFBvaW50Q2FyZXQoZm9jdXNDYXJldCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBuZXh0Q2FyZXQgb2YgJGV4dGVuZENhcmV0VG9SYW5nZShmb2N1c0NhcmV0KSkge1xuICAgIGlmICgkaXNDaGlsZENhcmV0KG5leHRDYXJldCkpIHtcbiAgICAgIHJldHVybiAhbmV4dENhcmV0Lm9yaWdpbi5pc0lubGluZSgpO1xuICAgIH0gZWxzZSBpZiAoJGlzRWxlbWVudE5vZGUobmV4dENhcmV0Lm9yaWdpbikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoJGlzRGVjb3JhdG9yTm9kZShuZXh0Q2FyZXQub3JpZ2luKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBNb3ZlcyB0aGUgc2VsZWN0aW9uIGFjY29yZGluZyB0byB0aGUgYXJndW1lbnRzLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCB0ZXh0IG9yIG5vZGVzLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gc2VsZWN0ZWQgYmFja3dhcmRzICh0aGUgZm9jdXMgY29tZXMgYmVmb3JlIHRoZSBhbmNob3IpP1xuICogQHBhcmFtIGdyYW51bGFyaXR5IC0gVGhlIGRpc3RhbmNlIHRvIGFkanVzdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpIHtcbiAgc2VsZWN0aW9uLm1vZGlmeShpc0hvbGRpbmdTaGlmdCA/ICdleHRlbmQnIDogJ21vdmUnLCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSk7XG59XG5cbi8qKlxuICogVGVzdHMgYSBwYXJlbnQgZWxlbWVudCBmb3IgcmlnaHQgdG8gbGVmdCBkaXJlY3Rpb24uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBwYXJlbnQgaXMgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9ucycgcGFyZW50IGVsZW1lbnQgaGFzIGEgZGlyZWN0aW9uIG9mICdydGwnIChyaWdodCB0byBsZWZ0KSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IHBhcmVudCA9ICRpc1Jvb3ROb2RlKGFuY2hvck5vZGUpID8gYW5jaG9yTm9kZSA6IGFuY2hvck5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICByZXR1cm4gcGFyZW50LmdldERpcmVjdGlvbigpID09PSAncnRsJztcbn1cblxuLyoqXG4gKiBNb3ZlcyBzZWxlY3Rpb24gYnkgY2hhcmFjdGVyIGFjY29yZGluZyB0byBhcmd1bWVudHMuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiB0aGUgY2hhcmFjdGVycyB0byBtb3ZlLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gYmFja3dhcmQgKHRoZSBmb2N1cyBjb21lcyBiZWZvcmUgdGhlIGFuY2hvcik/XG4gKi9cbmZ1bmN0aW9uICRtb3ZlQ2hhcmFjdGVyKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgaXNSVEwgPSAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbik7XG4gIGNvbnN0IGlzVmVydGljYWwgPSAkaXNFZGl0b3JWZXJ0aWNhbE9yaWVudGF0aW9uKHNlbGVjdGlvbik7XG5cbiAgLy8gSW4gdmVydGljYWwtcmwgd3JpdGluZyBtb2RlLCBhcnJvdyBrZXkgZGlyZWN0aW9ucyBuZWVkIHRvIGJlIGZsaXBwZWRcbiAgLy8gdG8gbWF0Y2ggdGhlIHZpc3VhbCBmbG93IG9mIHRleHQgKHRvcCB0byBib3R0b20sIHJpZ2h0IHRvIGxlZnQpXG4gIGxldCBhZGp1c3RlZElzQmFja3dhcmQ7XG4gIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgLy8gSW4gdmVydGljYWwtcmwgbW9kZSwgd2UgbmVlZCB0byBjb21wbGV0ZWx5IGludmVydCB0aGUgZGlyZWN0aW9uXG4gICAgLy8gTGVmdCBhcnJvdyAoYmFja3dhcmQpIHNob3VsZCBtb3ZlIGRvd24gKGZvcndhcmQpXG4gICAgLy8gUmlnaHQgYXJyb3cgKGZvcndhcmQpIHNob3VsZCBtb3ZlIHVwIChiYWNrd2FyZClcbiAgICBhZGp1c3RlZElzQmFja3dhcmQgPSAhaXNCYWNrd2FyZDtcbiAgfSBlbHNlIGlmIChpc1JUTCkge1xuICAgIC8vIEluIGhvcml6b250YWwgUlRMIG1vZGUsIHVzZSB0aGUgc3RhbmRhcmQgUlRMIGJlaGF2aW9yXG4gICAgYWRqdXN0ZWRJc0JhY2t3YXJkID0gIWlzQmFja3dhcmQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RhbmRhcmQgTFRSIGhvcml6b250YWwgdGV4dFxuICAgIGFkanVzdGVkSXNCYWNrd2FyZCA9IGlzQmFja3dhcmQ7XG4gIH1cblxuICAvLyBBcHBseSB0aGUgZGlyZWN0aW9uIGFkanVzdG1lbnQgdG8gbW92ZSB0aGUgY2FyZXRcbiAgJG1vdmVDYXJldFNlbGVjdGlvbihzZWxlY3Rpb24sIGlzSG9sZGluZ1NoaWZ0LCBhZGp1c3RlZElzQmFja3dhcmQsICdjaGFyYWN0ZXInKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlIG9mIGEgQ1NTIHByb3BlcnR5IGZvciBOb2RlcywgaWYgc2V0LiBJZiBub3Qgc2V0LCBpdCByZXR1cm5zIHRoZSBkZWZhdWx0VmFsdWUuXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBub2RlIHdob3NlIHN0eWxlIHZhbHVlIHRvIGdldC5cbiAqIEBwYXJhbSBzdHlsZVByb3BlcnR5IC0gVGhlIENTUyBzdHlsZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBmb3Igbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGdldE5vZGVTdHlsZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKSB7XG4gIGNvbnN0IGNzcyA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgY29uc3Qgc3R5bGVPYmplY3QgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKTtcbiAgaWYgKHN0eWxlT2JqZWN0ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0W3N0eWxlUHJvcGVydHldIHx8IGRlZmF1bHRWYWx1ZTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBDU1MgcHJvcGVydHkgZm9yIFRleHROb2RlcyBpbiB0aGUgU2VsZWN0aW9uLCBpZiBzZXQuIElmIG5vdCBzZXQsIGl0IHJldHVybnMgdGhlIGRlZmF1bHRWYWx1ZS5cbiAqIElmIGFsbCBUZXh0Tm9kZXMgZG8gbm90IGhhdmUgdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gb2YgVGV4dE5vZGVzIHdob3NlIHZhbHVlIHRvIGZpbmQuXG4gKiBAcGFyYW0gc3R5bGVQcm9wZXJ0eSAtIFRoZSBDU1Mgc3R5bGUgcHJvcGVydHkuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIC0gVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBwcm9wZXJ0eSwgZGVmYXVsdHMgdG8gYW4gZW1wdHkgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSBmb3IgdGhlIHNlbGVjdGVkIFRleHROb2Rlcy5cbiAqL1xuZnVuY3Rpb24gJGdldFNlbGVjdGlvblN0eWxlVmFsdWVGb3JQcm9wZXJ0eShzZWxlY3Rpb24sIHN0eWxlUHJvcGVydHksIGRlZmF1bHRWYWx1ZSA9ICcnKSB7XG4gIGxldCBzdHlsZVZhbHVlID0gbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICBjb25zdCBlbmRPZmZzZXQgPSBpc0JhY2t3YXJkID8gZm9jdXMub2Zmc2V0IDogYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZW5kTm9kZSA9IGlzQmFja3dhcmQgPyBmb2N1cy5nZXROb2RlKCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiBzZWxlY3Rpb24uc3R5bGUgIT09ICcnKSB7XG4gICAgY29uc3QgY3NzID0gc2VsZWN0aW9uLnN0eWxlO1xuICAgIGNvbnN0IHN0eWxlT2JqZWN0ID0gZ2V0U3R5bGVPYmplY3RGcm9tQ1NTKGNzcyk7XG4gICAgaWYgKHN0eWxlT2JqZWN0ICE9PSBudWxsICYmIHN0eWxlUHJvcGVydHkgaW4gc3R5bGVPYmplY3QpIHtcbiAgICAgIHJldHVybiBzdHlsZU9iamVjdFtzdHlsZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcblxuICAgIC8vIGlmIG5vIGFjdHVhbCBjaGFyYWN0ZXJzIGluIHRoZSBlbmQgbm9kZSBhcmUgc2VsZWN0ZWQsIHdlIGRvbid0XG4gICAgLy8gaW5jbHVkZSBpdCBpbiB0aGUgc2VsZWN0aW9uIGZvciBwdXJwb3NlcyBvZiBkZXRlcm1pbmluZyBzdHlsZVxuICAgIC8vIHZhbHVlXG4gICAgaWYgKGkgIT09IDAgJiYgZW5kT2Zmc2V0ID09PSAwICYmIG5vZGUuaXMoZW5kTm9kZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IG5vZGVTdHlsZVZhbHVlID0gJGdldE5vZGVTdHlsZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgIGlmIChzdHlsZVZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHN0eWxlVmFsdWUgPSBub2RlU3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoc3R5bGVWYWx1ZSAhPT0gbm9kZVN0eWxlVmFsdWUpIHtcbiAgICAgICAgLy8gbXVsdGlwbGUgdGV4dCBub2RlcyBhcmUgaW4gdGhlIHNlbGVjdGlvbiBhbmQgdGhleSBkb24ndCBhbGxcbiAgICAgICAgLy8gaGF2ZSB0aGUgc2FtZSBzdHlsZS5cbiAgICAgICAgc3R5bGVWYWx1ZSA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlVmFsdWUgPT09IG51bGwgPyBkZWZhdWx0VmFsdWUgOiBzdHlsZVZhbHVlO1xufVxuZnVuY3Rpb24gJGdldEFuY2VzdG9yKG5vZGUsIHByZWRpY2F0ZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuZ2V0UGFyZW50KCkgIT09IG51bGwgJiYgIXByZWRpY2F0ZShwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICByZXR1cm4gcHJlZGljYXRlKHBhcmVudCkgPyBwYXJlbnQgOiBudWxsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIHtAbGluayAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcn0gYnkgQGxleGljYWwvZXNsaW50LXBsdWdpbiBydWxlcy1vZi1sZXhpY2FsICovXG5jb25zdCB0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yID0gJHRyaW1UZXh0Q29udGVudEZyb21BbmNob3I7XG5cbmV4cG9ydCB7ICRhZGROb2RlU3R5bGUsICRjb3B5QmxvY2tGb3JtYXRJbmRlbnQsICRlbnN1cmVGb3J3YXJkUmFuZ2VTZWxlY3Rpb24sICRmb3JFYWNoU2VsZWN0ZWRUZXh0Tm9kZSwgJGdldFNlbGVjdGlvblN0eWxlVmFsdWVGb3JQcm9wZXJ0eSwgJGlzQXROb2RlRW5kLCAkaXNQYXJlbnRFbGVtZW50UlRMLCAkbW92ZUNhcmV0U2VsZWN0aW9uLCAkbW92ZUNoYXJhY3RlciwgJHBhdGNoU3R5bGVUZXh0LCAkc2V0QmxvY2tzVHlwZSwgJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbiwgJHNsaWNlU2VsZWN0ZWRUZXh0Tm9kZUNvbnRlbnQsICR0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yLCAkd3JhcE5vZGVzLCBjcmVhdGVET01SYW5nZSwgY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UsIGdldENTU0Zyb21TdHlsZU9iamVjdCwgZ2V0U3R5bGVPYmplY3RGcm9tQ1NTLCB0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lexical/selection/LexicalSelection.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/table/LexicalTable.dev.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/table/LexicalTable.dev.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $computeTableMap: function() { return /* binding */ $computeTableMap; },\n/* harmony export */   $computeTableMapSkipCellCheck: function() { return /* binding */ $computeTableMapSkipCellCheck; },\n/* harmony export */   $createTableCellNode: function() { return /* binding */ $createTableCellNode; },\n/* harmony export */   $createTableNode: function() { return /* binding */ $createTableNode; },\n/* harmony export */   $createTableNodeWithDimensions: function() { return /* binding */ $createTableNodeWithDimensions; },\n/* harmony export */   $createTableRowNode: function() { return /* binding */ $createTableRowNode; },\n/* harmony export */   $createTableSelection: function() { return /* binding */ $createTableSelection; },\n/* harmony export */   $createTableSelectionFrom: function() { return /* binding */ $createTableSelectionFrom; },\n/* harmony export */   $deleteTableColumn: function() { return /* binding */ $deleteTableColumn; },\n/* harmony export */   $deleteTableColumnAtSelection: function() { return /* binding */ $deleteTableColumnAtSelection; },\n/* harmony export */   $deleteTableColumn__EXPERIMENTAL: function() { return /* binding */ $deleteTableColumn__EXPERIMENTAL; },\n/* harmony export */   $deleteTableRowAtSelection: function() { return /* binding */ $deleteTableRowAtSelection; },\n/* harmony export */   $deleteTableRow__EXPERIMENTAL: function() { return /* binding */ $deleteTableRow__EXPERIMENTAL; },\n/* harmony export */   $findCellNode: function() { return /* binding */ $findCellNode; },\n/* harmony export */   $findTableNode: function() { return /* binding */ $findTableNode; },\n/* harmony export */   $getElementForTableNode: function() { return /* binding */ $getElementForTableNode; },\n/* harmony export */   $getNodeTriplet: function() { return /* binding */ $getNodeTriplet; },\n/* harmony export */   $getTableAndElementByKey: function() { return /* binding */ $getTableAndElementByKey; },\n/* harmony export */   $getTableCellNodeFromLexicalNode: function() { return /* binding */ $getTableCellNodeFromLexicalNode; },\n/* harmony export */   $getTableCellNodeRect: function() { return /* binding */ $getTableCellNodeRect; },\n/* harmony export */   $getTableColumnIndexFromTableCellNode: function() { return /* binding */ $getTableColumnIndexFromTableCellNode; },\n/* harmony export */   $getTableNodeFromLexicalNodeOrThrow: function() { return /* binding */ $getTableNodeFromLexicalNodeOrThrow; },\n/* harmony export */   $getTableRowIndexFromTableCellNode: function() { return /* binding */ $getTableRowIndexFromTableCellNode; },\n/* harmony export */   $getTableRowNodeFromTableCellNodeOrThrow: function() { return /* binding */ $getTableRowNodeFromTableCellNodeOrThrow; },\n/* harmony export */   $insertTableColumn: function() { return /* binding */ $insertTableColumn; },\n/* harmony export */   $insertTableColumnAtSelection: function() { return /* binding */ $insertTableColumnAtSelection; },\n/* harmony export */   $insertTableColumn__EXPERIMENTAL: function() { return /* binding */ $insertTableColumn__EXPERIMENTAL; },\n/* harmony export */   $insertTableRow: function() { return /* binding */ $insertTableRow; },\n/* harmony export */   $insertTableRowAtSelection: function() { return /* binding */ $insertTableRowAtSelection; },\n/* harmony export */   $insertTableRow__EXPERIMENTAL: function() { return /* binding */ $insertTableRow__EXPERIMENTAL; },\n/* harmony export */   $isScrollableTablesActive: function() { return /* binding */ $isScrollableTablesActive; },\n/* harmony export */   $isTableCellNode: function() { return /* binding */ $isTableCellNode; },\n/* harmony export */   $isTableNode: function() { return /* binding */ $isTableNode; },\n/* harmony export */   $isTableRowNode: function() { return /* binding */ $isTableRowNode; },\n/* harmony export */   $isTableSelection: function() { return /* binding */ $isTableSelection; },\n/* harmony export */   $mergeCells: function() { return /* binding */ $mergeCells; },\n/* harmony export */   $removeTableRowAtIndex: function() { return /* binding */ $removeTableRowAtIndex; },\n/* harmony export */   $unmergeCell: function() { return /* binding */ $unmergeCell; },\n/* harmony export */   INSERT_TABLE_COMMAND: function() { return /* binding */ INSERT_TABLE_COMMAND; },\n/* harmony export */   TableCellHeaderStates: function() { return /* binding */ TableCellHeaderStates; },\n/* harmony export */   TableCellNode: function() { return /* binding */ TableCellNode; },\n/* harmony export */   TableNode: function() { return /* binding */ TableNode; },\n/* harmony export */   TableObserver: function() { return /* binding */ TableObserver; },\n/* harmony export */   TableRowNode: function() { return /* binding */ TableRowNode; },\n/* harmony export */   applyTableHandlers: function() { return /* binding */ applyTableHandlers; },\n/* harmony export */   getDOMCellFromTarget: function() { return /* binding */ getDOMCellFromTarget; },\n/* harmony export */   getTableElement: function() { return /* binding */ getTableElement; },\n/* harmony export */   getTableObserverFromTableElement: function() { return /* binding */ getTableObserverFromTableElement; },\n/* harmony export */   registerTableCellUnmergeTransform: function() { return /* binding */ registerTableCellUnmergeTransform; },\n/* harmony export */   registerTablePlugin: function() { return /* binding */ registerTablePlugin; },\n/* harmony export */   registerTableSelectionObserver: function() { return /* binding */ registerTableSelectionObserver; },\n/* harmony export */   setScrollableTablesActive: function() { return /* binding */ setScrollableTablesActive; }\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"./node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"./node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n    this.__verticalAlign = node.__verticalAlign;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableCellNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || undefined).setBackgroundColor(serializedNode.backgroundColor || null).setVerticalAlign(serializedNode.verticalAlign || undefined);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n    this.__verticalAlign = undefined;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    if (isValidVerticalAlign(this.__verticalAlign)) {\n      element.style.verticalAlign = this.__verticalAlign;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const output = super.exportDOM(editor);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(output.element)) {\n      const element = output.element;\n      element.setAttribute('data-temporary-table-cell-lexical-key', this.getKey());\n      element.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element.rowSpan = this.__rowSpan;\n      }\n      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element.style.verticalAlign = this.getVerticalAlign() || 'top';\n      element.style.textAlign = 'start';\n      if (this.__backgroundColor === null && this.hasHeader()) {\n        element.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return output;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(isValidVerticalAlign(this.__verticalAlign) && {\n        verticalAlign: this.__verticalAlign\n      }),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  getVerticalAlign() {\n    return this.getLatest().__verticalAlign;\n  }\n  setVerticalAlign(newVerticalAlign) {\n    const self = this.getWritable();\n    self.__verticalAlign = newVerticalAlign || undefined;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor || prevNode.__verticalAlign !== this.__verticalAlign;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction isValidVerticalAlign(verticalAlign) {\n  return verticalAlign === 'middle' || verticalAlign === 'bottom';\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const verticalAlign = domNode_.style.verticalAlign;\n  if (isValidVerticalAlign(verticalAlign)) {\n    tableCellNode.__verticalAlign = verticalAlign;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      const result = [];\n      let paragraphNode = null;\n      const removeSingleLineBreakNode = () => {\n        if (paragraphNode) {\n          const firstChild = paragraphNode.getFirstChild();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(firstChild) && paragraphNode.getChildrenSize() === 1) {\n            firstChild.remove();\n          }\n        }\n      };\n      for (const child of childLexicalNodes) {\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isInlineElementOrDecoratorNode)(child) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(child)) {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            if (hasBoldFontWeight) {\n              child.toggleFormat('bold');\n            }\n            if (hasLinethroughTextDecoration) {\n              child.toggleFormat('strikethrough');\n            }\n            if (hasItalicFontStyle) {\n              child.toggleFormat('italic');\n            }\n            if (hasUnderlineTextDecoration) {\n              child.toggleFormat('underline');\n            }\n          }\n          if (paragraphNode) {\n            paragraphNode.append(child);\n          } else {\n            paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().append(child);\n            result.push(paragraphNode);\n          }\n        } else {\n          result.push(child);\n          removeSingleLineBreakNode();\n          paragraphNode = null;\n        }\n      }\n      removeSingleLineBreakNode();\n      if (result.length === 0) {\n        result.push((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      }\n      return result;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    const height = this.getHeight();\n    return {\n      ...super.exportJSON(),\n      ...(height === undefined ? undefined : {\n        height\n      })\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableRow);\n    return element;\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return self;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    after: children => (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$descendantsMatching)(children, $isTableCellNode),\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraphNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableRowAtSelection} or {@link $insertTableRowAtNode} instead.\n */\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtSelection(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableRowAtNode(anchorStartRow + anchorCell.__rowSpan > focusStartRow + focusCell.__rowSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableRowAtNode(focusStartRow < anchorStartRow ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableRowAtSelection}\n */\nconst $insertTableRow__EXPERIMENTAL = $insertTableRowAtSelection;\n\n/**\n * Inserts a table row before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtNode(cellNode, insertAfter = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: cellStartRow\n  } = cellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const insertAfterEndRow = cellStartRow + cellNode.__rowSpan - 1;\n    const insertAfterEndRowMap = gridMap[insertAfterEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertAfterEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {\n        const currentCell = insertAfterEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);\n    if (!$isTableRowNode(insertAfterEndRowNode)) {\n      formatDevErrorMessage(`insertAfterEndRow is not a TableRowNode`);\n    }\n    insertAfterEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const insertBeforeStartRow = cellStartRow;\n    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertBeforeStartRowMap[i];\n      if (startRow === insertBeforeStartRow) {\n        const currentCell = insertBeforeStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);\n    if (!$isTableRowNode(insertBeforeStartRowNode)) {\n      formatDevErrorMessage(`insertBeforeStartRow is not a TableRowNode`);\n    }\n    insertBeforeStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableColumnAtSelection} or {@link $insertTableColumnAtNode} instead.\n */\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtSelection(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableColumnAtNode(anchorStartColumn + anchorCell.__colSpan > focusStartColumn + focusCell.__colSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableColumnAtNode(focusStartColumn < anchorStartColumn ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableColumnAtSelection}\n */\nconst $insertTableColumn__EXPERIMENTAL = $insertTableColumnAtSelection;\n\n/**\n * Inserts a column before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtNode(cellNode, insertAfter = true, shouldSetSelection = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const rowCount = gridMap.length;\n  const {\n    startColumn\n  } = cellMap;\n  const insertAfterColumn = insertAfter ? startColumn + cellNode.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    formatDevErrorMessage(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        formatDevErrorMessage(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null && shouldSetSelection) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $deleteTableColumnAtSelection} instead.\n */\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRowAtSelection() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top or bottom have to be trimmed\n      if (cellStartRow < anchorStartRow || cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        const intersectionStart = Math.max(cellStartRow, anchorStartRow);\n        const intersectionEnd = Math.min(cell.__rowSpan + cellStartRow - 1, focusEndRow);\n        const overflowRowsCount = intersectionStart <= intersectionEnd ? intersectionEnd - intersectionStart + 1 : 0;\n        cell.setRowSpan(cell.__rowSpan - overflowRowsCount);\n      }\n      // Rows overflowing bottom have to be moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow &&\n      // Handle overflow only once\n      row === focusEndRow) {\n        if (!(nextRowNode !== null)) {\n          formatDevErrorMessage(`Expected nextRowNode not to be null`);\n        }\n        let insertAfterCell = null;\n        for (let columnIndex = 0; columnIndex < column; columnIndex++) {\n          const currentCellMap = nextRow[columnIndex];\n          const currentCell = currentCellMap.cell;\n          // Checking the cell having startRow as same as nextRow\n          if (currentCellMap.startRow === row + 1) {\n            insertAfterCell = currentCell;\n          }\n          if (currentCell.__colSpan > 1) {\n            columnIndex += currentCell.__colSpan - 1;\n          }\n        }\n        if (insertAfterCell === null) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          insertAfterCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableRowAtSelection}\n */\nconst $deleteTableRow__EXPERIMENTAL = $deleteTableRowAtSelection;\nfunction $deleteTableColumnAtSelection() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableColumnAtSelection}\n */\nconst $deleteTableColumn__EXPERIMENTAL = $deleteTableColumnAtSelection;\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $mergeCells(cellNodes) {\n  if (cellNodes.length === 0) {\n    return null;\n  }\n\n  // Find the table node\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(cellNodes[0]);\n  const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null);\n\n  // Find the boundaries of the selection including merged cells\n  let minRow = Infinity;\n  let maxRow = -Infinity;\n  let minCol = Infinity;\n  let maxCol = -Infinity;\n\n  // First pass: find the actual boundaries considering merged cells\n  const processedCells = new Set();\n  for (const row of gridMap) {\n    for (const mapCell of row) {\n      if (!mapCell || !mapCell.cell) {\n        continue;\n      }\n      const cellKey = mapCell.cell.getKey();\n      if (processedCells.has(cellKey)) {\n        continue;\n      }\n      if (cellNodes.some(cell => cell.is(mapCell.cell))) {\n        processedCells.add(cellKey);\n        // Get the actual position of this cell in the grid\n        const cellStartRow = mapCell.startRow;\n        const cellStartCol = mapCell.startColumn;\n        const cellRowSpan = mapCell.cell.__rowSpan || 1;\n        const cellColSpan = mapCell.cell.__colSpan || 1;\n\n        // Update boundaries considering the cell's actual position and span\n        minRow = Math.min(minRow, cellStartRow);\n        maxRow = Math.max(maxRow, cellStartRow + cellRowSpan - 1);\n        minCol = Math.min(minCol, cellStartCol);\n        maxCol = Math.max(maxCol, cellStartCol + cellColSpan - 1);\n      }\n    }\n  }\n\n  // Validate boundaries\n  if (minRow === Infinity || minCol === Infinity) {\n    return null;\n  }\n\n  // The total span of the merged cell\n  const totalRowSpan = maxRow - minRow + 1;\n  const totalColSpan = maxCol - minCol + 1;\n\n  // Use the top-left cell as the target cell\n  const targetCellMap = gridMap[minRow][minCol];\n  if (!targetCellMap.cell) {\n    return null;\n  }\n  const targetCell = targetCellMap.cell;\n\n  // Set the spans for the target cell\n  targetCell.setColSpan(totalColSpan);\n  targetCell.setRowSpan(totalRowSpan);\n\n  // Move content from other cells to the target cell\n  const seenCells = new Set([targetCell.getKey()]);\n\n  // Second pass: merge content and remove other cells\n  for (let row = minRow; row <= maxRow; row++) {\n    for (let col = minCol; col <= maxCol; col++) {\n      const mapCell = gridMap[row][col];\n      if (!mapCell.cell) {\n        continue;\n      }\n      const currentCell = mapCell.cell;\n      const key = currentCell.getKey();\n      if (!seenCells.has(key)) {\n        seenCells.add(key);\n        const isEmpty = $cellContainsEmptyParagraph(currentCell);\n        if (!isEmpty) {\n          targetCell.append(...currentCell.getChildren());\n        }\n        currentCell.remove();\n      }\n    }\n  }\n\n  // Ensure target cell has content\n  if (targetCell.getChildrenSize() === 0) {\n    targetCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n  return targetCell;\n}\nfunction $cellContainsEmptyParagraph(cell) {\n  if (cell.getChildrenSize() !== 1) {\n    return false;\n  }\n  const firstChild = cell.getFirstChildOrThrow();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(firstChild) || !firstChild.isEmpty()) {\n    return false;\n  }\n  return true;\n}\nfunction $unmergeCell() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor, $isTableCellNode);\n  if (!$isTableCellNode(cellNode)) {\n    formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n  }\n  return $unmergeCellNode(cellNode);\n}\nfunction $unmergeCellNode(cellNode) {\n  const [cell, row, grid] = $getNodeTriplet(cellNode);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        formatDevErrorMessage(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(tableNode, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    formatDevErrorMessage(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    formatDevErrorMessage(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = tableNode.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      formatDevErrorMessage(`Expected TableNode children to be TableRowNode`);\n    }\n    const startMapRow = getMapRow(rowIdx);\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        formatDevErrorMessage(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    formatDevErrorMessage(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    formatDevErrorMessage(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $computeTableCellRectSpans(map, boundary) {\n  const {\n    minColumn,\n    maxColumn,\n    minRow,\n    maxRow\n  } = boundary;\n  let topSpan = 1;\n  let leftSpan = 1;\n  let rightSpan = 1;\n  let bottomSpan = 1;\n  const topRow = map[minRow];\n  const bottomRow = map[maxRow];\n  for (let col = minColumn; col <= maxColumn; col++) {\n    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);\n    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);\n  }\n  for (let row = minRow; row <= maxRow; row++) {\n    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);\n    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);\n  }\n  return {\n    bottomSpan,\n    leftSpan,\n    rightSpan,\n    topSpan\n  };\n}\nfunction $computeTableCellRectBoundary(map, cellAMap, cellBMap) {\n  // Initial boundaries based on the anchor and focus cells\n  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n\n  // Keep expanding until we have a complete rectangle\n  let hasChanges;\n  do {\n    hasChanges = false;\n\n    // Check all cells in the table\n    for (let row = 0; row < map.length; row++) {\n      for (let col = 0; col < map[0].length; col++) {\n        const cell = map[row][col];\n        if (!cell) {\n          continue;\n        }\n        const cellEndCol = cell.startColumn + cell.cell.__colSpan - 1;\n        const cellEndRow = cell.startRow + cell.cell.__rowSpan - 1;\n\n        // Check if this cell intersects with our current selection rectangle\n        const intersectsHorizontally = cell.startColumn <= maxColumn && cellEndCol >= minColumn;\n        const intersectsVertically = cell.startRow <= maxRow && cellEndRow >= minRow;\n\n        // If the cell intersects either horizontally or vertically\n        if (intersectsHorizontally && intersectsVertically) {\n          // Expand boundaries to include this cell completely\n          const newMinColumn = Math.min(minColumn, cell.startColumn);\n          const newMaxColumn = Math.max(maxColumn, cellEndCol);\n          const newMinRow = Math.min(minRow, cell.startRow);\n          const newMaxRow = Math.max(maxRow, cellEndRow);\n\n          // Check if boundaries changed\n          if (newMinColumn !== minColumn || newMaxColumn !== maxColumn || newMinRow !== minRow || newMaxRow !== maxRow) {\n            minColumn = newMinColumn;\n            maxColumn = newMaxColumn;\n            minRow = newMinRow;\n            maxRow = newMaxRow;\n            hasChanges = true;\n          }\n        }\n      }\n    }\n  } while (hasChanges);\n  return {\n    maxColumn,\n    maxRow,\n    minColumn,\n    minRow\n  };\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\nfunction $getCellNodes(tableSelection) {\n  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ['anchor', 'focus'].map(k => {\n    const node = tableSelection[k].getNode();\n    const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n    if (!$isTableCellNode(cellNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);\n    }\n    const rowNode = cellNode.getParent();\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} cell parent to be a TableRowNode`);\n    }\n    const tableNode = rowNode.getParent();\n    if (!$isTableNode(tableNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} row parent to be a TableNode`);\n    }\n    return [node, cellNode, rowNode, tableNode];\n  });\n  // TODO: nested tables may violate this\n  if (!anchorTable.is(focusTable)) {\n    formatDevErrorMessage(`Expected TableSelection anchor and focus to be in the same table`);\n  }\n  return {\n    anchorCell,\n    anchorNode,\n    anchorRow,\n    anchorTable,\n    focusCell,\n    focusNode,\n    focusRow,\n    focusTable\n  };\n}\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * {@link $createTableSelection} unfortunately makes it very easy to create\n   * nonsense selections, so we have a method to see if the selection probably\n   * makes sense.\n   *\n   * @returns true if the TableSelection is (probably) valid\n   */\n  isValid() {\n    return this.tableKey !== 'root' && this.anchor.key !== 'root' && this.anchor.type === 'element' && this.focus.key !== 'root' && this.focus.type === 'element';\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    // note: closure compiler's acorn does not support ||=\n    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)(this.anchor.key, this.anchor.offset, this.anchor.type), (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)(this.focus.key, this.focus.offset, this.focus.type));\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = lexical__WEBPACK_IMPORTED_MODULE_0__.TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(focusNode)) {\n      formatDevErrorMessage(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const {\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);\n    if (!(anchorCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCell);\n    if (!(focusCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    if (!this.isValid()) {\n      return [];\n    }\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const {\n      anchorTable: tableNode,\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          formatDevErrorMessage(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          formatDevErrorMessage(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    const {\n      minColumn,\n      maxColumn,\n      minRow,\n      maxRow\n    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          formatDevErrorMessage(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n          lastRow = currentRow;\n        }\n        if (!nodeMap.has(cell.getKey())) {\n          $visitRecursively(cell, childNode => {\n            nodeMap.set(childNode.getKey(), childNode);\n          });\n        }\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isCurrentlyReadOnlyMode)()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  // TODO this is a suboptimal design, it doesn't make sense to have\n  // a table selection that isn't associated with a table. This\n  // constructor should have required arguments and in true we\n  // should check that they point to a table and are element points to\n  // cell nodes of that table.\n  const anchor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  const focus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $createTableSelectionFrom(tableNode, anchorCell, focusCell) {\n  const tableNodeKey = tableNode.getKey();\n  const anchorCellKey = anchorCell.getKey();\n  const focusCellKey = focusCell.getKey();\n  {\n    if (!tableNode.isAttached()) {\n      formatDevErrorMessage(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);\n    }\n    if (!tableNode.is($findTableNode(anchorCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);\n    }\n    if (!tableNode.is($findTableNode(focusCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);\n    } // TODO: Check for rectangular grid\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();\n  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());\n  return nextSelection;\n}\n\n/**\n * Depth first visitor\n * @param node The starting node\n * @param $visit The function to call for each node. If the function returns false, then children of this node will not be explored\n */\nfunction $visitRecursively(node, $visit) {\n  const stack = [[node]];\n  for (let currentArray = stack.at(-1); currentArray !== undefined && stack.length > 0; currentArray = stack.at(-1)) {\n    const currentNode = currentArray.pop();\n    if (currentNode === undefined) {\n      stack.pop();\n    } else if ($visit(currentNode) !== false && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      stack.push(currentNode.getChildren());\n    }\n  }\n}\n\nfunction $getTableAndElementByKey(tableNodeKey, editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)()) {\n  const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(tableNodeKey);\n  if (!$isTableNode(tableNode)) {\n    formatDevErrorMessage(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);\n  }\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);\n  }\n  return {\n    tableElement,\n    tableNode\n  };\n}\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.isSelecting = false;\n    this.pointerType = null;\n    this.shouldCheckSelection = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n    this.nextFocus = null;\n    this.trackTable();\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  $lookup() {\n    return $getTableAndElementByKey(this.tableNodeKey, this.editor);\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.getEditorState().read(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const {\n          tableNode,\n          tableElement\n        } = this.$lookup();\n        this.table = getTable(tableNode, tableElement);\n      }, {\n        editor: this.editor\n      });\n    });\n    this.editor.getEditorState().read(() => {\n      const {\n        tableNode,\n        tableElement\n      } = this.$lookup();\n      this.table = getTable(tableNode, tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }, {\n      editor: this.editor\n    });\n  }\n  $clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.$enableHighlightStyle();\n    const {\n      tableNode,\n      tableElement\n    } = this.$lookup();\n    const grid = getTable(tableNode, tableElement);\n    $updateDOMForSelection(editor, grid, null);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() !== null) {\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    }\n  }\n  $enableHighlightStyle() {\n    const editor = this.editor;\n    const {\n      tableElement\n    } = this.$lookup();\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(tableElement, editor._config.theme.tableSelection);\n    tableElement.classList.remove('disable-selection');\n    this.hasHijackedSelectionStyles = false;\n  }\n  $disableHighlightStyle() {\n    const {\n      tableElement\n    } = this.$lookup();\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, this.editor._config.theme.tableSelection);\n    this.hasHijackedSelectionStyles = true;\n  }\n  $updateTableTableSelection(selection) {\n    if (selection !== null) {\n      if (!(selection.tableKey === this.tableNodeKey)) {\n        formatDevErrorMessage(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);\n      }\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n      this.updateDOMSelection();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else {\n      this.$clearHighlight();\n    }\n  }\n\n  /**\n   * @internal\n   * Firefox has a strange behavior where pressing the down arrow key from\n   * above the table will move the caret after the table and then lexical\n   * will select the last cell instead of the first.\n   * We do still want to let the browser handle caret movement but we will\n   * use this property to \"tag\" the update so that we can recheck the\n   * selection after the event is processed.\n   */\n  setShouldCheckSelection() {\n    this.shouldCheckSelection = true;\n  }\n  /**\n   * @internal\n   */\n  getAndClearShouldCheckSelection() {\n    if (this.shouldCheckSelection) {\n      this.shouldCheckSelection = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @internal\n   * When handling mousemove events we track what the focus cell should be, but\n   * the DOM selection may end up somewhere else entirely. We don't have an elegant\n   * way to handle this after the DOM selection has been resolved in a\n   * SELECTION_CHANGE_COMMAND callback.\n   */\n  setNextFocus(nextFocus) {\n    this.nextFocus = nextFocus;\n  }\n\n  /** @internal */\n  getAndClearNextFocus() {\n    const {\n      nextFocus\n    } = this;\n    if (nextFocus !== null) {\n      this.nextFocus = null;\n    }\n    return nextFocus;\n  }\n\n  /** @internal */\n  updateDOMSelection() {\n    if (this.anchorCell !== null && this.focusCell !== null) {\n      const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(this.editor._window);\n      // We are not using a native selection for tables, and if we\n      // set one then the reconciler will undo it.\n      // TODO - it would make sense to have one so that native\n      //        copy/paste worked. Right now we have to emulate with\n      //        keyboard events but it won't fire if triggered from the menu\n      if (domSelection && domSelection.rangeCount > 0) {\n        domSelection.removeAllRanges();\n      }\n    }\n  }\n  $setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    const {\n      tableNode\n    } = this.$lookup();\n    const cellX = cell.x;\n    const cellY = cell.y;\n    this.focusCell = cell;\n    if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n    } else if (cellX === this.focusX && cellY === this.focusY) {\n      return false;\n    }\n    this.focusX = cellX;\n    this.focusY = cellY;\n    if (this.isHighlightingCells) {\n      const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n      if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {\n        this.focusCellNodeKey = focusTableCellNode.getKey();\n        this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(this.tableSelection);\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n        $updateDOMForSelection(editor, this.table, this.tableSelection);\n        return true;\n      }\n    }\n    return false;\n  }\n  $getAnchorTableCell() {\n    return this.anchorCellNodeKey ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.anchorCellNodeKey) : null;\n  }\n  $getAnchorTableCellOrThrow() {\n    const anchorTableCell = this.$getAnchorTableCell();\n    if (!(anchorTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver anchorTableCell is null`);\n    }\n    return anchorTableCell;\n  }\n  $getFocusTableCell() {\n    return this.focusCellNodeKey ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.focusCellNodeKey) : null;\n  }\n  $getFocusTableCellOrThrow() {\n    const focusTableCell = this.$getFocusTableCell();\n    if (!(focusTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver focusTableCell is null`);\n    }\n    return focusTableCell;\n  }\n  $setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    const {\n      tableNode\n    } = this.$lookup();\n    const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n    if (anchorTableCellNode !== null) {\n      const anchorNodeKey = anchorTableCellNode.getKey();\n      this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n      this.anchorCellNodeKey = anchorNodeKey;\n    }\n  }\n  $formatCells(type) {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected Table selection`);\n    }\n    const formatSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n    const anchor = formatSelection.anchor;\n    const focus = formatSelection.focus;\n    const cellNodes = selection.getNodes().filter($isTableCellNode);\n    if (!(cellNodes.length > 0)) {\n      formatDevErrorMessage(`No table cells present`);\n    }\n    const paragraph = cellNodes[0].getFirstChild();\n    const alignFormatWith = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n    cellNodes.forEach(cellNode => {\n      anchor.set(cellNode.getKey(), 0, 'element');\n      focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n      formatSelection.formatText(type, alignFormatWith);\n    });\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection);\n    this.editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n  }\n  $clearText() {\n    const {\n      editor\n    } = this;\n    const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n    if (!$isTableNode(tableNode)) {\n      throw new Error('Expected TableNode.');\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected TableSelection`);\n    }\n    const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n    // Check if the entire table is selected by verifying first and last cells\n    const firstRow = tableNode.getFirstChild();\n    const lastRow = tableNode.getLastChild();\n    const isEntireTableSelected = selectedNodes.length > 0 && firstRow !== null && lastRow !== null && $isTableRowNode(firstRow) && $isTableRowNode(lastRow) && selectedNodes[0] === firstRow.getFirstChild() && selectedNodes[selectedNodes.length - 1] === lastRow.getLastChild();\n    if (isEntireTableSelected) {\n      tableNode.selectPrevious();\n      const parent = tableNode.getParent();\n      // Delete entire table\n      tableNode.remove();\n      // Handle case when table was the only node\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent) && parent.isEmpty()) {\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, undefined);\n      }\n      return;\n    }\n    selectedNodes.forEach(cellNode => {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(cellNode)) {\n        const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)();\n        paragraphNode.append(textNode);\n        cellNode.append(paragraphNode);\n        cellNode.getChildren().forEach(child => {\n          if (child !== paragraphNode) {\n            child.remove();\n          }\n        });\n      }\n    });\n    $updateDOMForSelection(editor, this.table, null);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst isPointerDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction isHTMLTableElement(el) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(el) && el.nodeName === 'TABLE';\n}\nfunction getTableElement(tableNode, dom) {\n  if (!dom) {\n    return dom;\n  }\n  const element = isHTMLTableElement(dom) ? dom : tableNode.getDOMSlot(dom).element;\n  if (!(element.nodeName === 'TABLE')) {\n    formatDevErrorMessage(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);\n  }\n  return element;\n}\nfunction getEditorWindow(editor) {\n  return editor._window;\n}\nfunction $findParentTableCellNodeInTable(tableNode, node) {\n  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {\n    if (tableNode.is(currentNode)) {\n      return lastTableCellNode;\n    } else if ($isTableCellNode(currentNode)) {\n      lastTableCellNode = currentNode;\n    }\n  }\n  return null;\n}\nconst ARROW_KEY_COMMANDS_WITH_DIRECTION = [[lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, 'down'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, 'up'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, 'backward'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, 'forward']];\nconst DELETE_TEXT_COMMANDS = [lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND];\nconst DELETE_KEY_COMMANDS = [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND];\nfunction applyTableHandlers(tableNode, element, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  const editorWindow = getEditorWindow(editor);\n  if (!(rootElement !== null && editorWindow !== null)) {\n    formatDevErrorMessage(`applyTableHandlers: editor has no root element set`);\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const tableElement = getTableElement(tableNode, element);\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => detachTableObserverFromTableElement(tableElement, tableObserver));\n  const createPointerHandlers = () => {\n    if (tableObserver.isSelecting) {\n      return;\n    }\n    const onPointerUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('pointerup', onPointerUp);\n      editorWindow.removeEventListener('pointermove', onPointerMove);\n    };\n    const onPointerMove = moveEvent => {\n      if (!isPointerDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n        tableObserver.isSelecting = false;\n        editorWindow.removeEventListener('pointerup', onPointerUp);\n        editorWindow.removeEventListener('pointermove', onPointerMove);\n        return;\n      }\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(moveEvent.target)) {\n        return;\n      }\n      let focusCell = null;\n      // In firefox the moveEvent.target may be captured so we must always\n      // consult the coordinates #7245\n      const override = !(IS_FIREFOX || tableElement.contains(moveEvent.target));\n      if (override) {\n        focusCell = getDOMCellInTableFromTarget(tableElement, moveEvent.target);\n      } else {\n        for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {\n          focusCell = getDOMCellInTableFromTarget(tableElement, el);\n          if (focusCell) {\n            break;\n          }\n        }\n      }\n      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {\n        tableObserver.setNextFocus({\n          focusCell,\n          override\n        });\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n      }\n    };\n    tableObserver.isSelecting = true;\n    editorWindow.addEventListener('pointerup', onPointerUp, tableObserver.listenerOptions);\n    editorWindow.addEventListener('pointermove', onPointerMove, tableObserver.listenerOptions);\n  };\n  const onPointerDown = event => {\n    tableObserver.pointerType = event.pointerType;\n    if (event.button !== 0 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target) || !editorWindow) {\n      return;\n    }\n    const targetCell = getDOMCellFromTarget(event.target);\n    if (targetCell !== null) {\n      editor.update(() => {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        // We can't trust Firefox to do the right thing with the selection and\n        // we don't have a proper state machine to do this \"correctly\" but\n        // if we go ahead and make the table selection now it will work\n        if (IS_FIREFOX && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || $isTableSelection(prevSelection))) {\n          const prevAnchorNode = prevSelection.anchor.getNode();\n          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());\n          if (prevAnchorCell) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));\n            tableObserver.$setFocusCellForSelection(targetCell);\n            stopEvent(event);\n          } else {\n            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();\n            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);\n          }\n        } else {\n          // Only set anchor cell for selection if this is not a simple touch tap\n          // Touch taps should not initiate table selection mode\n          if (event.pointerType !== 'touch') {\n            tableObserver.$setAnchorCellForSelection(targetCell);\n          }\n        }\n      });\n    }\n    createPointerHandlers();\n  };\n  tableElement.addEventListener('pointerdown', onPointerDown, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('pointerdown', onPointerDown);\n  });\n  const onTripleClick = event => {\n    if (event.detail >= 3 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target)) {\n      const targetCell = getDOMCellFromTarget(event.target);\n      if (targetCell !== null) {\n        event.preventDefault();\n      }\n    }\n  };\n  tableElement.addEventListener('mousedown', onTripleClick, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('mousedown', onTripleClick);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const pointerDownCallback = event => {\n    const target = event.target;\n    if (event.button !== 0 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(target)) {\n      return;\n    }\n    editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.$clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('pointerdown', pointerDownCallback, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    editorWindow.removeEventListener('pointerdown', pointerDownCallback);\n  });\n  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, event => $handleArrowKey(editor, event, direction, tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());\n      if (focusCellNode !== null) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearText();\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.$clearText();\n        return true;\n      }\n      const nearestElementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n));\n      const topLevelCellElementNode = nearestElementNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(nearestElementNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && $isTableCellNode(n.getParent()));\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topLevelCellElementNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nearestElementNode)) {\n        return false;\n      }\n      if (command === lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  for (const command of DELETE_TEXT_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  const $deleteCellHandler = event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.$clearText();\n      return true;\n    }\n    return false;\n  };\n  for (const command of DELETE_KEY_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CUT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection) {\n      if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null, (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$getClipboardDataFromSelection)(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$formatCells(payload);\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n\n    // Align the table if the entire table is selected\n    if ($isFullTableSelection(selection, tableNode)) {\n      tableNode.setFormat(formatType);\n      return true;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);\n    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    const visited = new Set();\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        if (visited.has(cell)) {\n          continue;\n        }\n        visited.add(cell);\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearHighlight();\n      return false;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_TAB_COMMAND, event => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {\n        return false;\n      }\n      stopEvent(event);\n      $selectAdjacentCell(tableCellNode, event.shiftKey ? 'previous' : 'next');\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, (selectionPayload, dispatchEditor) => {\n    if (editor !== dispatchEditor) {\n      return false;\n    }\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor, focus] = anchorAndFocus;\n    const [anchorCellNode, anchorRowNode, gridNode] = $getNodeTriplet(anchor);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), n => $isTableCellNode(n));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableRowNode(anchorRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const templateGrid = nodes[0];\n    const [initialGridMap, anchorCellMap, focusCellMap] = $computeTableMap(gridNode, anchorCellNode, focusCellNode);\n    const [templateGridMap] = $computeTableMapSkipCellCheck(templateGrid, null, null);\n    const initialRowCount = initialGridMap.length;\n    const initialColCount = initialRowCount > 0 ? initialGridMap[0].length : 0;\n\n    // If we have a range selection, we'll fit the template grid into the\n    // table, growing the table if necessary.\n    let startRow = anchorCellMap.startRow;\n    let startCol = anchorCellMap.startColumn;\n    let affectedRowCount = templateGridMap.length;\n    let affectedColCount = affectedRowCount > 0 ? templateGridMap[0].length : 0;\n    if (isTableSelection) {\n      // If we have a table selection, we'll only modify the cells within\n      // the selection boundary.\n      const selectionBoundary = $computeTableCellRectBoundary(initialGridMap, anchorCellMap, focusCellMap);\n      const selectionRowCount = selectionBoundary.maxRow - selectionBoundary.minRow + 1;\n      const selectionColCount = selectionBoundary.maxColumn - selectionBoundary.minColumn + 1;\n      startRow = selectionBoundary.minRow;\n      startCol = selectionBoundary.minColumn;\n      affectedRowCount = Math.min(affectedRowCount, selectionRowCount);\n      affectedColCount = Math.min(affectedColCount, selectionColCount);\n    }\n\n    // Step 1: Unmerge all merged cells within the affected area\n    let didPerformMergeOperations = false;\n    const lastRowForUnmerge = Math.min(initialRowCount, startRow + affectedRowCount) - 1;\n    const lastColForUnmerge = Math.min(initialColCount, startCol + affectedColCount) - 1;\n    const unmergedKeys = new Set();\n    for (let row = startRow; row <= lastRowForUnmerge; row++) {\n      for (let col = startCol; col <= lastColForUnmerge; col++) {\n        const cellMap = initialGridMap[row][col];\n        if (unmergedKeys.has(cellMap.cell.getKey())) {\n          continue; // cell was a merged cell that was already handled\n        }\n        if (cellMap.cell.__rowSpan === 1 && cellMap.cell.__colSpan === 1) {\n          continue; // cell is not a merged cell\n        }\n        $unmergeCellNode(cellMap.cell);\n        unmergedKeys.add(cellMap.cell.getKey());\n        didPerformMergeOperations = true;\n      }\n    }\n    let [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 2: Expand current table (if needed)\n    const rowsToInsert = affectedRowCount - initialRowCount + startRow;\n    for (let i = 0; i < rowsToInsert; i++) {\n      const cellMap = interimGridMap[initialRowCount - 1][0];\n      $insertTableRowAtNode(cellMap.cell);\n    }\n    const colsToInsert = affectedColCount - initialColCount + startCol;\n    for (let i = 0; i < colsToInsert; i++) {\n      const cellMap = interimGridMap[0][initialColCount - 1];\n      $insertTableColumnAtNode(cellMap.cell, true, false);\n    }\n    [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 3: Merge cells and set cell content, to match template grid\n    for (let row = startRow; row < startRow + affectedRowCount; row++) {\n      for (let col = startCol; col < startCol + affectedColCount; col++) {\n        const templateRow = row - startRow;\n        const templateCol = col - startCol;\n        const templateCellMap = templateGridMap[templateRow][templateCol];\n        if (templateCellMap.startRow !== templateRow || templateCellMap.startColumn !== templateCol) {\n          continue; // cell is a merged cell that was already handled\n        }\n        const templateCell = templateCellMap.cell;\n        if (templateCell.__rowSpan !== 1 || templateCell.__colSpan !== 1) {\n          const cellsToMerge = [];\n          const lastRowForMerge = Math.min(row + templateCell.__rowSpan, startRow + affectedRowCount) - 1;\n          const lastColForMerge = Math.min(col + templateCell.__colSpan, startCol + affectedColCount) - 1;\n          for (let r = row; r <= lastRowForMerge; r++) {\n            for (let c = col; c <= lastColForMerge; c++) {\n              const cellMap = interimGridMap[r][c];\n              cellsToMerge.push(cellMap.cell);\n            }\n          }\n          $mergeCells(cellsToMerge);\n          didPerformMergeOperations = true;\n        }\n        const {\n          cell\n        } = interimGridMap[row][col];\n        const originalChildren = cell.getChildren();\n        templateCell.getChildren().forEach(child => {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n            paragraphNode.append(child);\n            cell.append(child);\n          } else {\n            cell.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n      }\n    }\n    if (isTableSelection && didPerformMergeOperations) {\n      // reset the table selection in case the anchor or focus cell was\n      // removed via merge operations\n      const [finalGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n      const newAnchorCellMap = finalGridMap[anchorCellMap.startRow][anchorCellMap.startColumn];\n      newAnchorCellMap.cell.selectEnd();\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n    const nextFocus = tableObserver.getAndClearNextFocus();\n    if (nextFocus !== null) {\n      const {\n        focusCell\n      } = nextFocus;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {\n          // The selection is already the correct table selection\n          return false;\n        } else {\n          tableObserver.$setFocusCellForSelection(focusCell);\n          return true;\n        }\n      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {\n        // The selection has crossed cells\n        tableObserver.$setFocusCellForSelection(focusCell);\n        return true;\n      }\n    }\n    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();\n    // If they pressed the down arrow with the selection outside of the\n    // table, and then the selection ends up in the table but not in the\n    // first cell, then move the selection to the first cell.\n    if (shouldCheckSelection && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n      const anchor = selection.anchor.getNode();\n      const firstRow = tableNode.getFirstChild();\n      const anchorCell = $findCellNode(anchor);\n      if (anchorCell !== null && $isTableRowNode(firstRow)) {\n        const firstCell = firstRow.getFirstChild();\n        if ($isTableCellNode(firstCell) && tableNode.is((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCell, node => node.is(tableNode) || node.is(firstCell)))) {\n          // The selection moved to the table, but not in the first cell\n          firstCell.selectStart();\n          return true;\n        }\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartiallyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into table selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));\n          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n        }\n\n        // Handle case when the pointer type is touch and the current and\n        // previous selection are collapsed, and the previous anchor and current\n        // focus cell nodes are different, then we convert it into table selection\n        // However, only do this if the table observer is actively selecting (user dragging)\n        // to prevent unwanted selections when simply tapping between cells on mobile\n        if (tableObserver.pointerType === 'touch' && tableObserver.isSelecting && selection.isCollapsed() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevAnchorCellNode = $findCellNode(prevSelection.anchor.getNode());\n          if (prevAnchorCellNode && !prevAnchorCellNode.is(focusCellNode)) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCellNode));\n            tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n            tableObserver.pointerType = null;\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editorWindow);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);\n        const anchorNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelectionFromDom)(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction detachTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    formatDevErrorMessage(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getDOMCellInTableFromTarget(table, node) {\n  if (!table.contains(node)) {\n    return null;\n  }\n  let cell = null;\n  for (let currentNode = node; currentNode != null; currentNode = currentNode.parentNode) {\n    if (currentNode === table) {\n      return cell;\n    }\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      cell = currentNode._cell || null;\n    }\n  }\n  return null;\n}\nfunction getTable(tableNode, dom) {\n  const tableElement = getTableElement(tableNode, dom);\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.$disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.$enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nfunction $selectAdjacentCell(tableCellNode, direction) {\n  const siblingMethod = direction === 'next' ? 'getNextSibling' : 'getPreviousSibling';\n  const childMethod = direction === 'next' ? 'getFirstChild' : 'getLastChild';\n  const sibling = tableCellNode[siblingMethod]();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n    return sibling.selectEnd();\n  }\n  const parentRow = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(tableCellNode, $isTableRowNode);\n  if (!(parentRow !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Cell not in table row`);\n  }\n  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {\n    const child = nextRow[childMethod]();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      return child.selectEnd();\n    }\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(parentRow, $isTableNode);\n  if (!(parentTable !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Row not in table`);\n  }\n  return direction === 'next' ? parentTable.selectNext() : parentTable.selectPrevious();\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nfunction getCorner(rect, cellValue) {\n  let colName;\n  let rowName;\n  if (cellValue.startColumn === rect.minColumn) {\n    colName = 'minColumn';\n  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {\n    colName = 'maxColumn';\n  } else {\n    return null;\n  }\n  if (cellValue.startRow === rect.minRow) {\n    rowName = 'minRow';\n  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {\n    rowName = 'maxRow';\n  } else {\n    return null;\n  }\n  return [colName, rowName];\n}\nfunction getCornerOrThrow(rect, cellValue) {\n  const corner = getCorner(rect, cellValue);\n  if (!(corner !== null)) {\n    formatDevErrorMessage(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);\n  }\n  return corner;\n}\nfunction oppositeCorner([colName, rowName]) {\n  return [colName === 'minColumn' ? 'maxColumn' : 'minColumn', rowName === 'minRow' ? 'maxRow' : 'minRow'];\n}\nfunction cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {\n  const rowNum = rect[rowName];\n  const rowMap = tableMap[rowNum];\n  if (!(rowMap !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);\n  }\n  const colNum = rect[colName];\n  const cell = rowMap[colNum];\n  if (!(cell !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);\n  }\n  return cell;\n}\nfunction $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {\n  // We are sure that the focus now either contracts or expands the rect\n  // but both the anchor and focus might be moved to ensure a rectangle\n  // given a potentially ragged merge shape\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorCorner = getCorner(rect, anchorCellValue);\n  if (anchorCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];\n  }\n  const newFocusCorner = getCorner(rect, newFocusCellValue);\n  if (newFocusCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];\n  }\n  // TODO this doesn't have to be arbitrary, use the closest corner instead\n  const newAnchorCorner = ['minColumn', 'minRow'];\n  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];\n}\nfunction $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);\n  const spans = $computeTableCellRectSpans(tableMap, rect);\n  const {\n    topSpan,\n    leftSpan,\n    bottomSpan,\n    rightSpan\n  } = spans;\n  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);\n  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);\n  let fCol = rect[focusColumn];\n  let fRow = rect[focusRow];\n  if (direction === 'forward') {\n    fCol += focusColumn === 'maxColumn' ? 1 : leftSpan;\n  } else if (direction === 'backward') {\n    fCol -= focusColumn === 'minColumn' ? 1 : rightSpan;\n  } else if (direction === 'down') {\n    fRow += focusRow === 'maxRow' ? 1 : topSpan;\n  } else if (direction === 'up') {\n    fRow -= focusRow === 'minRow' ? 1 : bottomSpan;\n  }\n  const targetRowMap = tableMap[fRow];\n  if (targetRowMap === undefined) {\n    return false;\n  }\n  const newFocusCellValue = targetRowMap[fCol];\n  if (newFocusCellValue === undefined) {\n    return false;\n  }\n  // We can be certain that anchorCellValue and newFocusCellValue are\n  // contained within the desired selection, but we are not certain if\n  // they need to be expanded or not to maintain a rectangular shape\n  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);\n  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);\n  tableObserver.$setAnchorCellForSelection(anchorDOM);\n  tableObserver.$setFocusCellForSelection(focusDOM, true);\n  return true;\n}\nfunction $isSelectionInTable(selection, tableNode) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection)) {\n    // TODO this should probably return false if there's an unrelated\n    //      shadow root between the node and the table (e.g. another table,\n    //      collapsible, etc.)\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction $isFullTableSelection(selection, tableNode) {\n  if ($isTableSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (tableNode && anchorNode && focusNode) {\n      const [map] = $computeTableMap(tableNode, anchorNode, focusNode);\n      return anchorNode.getKey() === map[0][0].cell.getKey() && focusNode.getKey() === map[map.length - 1].at(-1).cell.getKey();\n    }\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const editorThemeClasses = editor._config.theme;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, editorThemeClasses.tableCellSelected);\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const editorThemeClasses = editor._config.theme;\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(element, editorThemeClasses.tableCellSelected);\n}\nfunction $findCellNode(node) {\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $getBlockParentIfFirstNode(node) {\n  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {\n        // Not the first child or the initial node\n        return null;\n      } else if (!currentNode.isInline()) {\n        return currentNode;\n      }\n    }\n  }\n  return null;\n}\nfunction $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, isBackward, tableNode, tableObserver) {\n  const initialFocus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, isBackward ? 'previous' : 'next');\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isExtendableTextPointCaret)(initialFocus)) {\n    return false;\n  }\n  let lastCaret = initialFocus;\n  // TableCellNode is the only shadow root we are interested in piercing so\n  // we find the last internal caret and then check its parent\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(initialFocus).iterNodeCarets('shadowRoot')) {\n    if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isSiblingCaret)(nextCaret) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nextCaret.origin))) {\n      return false;\n    }\n    lastCaret = nextCaret;\n  }\n  const lastCaretParent = lastCaret.getParentAtCaret();\n  if (!$isTableCellNode(lastCaretParent)) {\n    return false;\n  }\n  const anchorCell = lastCaretParent;\n  const focusCaret = $findNextTableCell((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(anchorCell, lastCaret.direction));\n  const anchorCellTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCell, $isTableNode);\n  if (!(anchorCellTable && anchorCellTable.is(tableNode))) {\n    return false;\n  }\n  const anchorCellDOM = editor.getElementByKey(anchorCell.getKey());\n  const anchorDOMCell = getDOMCellFromTarget(anchorCellDOM);\n  if (!anchorCellDOM || !anchorDOMCell) {\n    return false;\n  }\n  const anchorCellTableElement = $getElementForTableNode(editor, anchorCellTable);\n  tableObserver.table = anchorCellTableElement;\n  if (!focusCaret) {\n    if (alter === 'extend') {\n      // extend the selection from a range inside the cell to a table selection of the cell\n      tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n      tableObserver.$setFocusCellForSelection(anchorDOMCell, true);\n    } else {\n      // exit the table\n      const outerFocusCaret = $getTableExitCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(anchorCellTable, initialFocus.direction));\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, outerFocusCaret);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, outerFocusCaret);\n    }\n  } else if (alter === 'extend') {\n    const focusDOMCell = getDOMCellFromTarget(editor.getElementByKey(focusCaret.origin.getKey()));\n    if (!focusDOMCell) {\n      return false;\n    }\n    tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n    tableObserver.$setFocusCellForSelection(focusDOMCell, true);\n  } else {\n    // alter === 'move'\n    const innerFocusCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(focusCaret);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, innerFocusCaret);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, innerFocusCaret);\n  }\n  stopEvent(event);\n  return true;\n}\nfunction $getTableExitCaret(initialCaret) {\n  const adjacent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(initialCaret);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(adjacent) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(adjacent) : initialCaret;\n}\nfunction $findNextTableCell(initialCaret) {\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(initialCaret).iterNodeCarets('root')) {\n    const {\n      origin\n    } = nextCaret;\n    if ($isTableCellNode(origin)) {\n      // not sure why ts isn't narrowing here (even if the guard is on nextCaret.origin)\n      // but returning a new caret is fine\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(nextCaret)) {\n        return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(origin, initialCaret.direction);\n      }\n    } else if (!$isTableRowNode(origin)) {\n      break;\n    }\n  }\n  return null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if (direction === 'backward') {\n        if (selection.focus.offset > 0) {\n          return false;\n        }\n        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        if (event.shiftKey) {\n          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), 'element');\n        } else {\n          siblingNode.selectEnd();\n        }\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? 'text' : 'element');\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);\n            if (tableCellNode !== null) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.$setAnchorCellForSelection(firstCellDOM);\n              tableObserver.$setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    if (direction === 'down' && $isScrollableTablesActive(editor)) {\n      // Enable Firefox workaround\n      tableObserver.setShouldCheckSelection();\n    }\n    return false;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    if (direction === 'backward' || direction === 'forward') {\n      const alter = event.shiftKey ? 'extend' : 'move';\n      return $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, direction === 'backward', tableNode, tableObserver);\n    }\n    if (selection.isCollapsed()) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n      const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n      if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n        return false;\n      }\n      const anchorCellTable = $findTableNode(anchorCellNode);\n      if (anchorCellTable !== tableNode && anchorCellTable != null) {\n        const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));\n        if (anchorCellTableElement != null) {\n          tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);\n          return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n        }\n      }\n      const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n      const anchorDOM = editor.getElementByKey(anchor.key);\n      if (anchorDOM == null || anchorCellDom == null) {\n        return false;\n      }\n      let edgeSelectionRect;\n      if (anchor.type === 'element') {\n        edgeSelectionRect = anchorDOM.getBoundingClientRect();\n      } else {\n        const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(getEditorWindow(editor));\n        if (domSelection === null || domSelection.rangeCount === 0) {\n          return false;\n        }\n        const range = domSelection.getRangeAt(0);\n        edgeSelectionRect = range.getBoundingClientRect();\n      }\n      const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n      if (edgeChild == null) {\n        return false;\n      }\n      const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n      if (edgeChildDOM == null) {\n        return false;\n      }\n      const edgeRect = edgeChildDOM.getBoundingClientRect();\n      const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n      if (isExiting) {\n        stopEvent(event);\n        const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n        if (event.shiftKey) {\n          const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n          tableObserver.$setAnchorCellForSelection(cell);\n          tableObserver.$setFocusCellForSelection(cell, true);\n        } else {\n          return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n        }\n        return true;\n      }\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    if (!$isTableNode(tableNodeFromSelection)) {\n      formatDevErrorMessage(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);\n    }\n    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.$updateTableTableSelection(selection);\n    const grid = getTable(tableNodeFromSelection, tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.$setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);\n      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(getEditorWindow(editor));\n  if (!domSelection) {\n    return undefined;\n  }\n  const domAnchorNode = domSelection.anchorNode;\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));\n  // We are only interested in the scenario where the\n  // native selection anchor is:\n  // - at or inside the table's parent DOM\n  // - and NOT at or inside the table DOM\n  // It may be adjacent to the table DOM (e.g. in a wrapper)\n  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {\n    return undefined;\n  }\n  const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\nfunction $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {\n  const {\n    tableNode\n  } = tableObserver.$lookup();\n  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n}\nfunction $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {\n  return $findParentTableCellNodeInTable(tableNode, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(startingDOM, editorState));\n}\n\nfunction isHTMLDivElement(element) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) && element.nodeName === 'DIV';\n}\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\nfunction setFrozenColumns(dom, tableElement, config, frozenColumnCount) {\n  if (frozenColumnCount > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableFrozenColumn);\n    tableElement.setAttribute('data-lexical-frozen-column', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableFrozenColumn);\n    tableElement.removeAttribute('data-lexical-frozen-column');\n  }\n}\nfunction setFrozenRows(dom, tableElement, config, frozenRowCount) {\n  if (frozenRowCount > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableFrozenRow);\n    tableElement.setAttribute('data-lexical-frozen-row', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableFrozenRow);\n    tableElement.removeAttribute('data-lexical-frozen-row');\n  }\n}\nfunction alignTableElement(dom, config, formatType) {\n  if (!config.theme.tableAlignment) {\n    return;\n  }\n  const removeClasses = [];\n  const addClasses = [];\n  for (const format of ['center', 'right']) {\n    const classes = config.theme.tableAlignment[format];\n    if (!classes) {\n      continue;\n    }\n    (format === formatType ? addClasses : removeClasses).push(classes);\n  }\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...removeClasses);\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...addClasses);\n}\nconst scrollableEditors = new WeakSet();\nfunction $isScrollableTablesActive(editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)()) {\n  return scrollableEditors.has(editor);\n}\nfunction setScrollableTablesActive(editor, active) {\n  if (active) {\n    if (!editor._config.theme.tableScrollableWrapper) {\n      console.warn('TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.');\n    }\n    scrollableEditors.add(editor);\n  } else {\n    scrollableEditors.delete(editor);\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = colWidths !== undefined && true ? Object.freeze(colWidths) : colWidths;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n    this.__frozenColumnCount = prevNode.__frozenColumnCount;\n    this.__frozenRowCount = prevNode.__frozenRowCount;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setFrozenColumns(serializedNode.frozenColumnCount || 0).setFrozenRows(serializedNode.frozenRowCount || 0).setColWidths(serializedNode.colWidths);\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n    this.__frozenColumnCount = 0;\n    this.__frozenRowCount = 0;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : undefined,\n      frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : undefined,\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined\n    };\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  getDOMSlot(element) {\n    const tableElement = !isHTMLTableElement(element) ? element.querySelector('table') : element;\n    if (!isHTMLTableElement(tableElement)) {\n      formatDevErrorMessage(`TableNode.getDOMSlot: createDOM() did not return a table`);\n    }\n    return super.getDOMSlot(element).withElement(tableElement).withAfter(tableElement.querySelector('colgroup'));\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    if (this.__style) {\n      tableElement.style.cssText = this.__style;\n    }\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.setDOMUnmanaged)(colGroup);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, config.theme.table);\n    this.updateTableElement(null, tableElement, config);\n    if ($isScrollableTablesActive(editor)) {\n      const wrapperElement = document.createElement('div');\n      const classes = config.theme.tableScrollableWrapper;\n      if (classes) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(wrapperElement, classes);\n      } else {\n        wrapperElement.style.cssText = 'overflow-x: auto;';\n      }\n      wrapperElement.appendChild(tableElement);\n      this.updateTableWrapper(null, wrapperElement, tableElement, config);\n      return wrapperElement;\n    }\n    return tableElement;\n  }\n  updateTableWrapper(prevNode, tableWrapper, tableElement, config) {\n    if (this.__frozenColumnCount !== (prevNode ? prevNode.__frozenColumnCount : 0)) {\n      setFrozenColumns(tableWrapper, tableElement, config, this.__frozenColumnCount);\n    }\n    if (this.__frozenRowCount !== (prevNode ? prevNode.__frozenRowCount : 0)) {\n      setFrozenRows(tableWrapper, tableElement, config, this.__frozenRowCount);\n    }\n  }\n  updateTableElement(prevNode, tableElement, config) {\n    if (this.__style !== (prevNode ? prevNode.__style : '')) {\n      tableElement.style.cssText = this.__style;\n    }\n    if (this.__rowStriping !== (prevNode ? prevNode.__rowStriping : false)) {\n      setRowStriping(tableElement, config, this.__rowStriping);\n    }\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    alignTableElement(tableElement, config, this.getFormatType());\n  }\n  updateDOM(prevNode, dom, config) {\n    const slot = this.getDOMSlot(dom);\n    const tableElement = slot.element;\n    if (dom === tableElement === $isScrollableTablesActive()) {\n      return true;\n    }\n    if (isHTMLDivElement(dom)) {\n      this.updateTableWrapper(prevNode, dom, tableElement, config);\n    }\n    this.updateTableElement(prevNode, tableElement, config);\n    return false;\n  }\n  exportDOM(editor) {\n    const superExport = super.exportDOM(editor);\n    const {\n      element\n    } = superExport;\n    return {\n      after: tableElement => {\n        if (superExport.after) {\n          tableElement = superExport.after(tableElement);\n        }\n        if (!isHTMLTableElement(tableElement) && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(tableElement)) {\n          tableElement = tableElement.querySelector('table');\n        }\n        if (!isHTMLTableElement(tableElement)) {\n          return null;\n        }\n        alignTableElement(tableElement, editor._config, this.getFormatType());\n\n        // Scan the table map to build a map of table cell key to the columns it needs\n        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);\n        const cellValues = new Map();\n        for (const mapRow of tableMap) {\n          for (const mapValue of mapRow) {\n            const key = mapValue.cell.getKey();\n            if (!cellValues.has(key)) {\n              cellValues.set(key, {\n                colSpan: mapValue.cell.getColSpan(),\n                startColumn: mapValue.startColumn\n              });\n            }\n          }\n        }\n\n        // scan the DOM to find the table cell keys that were used and mark those columns\n        const knownColumns = new Set();\n        for (const cellDOM of tableElement.querySelectorAll(':scope > tr > [data-temporary-table-cell-lexical-key]')) {\n          const key = cellDOM.getAttribute('data-temporary-table-cell-lexical-key');\n          if (key) {\n            const cellSpan = cellValues.get(key);\n            cellDOM.removeAttribute('data-temporary-table-cell-lexical-key');\n            if (cellSpan) {\n              cellValues.delete(key);\n              for (let i = 0; i < cellSpan.colSpan; i++) {\n                knownColumns.add(i + cellSpan.startColumn);\n              }\n            }\n          }\n        }\n\n        // Compute the colgroup and columns in the export\n        const colGroup = tableElement.querySelector(':scope > colgroup');\n        if (colGroup) {\n          // Only include the <col /> for rows that are in the output\n          const cols = Array.from(tableElement.querySelectorAll(':scope > colgroup > col')).filter((dom, i) => knownColumns.has(i));\n          colGroup.replaceChildren(...cols);\n        }\n\n        // Wrap direct descendant rows in a tbody for export\n        const rows = tableElement.querySelectorAll(':scope > tr');\n        if (rows.length > 0) {\n          const tBody = document.createElement('tbody');\n          for (const row of rows) {\n            tBody.appendChild(row);\n          }\n          tableElement.append(tBody);\n        }\n        return tableElement;\n      },\n      element: !isHTMLTableElement(element) && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) ? element.querySelector('table') : element\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      for (let x = 0; x < row.length; x++) {\n        const cell = row[x];\n        if (cell == null) {\n          continue;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);\n        if (cellNode !== null && tableCellNode.is(cellNode)) {\n          return {\n            x,\n            y\n          };\n        }\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    const self = this.getWritable();\n    self.__rowStriping = newRowStriping;\n    return self;\n  }\n  setFrozenColumns(columnCount) {\n    const self = this.getWritable();\n    self.__frozenColumnCount = columnCount;\n    return self;\n  }\n  getFrozenColumns() {\n    return this.getLatest().__frozenColumnCount;\n  }\n  setFrozenRows(rowCount) {\n    const self = this.getWritable();\n    self.__frozenRowCount = rowCount;\n    return self;\n  }\n  getFrozenRows() {\n    return this.getLatest().__frozenRowCount;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`$getElementForTableNode: Table Element Not Found`);\n  }\n  return getTable(tableNode, tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-column')) {\n    tableNode.setFrozenColumns(1);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-row')) {\n    tableNode.setFrozenRows(1);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      let width = col.style.width || '';\n      if (!PIXEL_VALUE_REG_EXP.test(width)) {\n        // Also support deprecated width attribute for google docs\n        width = col.getAttribute('width') || '';\n        if (!/^\\d+$/.test(width)) {\n          columns = undefined;\n          break;\n        }\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    after: children => (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$descendantsMatching)(children, $isTableRowNode),\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\nfunction $insertTableCommandListener({\n  rows,\n  columns,\n  includeHeaders\n}) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if (!selection || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return false;\n  }\n\n  // Prevent nested tables by checking if we're already inside a table\n  if ($findTableNode(selection.anchor.getNode())) {\n    return false;\n  }\n  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$insertNodeToNearestRoot)(tableNode);\n  const firstDescendant = tableNode.getFirstDescendant();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstDescendant)) {\n    firstDescendant.select();\n  }\n  return true;\n}\nfunction $tableCellTransform(node) {\n  if (!$isTableRowNode(node.getParent())) {\n    // TableCellNode must be a child of TableRowNode.\n    node.remove();\n  } else if (node.isEmpty()) {\n    // TableCellNode should never be empty\n    node.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n}\nfunction $tableRowTransform(node) {\n  if (!$isTableNode(node.getParent())) {\n    // TableRowNode must be a child of TableNode.\n    // TODO: Future support of tbody/thead/tfoot may change this\n    node.remove();\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$unwrapAndFilterDescendants)(node, $isTableCellNode);\n  }\n}\nfunction $tableTransform(node) {\n  // TableRowNode is the only valid child for TableNode\n  // TODO: Future support of tbody/thead/tfoot/caption may change this\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$unwrapAndFilterDescendants)(node, $isTableRowNode);\n  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);\n  const maxRowLength = gridMap.reduce((curLength, row) => {\n    return Math.max(curLength, row.length);\n  }, 0);\n  const rowNodes = node.getChildren();\n  for (let i = 0; i < gridMap.length; ++i) {\n    const rowNode = rowNodes[i];\n    if (!rowNode) {\n      continue;\n    }\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);\n    }\n    const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);\n    if (rowLength === maxRowLength) {\n      continue;\n    }\n    for (let j = rowLength; j < maxRowLength; ++j) {\n      // TODO: inherit header state from another header or body\n      const newCell = $createTableCellNode();\n      newCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      rowNode.append(newCell);\n    }\n  }\n}\nfunction $tableClickCommand(event) {\n  if (event.detail < 3 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target)) {\n    return false;\n  }\n  const startNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(event.target);\n  if (startNode === null) {\n    return false;\n  }\n  const blockNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (blockNode === null) {\n    return false;\n  }\n  const rootNode = blockNode.getParent();\n  if (!$isTableCellNode(rootNode)) {\n    return false;\n  }\n  blockNode.select(0);\n  return true;\n}\n\n/**\n * Register a transform to ensure that all TableCellNode have a colSpan and rowSpan of 1.\n * This should only be registered when you do not want to support merged cells.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTableCellUnmergeTransform(editor) {\n  return editor.registerNodeTransform(TableCellNode, node => {\n    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n      // When we have rowSpan we have to map the entire Table to understand where the new Cells\n      // fit best; let's analyze all Cells at once to save us from further transform iterations\n      const [,, gridNode] = $getNodeTriplet(node);\n      const [gridMap] = $computeTableMap(gridNode, node, node);\n      // TODO this function expects Tables to be normalized. Look into this once it exists\n      const rowsCount = gridMap.length;\n      const columnsCount = gridMap[0].length;\n      let row = gridNode.getFirstChild();\n      if (!$isTableRowNode(row)) {\n        formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n      }\n      const unmerged = [];\n      for (let i = 0; i < rowsCount; i++) {\n        if (i !== 0) {\n          row = row.getNextSibling();\n          if (!$isTableRowNode(row)) {\n            formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n          }\n        }\n        let lastRowCell = null;\n        for (let j = 0; j < columnsCount; j++) {\n          const cellMap = gridMap[i][j];\n          const cell = cellMap.cell;\n          if (cellMap.startRow === i && cellMap.startColumn === j) {\n            lastRowCell = cell;\n            unmerged.push(cell);\n          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n            if (!$isTableCellNode(cell)) {\n              formatDevErrorMessage(`Expected TableNode cell to be a TableCellNode`);\n            }\n            const newCell = $createTableCellNode(cell.__headerState);\n            if (lastRowCell !== null) {\n              lastRowCell.insertAfter(newCell);\n            } else {\n              (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$insertFirst)(row, newCell);\n            }\n          }\n        }\n      }\n      for (const cell of unmerged) {\n        cell.setColSpan(1);\n        cell.setRowSpan(1);\n      }\n    }\n  });\n}\nfunction registerTableSelectionObserver(editor, hasTabHandler = true) {\n  const tableSelections = new Map();\n  const initializeTableNode = (tableNode, nodeKey, dom) => {\n    const tableElement = getTableElement(tableNode, dom);\n    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n    tableSelections.set(nodeKey, [tableSelection, tableElement]);\n  };\n  const unregisterMutationListener = editor.registerMutationListener(TableNode, nodeMutations => {\n    editor.getEditorState().read(() => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        const tableSelection = tableSelections.get(nodeKey);\n        if (mutation === 'created' || mutation === 'updated') {\n          const {\n            tableNode,\n            tableElement\n          } = $getTableAndElementByKey(nodeKey);\n          if (tableSelection === undefined) {\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          } else if (tableElement !== tableSelection[1]) {\n            // The update created a new DOM node, destroy the existing TableObserver\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          }\n        } else if (mutation === 'destroyed') {\n          if (tableSelection !== undefined) {\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    }, {\n      editor\n    });\n  }, {\n    skipInitialization: false\n  });\n  return () => {\n    unregisterMutationListener();\n    // Hook might be called multiple times so cleaning up tables listeners as well,\n    // as it'll be reinitialized during recurring call\n    for (const [, [tableSelection]] of tableSelections) {\n      tableSelection.removeListeners();\n    }\n  };\n}\n\n/**\n * Register the INSERT_TABLE_COMMAND listener and the table integrity transforms. The\n * table selection observer should be registered separately after this with\n * {@link registerTableSelectionObserver}.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTablePlugin(editor) {\n  if (!editor.hasNodes([TableNode])) {\n    {\n      formatDevErrorMessage(`TablePlugin: TableNode is not registered on editor`);\n    }\n  }\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, ({\n    nodes,\n    selection\n  }, dispatchEditor) => {\n    if (editor !== dispatchEditor || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const isInsideTableCell = $findTableNode(selection.anchor.getNode()) !== null;\n    return isInsideTableCell && nodes.some($isTableNode);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLICK_COMMAND, $tableClickCommand, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyUjtBQUNvZ0M7QUFDMXNDOztBQUVyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0RBQVc7QUFDdkM7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0VBQStCLFdBQVcsb0RBQVcsV0FBVyx5REFBZ0I7QUFDNUYsY0FBYyxvREFBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osNEJBQTRCLDZEQUFvQjtBQUNoRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUFvQjtBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLHNEQUFhOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsZ0RBQVc7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9FQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBLDBCQUEwQix1QkFBdUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDZEQUFvQjtBQUNoRCwyQkFBMkIsd0RBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFLGtDQUFrQyxJQUFJLDZCQUE2QjtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNCQUFzQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkRBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakMsUUFBUSwwREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw2REFBb0I7QUFDbkYsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw2REFBb0I7QUFDbkYsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSxxQ0FBcUMsSUFBSSxnQ0FBZ0M7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2REFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0RBQWE7QUFDakMsUUFBUSwwREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELDZEQUFvQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFLHFDQUFxQztBQUN0RztBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQyxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHVCQUF1QjtBQUNyRCx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxZQUFZO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQyxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLG1DQUFtQyxxQkFBcUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0IsNkRBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHlEQUFnQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFhO0FBQ2pDLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtRUFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUJBQXlCLHVDQUF1QztBQUNoRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseUJBQXlCLDBDQUEwQztBQUNuRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQyxnRkFBZ0YsNkRBQW9CO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixzQkFBc0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQyxnR0FBZ0csNkRBQW9CO0FBQ3BIO0FBQ0EsUUFBUTtBQUNSLGtDQUFrQyxRQUFRO0FBQzFDLCtGQUErRiw2REFBb0I7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsOEJBQThCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0JBQXNCLGFBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osa0JBQWtCLG1FQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrQkFBa0IsbUVBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4Qyx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsYUFBYTtBQUNuQyx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUVBQW1CO0FBQ3hDO0FBQ0EsdURBQXVELEdBQUcsK0NBQStDLGVBQWUsVUFBVSxlQUFlO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxHQUFHO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxHQUFHO0FBQzFEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLDZCQUE2QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMscURBQVkseURBQXlELHFEQUFZO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseURBQWdCO0FBQzFCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLHdEQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdURBQWM7QUFDdkI7QUFDQTtBQUNBLHNCQUFzQiwwRUFBaUM7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEMsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdFQUF1QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFEQUFZO0FBQzdCLGdCQUFnQixxREFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGNBQWM7QUFDbEY7QUFDQTtBQUNBLHFFQUFxRSxlQUFlLGtCQUFrQixhQUFhO0FBQ25IO0FBQ0E7QUFDQSxvRUFBb0UsY0FBYyxrQkFBa0IsYUFBYTtBQUNqSCxNQUFNO0FBQ047QUFDQSx3QkFBd0Isc0RBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsZ0RBQWdEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBLE1BQU0sMENBQTBDLHVEQUFjO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUF5RCxtREFBVTtBQUNuRSxvQkFBb0Isc0RBQWE7QUFDakM7QUFDQSxrRUFBa0UsY0FBYztBQUNoRjtBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsYUFBYTtBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRLHNEQUFhO0FBQ3JCLE1BQU0sc0RBQWE7QUFDbkIsNkJBQTZCLDZEQUF3QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSSwyRUFBMkI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0gsbUJBQW1CLFNBQVMsa0JBQWtCO0FBQ3BLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3REFBZTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFhO0FBQ3JCLCtCQUErQiw2REFBd0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0RBQWE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4REFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIseURBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksc0RBQWE7QUFDakIsZ0NBQWdDLDZEQUF3QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBVztBQUNyQiwrQkFBK0IsNkRBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1REFBYztBQUN4Qiw4QkFBOEIsNkRBQW9CO0FBQ2xELHlCQUF5Qix3REFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLHNEQUFhO0FBQ2pCLDJCQUEyQiw2REFBd0I7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzREFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxhQUFhO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHNCQUFzQjtBQUMvRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMkRBQXNCLFlBQVkseURBQW9CLFVBQVUsMkRBQXNCLGdCQUFnQiw0REFBdUI7QUFDekssOEJBQThCLHdEQUFtQixFQUFFLHdEQUFtQixFQUFFLDZEQUF3QjtBQUNoRyw2QkFBNkIsMERBQXFCLEVBQUUsdURBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtEQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCwrQkFBK0IsNkRBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0RBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4REFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLDBEQUFpQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2QkFBNkIsa0RBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isa0RBQVM7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNKQUFzSiwwREFBcUI7QUFDM0s7QUFDQSw2REFBNkQsdURBQWtCO0FBQy9FLHNCQUFzQixzREFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUsMERBQXFCO0FBQzFCO0FBQ0Esc0JBQXNCLHNEQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sU0FBUywwREFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUVBQW1CLGtDQUFrQyx1REFBYztBQUNwRyw0REFBNEQsbUVBQW1CLDBCQUEwQix1REFBYztBQUN2SCxXQUFXLHVEQUFjLDhCQUE4Qix1REFBYztBQUNyRTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyw4REFBeUI7QUFDN0g7QUFDQTtBQUNBLHNCQUFzQixzREFBYTtBQUNuQywwQ0FBMEMsMERBQWlCO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLDhEQUF5QjtBQUNySDtBQUNBLDZEQUE2RCxnREFBVztBQUN4RSxzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQSw0Q0FBNEMsMERBQWlCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRUFBZSxTQUFTLGlFQUFpQix3Q0FBd0Msa0ZBQThCO0FBQzFIO0FBQ0EsVUFBVSwwREFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDhEQUF5QjtBQUM5Qiw2REFBNkQsd0RBQW1CO0FBQ2hGLHNCQUFzQixzREFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsMERBQWlCO0FBQ2hDLDRCQUE0QixtRUFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw4REFBeUI7QUFDOUIsNkRBQTZELDJEQUFzQjtBQUNuRixzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEMsOEJBQThCLGdCQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5QkFBeUI7QUFDakQ7QUFDQSxjQUFjLHVEQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw4REFBeUI7QUFDOUIsNkRBQTZELHNFQUFpQztBQUM5RixzQkFBc0Isc0RBQWE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLDBEQUFpQjtBQUNoQyw0QkFBNEIsbUVBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSx3REFBZTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDhEQUF5QjtBQUM5QjtBQUNBLCtEQUErRCxvREFBZTtBQUM5RSx3QkFBd0Isc0RBQWE7QUFDckMsV0FBVywwREFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLDhEQUF5QjtBQUNoQztBQUNBLDZEQUE2RCxrREFBYTtBQUMxRTtBQUNBLEdBQUcsRUFBRSwwREFBcUI7QUFDMUIsNkRBQTZELDZFQUF3QztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDZCQUE2QiwwREFBaUI7QUFDOUMsd0RBQXdELG1FQUFtQixtRUFBbUUsbUVBQW1CO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUVBQW1CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBCQUEwQjtBQUN2RCwrQkFBK0IsMEJBQTBCO0FBQ3pEO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFLCtCQUErQixtQ0FBbUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRCw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsY0FBYyxvREFBVztBQUN6QixrQ0FBa0MsNkRBQW9CO0FBQ3REO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDhEQUF5QjtBQUM5Qiw2REFBNkQsNkRBQXdCO0FBQ3JGLHNCQUFzQixzREFBYTtBQUNuQywwQkFBMEIsOERBQXFCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMERBQWlCLG1CQUFtQiwwREFBaUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtRUFBbUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBYTtBQUNyQjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RywwREFBaUI7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJCQUEyQix3REFBZTtBQUMxQztBQUNBLDBCQUEwQixtRUFBMEI7QUFDcEQ7QUFDQSwyQkFBMkIsbUVBQTBCO0FBQ3JEO0FBQ0E7QUFDQSwrQkFBK0IscUVBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw4REFBeUI7QUFDOUIsNkRBQTZELDZEQUF3QjtBQUNyRixzQkFBc0Isc0RBQWE7QUFDbkMsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw4REFBeUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtRUFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQkFBMEI7QUFDM0U7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtRUFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx5QkFBeUI7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsU0FBUyxJQUFJLGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxTQUFTLElBQUksZ0JBQWdCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEVBQUUsc0VBQXNCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyRUFBMkI7QUFDN0I7QUFDQTtBQUNBLG1CQUFtQixtRUFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1FQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCO0FBQ3RFLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdEQUFlO0FBQ3RDLE1BQU0sb0VBQTJCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNERBQW1CO0FBQzdDLFVBQVUsd0RBQWUsZUFBZSx1REFBYztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MseURBQWdCO0FBQ3hELDBCQUEwQixtRUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsaURBQWlELHlEQUFnQjtBQUNqRSxNQUFNLDJEQUFrQjtBQUN4QixNQUFNLDJEQUFrQjtBQUN4QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSw0QkFBNEIsd0RBQWU7QUFDM0MsSUFBSSwyREFBa0I7QUFDdEIsSUFBSSwyREFBa0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwrREFBc0I7QUFDekMsU0FBUyxzREFBYSxhQUFhLHdEQUFlO0FBQ2xEO0FBQ0E7QUFDQSwwQkFBMEIsNERBQW1CO0FBQzdDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBYTtBQUN2QixlQUFlLHVEQUFjO0FBQzdCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBYTtBQUNqQztBQUNBLFFBQVEsMERBQWlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1FQUFtQjtBQUNuRDtBQUNBLDhCQUE4QixtRUFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdURBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix1REFBYztBQUM5QjtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxvREFBVztBQUM5RSxVQUFVLHNEQUFhO0FBQ3ZCO0FBQ0E7QUFDQSxVQUFVLFNBQVMsNERBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixnQ0FBZ0MsbUVBQW1CLGlCQUFpQix1REFBYztBQUNsRjtBQUNBLDhCQUE4QixtRUFBbUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDZCQUE2QixtRUFBbUI7QUFDaEQsNEJBQTRCLG1FQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw2QkFBNkIsd0RBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQkFBMkIsbUVBQW1CO0FBQzlDLDBCQUEwQixtRUFBbUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkRBQW9CO0FBQzVDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsd0RBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtRUFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1FQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG1FQUEwQjtBQUM5RTs7QUFFQTtBQUNBLFNBQVMsNkRBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0EsSUFBSTtBQUNKLElBQUksMkVBQTJCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBLElBQUk7QUFDSixJQUFJLDJFQUEyQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQSxJQUFJO0FBQ0osSUFBSSwyRUFBMkI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDJFQUEyQjtBQUM3QixFQUFFLHNFQUFzQjtBQUN4QjtBQUNBO0FBQ0EsNENBQTRDLG1EQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGdEQUFXO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSx3REFBZTtBQUNuQixJQUFJLHNFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzRUFBc0I7QUFDOUIsUUFBUTtBQUNSLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsNkRBQWU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0JBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsK0NBQStDLDZEQUFlO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtRUFBMEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvRUFBb0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0Isc0RBQWEsTUFBTSw4REFBcUI7QUFDNUQscUJBQXFCLDBEQUFpQjtBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHdFQUF3QjtBQUMxQjtBQUNBLE1BQU0sb0RBQVc7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdCQUFnQiw2REFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSSwyRUFBMkI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsMkVBQTJCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRywwQkFBMEIsUUFBUSxrQkFBa0I7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBLHFCQUFxQiw2REFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrREFBUztBQUNwQztBQUNBO0FBQ0Esb0JBQW9CLG1FQUEwQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQW1CLG9CQUFvQix1REFBYztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWMsNERBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHFDQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkRBQWEsMkVBQTJFLDREQUF1QiwwQkFBMEIsNkVBQXdDO0FBQzFMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0NBQXNDLDBEQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSw0REFBdUIsMEJBQTBCLGtEQUFhLHNCQUFzQiw0REFBdUI7QUFDaEg7O0FBRXV2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGFibGUvTGV4aWNhbFRhYmxlLmRldi5tanM/ZjNjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsICRkZXNjZW5kYW50c01hdGNoaW5nLCAkZmluZE1hdGNoaW5nUGFyZW50LCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIG9iamVjdEtsYXNzRXF1YWxzLCBpc0hUTUxFbGVtZW50IGFzIGlzSFRNTEVsZW1lbnQkMSwgJGluc2VydEZpcnN0IGFzICRpbnNlcnRGaXJzdCQxLCBtZXJnZVJlZ2lzdGVyLCAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3QsICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50cyB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IEVsZW1lbnROb2RlLCBpc0hUTUxFbGVtZW50LCAkaXNJbmxpbmVFbGVtZW50T3JEZWNvcmF0b3JOb2RlLCAkaXNUZXh0Tm9kZSwgJGlzTGluZUJyZWFrTm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRhcHBseU5vZGVSZXBsYWNlbWVudCwgY3JlYXRlQ29tbWFuZCwgJGNyZWF0ZVRleHROb2RlLCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzUGFyYWdyYXBoTm9kZSwgJGNyZWF0ZVBvaW50LCAkaXNFbGVtZW50Tm9kZSwgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCBpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSwgVEVYVF9UWVBFX1RPX0ZPUk1BVCwgJGdldE5vZGVCeUtleSwgJGdldEVkaXRvciwgJHNldFNlbGVjdGlvbiwgU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCBnZXRET01TZWxlY3Rpb24sICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgJGlzUm9vdE5vZGUsIElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9ISUdILCBLRVlfRVNDQVBFX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwsIENVVF9DT01NQU5ELCBGT1JNQVRfVEVYVF9DT01NQU5ELCBGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIEtFWV9UQUJfQ09NTUFORCwgRk9DVVNfQ09NTUFORCwgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbSwgJGlzUm9vdE9yU2hhZG93Um9vdCwgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIEtFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBERUxFVEVfV09SRF9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgS0VZX0RFTEVURV9DT01NQU5ELCBpc0RPTU5vZGUsICRjYXJldEZyb21Qb2ludCwgJGlzRXh0ZW5kYWJsZVRleHRQb2ludENhcmV0LCAkZXh0ZW5kQ2FyZXRUb1JhbmdlLCAkaXNTaWJsaW5nQ2FyZXQsICRnZXRTaWJsaW5nQ2FyZXQsICRzZXRQb2ludEZyb21DYXJldCwgJG5vcm1hbGl6ZUNhcmV0LCAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0LCAkaXNDaGlsZENhcmV0LCAkZ2V0Q2hpbGRDYXJldCwgc2V0RE9NVW5tYW5hZ2VkLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiwgQ0xJQ0tfQ09NTUFORCB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgY29weVRvQ2xpcGJvYXJkLCAkZ2V0Q2xpcGJvYXJkRGF0YUZyb21TZWxlY3Rpb24gfSBmcm9tICdAbGV4aWNhbC9jbGlwYm9hcmQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFBJWEVMX1ZBTFVFX1JFR19FWFAgPSAvXihcXGQrKD86XFwuXFxkKyk/KXB4JC87XG5cbi8vIC5QbGF5Z3JvdW5kRWRpdG9yVGhlbWVfX3RhYmxlQ2VsbCB3aWR0aCB2YWx1ZSBmcm9tXG4vLyBwYWNrYWdlcy9sZXhpY2FsLXBsYXlncm91bmQvc3JjL3RoZW1lcy9QbGF5Z3JvdW5kRWRpdG9yVGhlbWUuY3NzXG5jb25zdCBDT0xVTU5fV0lEVEggPSA3NTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMgPSB7XG4gIEJPVEg6IDMsXG4gIENPTFVNTjogMixcbiAgTk9fU1RBVFVTOiAwLFxuICBST1c6IDFcbn07XG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVDZWxsTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZWNlbGwnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZUNlbGxOb2RlKG5vZGUuX19oZWFkZXJTdGF0ZSwgbm9kZS5fX2NvbFNwYW4sIG5vZGUuX193aWR0aCwgbm9kZS5fX2tleSk7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20obm9kZSkge1xuICAgIHN1cGVyLmFmdGVyQ2xvbmVGcm9tKG5vZGUpO1xuICAgIHRoaXMuX19yb3dTcGFuID0gbm9kZS5fX3Jvd1NwYW47XG4gICAgdGhpcy5fX2JhY2tncm91bmRDb2xvciA9IG5vZGUuX19iYWNrZ3JvdW5kQ29sb3I7XG4gICAgdGhpcy5fX3ZlcnRpY2FsQWxpZ24gPSBub2RlLl9fdmVydGljYWxBbGlnbjtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICB0aDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZUNlbGxOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRIZWFkZXJTdHlsZXMoc2VyaWFsaXplZE5vZGUuaGVhZGVyU3RhdGUpLnNldENvbFNwYW4oc2VyaWFsaXplZE5vZGUuY29sU3BhbiB8fCAxKS5zZXRSb3dTcGFuKHNlcmlhbGl6ZWROb2RlLnJvd1NwYW4gfHwgMSkuc2V0V2lkdGgoc2VyaWFsaXplZE5vZGUud2lkdGggfHwgdW5kZWZpbmVkKS5zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VyaWFsaXplZE5vZGUuYmFja2dyb3VuZENvbG9yIHx8IG51bGwpLnNldFZlcnRpY2FsQWxpZ24oc2VyaWFsaXplZE5vZGUudmVydGljYWxBbGlnbiB8fCB1bmRlZmluZWQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgY29sU3BhbiA9IDEsIHdpZHRoLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19jb2xTcGFuID0gY29sU3BhbjtcbiAgICB0aGlzLl9fcm93U3BhbiA9IDE7XG4gICAgdGhpcy5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGU7XG4gICAgdGhpcy5fX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fX2JhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgdGhpcy5fX3ZlcnRpY2FsQWxpZ24gPSB1bmRlZmluZWQ7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuZ2V0VGFnKCkpO1xuICAgIGlmICh0aGlzLl9fd2lkdGgpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9fd2lkdGh9cHhgO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICBlbGVtZW50LmNvbFNwYW4gPSB0aGlzLl9fY29sU3BhbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19yb3dTcGFuID4gMSkge1xuICAgICAgZWxlbWVudC5yb3dTcGFuID0gdGhpcy5fX3Jvd1NwYW47XG4gICAgfVxuICAgIGlmICh0aGlzLl9fYmFja2dyb3VuZENvbG9yICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX19iYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICAgIGlmIChpc1ZhbGlkVmVydGljYWxBbGlnbih0aGlzLl9fdmVydGljYWxBbGlnbikpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IHRoaXMuX192ZXJ0aWNhbEFsaWduO1xuICAgIH1cbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZUNlbGwsIHRoaXMuaGFzSGVhZGVyKCkgJiYgY29uZmlnLnRoZW1lLnRhYmxlQ2VsbEhlYWRlcik7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IG91dHB1dCA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuICAgIGlmIChpc0hUTUxFbGVtZW50KG91dHB1dC5lbGVtZW50KSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IG91dHB1dC5lbGVtZW50O1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGVtcG9yYXJ5LXRhYmxlLWNlbGwtbGV4aWNhbC1rZXknLCB0aGlzLmdldEtleSgpKTtcbiAgICAgIGVsZW1lbnQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCBibGFjayc7XG4gICAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgIGVsZW1lbnQuY29sU3BhbiA9IHRoaXMuX19jb2xTcGFuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19yb3dTcGFuID4gMSkge1xuICAgICAgICBlbGVtZW50LnJvd1NwYW4gPSB0aGlzLl9fcm93U3BhbjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLmdldFdpZHRoKCkgfHwgQ09MVU1OX1dJRFRIfXB4YDtcbiAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IHRoaXMuZ2V0VmVydGljYWxBbGlnbigpIHx8ICd0b3AnO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSAnc3RhcnQnO1xuICAgICAgaWYgKHRoaXMuX19iYWNrZ3JvdW5kQ29sb3IgPT09IG51bGwgJiYgdGhpcy5oYXNIZWFkZXIoKSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZjJmM2Y1JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICAuLi4oaXNWYWxpZFZlcnRpY2FsQWxpZ24odGhpcy5fX3ZlcnRpY2FsQWxpZ24pICYmIHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5fX3ZlcnRpY2FsQWxpZ25cbiAgICAgIH0pLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmdldEJhY2tncm91bmRDb2xvcigpLFxuICAgICAgY29sU3BhbjogdGhpcy5fX2NvbFNwYW4sXG4gICAgICBoZWFkZXJTdGF0ZTogdGhpcy5fX2hlYWRlclN0YXRlLFxuICAgICAgcm93U3BhbjogdGhpcy5fX3Jvd1NwYW4sXG4gICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpXG4gICAgfTtcbiAgfVxuICBnZXRDb2xTcGFuKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fY29sU3BhbjtcbiAgfVxuICBzZXRDb2xTcGFuKGNvbFNwYW4pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19jb2xTcGFuID0gY29sU3BhbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRSb3dTcGFuKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fcm93U3BhbjtcbiAgfVxuICBzZXRSb3dTcGFuKHJvd1NwYW4pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19yb3dTcGFuID0gcm93U3BhbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzSGVhZGVyKCkgPyAndGgnIDogJ3RkJztcbiAgfVxuICBzZXRIZWFkZXJTdHlsZXMoaGVhZGVyU3RhdGUsIG1hc2sgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQk9USCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGUgJiBtYXNrIHwgc2VsZi5fX2hlYWRlclN0YXRlICYgfm1hc2s7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0SGVhZGVyU3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVhZGVyU3RhdGU7XG4gIH1cbiAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX193aWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fd2lkdGg7XG4gIH1cbiAgZ2V0QmFja2dyb3VuZENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIHNldEJhY2tncm91bmRDb2xvcihuZXdCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19iYWNrZ3JvdW5kQ29sb3IgPSBuZXdCYWNrZ3JvdW5kQ29sb3I7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0VmVydGljYWxBbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3ZlcnRpY2FsQWxpZ247XG4gIH1cbiAgc2V0VmVydGljYWxBbGlnbihuZXdWZXJ0aWNhbEFsaWduKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fdmVydGljYWxBbGlnbiA9IG5ld1ZlcnRpY2FsQWxpZ24gfHwgdW5kZWZpbmVkO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHRvZ2dsZUhlYWRlclN0eWxlKGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGlmICgoc2VsZi5fX2hlYWRlclN0YXRlICYgaGVhZGVyU3RhdGVUb1RvZ2dsZSkgPT09IGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICAgIHNlbGYuX19oZWFkZXJTdGF0ZSAtPSBoZWFkZXJTdGF0ZVRvVG9nZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9faGVhZGVyU3RhdGUgKz0gaGVhZGVyU3RhdGVUb1RvZ2dsZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaGFzSGVhZGVyU3RhdGUoaGVhZGVyU3RhdGUpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0SGVhZGVyU3R5bGVzKCkgJiBoZWFkZXJTdGF0ZSkgPT09IGhlYWRlclN0YXRlO1xuICB9XG4gIGhhc0hlYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2hlYWRlclN0YXRlICE9PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX2hlYWRlclN0YXRlICE9PSB0aGlzLl9faGVhZGVyU3RhdGUgfHwgcHJldk5vZGUuX193aWR0aCAhPT0gdGhpcy5fX3dpZHRoIHx8IHByZXZOb2RlLl9fY29sU3BhbiAhPT0gdGhpcy5fX2NvbFNwYW4gfHwgcHJldk5vZGUuX19yb3dTcGFuICE9PSB0aGlzLl9fcm93U3BhbiB8fCBwcmV2Tm9kZS5fX2JhY2tncm91bmRDb2xvciAhPT0gdGhpcy5fX2JhY2tncm91bmRDb2xvciB8fCBwcmV2Tm9kZS5fX3ZlcnRpY2FsQWxpZ24gIT09IHRoaXMuX192ZXJ0aWNhbEFsaWduO1xuICB9XG4gIGlzU2hhZG93Um9vdCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZFZlcnRpY2FsQWxpZ24odmVydGljYWxBbGlnbikge1xuICByZXR1cm4gdmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScgfHwgdmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbSc7XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgZG9tTm9kZV8gPSBkb21Ob2RlO1xuICBjb25zdCBub2RlTmFtZSA9IGRvbU5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IHdpZHRoID0gdW5kZWZpbmVkO1xuICBpZiAoUElYRUxfVkFMVUVfUkVHX0VYUC50ZXN0KGRvbU5vZGVfLnN0eWxlLndpZHRoKSkge1xuICAgIHdpZHRoID0gcGFyc2VGbG9hdChkb21Ob2RlXy5zdHlsZS53aWR0aCk7XG4gIH1cbiAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKG5vZGVOYW1lID09PSAndGgnID8gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVyA6IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMsIGRvbU5vZGVfLmNvbFNwYW4sIHdpZHRoKTtcbiAgdGFibGVDZWxsTm9kZS5fX3Jvd1NwYW4gPSBkb21Ob2RlXy5yb3dTcGFuO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkb21Ob2RlXy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09ICcnKSB7XG4gICAgdGFibGVDZWxsTm9kZS5fX2JhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgfVxuICBjb25zdCB2ZXJ0aWNhbEFsaWduID0gZG9tTm9kZV8uc3R5bGUudmVydGljYWxBbGlnbjtcbiAgaWYgKGlzVmFsaWRWZXJ0aWNhbEFsaWduKHZlcnRpY2FsQWxpZ24pKSB7XG4gICAgdGFibGVDZWxsTm9kZS5fX3ZlcnRpY2FsQWxpZ24gPSB2ZXJ0aWNhbEFsaWduO1xuICB9XG4gIGNvbnN0IHN0eWxlID0gZG9tTm9kZV8uc3R5bGU7XG4gIGNvbnN0IHRleHREZWNvcmF0aW9uID0gKHN0eWxlICYmIHN0eWxlLnRleHREZWNvcmF0aW9uIHx8ICcnKS5zcGxpdCgnICcpO1xuICBjb25zdCBoYXNCb2xkRm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHQgPT09ICc3MDAnIHx8IHN0eWxlLmZvbnRXZWlnaHQgPT09ICdib2xkJztcbiAgY29uc3QgaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbiA9IHRleHREZWNvcmF0aW9uLmluY2x1ZGVzKCdsaW5lLXRocm91Z2gnKTtcbiAgY29uc3QgaGFzSXRhbGljRm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID09PSAnaXRhbGljJztcbiAgY29uc3QgaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygndW5kZXJsaW5lJyk7XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGNoaWxkTGV4aWNhbE5vZGVzID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgbGV0IHBhcmFncmFwaE5vZGUgPSBudWxsO1xuICAgICAgY29uc3QgcmVtb3ZlU2luZ2xlTGluZUJyZWFrTm9kZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHBhcmFncmFwaE5vZGUpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyYWdyYXBoTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgICAgaWYgKCRpc0xpbmVCcmVha05vZGUoZmlyc3RDaGlsZCkgJiYgcGFyYWdyYXBoTm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgICAgICAgZmlyc3RDaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkTGV4aWNhbE5vZGVzKSB7XG4gICAgICAgIGlmICgkaXNJbmxpbmVFbGVtZW50T3JEZWNvcmF0b3JOb2RlKGNoaWxkKSB8fCAkaXNUZXh0Tm9kZShjaGlsZCkgfHwgJGlzTGluZUJyZWFrTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoaGFzQm9sZEZvbnRXZWlnaHQpIHtcbiAgICAgICAgICAgICAgY2hpbGQudG9nZ2xlRm9ybWF0KCdib2xkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICBjaGlsZC50b2dnbGVGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNJdGFsaWNGb250U3R5bGUpIHtcbiAgICAgICAgICAgICAgY2hpbGQudG9nZ2xlRm9ybWF0KCdpdGFsaWMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNVbmRlcmxpbmVUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICBjaGlsZC50b2dnbGVGb3JtYXQoJ3VuZGVybGluZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYWdyYXBoTm9kZSkge1xuICAgICAgICAgICAgcGFyYWdyYXBoTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYWdyYXBoTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICByZW1vdmVTaW5nbGVMaW5lQnJlYWtOb2RlKCk7XG4gICAgICAgICAgcGFyYWdyYXBoTm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbW92ZVNpbmdsZUxpbmVCcmVha05vZGUoKTtcbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIG5vZGU6IHRhYmxlQ2VsbE5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgY29sU3BhbiA9IDEsIHdpZHRoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIGNvbFNwYW4sIHdpZHRoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZUNlbGxOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJsZUNlbGxOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IElOU0VSVF9UQUJMRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1RBQkxFX0NPTU1BTkQnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscy5cblxuZnVuY3Rpb24gZm9ybWF0RGV2RXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJsZVJvd05vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3RhYmxlcm93JztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGFibGVSb3dOb2RlKG5vZGUuX19oZWlnaHQsIG5vZGUuX19rZXkpO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVSb3dFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZVJvd05vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldEhlaWdodChzZXJpYWxpemVkTm9kZS5oZWlnaHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGhlaWdodCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9faGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgLi4uKGhlaWdodCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDoge1xuICAgICAgICBoZWlnaHRcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgaWYgKHRoaXMuX19oZWlnaHQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5fX2hlaWdodH1weGA7XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlUm93KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uID09PSAnaHRtbCc7XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVpZ2h0O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX2hlaWdodCAhPT0gdGhpcy5fX2hlaWdodDtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlUm93RWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGRvbU5vZGVfID0gZG9tTm9kZTtcbiAgbGV0IGhlaWdodCA9IHVuZGVmaW5lZDtcbiAgaWYgKFBJWEVMX1ZBTFVFX1JFR19FWFAudGVzdChkb21Ob2RlXy5zdHlsZS5oZWlnaHQpKSB7XG4gICAgaGVpZ2h0ID0gcGFyc2VGbG9hdChkb21Ob2RlXy5zdHlsZS5oZWlnaHQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGNoaWxkcmVuID0+ICRkZXNjZW5kYW50c01hdGNoaW5nKGNoaWxkcmVuLCAkaXNUYWJsZUNlbGxOb2RlKSxcbiAgICBub2RlOiAkY3JlYXRlVGFibGVSb3dOb2RlKGhlaWdodClcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZVJvd05vZGUoaGVpZ2h0KSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlUm93Tm9kZShoZWlnaHQpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlUm93Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFibGVSb3dOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBJU19GSVJFRk9YID0gQ0FOX1VTRV9ET00gJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuQ0FOX1VTRV9ET00gJiYgJ0lucHV0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlID8gJ2dldFRhcmdldFJhbmdlcycgaW4gbmV3IHdpbmRvdy5JbnB1dEV2ZW50KCdpbnB1dCcpIDogZmFsc2U7XG5cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZU5vZGVXaXRoRGltZW5zaW9ucyhyb3dDb3VudCwgY29sdW1uQ291bnQsIGluY2x1ZGVIZWFkZXJzID0gdHJ1ZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkY3JlYXRlVGFibGVOb2RlKCk7XG4gIGZvciAobGV0IGlSb3cgPSAwOyBpUm93IDwgcm93Q291bnQ7IGlSb3crKykge1xuICAgIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpQ29sdW1uID0gMDsgaUNvbHVtbiA8IGNvbHVtbkNvdW50OyBpQ29sdW1uKyspIHtcbiAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICBpZiAodHlwZW9mIGluY2x1ZGVIZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaVJvdyA9PT0gMCAmJiBpbmNsdWRlSGVhZGVycy5yb3dzKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaUNvbHVtbiA9PT0gMCAmJiBpbmNsdWRlSGVhZGVycy5jb2x1bW5zKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlSGVhZGVycykge1xuICAgICAgICBpZiAoaVJvdyA9PT0gMCkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlDb2x1bW4gPT09IDApIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpO1xuICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCgkY3JlYXRlVGV4dE5vZGUoKSk7XG4gICAgICB0YWJsZUNlbGxOb2RlLmFwcGVuZChwYXJhZ3JhcGhOb2RlKTtcbiAgICAgIHRhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgfVxuICAgIHRhYmxlTm9kZS5hcHBlbmQodGFibGVSb3dOb2RlKTtcbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbE5vZGVGcm9tTGV4aWNhbE5vZGUoc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3coc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZVJvd05vZGUobikpO1xuICBpZiAoJGlzVGFibGVSb3dOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0YWJsZSBjZWxsIHRvIGJlIGluc2lkZSBvZiB0YWJsZSByb3cuJyk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVOb2RlRnJvbUxleGljYWxOb2RlT3JUaHJvdyhzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlTm9kZShuKSk7XG4gIGlmICgkaXNUYWJsZU5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlLicpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlUm93SW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHRhYmxlUm93Tm9kZSk7XG4gIHJldHVybiB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlUm93Tm9kZSkpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ29sdW1uSW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIHJldHVybiB0YWJsZVJvd05vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlQ2VsbE5vZGUpKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHRhYmxlQ2VsbE5vZGUpO1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGUpO1xuICByZXR1cm4ge1xuICAgIGFib3ZlOiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSAtIDEsIHRhYmxlKSxcbiAgICBiZWxvdzogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHkgKyAxLCB0YWJsZSksXG4gICAgbGVmdDogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHggLSAxLCB5LCB0YWJsZSksXG4gICAgcmlnaHQ6IHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkcyh4ICsgMSwgeSwgdGFibGUpXG4gIH07XG59XG5mdW5jdGlvbiAkcmVtb3ZlVGFibGVSb3dBdEluZGV4KHRhYmxlTm9kZSwgaW5kZXhUb0RlbGV0ZSkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgaWYgKGluZGV4VG9EZWxldGUgPj0gdGFibGVSb3dzLmxlbmd0aCB8fCBpbmRleFRvRGVsZXRlIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGFibGUgY2VsbCB0byBiZSBpbnNpZGUgb2YgdGFibGUgcm93LicpO1xuICB9XG4gIGNvbnN0IHRhcmdldFJvd05vZGUgPSB0YWJsZVJvd3NbaW5kZXhUb0RlbGV0ZV07XG4gIHRhcmdldFJvd05vZGUucmVtb3ZlKCk7XG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IG1lcmdlZCBjZWxscy4gVXNlIHtAbGluayAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbn0gb3Ige0BsaW5rICRpbnNlcnRUYWJsZVJvd0F0Tm9kZX0gaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlUm93KHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgsIHNob3VsZEluc2VydEFmdGVyID0gdHJ1ZSwgcm93Q291bnQsIHRhYmxlKSB7XG4gIGNvbnN0IHRhYmxlUm93cyA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dzLmxlbmd0aCB8fCB0YXJnZXRJbmRleCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIHJvdyB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0Um93Tm9kZSA9IHRhYmxlUm93c1t0YXJnZXRJbmRleF07XG4gIGlmICgkaXNUYWJsZVJvd05vZGUodGFyZ2V0Um93Tm9kZSkpIHtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgIGNvbnN0IHRhYmxlUm93Q2VsbHMgPSB0YXJnZXRSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBjb25zdCB0YWJsZUNvbHVtbkNvdW50ID0gdGFibGVSb3dDZWxscy5sZW5ndGg7XG4gICAgICBjb25zdCBuZXdUYWJsZVJvd05vZGUgPSAkY3JlYXRlVGFibGVSb3dOb2RlKCk7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRhYmxlQ29sdW1uQ291bnQ7IGMrKykge1xuICAgICAgICBjb25zdCB0YWJsZUNlbGxGcm9tVGFyZ2V0Um93ID0gdGFibGVSb3dDZWxsc1tjXTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbEZyb21UYXJnZXRSb3cpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0YWJsZSBjZWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFib3ZlLFxuICAgICAgICAgIGJlbG93XG4gICAgICAgIH0gPSAkZ2V0VGFibGVDZWxsU2libGluZ3NGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxGcm9tVGFyZ2V0Um93LCB0YWJsZSk7XG4gICAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gYWJvdmUgJiYgYWJvdmUuZ2V0V2lkdGgoKSB8fCBiZWxvdyAmJiBiZWxvdy5nZXRXaWR0aCgpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFib3ZlICYmIGFib3ZlLmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pIHx8IGJlbG93ICYmIGJlbG93Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIDEsIHdpZHRoKTtcbiAgICAgICAgdGFibGVDZWxsTm9kZS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgIG5ld1RhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW5zZXJ0QWZ0ZXIpIHtcbiAgICAgICAgdGFyZ2V0Um93Tm9kZS5pbnNlcnRBZnRlcihuZXdUYWJsZVJvd05vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Um93Tm9kZS5pbnNlcnRCZWZvcmUobmV3VGFibGVSb3dOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb3cgYmVmb3JlIGluc2VydGlvbiBpbmRleCBkb2VzIG5vdCBleGlzdC4nKTtcbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuY29uc3QgZ2V0SGVhZGVyU3RhdGUgPSAoY3VycmVudFN0YXRlLCBwb3NzaWJsZVN0YXRlKSA9PiB7XG4gIGlmIChjdXJyZW50U3RhdGUgPT09IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5CT1RIIHx8IGN1cnJlbnRTdGF0ZSA9PT0gcG9zc2libGVTdGF0ZSkge1xuICAgIHJldHVybiBwb3NzaWJsZVN0YXRlO1xuICB9XG4gIHJldHVybiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgdGFibGUgcm93IGJlZm9yZSBvciBhZnRlciB0aGUgY3VycmVudCBmb2N1cyBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGluc2VydGVkIHRhYmxlIHJvdyBub2RlLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbihpbnNlcnRBZnRlciA9IHRydWUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2FuY2hvckNlbGxdID0gJGdldE5vZGVUcmlwbGV0KGFuY2hvcik7XG4gIGNvbnN0IFtmb2N1c0NlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFssIGZvY3VzQ2VsbE1hcCwgYW5jaG9yQ2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGZvY3VzQ2VsbCwgYW5jaG9yQ2VsbCk7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogYW5jaG9yU3RhcnRSb3dcbiAgfSA9IGFuY2hvckNlbGxNYXA7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogZm9jdXNTdGFydFJvd1xuICB9ID0gZm9jdXNDZWxsTWFwO1xuICBpZiAoaW5zZXJ0QWZ0ZXIpIHtcbiAgICByZXR1cm4gJGluc2VydFRhYmxlUm93QXROb2RlKGFuY2hvclN0YXJ0Um93ICsgYW5jaG9yQ2VsbC5fX3Jvd1NwYW4gPiBmb2N1c1N0YXJ0Um93ICsgZm9jdXNDZWxsLl9fcm93U3BhbiA/IGFuY2hvckNlbGwgOiBmb2N1c0NlbGwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAkaW5zZXJ0VGFibGVSb3dBdE5vZGUoZm9jdXNTdGFydFJvdyA8IGFuY2hvclN0YXJ0Um93ID8gZm9jdXNDZWxsIDogYW5jaG9yQ2VsbCwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJGluc2VydFRhYmxlUm93QXRTZWxlY3Rpb259XG4gKi9cbmNvbnN0ICRpbnNlcnRUYWJsZVJvd19fRVhQRVJJTUVOVEFMID0gJGluc2VydFRhYmxlUm93QXRTZWxlY3Rpb247XG5cbi8qKlxuICogSW5zZXJ0cyBhIHRhYmxlIHJvdyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGdpdmVuIGNlbGwgbm9kZSxcbiAqIHRha2luZyBpbnRvIGFjY291bnQgYW55IHNwYW5zLiBJZiBzdWNjZXNzZnVsLCByZXR1cm5zIHRoZVxuICogaW5zZXJ0ZWQgdGFibGUgcm93IG5vZGUuXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRUYWJsZVJvd0F0Tm9kZShjZWxsTm9kZSwgaW5zZXJ0QWZ0ZXIgPSB0cnVlKSB7XG4gIGNvbnN0IFssLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChjZWxsTm9kZSk7XG4gIGNvbnN0IFtncmlkTWFwLCBjZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgY2VsbE5vZGUsIGNlbGxOb2RlKTtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBjZWxsU3RhcnRSb3dcbiAgfSA9IGNlbGxNYXA7XG4gIGxldCBpbnNlcnRlZFJvdyA9IG51bGw7XG4gIGlmIChpbnNlcnRBZnRlcikge1xuICAgIGNvbnN0IGluc2VydEFmdGVyRW5kUm93ID0gY2VsbFN0YXJ0Um93ICsgY2VsbE5vZGUuX19yb3dTcGFuIC0gMTtcbiAgICBjb25zdCBpbnNlcnRBZnRlckVuZFJvd01hcCA9IGdyaWRNYXBbaW5zZXJ0QWZ0ZXJFbmRSb3ddO1xuICAgIGNvbnN0IG5ld1JvdyA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3dcbiAgICAgIH0gPSBpbnNlcnRBZnRlckVuZFJvd01hcFtpXTtcbiAgICAgIGlmIChzdGFydFJvdyArIGNlbGwuX19yb3dTcGFuIC0gMSA8PSBpbnNlcnRBZnRlckVuZFJvdykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGluc2VydEFmdGVyRW5kUm93TWFwW2ldLmNlbGw7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUgPSBjdXJyZW50Q2VsbC5fX2hlYWRlclN0YXRlO1xuICAgICAgICBjb25zdCBoZWFkZXJTdGF0ZSA9IGdldEhlYWRlclN0YXRlKGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUsIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pO1xuICAgICAgICBuZXdSb3cuYXBwZW5kKCRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluc2VydEFmdGVyRW5kUm93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KGluc2VydEFmdGVyRW5kUm93KTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShpbnNlcnRBZnRlckVuZFJvd05vZGUpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGluc2VydEFmdGVyRW5kUm93IGlzIG5vdCBhIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBpbnNlcnRBZnRlckVuZFJvd05vZGUuaW5zZXJ0QWZ0ZXIobmV3Um93KTtcbiAgICBpbnNlcnRlZFJvdyA9IG5ld1JvdztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpbnNlcnRCZWZvcmVTdGFydFJvdyA9IGNlbGxTdGFydFJvdztcbiAgICBjb25zdCBpbnNlcnRCZWZvcmVTdGFydFJvd01hcCA9IGdyaWRNYXBbaW5zZXJ0QmVmb3JlU3RhcnRSb3ddO1xuICAgIGNvbnN0IG5ld1JvdyA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3dcbiAgICAgIH0gPSBpbnNlcnRCZWZvcmVTdGFydFJvd01hcFtpXTtcbiAgICAgIGlmIChzdGFydFJvdyA9PT0gaW5zZXJ0QmVmb3JlU3RhcnRSb3cpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGwgPSBpbnNlcnRCZWZvcmVTdGFydFJvd01hcFtpXS5jZWxsO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbEhlYWRlclN0YXRlID0gY3VycmVudENlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICAgICAgY29uc3QgaGVhZGVyU3RhdGUgPSBnZXRIZWFkZXJTdGF0ZShjdXJyZW50Q2VsbEhlYWRlclN0YXRlLCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OKTtcbiAgICAgICAgbmV3Um93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbihjZWxsLl9fcm93U3BhbiArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnNlcnRCZWZvcmVTdGFydFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChpbnNlcnRCZWZvcmVTdGFydFJvdyk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoaW5zZXJ0QmVmb3JlU3RhcnRSb3dOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbnNlcnRCZWZvcmVTdGFydFJvdyBpcyBub3QgYSBUYWJsZVJvd05vZGVgKTtcbiAgICB9XG4gICAgaW5zZXJ0QmVmb3JlU3RhcnRSb3dOb2RlLmluc2VydEJlZm9yZShuZXdSb3cpO1xuICAgIGluc2VydGVkUm93ID0gbmV3Um93O1xuICB9XG4gIHJldHVybiBpbnNlcnRlZFJvdztcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgbWVyZ2VkIGNlbGxzLiBVc2Uge0BsaW5rICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9ufSBvciB7QGxpbmsgJGluc2VydFRhYmxlQ29sdW1uQXROb2RlfSBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb2x1bW4odGFibGVOb2RlLCB0YXJnZXRJbmRleCwgc2hvdWxkSW5zZXJ0QWZ0ZXIgPSB0cnVlLCBjb2x1bW5Db3VudCwgdGFibGUpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IHRhYmxlQ2VsbHNUb0JlSW5zZXJ0ZWQgPSBbXTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0YWJsZVJvd3MubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBjdXJyZW50VGFibGVSb3dOb2RlID0gdGFibGVSb3dzW3JdO1xuICAgIGlmICgkaXNUYWJsZVJvd05vZGUoY3VycmVudFRhYmxlUm93Tm9kZSkpIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29sdW1uQ291bnQ7IGMrKykge1xuICAgICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dDaGlsZHJlbi5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSBjb2x1bW4gdGFyZ2V0IGluZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldENlbGwgPSB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhcmdldENlbGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0YWJsZSBjZWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgcmlnaHRcbiAgICAgICAgfSA9ICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhcmdldENlbGwsIHRhYmxlKTtcbiAgICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbiAgICAgICAgaWYgKGxlZnQgJiYgbGVmdC5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKSB8fCByaWdodCAmJiByaWdodC5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKSkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3VGFibGVDZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpO1xuICAgICAgICBuZXdUYWJsZUNlbGwuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgICB0YWJsZUNlbGxzVG9CZUluc2VydGVkLnB1c2goe1xuICAgICAgICAgIG5ld1RhYmxlQ2VsbCxcbiAgICAgICAgICB0YXJnZXRDZWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0YWJsZUNlbGxzVG9CZUluc2VydGVkLmZvckVhY2goKHtcbiAgICBuZXdUYWJsZUNlbGwsXG4gICAgdGFyZ2V0Q2VsbFxuICB9KSA9PiB7XG4gICAgaWYgKHNob3VsZEluc2VydEFmdGVyKSB7XG4gICAgICB0YXJnZXRDZWxsLmluc2VydEFmdGVyKG5ld1RhYmxlQ2VsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldENlbGwuaW5zZXJ0QmVmb3JlKG5ld1RhYmxlQ2VsbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGEgY29sdW1uIGJlZm9yZSBvciBhZnRlciB0aGUgY3VycmVudCBmb2N1cyBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGZpcnN0IGluc2VydGVkIGNlbGwgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29sdW1uQXRTZWxlY3Rpb24oaW5zZXJ0QWZ0ZXIgPSB0cnVlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBUYWJsZVNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFthbmNob3JDZWxsXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbLCBmb2N1c0NlbGxNYXAsIGFuY2hvckNlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBmb2N1c0NlbGwsIGFuY2hvckNlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW46IGFuY2hvclN0YXJ0Q29sdW1uXG4gIH0gPSBhbmNob3JDZWxsTWFwO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW46IGZvY3VzU3RhcnRDb2x1bW5cbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgaWYgKGluc2VydEFmdGVyKSB7XG4gICAgcmV0dXJuICRpbnNlcnRUYWJsZUNvbHVtbkF0Tm9kZShhbmNob3JTdGFydENvbHVtbiArIGFuY2hvckNlbGwuX19jb2xTcGFuID4gZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW4gPyBhbmNob3JDZWxsIDogZm9jdXNDZWxsLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJGluc2VydFRhYmxlQ29sdW1uQXROb2RlKGZvY3VzU3RhcnRDb2x1bW4gPCBhbmNob3JTdGFydENvbHVtbiA/IGZvY3VzQ2VsbCA6IGFuY2hvckNlbGwsIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9ufVxuICovXG5jb25zdCAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCA9ICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9uO1xuXG4vKipcbiAqIEluc2VydHMgYSBjb2x1bW4gYmVmb3JlIG9yIGFmdGVyIHRoZSBnaXZlbiBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGZpcnN0IGluc2VydGVkIGNlbGwgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29sdW1uQXROb2RlKGNlbGxOb2RlLCBpbnNlcnRBZnRlciA9IHRydWUsIHNob3VsZFNldFNlbGVjdGlvbiA9IHRydWUpIHtcbiAgY29uc3QgWywsIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGNlbGxOb2RlKTtcbiAgY29uc3QgW2dyaWRNYXAsIGNlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBjZWxsTm9kZSwgY2VsbE5vZGUpO1xuICBjb25zdCByb3dDb3VudCA9IGdyaWRNYXAubGVuZ3RoO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW5cbiAgfSA9IGNlbGxNYXA7XG4gIGNvbnN0IGluc2VydEFmdGVyQ29sdW1uID0gaW5zZXJ0QWZ0ZXIgPyBzdGFydENvbHVtbiArIGNlbGxOb2RlLl9fY29sU3BhbiAtIDEgOiBzdGFydENvbHVtbiAtIDE7XG4gIGNvbnN0IGdyaWRGaXJzdENoaWxkID0gZ3JpZC5nZXRGaXJzdENoaWxkKCk7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKGdyaWRGaXJzdENoaWxkKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgZmlyc3RUYWJsZSBjaGlsZCB0byBiZSBhIHJvd2ApO1xuICB9XG4gIGxldCBmaXJzdEluc2VydGVkQ2VsbCA9IG51bGw7XG4gIGZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlRm9ySW5zZXJ0VGFibGVDb2x1bW4oaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTKSB7XG4gICAgY29uc3QgY2VsbCA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgaWYgKGZpcnN0SW5zZXJ0ZWRDZWxsID09PSBudWxsKSB7XG4gICAgICBmaXJzdEluc2VydGVkQ2VsbCA9IGNlbGw7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xuICB9XG4gIGxldCBsb29wUm93ID0gZ3JpZEZpcnN0Q2hpbGQ7XG4gIHJvd0xvb3A6IGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93ID0gbG9vcFJvdy5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoY3VycmVudFJvdykpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCByb3cgbmV4dFNpYmxpbmcgdG8gYmUgYSByb3dgKTtcbiAgICAgIH1cbiAgICAgIGxvb3BSb3cgPSBjdXJyZW50Um93O1xuICAgIH1cbiAgICBjb25zdCByb3dNYXAgPSBncmlkTWFwW2ldO1xuICAgIGNvbnN0IGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUgPSByb3dNYXBbaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwID8gMCA6IGluc2VydEFmdGVyQ29sdW1uXS5jZWxsLl9faGVhZGVyU3RhdGU7XG4gICAgY29uc3QgaGVhZGVyU3RhdGUgPSBnZXRIZWFkZXJTdGF0ZShjdXJyZW50Q2VsbEhlYWRlclN0YXRlLCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKTtcbiAgICBpZiAoaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwKSB7XG4gICAgICAkaW5zZXJ0Rmlyc3QobG9vcFJvdywgJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNlbGw6IGN1cnJlbnRDZWxsLFxuICAgICAgc3RhcnRDb2x1bW46IGN1cnJlbnRTdGFydENvbHVtbixcbiAgICAgIHN0YXJ0Um93OiBjdXJyZW50U3RhcnRSb3dcbiAgICB9ID0gcm93TWFwW2luc2VydEFmdGVyQ29sdW1uXTtcbiAgICBpZiAoY3VycmVudFN0YXJ0Q29sdW1uICsgY3VycmVudENlbGwuX19jb2xTcGFuIC0gMSA8PSBpbnNlcnRBZnRlckNvbHVtbikge1xuICAgICAgbGV0IGluc2VydEFmdGVyQ2VsbCA9IGN1cnJlbnRDZWxsO1xuICAgICAgbGV0IGluc2VydEFmdGVyQ2VsbFJvd1N0YXJ0ID0gY3VycmVudFN0YXJ0Um93O1xuICAgICAgbGV0IHByZXZDZWxsSW5kZXggPSBpbnNlcnRBZnRlckNvbHVtbjtcbiAgICAgIHdoaWxlIChpbnNlcnRBZnRlckNlbGxSb3dTdGFydCAhPT0gaSAmJiBpbnNlcnRBZnRlckNlbGwuX19yb3dTcGFuID4gMSkge1xuICAgICAgICBwcmV2Q2VsbEluZGV4IC09IGN1cnJlbnRDZWxsLl9fY29sU3BhbjtcbiAgICAgICAgaWYgKHByZXZDZWxsSW5kZXggPj0gMCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNlbGw6IGNlbGxfLFxuICAgICAgICAgICAgc3RhcnRSb3c6IHN0YXJ0Um93X1xuICAgICAgICAgIH0gPSByb3dNYXBbcHJldkNlbGxJbmRleF07XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsID0gY2VsbF87XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsUm93U3RhcnQgPSBzdGFydFJvd187XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9vcFJvdy5hcHBlbmQoJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSkpO1xuICAgICAgICAgIGNvbnRpbnVlIHJvd0xvb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc2VydEFmdGVyQ2VsbC5pbnNlcnRBZnRlcigkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKGhlYWRlclN0YXRlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDZWxsLnNldENvbFNwYW4oY3VycmVudENlbGwuX19jb2xTcGFuICsgMSk7XG4gICAgfVxuICB9XG4gIGlmIChmaXJzdEluc2VydGVkQ2VsbCAhPT0gbnVsbCAmJiBzaG91bGRTZXRTZWxlY3Rpb24pIHtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChmaXJzdEluc2VydGVkQ2VsbCk7XG4gIH1cbiAgY29uc3QgY29sV2lkdGhzID0gZ3JpZC5nZXRDb2xXaWR0aHMoKTtcbiAgaWYgKGNvbFdpZHRocykge1xuICAgIGNvbnN0IG5ld0NvbFdpZHRocyA9IFsuLi5jb2xXaWR0aHNdO1xuICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwID8gMCA6IGluc2VydEFmdGVyQ29sdW1uO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gbmV3Q29sV2lkdGhzW2NvbHVtbkluZGV4XTtcbiAgICBuZXdDb2xXaWR0aHMuc3BsaWNlKGNvbHVtbkluZGV4LCAwLCBuZXdXaWR0aCk7XG4gICAgZ3JpZC5zZXRDb2xXaWR0aHMobmV3Q29sV2lkdGhzKTtcbiAgfVxuICByZXR1cm4gZmlyc3RJbnNlcnRlZENlbGw7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IG1lcmdlZCBjZWxscy4gVXNlIHtAbGluayAkZGVsZXRlVGFibGVDb2x1bW5BdFNlbGVjdGlvbn0gaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uKHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGVSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudFRhYmxlUm93Tm9kZSA9IHRhYmxlUm93c1tpXTtcbiAgICBpZiAoJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRUYWJsZVJvd05vZGUpKSB7XG4gICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93Q2hpbGRyZW4ubGVuZ3RoIHx8IHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIGNvbHVtbiB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICB9XG4gICAgICB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRkZWxldGVUYWJsZVJvd0F0U2VsZWN0aW9uKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgVGFibGVTZWxlY3Rpb25gKTtcbiAgfVxuICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gW3NlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCksIHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpXSA6IFtzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKV07XG4gIGNvbnN0IFthbmNob3JDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBhbmNob3JTdGFydFJvd1xuICB9ID0gYW5jaG9yQ2VsbE1hcDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBmb2N1c1N0YXJ0Um93XG4gIH0gPSBmb2N1c0NlbGxNYXA7XG4gIGNvbnN0IGZvY3VzRW5kUm93ID0gZm9jdXNTdGFydFJvdyArIGZvY3VzQ2VsbC5fX3Jvd1NwYW4gLSAxO1xuICBpZiAoZ3JpZE1hcC5sZW5ndGggPT09IGZvY3VzRW5kUm93IC0gYW5jaG9yU3RhcnRSb3cgKyAxKSB7XG4gICAgLy8gRW1wdHkgZ3JpZFxuICAgIGdyaWQucmVtb3ZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gZ3JpZE1hcFswXS5sZW5ndGg7XG4gIGNvbnN0IG5leHRSb3cgPSBncmlkTWFwW2ZvY3VzRW5kUm93ICsgMV07XG4gIGNvbnN0IG5leHRSb3dOb2RlID0gZ3JpZC5nZXRDaGlsZEF0SW5kZXgoZm9jdXNFbmRSb3cgKyAxKTtcbiAgZm9yIChsZXQgcm93ID0gZm9jdXNFbmRSb3c7IHJvdyA+PSBhbmNob3JTdGFydFJvdzsgcm93LS0pIHtcbiAgICBmb3IgKGxldCBjb2x1bW4gPSBjb2x1bW5Db3VudCAtIDE7IGNvbHVtbiA+PSAwOyBjb2x1bW4tLSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydFJvdzogY2VsbFN0YXJ0Um93LFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uXG4gICAgICB9ID0gZ3JpZE1hcFtyb3ddW2NvbHVtbl07XG4gICAgICBpZiAoY2VsbFN0YXJ0Q29sdW1uICE9PSBjb2x1bW4pIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwZWF0IHdvcmsgZm9yIHRoZSBzYW1lIENlbGxcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBSb3dzIG92ZXJmbG93aW5nIHRvcCBvciBib3R0b20gaGF2ZSB0byBiZSB0cmltbWVkXG4gICAgICBpZiAoY2VsbFN0YXJ0Um93IDwgYW5jaG9yU3RhcnRSb3cgfHwgY2VsbFN0YXJ0Um93ICsgY2VsbC5fX3Jvd1NwYW4gLSAxID4gZm9jdXNFbmRSb3cpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uU3RhcnQgPSBNYXRoLm1heChjZWxsU3RhcnRSb3csIGFuY2hvclN0YXJ0Um93KTtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uRW5kID0gTWF0aC5taW4oY2VsbC5fX3Jvd1NwYW4gKyBjZWxsU3RhcnRSb3cgLSAxLCBmb2N1c0VuZFJvdyk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93Um93c0NvdW50ID0gaW50ZXJzZWN0aW9uU3RhcnQgPD0gaW50ZXJzZWN0aW9uRW5kID8gaW50ZXJzZWN0aW9uRW5kIC0gaW50ZXJzZWN0aW9uU3RhcnQgKyAxIDogMDtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuIC0gb3ZlcmZsb3dSb3dzQ291bnQpO1xuICAgICAgfVxuICAgICAgLy8gUm93cyBvdmVyZmxvd2luZyBib3R0b20gaGF2ZSB0byBiZSBtb3ZlZCB0byB0aGUgbmV4dCByb3dcbiAgICAgIGlmIChjZWxsU3RhcnRSb3cgPj0gYW5jaG9yU3RhcnRSb3cgJiYgY2VsbFN0YXJ0Um93ICsgY2VsbC5fX3Jvd1NwYW4gLSAxID4gZm9jdXNFbmRSb3cgJiZcbiAgICAgIC8vIEhhbmRsZSBvdmVyZmxvdyBvbmx5IG9uY2VcbiAgICAgIHJvdyA9PT0gZm9jdXNFbmRSb3cpIHtcbiAgICAgICAgaWYgKCEobmV4dFJvd05vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBuZXh0Um93Tm9kZSBub3QgdG8gYmUgbnVsbGApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnNlcnRBZnRlckNlbGwgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBjb2x1bW5JbmRleCA9IDA7IGNvbHVtbkluZGV4IDwgY29sdW1uOyBjb2x1bW5JbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudENlbGxNYXAgPSBuZXh0Um93W2NvbHVtbkluZGV4XTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGN1cnJlbnRDZWxsTWFwLmNlbGw7XG4gICAgICAgICAgLy8gQ2hlY2tpbmcgdGhlIGNlbGwgaGF2aW5nIHN0YXJ0Um93IGFzIHNhbWUgYXMgbmV4dFJvd1xuICAgICAgICAgIGlmIChjdXJyZW50Q2VsbE1hcC5zdGFydFJvdyA9PT0gcm93ICsgMSkge1xuICAgICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsID0gY3VycmVudENlbGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50Q2VsbC5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleCArPSBjdXJyZW50Q2VsbC5fX2NvbFNwYW4gLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zZXJ0QWZ0ZXJDZWxsID09PSBudWxsKSB7XG4gICAgICAgICAgJGluc2VydEZpcnN0KG5leHRSb3dOb2RlLCBjZWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwuaW5zZXJ0QWZ0ZXIoY2VsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgcm93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KHJvdyk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93Tm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGNoaWxkQXRJbmRleCgke1N0cmluZyhyb3cpfSkgdG8gYmUgUm93Tm9kZWApO1xuICAgIH1cbiAgICByb3dOb2RlLnJlbW92ZSgpO1xuICB9XG4gIGlmIChuZXh0Um93ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IG5leHRSb3dbMF07XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldmlvdXNSb3cgPSBncmlkTWFwW2FuY2hvclN0YXJ0Um93IC0gMV07XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBwcmV2aW91c1Jvd1swXTtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICRkZWxldGVUYWJsZVJvd0F0U2VsZWN0aW9ufVxuICovXG5jb25zdCAkZGVsZXRlVGFibGVSb3dfX0VYUEVSSU1FTlRBTCA9ICRkZWxldGVUYWJsZVJvd0F0U2VsZWN0aW9uO1xuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBUYWJsZVNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFthbmNob3JDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Q29sdW1uOiBhbmNob3JTdGFydENvbHVtblxuICB9ID0gYW5jaG9yQ2VsbE1hcDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBmb2N1c1N0YXJ0Um93LFxuICAgIHN0YXJ0Q29sdW1uOiBmb2N1c1N0YXJ0Q29sdW1uXG4gIH0gPSBmb2N1c0NlbGxNYXA7XG4gIGNvbnN0IHN0YXJ0Q29sdW1uID0gTWF0aC5taW4oYW5jaG9yU3RhcnRDb2x1bW4sIGZvY3VzU3RhcnRDb2x1bW4pO1xuICBjb25zdCBlbmRDb2x1bW4gPSBNYXRoLm1heChhbmNob3JTdGFydENvbHVtbiArIGFuY2hvckNlbGwuX19jb2xTcGFuIC0gMSwgZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgY29uc3Qgc2VsZWN0ZWRDb2x1bW5Db3VudCA9IGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMTtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgaWYgKGNvbHVtbkNvdW50ID09PSBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEpIHtcbiAgICAvLyBFbXB0eSBncmlkXG4gICAgZ3JpZC5zZWxlY3RQcmV2aW91cygpO1xuICAgIGdyaWQucmVtb3ZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJvd0NvdW50ID0gZ3JpZE1hcC5sZW5ndGg7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd0NvdW50OyByb3crKykge1xuICAgIGZvciAobGV0IGNvbHVtbiA9IHN0YXJ0Q29sdW1uOyBjb2x1bW4gPD0gZW5kQ29sdW1uOyBjb2x1bW4rKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uXG4gICAgICB9ID0gZ3JpZE1hcFtyb3ddW2NvbHVtbl07XG4gICAgICBpZiAoY2VsbFN0YXJ0Q29sdW1uIDwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICBjb25zdCBvdmVyZmxvd0xlZnQgPSBzdGFydENvbHVtbiAtIGNlbGxTdGFydENvbHVtbjtcbiAgICAgICAgICAvLyBPdmVyZmxvd2luZyBsZWZ0XG4gICAgICAgICAgY2VsbC5zZXRDb2xTcGFuKGNlbGwuX19jb2xTcGFuIC1cbiAgICAgICAgICAvLyBQb3NzaWJsZSBvdmVyZmxvdyByaWdodCB0b29cbiAgICAgICAgICBNYXRoLm1pbihzZWxlY3RlZENvbHVtbkNvdW50LCBjZWxsLl9fY29sU3BhbiAtIG92ZXJmbG93TGVmdCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNlbGxTdGFydENvbHVtbiArIGNlbGwuX19jb2xTcGFuIC0gMSA+IGVuZENvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uID09PSBlbmRDb2x1bW4pIHtcbiAgICAgICAgICAvLyBPdmVyZmxvd2luZyByaWdodFxuICAgICAgICAgIGNvbnN0IGluU2VsZWN0ZWRBcmVhID0gZW5kQ29sdW1uIC0gY2VsbFN0YXJ0Q29sdW1uICsgMTtcbiAgICAgICAgICBjZWxsLnNldENvbFNwYW4oY2VsbC5fX2NvbFNwYW4gLSBpblNlbGVjdGVkQXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvY3VzUm93TWFwID0gZ3JpZE1hcFtmb2N1c1N0YXJ0Um93XTtcbiAgY29uc3QgbmV4dENvbHVtbiA9IGFuY2hvclN0YXJ0Q29sdW1uID4gZm9jdXNTdGFydENvbHVtbiA/IGZvY3VzUm93TWFwW2FuY2hvclN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5fX2NvbFNwYW5dIDogZm9jdXNSb3dNYXBbZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW5dO1xuICBpZiAobmV4dENvbHVtbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBuZXh0Q29sdW1uO1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXZpb3VzUm93ID0gZm9jdXNTdGFydENvbHVtbiA8IGFuY2hvclN0YXJ0Q29sdW1uID8gZm9jdXNSb3dNYXBbZm9jdXNTdGFydENvbHVtbiAtIDFdIDogZm9jdXNSb3dNYXBbYW5jaG9yU3RhcnRDb2x1bW4gLSAxXTtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IHByZXZpb3VzUm93O1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9XG4gIGNvbnN0IGNvbFdpZHRocyA9IGdyaWQuZ2V0Q29sV2lkdGhzKCk7XG4gIGlmIChjb2xXaWR0aHMpIHtcbiAgICBjb25zdCBuZXdDb2xXaWR0aHMgPSBbLi4uY29sV2lkdGhzXTtcbiAgICBuZXdDb2xXaWR0aHMuc3BsaWNlKHN0YXJ0Q29sdW1uLCBzZWxlY3RlZENvbHVtbkNvdW50KTtcbiAgICBncmlkLnNldENvbFdpZHRocyhuZXdDb2xXaWR0aHMpO1xuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb259XG4gKi9cbmNvbnN0ICRkZWxldGVUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMID0gJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb247XG5mdW5jdGlvbiAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKSB7XG4gIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IGNlbGwuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGlmIChmaXJzdERlc2NlbmRhbnQgPT0gbnVsbCkge1xuICAgIGNlbGwuc2VsZWN0U3RhcnQoKTtcbiAgfSBlbHNlIHtcbiAgICBmaXJzdERlc2NlbmRhbnQuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRpbnNlcnRGaXJzdChwYXJlbnQsIG5vZGUpIHtcbiAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmVudC5nZXRGaXJzdENoaWxkKCk7XG4gIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LmFwcGVuZChub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gJG1lcmdlQ2VsbHMoY2VsbE5vZGVzKSB7XG4gIGlmIChjZWxsTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBGaW5kIHRoZSB0YWJsZSBub2RlXG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KGNlbGxOb2Rlc1swXSk7XG4gIGNvbnN0IFtncmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRhYmxlTm9kZSwgbnVsbCwgbnVsbCk7XG5cbiAgLy8gRmluZCB0aGUgYm91bmRhcmllcyBvZiB0aGUgc2VsZWN0aW9uIGluY2x1ZGluZyBtZXJnZWQgY2VsbHNcbiAgbGV0IG1pblJvdyA9IEluZmluaXR5O1xuICBsZXQgbWF4Um93ID0gLUluZmluaXR5O1xuICBsZXQgbWluQ29sID0gSW5maW5pdHk7XG4gIGxldCBtYXhDb2wgPSAtSW5maW5pdHk7XG5cbiAgLy8gRmlyc3QgcGFzczogZmluZCB0aGUgYWN0dWFsIGJvdW5kYXJpZXMgY29uc2lkZXJpbmcgbWVyZ2VkIGNlbGxzXG4gIGNvbnN0IHByb2Nlc3NlZENlbGxzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHJvdyBvZiBncmlkTWFwKSB7XG4gICAgZm9yIChjb25zdCBtYXBDZWxsIG9mIHJvdykge1xuICAgICAgaWYgKCFtYXBDZWxsIHx8ICFtYXBDZWxsLmNlbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjZWxsS2V5ID0gbWFwQ2VsbC5jZWxsLmdldEtleSgpO1xuICAgICAgaWYgKHByb2Nlc3NlZENlbGxzLmhhcyhjZWxsS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjZWxsTm9kZXMuc29tZShjZWxsID0+IGNlbGwuaXMobWFwQ2VsbC5jZWxsKSkpIHtcbiAgICAgICAgcHJvY2Vzc2VkQ2VsbHMuYWRkKGNlbGxLZXkpO1xuICAgICAgICAvLyBHZXQgdGhlIGFjdHVhbCBwb3NpdGlvbiBvZiB0aGlzIGNlbGwgaW4gdGhlIGdyaWRcbiAgICAgICAgY29uc3QgY2VsbFN0YXJ0Um93ID0gbWFwQ2VsbC5zdGFydFJvdztcbiAgICAgICAgY29uc3QgY2VsbFN0YXJ0Q29sID0gbWFwQ2VsbC5zdGFydENvbHVtbjtcbiAgICAgICAgY29uc3QgY2VsbFJvd1NwYW4gPSBtYXBDZWxsLmNlbGwuX19yb3dTcGFuIHx8IDE7XG4gICAgICAgIGNvbnN0IGNlbGxDb2xTcGFuID0gbWFwQ2VsbC5jZWxsLl9fY29sU3BhbiB8fCAxO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBib3VuZGFyaWVzIGNvbnNpZGVyaW5nIHRoZSBjZWxsJ3MgYWN0dWFsIHBvc2l0aW9uIGFuZCBzcGFuXG4gICAgICAgIG1pblJvdyA9IE1hdGgubWluKG1pblJvdywgY2VsbFN0YXJ0Um93KTtcbiAgICAgICAgbWF4Um93ID0gTWF0aC5tYXgobWF4Um93LCBjZWxsU3RhcnRSb3cgKyBjZWxsUm93U3BhbiAtIDEpO1xuICAgICAgICBtaW5Db2wgPSBNYXRoLm1pbihtaW5Db2wsIGNlbGxTdGFydENvbCk7XG4gICAgICAgIG1heENvbCA9IE1hdGgubWF4KG1heENvbCwgY2VsbFN0YXJ0Q29sICsgY2VsbENvbFNwYW4gLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBib3VuZGFyaWVzXG4gIGlmIChtaW5Sb3cgPT09IEluZmluaXR5IHx8IG1pbkNvbCA9PT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRoZSB0b3RhbCBzcGFuIG9mIHRoZSBtZXJnZWQgY2VsbFxuICBjb25zdCB0b3RhbFJvd1NwYW4gPSBtYXhSb3cgLSBtaW5Sb3cgKyAxO1xuICBjb25zdCB0b3RhbENvbFNwYW4gPSBtYXhDb2wgLSBtaW5Db2wgKyAxO1xuXG4gIC8vIFVzZSB0aGUgdG9wLWxlZnQgY2VsbCBhcyB0aGUgdGFyZ2V0IGNlbGxcbiAgY29uc3QgdGFyZ2V0Q2VsbE1hcCA9IGdyaWRNYXBbbWluUm93XVttaW5Db2xdO1xuICBpZiAoIXRhcmdldENlbGxNYXAuY2VsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHRhcmdldENlbGwgPSB0YXJnZXRDZWxsTWFwLmNlbGw7XG5cbiAgLy8gU2V0IHRoZSBzcGFucyBmb3IgdGhlIHRhcmdldCBjZWxsXG4gIHRhcmdldENlbGwuc2V0Q29sU3Bhbih0b3RhbENvbFNwYW4pO1xuICB0YXJnZXRDZWxsLnNldFJvd1NwYW4odG90YWxSb3dTcGFuKTtcblxuICAvLyBNb3ZlIGNvbnRlbnQgZnJvbSBvdGhlciBjZWxscyB0byB0aGUgdGFyZ2V0IGNlbGxcbiAgY29uc3Qgc2VlbkNlbGxzID0gbmV3IFNldChbdGFyZ2V0Q2VsbC5nZXRLZXkoKV0pO1xuXG4gIC8vIFNlY29uZCBwYXNzOiBtZXJnZSBjb250ZW50IGFuZCByZW1vdmUgb3RoZXIgY2VsbHNcbiAgZm9yIChsZXQgcm93ID0gbWluUm93OyByb3cgPD0gbWF4Um93OyByb3crKykge1xuICAgIGZvciAobGV0IGNvbCA9IG1pbkNvbDsgY29sIDw9IG1heENvbDsgY29sKyspIHtcbiAgICAgIGNvbnN0IG1hcENlbGwgPSBncmlkTWFwW3Jvd11bY29sXTtcbiAgICAgIGlmICghbWFwQ2VsbC5jZWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudENlbGwgPSBtYXBDZWxsLmNlbGw7XG4gICAgICBjb25zdCBrZXkgPSBjdXJyZW50Q2VsbC5nZXRLZXkoKTtcbiAgICAgIGlmICghc2VlbkNlbGxzLmhhcyhrZXkpKSB7XG4gICAgICAgIHNlZW5DZWxscy5hZGQoa2V5KTtcbiAgICAgICAgY29uc3QgaXNFbXB0eSA9ICRjZWxsQ29udGFpbnNFbXB0eVBhcmFncmFwaChjdXJyZW50Q2VsbCk7XG4gICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgIHRhcmdldENlbGwuYXBwZW5kKC4uLmN1cnJlbnRDZWxsLmdldENoaWxkcmVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRDZWxsLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEVuc3VyZSB0YXJnZXQgY2VsbCBoYXMgY29udGVudFxuICBpZiAodGFyZ2V0Q2VsbC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgIHRhcmdldENlbGwuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICB9XG4gIHJldHVybiB0YXJnZXRDZWxsO1xufVxuZnVuY3Rpb24gJGNlbGxDb250YWluc0VtcHR5UGFyYWdyYXBoKGNlbGwpIHtcbiAgaWYgKGNlbGwuZ2V0Q2hpbGRyZW5TaXplKCkgIT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IGNlbGwuZ2V0Rmlyc3RDaGlsZE9yVGhyb3coKTtcbiAgaWYgKCEkaXNQYXJhZ3JhcGhOb2RlKGZpcnN0Q2hpbGQpIHx8ICFmaXJzdENoaWxkLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICR1bm1lcmdlQ2VsbCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3IsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoY2VsbE5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IFRhYmxlQ2VsbE5vZGVgKTtcbiAgfVxuICByZXR1cm4gJHVubWVyZ2VDZWxsTm9kZShjZWxsTm9kZSk7XG59XG5mdW5jdGlvbiAkdW5tZXJnZUNlbGxOb2RlKGNlbGxOb2RlKSB7XG4gIGNvbnN0IFtjZWxsLCByb3csIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGNlbGxOb2RlKTtcbiAgY29uc3QgY29sU3BhbiA9IGNlbGwuX19jb2xTcGFuO1xuICBjb25zdCByb3dTcGFuID0gY2VsbC5fX3Jvd1NwYW47XG4gIGlmIChjb2xTcGFuID09PSAxICYmIHJvd1NwYW4gPT09IDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW21hcCwgY2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGNlbGwsIGNlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW4sXG4gICAgc3RhcnRSb3dcbiAgfSA9IGNlbGxNYXA7XG4gIC8vIENyZWF0ZSBhIGhldXJpc3RpYyBmb3Igd2hhdCB0aGUgc3R5bGUgb2YgdGhlIHVubWVyZ2VkIGNlbGxzIHNob3VsZCBiZVxuICAvLyBiYXNlZCBvbiB3aGV0aGVyIGV2ZXJ5IHJvdyBvciBjb2x1bW4gYWxyZWFkeSBoYWQgdGhhdCBzdGF0ZSBiZWZvcmUgdGhlXG4gIC8vIHVubWVyZ2UuXG4gIGNvbnN0IGJhc2VDb2xTdHlsZSA9IGNlbGwuX19oZWFkZXJTdGF0ZSAmIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU47XG4gIGNvbnN0IGNvbFN0eWxlcyA9IEFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogY29sU3BhblxuICB9LCAoX3YsIGkpID0+IHtcbiAgICBsZXQgY29sU3R5bGUgPSBiYXNlQ29sU3R5bGU7XG4gICAgZm9yIChsZXQgcm93SWR4ID0gMDsgY29sU3R5bGUgIT09IDAgJiYgcm93SWR4IDwgbWFwLmxlbmd0aDsgcm93SWR4KyspIHtcbiAgICAgIGNvbFN0eWxlICY9IG1hcFtyb3dJZHhdW2kgKyBzdGFydENvbHVtbl0uY2VsbC5fX2hlYWRlclN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY29sU3R5bGU7XG4gIH0pO1xuICBjb25zdCBiYXNlUm93U3R5bGUgPSBjZWxsLl9faGVhZGVyU3RhdGUgJiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XO1xuICBjb25zdCByb3dTdHlsZXMgPSBBcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IHJvd1NwYW5cbiAgfSwgKF92LCBpKSA9PiB7XG4gICAgbGV0IHJvd1N0eWxlID0gYmFzZVJvd1N0eWxlO1xuICAgIGZvciAobGV0IGNvbElkeCA9IDA7IHJvd1N0eWxlICE9PSAwICYmIGNvbElkeCA8IG1hcFswXS5sZW5ndGg7IGNvbElkeCsrKSB7XG4gICAgICByb3dTdHlsZSAmPSBtYXBbaSArIHN0YXJ0Um93XVtjb2xJZHhdLmNlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJvd1N0eWxlO1xuICB9KTtcbiAgaWYgKGNvbFNwYW4gPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb2xTcGFuOyBpKyspIHtcbiAgICAgIGNlbGwuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY29sU3R5bGVzW2ldIHwgcm93U3R5bGVzWzBdKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgIH1cbiAgICBjZWxsLnNldENvbFNwYW4oMSk7XG4gIH1cbiAgaWYgKHJvd1NwYW4gPiAxKSB7XG4gICAgbGV0IGN1cnJlbnRSb3dOb2RlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm93U3BhbjsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93ID0gc3RhcnRSb3cgKyBpO1xuICAgICAgY29uc3QgY3VycmVudFJvd01hcCA9IG1hcFtjdXJyZW50Um93XTtcbiAgICAgIGN1cnJlbnRSb3dOb2RlID0gKGN1cnJlbnRSb3dOb2RlIHx8IHJvdykuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRSb3dOb2RlKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHJvdyBuZXh0IHNpYmxpbmcgdG8gYmUgYSByb3dgKTtcbiAgICAgIH1cbiAgICAgIGxldCBpbnNlcnRBZnRlckNlbGwgPSBudWxsO1xuICAgICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgc3RhcnRDb2x1bW47IGNvbHVtbisrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsTWFwID0gY3VycmVudFJvd01hcFtjb2x1bW5dO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGN1cnJlbnRDZWxsTWFwLmNlbGw7XG4gICAgICAgIGlmIChjdXJyZW50Q2VsbE1hcC5zdGFydFJvdyA9PT0gY3VycmVudFJvdykge1xuICAgICAgICAgIGluc2VydEFmdGVyQ2VsbCA9IGN1cnJlbnRDZWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q2VsbC5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgY29sdW1uICs9IGN1cnJlbnRDZWxsLl9fY29sU3BhbiAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnNlcnRBZnRlckNlbGwgPT09IG51bGwpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGNvbFNwYW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICRpbnNlcnRGaXJzdChjdXJyZW50Um93Tm9kZSwgJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY29sU3R5bGVzW2pdIHwgcm93U3R5bGVzW2ldKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBqID0gY29sU3BhbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsLmluc2VydEFmdGVyKCRjcmVhdGVUYWJsZUNlbGxOb2RlKGNvbFN0eWxlc1tqXSB8IHJvd1N0eWxlc1tpXSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjZWxsLnNldFJvd1NwYW4oMSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBjZWxsQSwgY2VsbEIpIHtcbiAgY29uc3QgW3RhYmxlTWFwLCBjZWxsQVZhbHVlLCBjZWxsQlZhbHVlXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRhYmxlTm9kZSwgY2VsbEEsIGNlbGxCKTtcbiAgaWYgKCEoY2VsbEFWYWx1ZSAhPT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEFuY2hvciBub3QgZm91bmQgaW4gVGFibGVgKTtcbiAgfVxuICBpZiAoIShjZWxsQlZhbHVlICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRm9jdXMgbm90IGZvdW5kIGluIFRhYmxlYCk7XG4gIH1cbiAgcmV0dXJuIFt0YWJsZU1hcCwgY2VsbEFWYWx1ZSwgY2VsbEJWYWx1ZV07XG59XG5mdW5jdGlvbiAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayh0YWJsZU5vZGUsIGNlbGxBLCBjZWxsQikge1xuICBjb25zdCB0YWJsZU1hcCA9IFtdO1xuICBsZXQgY2VsbEFWYWx1ZSA9IG51bGw7XG4gIGxldCBjZWxsQlZhbHVlID0gbnVsbDtcbiAgZnVuY3Rpb24gZ2V0TWFwUm93KGkpIHtcbiAgICBsZXQgcm93ID0gdGFibGVNYXBbaV07XG4gICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YWJsZU1hcFtpXSA9IHJvdyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcm93O1xuICB9XG4gIGNvbnN0IGdyaWRDaGlsZHJlbiA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuICBmb3IgKGxldCByb3dJZHggPSAwOyByb3dJZHggPCBncmlkQ2hpbGRyZW4ubGVuZ3RoOyByb3dJZHgrKykge1xuICAgIGNvbnN0IHJvdyA9IGdyaWRDaGlsZHJlbltyb3dJZHhdO1xuICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGNoaWxkcmVuIHRvIGJlIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzdGFydE1hcFJvdyA9IGdldE1hcFJvdyhyb3dJZHgpO1xuICAgIGZvciAobGV0IGNlbGwgPSByb3cuZ2V0Rmlyc3RDaGlsZCgpLCBjb2xJZHggPSAwOyBjZWxsICE9IG51bGw7IGNlbGwgPSBjZWxsLmdldE5leHRTaWJsaW5nKCkpIHtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlUm93Tm9kZSBjaGlsZHJlbiB0byBiZSBUYWJsZUNlbGxOb2RlYCk7XG4gICAgICB9IC8vIFNraXAgcGFzdCBhbnkgY29sdW1ucyB0aGF0IHdlcmUgbWVyZ2VkIGZyb20gYSBoaWdoZXIgcm93XG4gICAgICB3aGlsZSAoc3RhcnRNYXBSb3dbY29sSWR4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbElkeCsrO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjb2xJZHgsXG4gICAgICAgIHN0YXJ0Um93OiByb3dJZHhcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIF9fcm93U3Bhbjogcm93U3BhbixcbiAgICAgICAgX19jb2xTcGFuOiBjb2xTcGFuXG4gICAgICB9ID0gY2VsbDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93U3BhbjsgaisrKSB7XG4gICAgICAgIGlmIChyb3dJZHggKyBqID49IGdyaWRDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGUgdGFibGUgaXMgbm9uLXJlY3Rhbmd1bGFyIHdpdGggYSByb3dTcGFuXG4gICAgICAgICAgLy8gYmVsb3cgdGhlIGxhc3QgPHRyPiBpbiB0aGUgdGFibGUuXG4gICAgICAgICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGhhbmRsZSB0aGlzIHdpdGggYSBub2RlIHRyYW5zZm9ybVxuICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHRhYmxlcyBhcmUgYWx3YXlzIHJlY3Rhbmd1bGFyIGJ1dCB0aGlzXG4gICAgICAgICAgLy8gd2lsbCBhdm9pZCBjcmFzaGVzIHN1Y2ggYXMgIzY1ODRcbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlcmUgYXJlIHByb2JhYmx5IHN0aWxsIGxhdGVudCBidWdzXG4gICAgICAgICAgLy8gcmVnYXJkaW5nIGNvbFNwYW4gb3IgZ2VuZXJhbCBjZWxsIGNvdW50IG1pc21hdGNoZXMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFwUm93ID0gZ2V0TWFwUm93KHJvd0lkeCArIGopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbFNwYW47IGkrKykge1xuICAgICAgICAgIG1hcFJvd1tjb2xJZHggKyBpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2VsbEEgIT09IG51bGwgJiYgY2VsbEFWYWx1ZSA9PT0gbnVsbCAmJiBjZWxsQS5pcyhjZWxsKSkge1xuICAgICAgICBjZWxsQVZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoY2VsbEIgIT09IG51bGwgJiYgY2VsbEJWYWx1ZSA9PT0gbnVsbCAmJiBjZWxsQi5pcyhjZWxsKSkge1xuICAgICAgICBjZWxsQlZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbdGFibGVNYXAsIGNlbGxBVmFsdWUsIGNlbGxCVmFsdWVdO1xufVxuZnVuY3Rpb24gJGdldE5vZGVUcmlwbGV0KHNvdXJjZSkge1xuICBsZXQgY2VsbDtcbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFRhYmxlQ2VsbE5vZGUpIHtcbiAgICBjZWxsID0gc291cmNlO1xuICB9IGVsc2UgaWYgKCdfX3R5cGUnIGluIHNvdXJjZSkge1xuICAgIGNvbnN0IGNlbGxfID0gJGZpbmRNYXRjaGluZ1BhcmVudChzb3VyY2UsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsXykpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgdG8gZmluZCBhIHBhcmVudCBUYWJsZUNlbGxOb2RlYCk7XG4gICAgfVxuICAgIGNlbGwgPSBjZWxsXztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjZWxsXyA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc291cmNlLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGxfKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY2VsbCA9IGNlbGxfO1xuICB9XG4gIGNvbnN0IHJvdyA9IGNlbGwuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlQ2VsbE5vZGUgdG8gaGF2ZSBhIHBhcmVudCBUYWJsZVJvd05vZGVgKTtcbiAgfVxuICBjb25zdCBncmlkID0gcm93LmdldFBhcmVudCgpO1xuICBpZiAoISRpc1RhYmxlTm9kZShncmlkKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVSb3dOb2RlIHRvIGhhdmUgYSBwYXJlbnQgVGFibGVOb2RlYCk7XG4gIH1cbiAgcmV0dXJuIFtjZWxsLCByb3csIGdyaWRdO1xufVxuZnVuY3Rpb24gJGNvbXB1dGVUYWJsZUNlbGxSZWN0U3BhbnMobWFwLCBib3VuZGFyeSkge1xuICBjb25zdCB7XG4gICAgbWluQ29sdW1uLFxuICAgIG1heENvbHVtbixcbiAgICBtaW5Sb3csXG4gICAgbWF4Um93XG4gIH0gPSBib3VuZGFyeTtcbiAgbGV0IHRvcFNwYW4gPSAxO1xuICBsZXQgbGVmdFNwYW4gPSAxO1xuICBsZXQgcmlnaHRTcGFuID0gMTtcbiAgbGV0IGJvdHRvbVNwYW4gPSAxO1xuICBjb25zdCB0b3BSb3cgPSBtYXBbbWluUm93XTtcbiAgY29uc3QgYm90dG9tUm93ID0gbWFwW21heFJvd107XG4gIGZvciAobGV0IGNvbCA9IG1pbkNvbHVtbjsgY29sIDw9IG1heENvbHVtbjsgY29sKyspIHtcbiAgICB0b3BTcGFuID0gTWF0aC5tYXgodG9wU3BhbiwgdG9wUm93W2NvbF0uY2VsbC5fX3Jvd1NwYW4pO1xuICAgIGJvdHRvbVNwYW4gPSBNYXRoLm1heChib3R0b21TcGFuLCBib3R0b21Sb3dbY29sXS5jZWxsLl9fcm93U3Bhbik7XG4gIH1cbiAgZm9yIChsZXQgcm93ID0gbWluUm93OyByb3cgPD0gbWF4Um93OyByb3crKykge1xuICAgIGxlZnRTcGFuID0gTWF0aC5tYXgobGVmdFNwYW4sIG1hcFtyb3ddW21pbkNvbHVtbl0uY2VsbC5fX2NvbFNwYW4pO1xuICAgIHJpZ2h0U3BhbiA9IE1hdGgubWF4KHJpZ2h0U3BhbiwgbWFwW3Jvd11bbWF4Q29sdW1uXS5jZWxsLl9fY29sU3Bhbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBib3R0b21TcGFuLFxuICAgIGxlZnRTcGFuLFxuICAgIHJpZ2h0U3BhbixcbiAgICB0b3BTcGFuXG4gIH07XG59XG5mdW5jdGlvbiAkY29tcHV0ZVRhYmxlQ2VsbFJlY3RCb3VuZGFyeShtYXAsIGNlbGxBTWFwLCBjZWxsQk1hcCkge1xuICAvLyBJbml0aWFsIGJvdW5kYXJpZXMgYmFzZWQgb24gdGhlIGFuY2hvciBhbmQgZm9jdXMgY2VsbHNcbiAgbGV0IG1pbkNvbHVtbiA9IE1hdGgubWluKGNlbGxBTWFwLnN0YXJ0Q29sdW1uLCBjZWxsQk1hcC5zdGFydENvbHVtbik7XG4gIGxldCBtaW5Sb3cgPSBNYXRoLm1pbihjZWxsQU1hcC5zdGFydFJvdywgY2VsbEJNYXAuc3RhcnRSb3cpO1xuICBsZXQgbWF4Q29sdW1uID0gTWF0aC5tYXgoY2VsbEFNYXAuc3RhcnRDb2x1bW4gKyBjZWxsQU1hcC5jZWxsLl9fY29sU3BhbiAtIDEsIGNlbGxCTWFwLnN0YXJ0Q29sdW1uICsgY2VsbEJNYXAuY2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgbGV0IG1heFJvdyA9IE1hdGgubWF4KGNlbGxBTWFwLnN0YXJ0Um93ICsgY2VsbEFNYXAuY2VsbC5fX3Jvd1NwYW4gLSAxLCBjZWxsQk1hcC5zdGFydFJvdyArIGNlbGxCTWFwLmNlbGwuX19yb3dTcGFuIC0gMSk7XG5cbiAgLy8gS2VlcCBleHBhbmRpbmcgdW50aWwgd2UgaGF2ZSBhIGNvbXBsZXRlIHJlY3RhbmdsZVxuICBsZXQgaGFzQ2hhbmdlcztcbiAgZG8ge1xuICAgIGhhc0NoYW5nZXMgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGFsbCBjZWxscyBpbiB0aGUgdGFibGVcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAubGVuZ3RoOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgbWFwWzBdLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IG1hcFtyb3ddW2NvbF07XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGxFbmRDb2wgPSBjZWxsLnN0YXJ0Q29sdW1uICsgY2VsbC5jZWxsLl9fY29sU3BhbiAtIDE7XG4gICAgICAgIGNvbnN0IGNlbGxFbmRSb3cgPSBjZWxsLnN0YXJ0Um93ICsgY2VsbC5jZWxsLl9fcm93U3BhbiAtIDE7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjZWxsIGludGVyc2VjdHMgd2l0aCBvdXIgY3VycmVudCBzZWxlY3Rpb24gcmVjdGFuZ2xlXG4gICAgICAgIGNvbnN0IGludGVyc2VjdHNIb3Jpem9udGFsbHkgPSBjZWxsLnN0YXJ0Q29sdW1uIDw9IG1heENvbHVtbiAmJiBjZWxsRW5kQ29sID49IG1pbkNvbHVtbjtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0c1ZlcnRpY2FsbHkgPSBjZWxsLnN0YXJ0Um93IDw9IG1heFJvdyAmJiBjZWxsRW5kUm93ID49IG1pblJvdztcblxuICAgICAgICAvLyBJZiB0aGUgY2VsbCBpbnRlcnNlY3RzIGVpdGhlciBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICAgICAgICBpZiAoaW50ZXJzZWN0c0hvcml6b250YWxseSAmJiBpbnRlcnNlY3RzVmVydGljYWxseSkge1xuICAgICAgICAgIC8vIEV4cGFuZCBib3VuZGFyaWVzIHRvIGluY2x1ZGUgdGhpcyBjZWxsIGNvbXBsZXRlbHlcbiAgICAgICAgICBjb25zdCBuZXdNaW5Db2x1bW4gPSBNYXRoLm1pbihtaW5Db2x1bW4sIGNlbGwuc3RhcnRDb2x1bW4pO1xuICAgICAgICAgIGNvbnN0IG5ld01heENvbHVtbiA9IE1hdGgubWF4KG1heENvbHVtbiwgY2VsbEVuZENvbCk7XG4gICAgICAgICAgY29uc3QgbmV3TWluUm93ID0gTWF0aC5taW4obWluUm93LCBjZWxsLnN0YXJ0Um93KTtcbiAgICAgICAgICBjb25zdCBuZXdNYXhSb3cgPSBNYXRoLm1heChtYXhSb3csIGNlbGxFbmRSb3cpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYm91bmRhcmllcyBjaGFuZ2VkXG4gICAgICAgICAgaWYgKG5ld01pbkNvbHVtbiAhPT0gbWluQ29sdW1uIHx8IG5ld01heENvbHVtbiAhPT0gbWF4Q29sdW1uIHx8IG5ld01pblJvdyAhPT0gbWluUm93IHx8IG5ld01heFJvdyAhPT0gbWF4Um93KSB7XG4gICAgICAgICAgICBtaW5Db2x1bW4gPSBuZXdNaW5Db2x1bW47XG4gICAgICAgICAgICBtYXhDb2x1bW4gPSBuZXdNYXhDb2x1bW47XG4gICAgICAgICAgICBtaW5Sb3cgPSBuZXdNaW5Sb3c7XG4gICAgICAgICAgICBtYXhSb3cgPSBuZXdNYXhSb3c7XG4gICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKGhhc0NoYW5nZXMpO1xuICByZXR1cm4ge1xuICAgIG1heENvbHVtbixcbiAgICBtYXhSb3csXG4gICAgbWluQ29sdW1uLFxuICAgIG1pblJvd1xuICB9O1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbE5vZGVSZWN0KHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgW2NlbGxOb2RlLCwgZ3JpZE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KHRhYmxlQ2VsbE5vZGUpO1xuICBjb25zdCByb3dzID0gZ3JpZE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3Qgcm93Q291bnQgPSByb3dzLmxlbmd0aDtcbiAgY29uc3QgY29sdW1uQ291bnQgPSByb3dzWzBdLmdldENoaWxkcmVuKCkubGVuZ3RoO1xuXG4gIC8vIENyZWF0ZSBhIG1hdHJpeCBvZiB0aGUgc2FtZSBzaXplIGFzIHRoZSB0YWJsZSB0byB0cmFjayB0aGUgcG9zaXRpb24gb2YgZWFjaCBjZWxsXG4gIGNvbnN0IGNlbGxNYXRyaXggPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBjZWxsTWF0cml4W2ldID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcbiAgfVxuICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93Q291bnQ7IHJvd0luZGV4KyspIHtcbiAgICBjb25zdCByb3cgPSByb3dzW3Jvd0luZGV4XTtcbiAgICBjb25zdCBjZWxscyA9IHJvdy5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBjb2x1bW5JbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY2VsbEluZGV4ID0gMDsgY2VsbEluZGV4IDwgY2VsbHMubGVuZ3RoOyBjZWxsSW5kZXgrKykge1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBhdmFpbGFibGUgcG9zaXRpb24gaW4gdGhlIG1hdHJpeCwgc2tpcCB0aGUgcG9zaXRpb24gb2YgbWVyZ2VkIGNlbGxzXG4gICAgICB3aGlsZSAoY2VsbE1hdHJpeFtyb3dJbmRleF1bY29sdW1uSW5kZXhdKSB7XG4gICAgICAgIGNvbHVtbkluZGV4Kys7XG4gICAgICB9XG4gICAgICBjb25zdCBjZWxsID0gY2VsbHNbY2VsbEluZGV4XTtcbiAgICAgIGNvbnN0IHJvd1NwYW4gPSBjZWxsLl9fcm93U3BhbiB8fCAxO1xuICAgICAgY29uc3QgY29sU3BhbiA9IGNlbGwuX19jb2xTcGFuIHx8IDE7XG5cbiAgICAgIC8vIFB1dCB0aGUgY2VsbCBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHBvc2l0aW9uIGluIHRoZSBtYXRyaXhcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93U3BhbjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sU3BhbjsgaisrKSB7XG4gICAgICAgICAgY2VsbE1hdHJpeFtyb3dJbmRleCArIGldW2NvbHVtbkluZGV4ICsgal0gPSBjZWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0byB0aGUgb3JpZ2luYWwgaW5kZXgsIHJvdyBzcGFuIGFuZCBjb2x1bW4gc3BhbiBvZiB0aGUgY2VsbC5cbiAgICAgIGlmIChjZWxsTm9kZSA9PT0gY2VsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbFNwYW4sXG4gICAgICAgICAgY29sdW1uSW5kZXgsXG4gICAgICAgICAgcm93SW5kZXgsXG4gICAgICAgICAgcm93U3BhblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29sdW1uSW5kZXggKz0gY29sU3BhbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uICRnZXRDZWxsTm9kZXModGFibGVTZWxlY3Rpb24pIHtcbiAgY29uc3QgW1thbmNob3JOb2RlLCBhbmNob3JDZWxsLCBhbmNob3JSb3csIGFuY2hvclRhYmxlXSwgW2ZvY3VzTm9kZSwgZm9jdXNDZWxsLCBmb2N1c1JvdywgZm9jdXNUYWJsZV1dID0gWydhbmNob3InLCAnZm9jdXMnXS5tYXAoayA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHRhYmxlU2VsZWN0aW9uW2tdLmdldE5vZGUoKTtcbiAgICBjb25zdCBjZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGxOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbiAke2t9IHRvIGJlIChvciBhIGNoaWxkIG9mKSBUYWJsZUNlbGxOb2RlLCBnb3Qga2V5ICR7bm9kZS5nZXRLZXkoKX0gb2YgdHlwZSAke25vZGUuZ2V0VHlwZSgpfWApO1xuICAgIH1cbiAgICBjb25zdCByb3dOb2RlID0gY2VsbE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93Tm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gJHtrfSBjZWxsIHBhcmVudCB0byBiZSBhIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZU5vZGUgPSByb3dOb2RlLmdldFBhcmVudCgpO1xuICAgIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gJHtrfSByb3cgcGFyZW50IHRvIGJlIGEgVGFibGVOb2RlYCk7XG4gICAgfVxuICAgIHJldHVybiBbbm9kZSwgY2VsbE5vZGUsIHJvd05vZGUsIHRhYmxlTm9kZV07XG4gIH0pO1xuICAvLyBUT0RPOiBuZXN0ZWQgdGFibGVzIG1heSB2aW9sYXRlIHRoaXNcbiAgaWYgKCFhbmNob3JUYWJsZS5pcyhmb2N1c1RhYmxlKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gYW5jaG9yIGFuZCBmb2N1cyB0byBiZSBpbiB0aGUgc2FtZSB0YWJsZWApO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yQ2VsbCxcbiAgICBhbmNob3JOb2RlLFxuICAgIGFuY2hvclJvdyxcbiAgICBhbmNob3JUYWJsZSxcbiAgICBmb2N1c0NlbGwsXG4gICAgZm9jdXNOb2RlLFxuICAgIGZvY3VzUm93LFxuICAgIGZvY3VzVGFibGVcbiAgfTtcbn1cbmNsYXNzIFRhYmxlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IodGFibGVLZXksIGFuY2hvciwgZm9jdXMpIHtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmZvY3VzID0gZm9jdXM7XG4gICAgYW5jaG9yLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIGZvY3VzLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy50YWJsZUtleSA9IHRhYmxlS2V5O1xuICB9XG4gIGdldFN0YXJ0RW5kUG9pbnRzKCkge1xuICAgIHJldHVybiBbdGhpcy5hbmNob3IsIHRoaXMuZm9jdXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayAkY3JlYXRlVGFibGVTZWxlY3Rpb259IHVuZm9ydHVuYXRlbHkgbWFrZXMgaXQgdmVyeSBlYXN5IHRvIGNyZWF0ZVxuICAgKiBub25zZW5zZSBzZWxlY3Rpb25zLCBzbyB3ZSBoYXZlIGEgbWV0aG9kIHRvIHNlZSBpZiB0aGUgc2VsZWN0aW9uIHByb2JhYmx5XG4gICAqIG1ha2VzIHNlbnNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUYWJsZVNlbGVjdGlvbiBpcyAocHJvYmFibHkpIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlS2V5ICE9PSAncm9vdCcgJiYgdGhpcy5hbmNob3Iua2V5ICE9PSAncm9vdCcgJiYgdGhpcy5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHRoaXMuZm9jdXMua2V5ICE9PSAncm9vdCcgJiYgdGhpcy5mb2N1cy50eXBlID09PSAnZWxlbWVudCc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTZWxlY3Rpb24gaXMgXCJiYWNrd2FyZHNcIiwgbWVhbmluZyB0aGUgZm9jdXNcbiAgICogbG9naWNhbGx5IHByZWNlZGVzIHRoZSBhbmNob3IgaW4gdGhlIEVkaXRvclN0YXRlLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgYmFja3dhcmRzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0JhY2t3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzLmlzQmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgfVxuICBnZXRDYWNoZWROb2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTm9kZXM7XG4gIH1cbiAgc2V0Q2FjaGVkTm9kZXMobm9kZXMpIHtcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG5vZGVzO1xuICB9XG4gIGlzKHNlbGVjdGlvbikge1xuICAgIHJldHVybiAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHRoaXMudGFibGVLZXkgPT09IHNlbGVjdGlvbi50YWJsZUtleSAmJiB0aGlzLmFuY2hvci5pcyhzZWxlY3Rpb24uYW5jaG9yKSAmJiB0aGlzLmZvY3VzLmlzKHNlbGVjdGlvbi5mb2N1cyk7XG4gIH1cbiAgc2V0KHRhYmxlS2V5LCBhbmNob3JDZWxsS2V5LCBmb2N1c0NlbGxLZXkpIHtcbiAgICAvLyBub3RlOiBjbG9zdXJlIGNvbXBpbGVyJ3MgYWNvcm4gZG9lcyBub3Qgc3VwcG9ydCB8fD1cbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5kaXJ0eSB8fCB0YWJsZUtleSAhPT0gdGhpcy50YWJsZUtleSB8fCBhbmNob3JDZWxsS2V5ICE9PSB0aGlzLmFuY2hvci5rZXkgfHwgZm9jdXNDZWxsS2V5ICE9PSB0aGlzLmZvY3VzLmtleTtcbiAgICB0aGlzLnRhYmxlS2V5ID0gdGFibGVLZXk7XG4gICAgdGhpcy5hbmNob3Iua2V5ID0gYW5jaG9yQ2VsbEtleTtcbiAgICB0aGlzLmZvY3VzLmtleSA9IGZvY3VzQ2VsbEtleTtcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZVNlbGVjdGlvbih0aGlzLnRhYmxlS2V5LCAkY3JlYXRlUG9pbnQodGhpcy5hbmNob3Iua2V5LCB0aGlzLmFuY2hvci5vZmZzZXQsIHRoaXMuYW5jaG9yLnR5cGUpLCAkY3JlYXRlUG9pbnQodGhpcy5mb2N1cy5rZXksIHRoaXMuZm9jdXMub2Zmc2V0LCB0aGlzLmZvY3VzLnR5cGUpKTtcbiAgfVxuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZXh0cmFjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROb2RlcygpO1xuICB9XG4gIGluc2VydFJhd1RleHQodGV4dCkge1xuICAgIC8vIERvIG5vdGhpbmc/XG4gIH1cbiAgaW5zZXJ0VGV4dCgpIHtcbiAgICAvLyBEbyBub3RoaW5nP1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgVGV4dEZvcm1hdFR5cGUgaXMgcHJlc2VudCBvbiB0aGUgU2VsZWN0aW9uLlxuICAgKiBUaGlzIHdpbGwgYmUgdHJ1ZSBpZiBhbnkgcGFyYWdyYXBoIGluIHRhYmxlIGNlbGxzIGhhcyB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIFRleHRGb3JtYXRUeXBlIHRvIGNoZWNrIGZvci5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgZm9ybWF0IGlzIGN1cnJlbnRseSB0b2dnbGVkIG9uIG9uIHRoZSBTZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc0Zvcm1hdCh0eXBlKSB7XG4gICAgbGV0IGZvcm1hdCA9IDA7XG4gICAgY29uc3QgY2VsbE5vZGVzID0gdGhpcy5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBjZWxsTm9kZXMuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICBjb25zdCBwYXJhZ3JhcGggPSBjZWxsTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoJGlzUGFyYWdyYXBoTm9kZShwYXJhZ3JhcGgpKSB7XG4gICAgICAgIGZvcm1hdCB8PSBwYXJhZ3JhcGguZ2V0VGV4dEZvcm1hdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGZvcm1hdEZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICAgIHJldHVybiAoZm9ybWF0ICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cbiAgaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgICBjb25zdCBmb2N1c05vZGUgPSB0aGlzLmZvY3VzLmdldE5vZGUoKTtcbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gZm9jdXMgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMKGZvY3VzTm9kZS5zZWxlY3QoMCwgZm9jdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpKSk7XG4gICAgc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzKTtcbiAgfVxuXG4gIC8vIFRPRE8gRGVwcmVjYXRlIHRoaXMgbWV0aG9kLiBJdCdzIGNvbmZ1c2luZyB3aGVuIHVzZWQgd2l0aCBjb2xzcGFufHJvd3NwYW5cbiAgZ2V0U2hhcGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yQ2VsbCxcbiAgICAgIGZvY3VzQ2VsbFxuICAgIH0gPSAkZ2V0Q2VsbE5vZGVzKHRoaXMpO1xuICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlUmVjdCA9ICRnZXRUYWJsZUNlbGxOb2RlUmVjdChhbmNob3JDZWxsKTtcbiAgICBpZiAoIShhbmNob3JDZWxsTm9kZVJlY3QgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGdldENlbGxSZWN0OiBleHBlY3RlZCB0byBmaW5kIEFuY2hvck5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgZm9jdXNDZWxsTm9kZVJlY3QgPSAkZ2V0VGFibGVDZWxsTm9kZVJlY3QoZm9jdXNDZWxsKTtcbiAgICBpZiAoIShmb2N1c0NlbGxOb2RlUmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0Q2VsbFJlY3Q6IGV4cGVjdGVkIHRvIGZpbmQgZm9jdXNDZWxsTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFggPSBNYXRoLm1pbihhbmNob3JDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXgsIGZvY3VzQ2VsbE5vZGVSZWN0LmNvbHVtbkluZGV4KTtcbiAgICBjb25zdCBzdG9wWCA9IE1hdGgubWF4KGFuY2hvckNlbGxOb2RlUmVjdC5jb2x1bW5JbmRleCArIGFuY2hvckNlbGxOb2RlUmVjdC5jb2xTcGFuIC0gMSwgZm9jdXNDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXggKyBmb2N1c0NlbGxOb2RlUmVjdC5jb2xTcGFuIC0gMSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5taW4oYW5jaG9yQ2VsbE5vZGVSZWN0LnJvd0luZGV4LCBmb2N1c0NlbGxOb2RlUmVjdC5yb3dJbmRleCk7XG4gICAgY29uc3Qgc3RvcFkgPSBNYXRoLm1heChhbmNob3JDZWxsTm9kZVJlY3Qucm93SW5kZXggKyBhbmNob3JDZWxsTm9kZVJlY3Qucm93U3BhbiAtIDEsIGZvY3VzQ2VsbE5vZGVSZWN0LnJvd0luZGV4ICsgZm9jdXNDZWxsTm9kZVJlY3Qucm93U3BhbiAtIDEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tWDogTWF0aC5taW4oc3RhcnRYLCBzdG9wWCksXG4gICAgICBmcm9tWTogTWF0aC5taW4oc3RhcnRZLCBzdG9wWSksXG4gICAgICB0b1g6IE1hdGgubWF4KHN0YXJ0WCwgc3RvcFgpLFxuICAgICAgdG9ZOiBNYXRoLm1heChzdGFydFksIHN0b3BZKVxuICAgIH07XG4gIH1cbiAgZ2V0Tm9kZXMoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWROb2RlcyA9IHRoaXMuX2NhY2hlZE5vZGVzO1xuICAgIGlmIChjYWNoZWROb2RlcyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZE5vZGVzO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JUYWJsZTogdGFibGVOb2RlLFxuICAgICAgYW5jaG9yQ2VsbCxcbiAgICAgIGZvY3VzQ2VsbFxuICAgIH0gPSAkZ2V0Q2VsbE5vZGVzKHRoaXMpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbEdyaWQgPSBmb2N1c0NlbGwuZ2V0UGFyZW50cygpWzFdO1xuICAgIGlmIChmb2N1c0NlbGxHcmlkICE9PSB0YWJsZU5vZGUpIHtcbiAgICAgIGlmICghdGFibGVOb2RlLmlzUGFyZW50T2YoZm9jdXNDZWxsKSkge1xuICAgICAgICAvLyBmb2N1cyBpcyBvbiBoaWdoZXIgR3JpZCBsZXZlbCB0aGFuIGFuY2hvclxuICAgICAgICBjb25zdCBncmlkUGFyZW50ID0gdGFibGVOb2RlLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoIShncmlkUGFyZW50ICE9IG51bGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBncmlkUGFyZW50IHRvIGhhdmUgYSBwYXJlbnRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldCh0aGlzLnRhYmxlS2V5LCBncmlkUGFyZW50LmdldEtleSgpLCBmb2N1c0NlbGwuZ2V0S2V5KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYW5jaG9yIGlzIG9uIGhpZ2hlciBHcmlkIGxldmVsIHRoYW4gZm9jdXNcbiAgICAgICAgY29uc3QgZm9jdXNDZWxsUGFyZW50ID0gZm9jdXNDZWxsR3JpZC5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCEoZm9jdXNDZWxsUGFyZW50ICE9IG51bGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBmb2N1c0NlbGxQYXJlbnQgdG8gaGF2ZSBhIHBhcmVudGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KHRoaXMudGFibGVLZXksIGZvY3VzQ2VsbC5nZXRLZXkoKSwgZm9jdXNDZWxsUGFyZW50LmdldEtleSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBNYXBwaW5nIHRoZSB3aG9sZSBHcmlkIGV2ZXJ5IHRpbWUgbm90IGVmZmljaWVudC4gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBlbnRpcmUgc3RhdGUgb25seVxuICAgIC8vIG9uY2UgKG9uIGxvYWQpIGFuZCBpdGVyYXRlIG9uIGl0IGFzIHVwZGF0ZXMgb2NjdXIuIEhvd2V2ZXIsIHRvIGRvIHRoaXMgd2UgbmVlZCB0byBoYXZlIHRoZVxuICAgIC8vIGFiaWxpdHkgdG8gc3RvcmUgYSBzdGF0ZS4gS2lsbGluZyBUYWJsZVNlbGVjdGlvbiBhbmQgbW92aW5nIHRoZSBsb2dpYyB0byB0aGUgcGx1Z2luIHdvdWxkIG1ha2VcbiAgICAvLyB0aGlzIHBvc3NpYmxlLlxuICAgIGNvbnN0IFttYXAsIGNlbGxBTWFwLCBjZWxsQk1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgICBjb25zdCB7XG4gICAgICBtaW5Db2x1bW4sXG4gICAgICBtYXhDb2x1bW4sXG4gICAgICBtaW5Sb3csXG4gICAgICBtYXhSb3dcbiAgICB9ID0gJGNvbXB1dGVUYWJsZUNlbGxSZWN0Qm91bmRhcnkobWFwLCBjZWxsQU1hcCwgY2VsbEJNYXApO1xuXG4gICAgLy8gV2UgdXNlIGEgTWFwIGhlcmUgYmVjYXVzZSBtZXJnZWQgY2VsbHMgaW4gdGhlIGdyaWQgd291bGQgb3RoZXJ3aXNlXG4gICAgLy8gc2hvdyB1cCBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgbm9kZXMgYXJyYXlcbiAgICBjb25zdCBub2RlTWFwID0gbmV3IE1hcChbW3RhYmxlTm9kZS5nZXRLZXkoKSwgdGFibGVOb2RlXV0pO1xuICAgIGxldCBsYXN0Um93ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gbWluUm93OyBpIDw9IG1heFJvdzsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gbWluQ29sdW1uOyBqIDw9IG1heENvbHVtbjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjZWxsXG4gICAgICAgIH0gPSBtYXBbaV1bal07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBjZWxsLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShjdXJyZW50Um93KSkge1xuICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVDZWxsTm9kZSBwYXJlbnQgdG8gYmUgYSBUYWJsZVJvd05vZGVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFJvdyAhPT0gbGFzdFJvdykge1xuICAgICAgICAgIG5vZGVNYXAuc2V0KGN1cnJlbnRSb3cuZ2V0S2V5KCksIGN1cnJlbnRSb3cpO1xuICAgICAgICAgIGxhc3RSb3cgPSBjdXJyZW50Um93O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZU1hcC5oYXMoY2VsbC5nZXRLZXkoKSkpIHtcbiAgICAgICAgICAkdmlzaXRSZWN1cnNpdmVseShjZWxsLCBjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZU1hcC5zZXQoY2hpbGROb2RlLmdldEtleSgpLCBjaGlsZE5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gQXJyYXkuZnJvbShub2RlTWFwLnZhbHVlcygpKTtcbiAgICBpZiAoIWlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKS5maWx0ZXIobm9kZSA9PiAkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBjb25zdCByb3cgPSBub2RlLl9fcGFyZW50O1xuICAgICAgY29uc3QgbmV4dFJvdyA9IChub2Rlc1tpICsgMV0gfHwge30pLl9fcGFyZW50O1xuICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZS5nZXRUZXh0Q29udGVudCgpICsgKG5leHRSb3cgIT09IHJvdyA/ICdcXG4nIDogJ1xcdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc1RhYmxlU2VsZWN0aW9uKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBUYWJsZVNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZVNlbGVjdGlvbigpIHtcbiAgLy8gVE9ETyB0aGlzIGlzIGEgc3Vib3B0aW1hbCBkZXNpZ24sIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBoYXZlXG4gIC8vIGEgdGFibGUgc2VsZWN0aW9uIHRoYXQgaXNuJ3QgYXNzb2NpYXRlZCB3aXRoIGEgdGFibGUuIFRoaXNcbiAgLy8gY29uc3RydWN0b3Igc2hvdWxkIGhhdmUgcmVxdWlyZWQgYXJndW1lbnRzIGFuZCBpbiB0cnVlIHdlXG4gIC8vIHNob3VsZCBjaGVjayB0aGF0IHRoZXkgcG9pbnQgdG8gYSB0YWJsZSBhbmQgYXJlIGVsZW1lbnQgcG9pbnRzIHRvXG4gIC8vIGNlbGwgbm9kZXMgb2YgdGhhdCB0YWJsZS5cbiAgY29uc3QgYW5jaG9yID0gJGNyZWF0ZVBvaW50KCdyb290JywgMCwgJ2VsZW1lbnQnKTtcbiAgY29uc3QgZm9jdXMgPSAkY3JlYXRlUG9pbnQoJ3Jvb3QnLCAwLCAnZWxlbWVudCcpO1xuICByZXR1cm4gbmV3IFRhYmxlU2VsZWN0aW9uKCdyb290JywgYW5jaG9yLCBmb2N1cyk7XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKSB7XG4gIGNvbnN0IHRhYmxlTm9kZUtleSA9IHRhYmxlTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgYW5jaG9yQ2VsbEtleSA9IGFuY2hvckNlbGwuZ2V0S2V5KCk7XG4gIGNvbnN0IGZvY3VzQ2VsbEtleSA9IGZvY3VzQ2VsbC5nZXRLZXkoKTtcbiAge1xuICAgIGlmICghdGFibGVOb2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tOiB0YWJsZU5vZGUgJHt0YWJsZU5vZGVLZXl9IGlzIG5vdCBhdHRhY2hlZGApO1xuICAgIH1cbiAgICBpZiAoIXRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShhbmNob3JDZWxsKSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGNyZWF0ZVRhYmxlU2VsZWN0aW9uRnJvbTogYW5jaG9yQ2VsbCAke2FuY2hvckNlbGxLZXl9IGlzIG5vdCBpbiB0YWJsZSAke3RhYmxlTm9kZUtleX1gKTtcbiAgICB9XG4gICAgaWYgKCF0YWJsZU5vZGUuaXMoJGZpbmRUYWJsZU5vZGUoZm9jdXNDZWxsKSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGNyZWF0ZVRhYmxlU2VsZWN0aW9uRnJvbTogZm9jdXNDZWxsICR7Zm9jdXNDZWxsS2V5fSBpcyBub3QgaW4gdGFibGUgJHt0YWJsZU5vZGVLZXl9YCk7XG4gICAgfSAvLyBUT0RPOiBDaGVjayBmb3IgcmVjdGFuZ3VsYXIgZ3JpZFxuICB9XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGNvbnN0IG5leHRTZWxlY3Rpb24gPSAkaXNUYWJsZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSA/IHByZXZTZWxlY3Rpb24uY2xvbmUoKSA6ICRjcmVhdGVUYWJsZVNlbGVjdGlvbigpO1xuICBuZXh0U2VsZWN0aW9uLnNldCh0YWJsZU5vZGUuZ2V0S2V5KCksIGFuY2hvckNlbGwuZ2V0S2V5KCksIGZvY3VzQ2VsbC5nZXRLZXkoKSk7XG4gIHJldHVybiBuZXh0U2VsZWN0aW9uO1xufVxuXG4vKipcbiAqIERlcHRoIGZpcnN0IHZpc2l0b3JcbiAqIEBwYXJhbSBub2RlIFRoZSBzdGFydGluZyBub2RlXG4gKiBAcGFyYW0gJHZpc2l0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIG5vZGUuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGVuIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSB3aWxsIG5vdCBiZSBleHBsb3JlZFxuICovXG5mdW5jdGlvbiAkdmlzaXRSZWN1cnNpdmVseShub2RlLCAkdmlzaXQpIHtcbiAgY29uc3Qgc3RhY2sgPSBbW25vZGVdXTtcbiAgZm9yIChsZXQgY3VycmVudEFycmF5ID0gc3RhY2suYXQoLTEpOyBjdXJyZW50QXJyYXkgIT09IHVuZGVmaW5lZCAmJiBzdGFjay5sZW5ndGggPiAwOyBjdXJyZW50QXJyYXkgPSBzdGFjay5hdCgtMSkpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IGN1cnJlbnRBcnJheS5wb3AoKTtcbiAgICBpZiAoY3VycmVudE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIGlmICgkdmlzaXQoY3VycmVudE5vZGUpICE9PSBmYWxzZSAmJiAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHN0YWNrLnB1c2goY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uICRnZXRUYWJsZUFuZEVsZW1lbnRCeUtleSh0YWJsZU5vZGVLZXksIGVkaXRvciA9ICRnZXRFZGl0b3IoKSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHRhYmxlTm9kZUtleSk7XG4gIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXI6IEV4cGVjdGVkIHRhYmxlTm9kZUtleSAke3RhYmxlTm9kZUtleX0gdG8gYmUgYSBUYWJsZU5vZGVgKTtcbiAgfVxuICBjb25zdCB0YWJsZUVsZW1lbnQgPSBnZXRUYWJsZUVsZW1lbnQodGFibGVOb2RlLCBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZUtleSkpO1xuICBpZiAoISh0YWJsZUVsZW1lbnQgIT09IG51bGwpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUYWJsZU9ic2VydmVyOiBFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00gZm9yIGtleSAke3RhYmxlTm9kZUtleX1gKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRhYmxlRWxlbWVudCxcbiAgICB0YWJsZU5vZGVcbiAgfTtcbn1cbmNsYXNzIFRhYmxlT2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3RvcihlZGl0b3IsIHRhYmxlTm9kZUtleSkge1xuICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IGZhbHNlO1xuICAgIHRoaXMuYW5jaG9yWCA9IC0xO1xuICAgIHRoaXMuYW5jaG9yWSA9IC0xO1xuICAgIHRoaXMuZm9jdXNYID0gLTE7XG4gICAgdGhpcy5mb2N1c1kgPSAtMTtcbiAgICB0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlID0gbmV3IFNldCgpO1xuICAgIHRoaXMudGFibGVOb2RlS2V5ID0gdGFibGVOb2RlS2V5O1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMudGFibGUgPSB7XG4gICAgICBjb2x1bW5zOiAwLFxuICAgICAgZG9tUm93czogW10sXG4gICAgICByb3dzOiAwXG4gICAgfTtcbiAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGwgPSBudWxsO1xuICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzU2VsZWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5wb2ludGVyVHlwZSA9IG51bGw7XG4gICAgdGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMubGlzdGVuZXJPcHRpb25zID0ge1xuICAgICAgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9O1xuICAgIHRoaXMubmV4dEZvY3VzID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrVGFibGUoKTtcbiAgfVxuICBnZXRUYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoJ3JlbW92ZUxpc3RlbmVycycpO1xuICAgIEFycmF5LmZyb20odGhpcy5saXN0ZW5lcnNUb1JlbW92ZSkuZm9yRWFjaChyZW1vdmVMaXN0ZW5lciA9PiByZW1vdmVMaXN0ZW5lcigpKTtcbiAgICB0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlLmNsZWFyKCk7XG4gIH1cbiAgJGxvb2t1cCgpIHtcbiAgICByZXR1cm4gJGdldFRhYmxlQW5kRWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5LCB0aGlzLmVkaXRvcik7XG4gIH1cbiAgdHJhY2tUYWJsZSgpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHJlY29yZHMgPT4ge1xuICAgICAgdGhpcy5lZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgICAgbGV0IGdyaWROZWVkc1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJlY29yZC50YXJnZXQ7XG4gICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWU7XG4gICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnVEFCTEUnIHx8IG5vZGVOYW1lID09PSAnVEJPRFknIHx8IG5vZGVOYW1lID09PSAnVEhFQUQnIHx8IG5vZGVOYW1lID09PSAnVFInKSB7XG4gICAgICAgICAgICBncmlkTmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JpZE5lZWRzUmVkcmF3KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0YWJsZU5vZGUsXG4gICAgICAgICAgdGFibGVFbGVtZW50XG4gICAgICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICAgICAgdGhpcy50YWJsZSA9IGdldFRhYmxlKHRhYmxlTm9kZSwgdGFibGVFbGVtZW50KTtcbiAgICAgIH0sIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFibGVOb2RlLFxuICAgICAgICB0YWJsZUVsZW1lbnRcbiAgICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICAgIHRoaXMudGFibGUgPSBnZXRUYWJsZSh0YWJsZU5vZGUsIHRhYmxlRWxlbWVudCk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKHRhYmxlRWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3JcbiAgICB9KTtcbiAgfVxuICAkY2xlYXJIaWdobGlnaHQoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JYID0gLTE7XG4gICAgdGhpcy5hbmNob3JZID0gLTE7XG4gICAgdGhpcy5mb2N1c1ggPSAtMTtcbiAgICB0aGlzLmZvY3VzWSA9IC0xO1xuICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICAgIHRoaXMuJGVuYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICAgY29uc3Qge1xuICAgICAgdGFibGVOb2RlLFxuICAgICAgdGFibGVFbGVtZW50XG4gICAgfSA9IHRoaXMuJGxvb2t1cCgpO1xuICAgIGNvbnN0IGdyaWQgPSBnZXRUYWJsZSh0YWJsZU5vZGUsIHRhYmxlRWxlbWVudCk7XG4gICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIGdyaWQsIG51bGwpO1xuICAgIGlmICgkZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwpIHtcbiAgICAgICRzZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cbiAgJGVuYWJsZUhpZ2hsaWdodFN0eWxlKCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhYmxlRWxlbWVudFxuICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQodGFibGVFbGVtZW50LCBlZGl0b3IuX2NvbmZpZy50aGVtZS50YWJsZVNlbGVjdGlvbik7XG4gICAgdGFibGVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGUtc2VsZWN0aW9uJyk7XG4gICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICB9XG4gICRkaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFibGVFbGVtZW50XG4gICAgfSA9IHRoaXMuJGxvb2t1cCgpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQodGFibGVFbGVtZW50LCB0aGlzLmVkaXRvci5fY29uZmlnLnRoZW1lLnRhYmxlU2VsZWN0aW9uKTtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gdHJ1ZTtcbiAgfVxuICAkdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBpZiAoIShzZWxlY3Rpb24udGFibGVLZXkgPT09IHRoaXMudGFibGVOb2RlS2V5KSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXIuJHVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb246IHNlbGVjdGlvbi50YWJsZUtleSAhPT0gdGhpcy50YWJsZU5vZGVLZXkgKCcke3NlbGVjdGlvbi50YWJsZUtleX0nICE9PSAnJHt0aGlzLnRhYmxlTm9kZUtleX0nKWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgICAgdGhpcy51cGRhdGVET01TZWxlY3Rpb24oKTtcbiAgICAgICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCB0aGlzLnRhYmxlLCB0aGlzLnRhYmxlU2VsZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kY2xlYXJIaWdobGlnaHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEZpcmVmb3ggaGFzIGEgc3RyYW5nZSBiZWhhdmlvciB3aGVyZSBwcmVzc2luZyB0aGUgZG93biBhcnJvdyBrZXkgZnJvbVxuICAgKiBhYm92ZSB0aGUgdGFibGUgd2lsbCBtb3ZlIHRoZSBjYXJldCBhZnRlciB0aGUgdGFibGUgYW5kIHRoZW4gbGV4aWNhbFxuICAgKiB3aWxsIHNlbGVjdCB0aGUgbGFzdCBjZWxsIGluc3RlYWQgb2YgdGhlIGZpcnN0LlxuICAgKiBXZSBkbyBzdGlsbCB3YW50IHRvIGxldCB0aGUgYnJvd3NlciBoYW5kbGUgY2FyZXQgbW92ZW1lbnQgYnV0IHdlIHdpbGxcbiAgICogdXNlIHRoaXMgcHJvcGVydHkgdG8gXCJ0YWdcIiB0aGUgdXBkYXRlIHNvIHRoYXQgd2UgY2FuIHJlY2hlY2sgdGhlXG4gICAqIHNlbGVjdGlvbiBhZnRlciB0aGUgZXZlbnQgaXMgcHJvY2Vzc2VkLlxuICAgKi9cbiAgc2V0U2hvdWxkQ2hlY2tTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbiA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0QW5kQ2xlYXJTaG91bGRDaGVja1NlbGVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogV2hlbiBoYW5kbGluZyBtb3VzZW1vdmUgZXZlbnRzIHdlIHRyYWNrIHdoYXQgdGhlIGZvY3VzIGNlbGwgc2hvdWxkIGJlLCBidXRcbiAgICogdGhlIERPTSBzZWxlY3Rpb24gbWF5IGVuZCB1cCBzb21ld2hlcmUgZWxzZSBlbnRpcmVseS4gV2UgZG9uJ3QgaGF2ZSBhbiBlbGVnYW50XG4gICAqIHdheSB0byBoYW5kbGUgdGhpcyBhZnRlciB0aGUgRE9NIHNlbGVjdGlvbiBoYXMgYmVlbiByZXNvbHZlZCBpbiBhXG4gICAqIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCBjYWxsYmFjay5cbiAgICovXG4gIHNldE5leHRGb2N1cyhuZXh0Rm9jdXMpIHtcbiAgICB0aGlzLm5leHRGb2N1cyA9IG5leHRGb2N1cztcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0QW5kQ2xlYXJOZXh0Rm9jdXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmV4dEZvY3VzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG5leHRGb2N1cyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0Rm9jdXMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dEZvY3VzO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVET01TZWxlY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYW5jaG9yQ2VsbCAhPT0gbnVsbCAmJiB0aGlzLmZvY3VzQ2VsbCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKHRoaXMuZWRpdG9yLl93aW5kb3cpO1xuICAgICAgLy8gV2UgYXJlIG5vdCB1c2luZyBhIG5hdGl2ZSBzZWxlY3Rpb24gZm9yIHRhYmxlcywgYW5kIGlmIHdlXG4gICAgICAvLyBzZXQgb25lIHRoZW4gdGhlIHJlY29uY2lsZXIgd2lsbCB1bmRvIGl0LlxuICAgICAgLy8gVE9ETyAtIGl0IHdvdWxkIG1ha2Ugc2Vuc2UgdG8gaGF2ZSBvbmUgc28gdGhhdCBuYXRpdmVcbiAgICAgIC8vICAgICAgICBjb3B5L3Bhc3RlIHdvcmtlZC4gUmlnaHQgbm93IHdlIGhhdmUgdG8gZW11bGF0ZSB3aXRoXG4gICAgICAvLyAgICAgICAga2V5Ym9hcmQgZXZlbnRzIGJ1dCBpdCB3b24ndCBmaXJlIGlmIHRyaWdnZXJlZCBmcm9tIHRoZSBtZW51XG4gICAgICBpZiAoZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oY2VsbCwgaWdub3JlU3RhcnQgPSBmYWxzZSkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhYmxlTm9kZVxuICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICBjb25zdCBjZWxsWCA9IGNlbGwueDtcbiAgICBjb25zdCBjZWxsWSA9IGNlbGwueTtcbiAgICB0aGlzLmZvY3VzQ2VsbCA9IGNlbGw7XG4gICAgaWYgKCF0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgJiYgKHRoaXMuYW5jaG9yWCAhPT0gY2VsbFggfHwgdGhpcy5hbmNob3JZICE9PSBjZWxsWSB8fCBpZ25vcmVTdGFydCkpIHtcbiAgICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IHRydWU7XG4gICAgICB0aGlzLiRkaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICB9IGVsc2UgaWYgKGNlbGxYID09PSB0aGlzLmZvY3VzWCAmJiBjZWxsWSA9PT0gdGhpcy5mb2N1c1kpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5mb2N1c1ggPSBjZWxsWDtcbiAgICB0aGlzLmZvY3VzWSA9IGNlbGxZO1xuICAgIGlmICh0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMpIHtcbiAgICAgIGNvbnN0IGZvY3VzVGFibGVDZWxsTm9kZSA9ICRnZXROZWFyZXN0VGFibGVDZWxsSW5UYWJsZUZyb21ET01Ob2RlKHRhYmxlTm9kZSwgY2VsbC5lbGVtKTtcbiAgICAgIGlmICh0aGlzLnRhYmxlU2VsZWN0aW9uICE9IG51bGwgJiYgdGhpcy5hbmNob3JDZWxsTm9kZUtleSAhPSBudWxsICYmIGZvY3VzVGFibGVDZWxsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkgPSBmb2N1c1RhYmxlQ2VsbE5vZGUuZ2V0S2V5KCk7XG4gICAgICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tKHRhYmxlTm9kZSwgdGhpcy4kZ2V0QW5jaG9yVGFibGVDZWxsT3JUaHJvdygpLCBmb2N1c1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgICAkc2V0U2VsZWN0aW9uKHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gICRnZXRBbmNob3JUYWJsZUNlbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPyAkZ2V0Tm9kZUJ5S2V5KHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkpIDogbnVsbDtcbiAgfVxuICAkZ2V0QW5jaG9yVGFibGVDZWxsT3JUaHJvdygpIHtcbiAgICBjb25zdCBhbmNob3JUYWJsZUNlbGwgPSB0aGlzLiRnZXRBbmNob3JUYWJsZUNlbGwoKTtcbiAgICBpZiAoIShhbmNob3JUYWJsZUNlbGwgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXIgYW5jaG9yVGFibGVDZWxsIGlzIG51bGxgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuY2hvclRhYmxlQ2VsbDtcbiAgfVxuICAkZ2V0Rm9jdXNUYWJsZUNlbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA/ICRnZXROb2RlQnlLZXkodGhpcy5mb2N1c0NlbGxOb2RlS2V5KSA6IG51bGw7XG4gIH1cbiAgJGdldEZvY3VzVGFibGVDZWxsT3JUaHJvdygpIHtcbiAgICBjb25zdCBmb2N1c1RhYmxlQ2VsbCA9IHRoaXMuJGdldEZvY3VzVGFibGVDZWxsKCk7XG4gICAgaWYgKCEoZm9jdXNUYWJsZUNlbGwgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXIgZm9jdXNUYWJsZUNlbGwgaXMgbnVsbGApO1xuICAgIH1cbiAgICByZXR1cm4gZm9jdXNUYWJsZUNlbGw7XG4gIH1cbiAgJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCkge1xuICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IGZhbHNlO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IGNlbGw7XG4gICAgdGhpcy5hbmNob3JYID0gY2VsbC54O1xuICAgIHRoaXMuYW5jaG9yWSA9IGNlbGwueTtcbiAgICBjb25zdCB7XG4gICAgICB0YWJsZU5vZGVcbiAgICB9ID0gdGhpcy4kbG9va3VwKCk7XG4gICAgY29uc3QgYW5jaG9yVGFibGVDZWxsTm9kZSA9ICRnZXROZWFyZXN0VGFibGVDZWxsSW5UYWJsZUZyb21ET01Ob2RlKHRhYmxlTm9kZSwgY2VsbC5lbGVtKTtcbiAgICBpZiAoYW5jaG9yVGFibGVDZWxsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5jaG9yTm9kZUtleSA9IGFuY2hvclRhYmxlQ2VsbE5vZGUuZ2V0S2V5KCk7XG4gICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gdGhpcy50YWJsZVNlbGVjdGlvbiAhPSBudWxsID8gdGhpcy50YWJsZVNlbGVjdGlvbi5jbG9uZSgpIDogJGNyZWF0ZVRhYmxlU2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gYW5jaG9yTm9kZUtleTtcbiAgICB9XG4gIH1cbiAgJGZvcm1hdENlbGxzKHR5cGUpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlIHNlbGVjdGlvbmApO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXRTZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBhbmNob3IgPSBmb3JtYXRTZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gZm9ybWF0U2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IGNlbGxOb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBpZiAoIShjZWxsTm9kZXMubGVuZ3RoID4gMCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTm8gdGFibGUgY2VsbHMgcHJlc2VudGApO1xuICAgIH1cbiAgICBjb25zdCBwYXJhZ3JhcGggPSBjZWxsTm9kZXNbMF0uZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGNvbnN0IGFsaWduRm9ybWF0V2l0aCA9ICRpc1BhcmFncmFwaE5vZGUocGFyYWdyYXBoKSA/IHBhcmFncmFwaC5nZXRGb3JtYXRGbGFncyh0eXBlLCBudWxsKSA6IG51bGw7XG4gICAgY2VsbE5vZGVzLmZvckVhY2goY2VsbE5vZGUgPT4ge1xuICAgICAgYW5jaG9yLnNldChjZWxsTm9kZS5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgIGZvY3VzLnNldChjZWxsTm9kZS5nZXRLZXkoKSwgY2VsbE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICBmb3JtYXRTZWxlY3Rpb24uZm9ybWF0VGV4dCh0eXBlLCBhbGlnbkZvcm1hdFdpdGgpO1xuICAgIH0pO1xuICAgICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB0aGlzLmVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9XG4gICRjbGVhclRleHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWRpdG9yXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgdGFibGVOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBUYWJsZU5vZGUuJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb25gKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBlbnRpcmUgdGFibGUgaXMgc2VsZWN0ZWQgYnkgdmVyaWZ5aW5nIGZpcnN0IGFuZCBsYXN0IGNlbGxzXG4gICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGNvbnN0IGxhc3RSb3cgPSB0YWJsZU5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gICAgY29uc3QgaXNFbnRpcmVUYWJsZVNlbGVjdGVkID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGggPiAwICYmIGZpcnN0Um93ICE9PSBudWxsICYmIGxhc3RSb3cgIT09IG51bGwgJiYgJGlzVGFibGVSb3dOb2RlKGZpcnN0Um93KSAmJiAkaXNUYWJsZVJvd05vZGUobGFzdFJvdykgJiYgc2VsZWN0ZWROb2Rlc1swXSA9PT0gZmlyc3RSb3cuZ2V0Rmlyc3RDaGlsZCgpICYmIHNlbGVjdGVkTm9kZXNbc2VsZWN0ZWROb2Rlcy5sZW5ndGggLSAxXSA9PT0gbGFzdFJvdy5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAoaXNFbnRpcmVUYWJsZVNlbGVjdGVkKSB7XG4gICAgICB0YWJsZU5vZGUuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRhYmxlTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIC8vIERlbGV0ZSBlbnRpcmUgdGFibGVcbiAgICAgIHRhYmxlTm9kZS5yZW1vdmUoKTtcbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFibGUgd2FzIHRoZSBvbmx5IG5vZGVcbiAgICAgIGlmICgkaXNSb290Tm9kZShwYXJlbnQpICYmIHBhcmVudC5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2VsbE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gICAgICAgIGNlbGxOb2RlLmFwcGVuZChwYXJhZ3JhcGhOb2RlKTtcbiAgICAgICAgY2VsbE5vZGUuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQgIT09IHBhcmFncmFwaE5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIG51bGwpO1xuICAgICRzZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuY29uc3QgTEVYSUNBTF9FTEVNRU5UX0tFWSA9ICdfX2xleGljYWxUYWJsZVNlbGVjdGlvbic7XG5jb25zdCBpc1BvaW50ZXJEb3duT25FdmVudCA9IGV2ZW50ID0+IHtcbiAgcmV0dXJuIChldmVudC5idXR0b25zICYgMSkgPT09IDE7XG59O1xuZnVuY3Rpb24gaXNIVE1MVGFibGVFbGVtZW50KGVsKSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGVsKSAmJiBlbC5ub2RlTmFtZSA9PT0gJ1RBQkxFJztcbn1cbmZ1bmN0aW9uIGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGUsIGRvbSkge1xuICBpZiAoIWRvbSkge1xuICAgIHJldHVybiBkb207XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IGlzSFRNTFRhYmxlRWxlbWVudChkb20pID8gZG9tIDogdGFibGVOb2RlLmdldERPTVNsb3QoZG9tKS5lbGVtZW50O1xuICBpZiAoIShlbGVtZW50Lm5vZGVOYW1lID09PSAnVEFCTEUnKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0VGFibGVFbGVtZW50OiBFeHBlY3RpbmcgdGFibGUgaW4gYXMgRE9NIG5vZGUgZm9yIFRhYmxlTm9kZSwgbm90ICR7ZG9tLm5vZGVOYW1lfWApO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0RWRpdG9yV2luZG93KGVkaXRvcikge1xuICByZXR1cm4gZWRpdG9yLl93aW5kb3c7XG59XG5mdW5jdGlvbiAkZmluZFBhcmVudFRhYmxlQ2VsbE5vZGVJblRhYmxlKHRhYmxlTm9kZSwgbm9kZSkge1xuICBmb3IgKGxldCBjdXJyZW50Tm9kZSA9IG5vZGUsIGxhc3RUYWJsZUNlbGxOb2RlID0gbnVsbDsgY3VycmVudE5vZGUgIT09IG51bGw7IGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuZ2V0UGFyZW50KCkpIHtcbiAgICBpZiAodGFibGVOb2RlLmlzKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGxhc3RUYWJsZUNlbGxOb2RlO1xuICAgIH0gZWxzZSBpZiAoJGlzVGFibGVDZWxsTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGxhc3RUYWJsZUNlbGxOb2RlID0gY3VycmVudE5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgQVJST1dfS0VZX0NPTU1BTkRTX1dJVEhfRElSRUNUSU9OID0gW1tLRVlfQVJST1dfRE9XTl9DT01NQU5ELCAnZG93biddLCBbS0VZX0FSUk9XX1VQX0NPTU1BTkQsICd1cCddLCBbS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgJ2JhY2t3YXJkJ10sIFtLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgJ2ZvcndhcmQnXV07XG5jb25zdCBERUxFVEVfVEVYVF9DT01NQU5EUyA9IFtERUxFVEVfV09SRF9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkRdO1xuY29uc3QgREVMRVRFX0tFWV9DT01NQU5EUyA9IFtLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIEtFWV9ERUxFVEVfQ09NTUFORF07XG5mdW5jdGlvbiBhcHBseVRhYmxlSGFuZGxlcnModGFibGVOb2RlLCBlbGVtZW50LCBlZGl0b3IsIGhhc1RhYkhhbmRsZXIpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgY29uc3QgZWRpdG9yV2luZG93ID0gZ2V0RWRpdG9yV2luZG93KGVkaXRvcik7XG4gIGlmICghKHJvb3RFbGVtZW50ICE9PSBudWxsICYmIGVkaXRvcldpbmRvdyAhPT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGFwcGx5VGFibGVIYW5kbGVyczogZWRpdG9yIGhhcyBubyByb290IGVsZW1lbnQgc2V0YCk7XG4gIH1cbiAgY29uc3QgdGFibGVPYnNlcnZlciA9IG5ldyBUYWJsZU9ic2VydmVyKGVkaXRvciwgdGFibGVOb2RlLmdldEtleSgpKTtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KHRhYmxlTm9kZSwgZWxlbWVudCk7XG4gIGF0dGFjaFRhYmxlT2JzZXJ2ZXJUb1RhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiBkZXRhY2hUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpKTtcbiAgY29uc3QgY3JlYXRlUG9pbnRlckhhbmRsZXJzID0gKCkgPT4ge1xuICAgIGlmICh0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gKCkgPT4ge1xuICAgICAgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwKTtcbiAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyTW92ZSA9IG1vdmVFdmVudCA9PiB7XG4gICAgICBpZiAoIWlzUG9pbnRlckRvd25PbkV2ZW50KG1vdmVFdmVudCkgJiYgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZykge1xuICAgICAgICB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcCk7XG4gICAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzRE9NTm9kZShtb3ZlRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZm9jdXNDZWxsID0gbnVsbDtcbiAgICAgIC8vIEluIGZpcmVmb3ggdGhlIG1vdmVFdmVudC50YXJnZXQgbWF5IGJlIGNhcHR1cmVkIHNvIHdlIG11c3QgYWx3YXlzXG4gICAgICAvLyBjb25zdWx0IHRoZSBjb29yZGluYXRlcyAjNzI0NVxuICAgICAgY29uc3Qgb3ZlcnJpZGUgPSAhKElTX0ZJUkVGT1ggfHwgdGFibGVFbGVtZW50LmNvbnRhaW5zKG1vdmVFdmVudC50YXJnZXQpKTtcbiAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICBmb2N1c0NlbGwgPSBnZXRET01DZWxsSW5UYWJsZUZyb21UYXJnZXQodGFibGVFbGVtZW50LCBtb3ZlRXZlbnQudGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQobW92ZUV2ZW50LmNsaWVudFgsIG1vdmVFdmVudC5jbGllbnRZKSkge1xuICAgICAgICAgIGZvY3VzQ2VsbCA9IGdldERPTUNlbGxJblRhYmxlRnJvbVRhcmdldCh0YWJsZUVsZW1lbnQsIGVsKTtcbiAgICAgICAgICBpZiAoZm9jdXNDZWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb2N1c0NlbGwgJiYgKHRhYmxlT2JzZXJ2ZXIuZm9jdXNDZWxsID09PSBudWxsIHx8IGZvY3VzQ2VsbC5lbGVtICE9PSB0YWJsZU9ic2VydmVyLmZvY3VzQ2VsbC5lbGVtKSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldE5leHRGb2N1cyh7XG4gICAgICAgICAgZm9jdXNDZWxsLFxuICAgICAgICAgIG92ZXJyaWRlXG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlT2JzZXJ2ZXIuaXNTZWxlY3RpbmcgPSB0cnVlO1xuICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcCwgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUsIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgfTtcbiAgY29uc3Qgb25Qb2ludGVyRG93biA9IGV2ZW50ID0+IHtcbiAgICB0YWJsZU9ic2VydmVyLnBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCAhaXNET01Ob2RlKGV2ZW50LnRhcmdldCkgfHwgIWVkaXRvcldpbmRvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRDZWxsID0gZ2V0RE9NQ2VsbEZyb21UYXJnZXQoZXZlbnQudGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgdHJ1c3QgRmlyZWZveCB0byBkbyB0aGUgcmlnaHQgdGhpbmcgd2l0aCB0aGUgc2VsZWN0aW9uIGFuZFxuICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIGEgcHJvcGVyIHN0YXRlIG1hY2hpbmUgdG8gZG8gdGhpcyBcImNvcnJlY3RseVwiIGJ1dFxuICAgICAgICAvLyBpZiB3ZSBnbyBhaGVhZCBhbmQgbWFrZSB0aGUgdGFibGUgc2VsZWN0aW9uIG5vdyBpdCB3aWxsIHdvcmtcbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZXZlbnQuc2hpZnRLZXkgJiYgJGlzU2VsZWN0aW9uSW5UYWJsZShwcmV2U2VsZWN0aW9uLCB0YWJsZU5vZGUpICYmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2QW5jaG9yTm9kZSA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBwcmV2QW5jaG9yQ2VsbCA9ICRmaW5kUGFyZW50VGFibGVDZWxsTm9kZUluVGFibGUodGFibGVOb2RlLCBwcmV2U2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgICAgICAgIGlmIChwcmV2QW5jaG9yQ2VsbCkge1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbigkZ2V0T2JzZXJ2ZXJDZWxsRnJvbUNlbGxOb2RlT3JUaHJvdyh0YWJsZU9ic2VydmVyLCBwcmV2QW5jaG9yQ2VsbCkpO1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKHRhcmdldENlbGwpO1xuICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gdGFibGVOb2RlLmlzQmVmb3JlKHByZXZBbmNob3JOb2RlKSA/IHRhYmxlTm9kZS5zZWxlY3RTdGFydCgpIDogdGFibGVOb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQocHJldlNlbGVjdGlvbi5hbmNob3Iua2V5LCBwcmV2U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQsIHByZXZTZWxlY3Rpb24uYW5jaG9yLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPbmx5IHNldCBhbmNob3IgY2VsbCBmb3Igc2VsZWN0aW9uIGlmIHRoaXMgaXMgbm90IGEgc2ltcGxlIHRvdWNoIHRhcFxuICAgICAgICAgIC8vIFRvdWNoIHRhcHMgc2hvdWxkIG5vdCBpbml0aWF0ZSB0YWJsZSBzZWxlY3Rpb24gbW9kZVxuICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbih0YXJnZXRDZWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVQb2ludGVySGFuZGxlcnMoKTtcbiAgfTtcbiAgdGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93biwgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiB7XG4gICAgdGFibGVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93bik7XG4gIH0pO1xuICBjb25zdCBvblRyaXBsZUNsaWNrID0gZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5kZXRhaWwgPj0gMyAmJiBpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgY29uc3QgdGFyZ2V0Q2VsbCA9IGdldERPTUNlbGxGcm9tVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICBpZiAodGFyZ2V0Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uVHJpcGxlQ2xpY2ssIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoKCkgPT4ge1xuICAgIHRhYmxlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvblRyaXBsZUNsaWNrKTtcbiAgfSk7XG5cbiAgLy8gQ2xlYXIgc2VsZWN0aW9uIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiBkb20uXG4gIGNvbnN0IHBvaW50ZXJEb3duQ2FsbGJhY2sgPSBldmVudCA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIWlzRE9NTm9kZSh0YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSAmJiByb290RWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuJGNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHBvaW50ZXJEb3duQ2FsbGJhY2ssIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoKCkgPT4ge1xuICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHBvaW50ZXJEb3duQ2FsbGJhY2spO1xuICB9KTtcbiAgZm9yIChjb25zdCBbY29tbWFuZCwgZGlyZWN0aW9uXSBvZiBBUlJPV19LRVlfQ09NTUFORFNfV0lUSF9ESVJFQ1RJT04pIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGV2ZW50ID0+ICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCBkaXJlY3Rpb24sIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlciksIENPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB9XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0VTQ0FQRV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRQYXJlbnRUYWJsZUNlbGxOb2RlSW5UYWJsZSh0YWJsZU5vZGUsIHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgICAgaWYgKGZvY3VzQ2VsbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgZm9jdXNDZWxsTm9kZS5zZWxlY3RFbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIGNvbnN0IGRlbGV0ZVRleHRIYW5kbGVyID0gY29tbWFuZCA9PiAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuJGNsZWFyVGV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRQYXJlbnRUYWJsZUNlbGxOb2RlSW5UYWJsZSh0YWJsZU5vZGUsIHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihhbmNob3JOb2RlKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihmb2N1c05vZGUpO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQ29udGFpbnNQYXJ0aWFsVGFibGUgPSBpc0FuY2hvckluc2lkZSAmJiAhaXNGb2N1c0luc2lkZSB8fCBpc0ZvY3VzSW5zaWRlICYmICFpc0FuY2hvckluc2lkZTtcbiAgICAgIGlmIChzZWxlY3Rpb25Db250YWluc1BhcnRpYWxUYWJsZSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLiRjbGVhclRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuZWFyZXN0RWxlbWVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc0VsZW1lbnROb2RlKG4pKTtcbiAgICAgIGNvbnN0IHRvcExldmVsQ2VsbEVsZW1lbnROb2RlID0gbmVhcmVzdEVsZW1lbnROb2RlICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQobmVhcmVzdEVsZW1lbnROb2RlLCBuID0+ICRpc0VsZW1lbnROb2RlKG4pICYmICRpc1RhYmxlQ2VsbE5vZGUobi5nZXRQYXJlbnQoKSkpO1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZSh0b3BMZXZlbENlbGxFbGVtZW50Tm9kZSkgfHwgISRpc0VsZW1lbnROb2RlKG5lYXJlc3RFbGVtZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1hbmQgPT09IERFTEVURV9MSU5FX0NPTU1BTkQgJiYgdG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogRml4IERlbGV0ZSBMaW5lIGluIFRhYmxlIENlbGxzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgREVMRVRFX1RFWFRfQ09NTUFORFMpIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGRlbGV0ZVRleHRIYW5kbGVyKGNvbW1hbmQpLCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIH1cbiAgY29uc3QgJGRlbGV0ZUNlbGxIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBpbnNpZGUgdGhlIHRhYmxlIGJ1dCBzaG91bGQgcmVtb3ZlIHRoZSB3aG9sZSB0YWJsZVxuICAgIC8vIHdlIGV4cGFuZCB0aGUgc2VsZWN0aW9uIHNvIHRoYXQgYm90aCB0aGUgYW5jaG9yIGFuZCBmb2N1cyBhcmUgb3V0c2lkZVxuICAgIC8vIHRoZSB0YWJsZSBhbmQgdGhlIGVkaXRvcidzIGNvbW1hbmQgbGlzdGVuZXIgd2lsbCBoYW5kbGUgdGhlIGRlbGV0ZVxuICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2Yoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpKTtcbiAgICBpZiAoaXNBbmNob3JJbnNpZGUgIT09IGlzRm9jdXNJbnNpZGUpIHtcbiAgICAgIGNvbnN0IHRhYmxlUG9pbnQgPSBpc0FuY2hvckluc2lkZSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgICAgIGNvbnN0IG91dGVyUG9pbnQgPSBpc0FuY2hvckluc2lkZSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICAgIC8vIFByZXNlcnZlIHRoZSBvdXRlciBwb2ludFxuICAgICAgY29uc3Qge1xuICAgICAgICBrZXksXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHNlbGVjdGlvbltvdXRlclBvaW50XTtcbiAgICAgIC8vIEV4cGFuZCB0aGUgc2VsZWN0aW9uIGFyb3VuZCB0aGUgdGFibGVcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHRhYmxlTm9kZVtzZWxlY3Rpb25bdGFibGVQb2ludF0uaXNCZWZvcmUoc2VsZWN0aW9uW291dGVyUG9pbnRdKSA/ICdzZWxlY3RQcmV2aW91cycgOiAnc2VsZWN0TmV4dCddKCk7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBvdXRlciBwb2ludCBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICBuZXdTZWxlY3Rpb25bb3V0ZXJQb2ludF0uc2V0KGtleSwgb2Zmc2V0LCB0eXBlKTtcbiAgICAgIC8vIExldCB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBoYW5kbGUgdGhlIHJlc3RcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgdGFibGVPYnNlcnZlci4kY2xlYXJUZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgREVMRVRFX0tFWV9DT01NQU5EUykge1xuICAgIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgJGRlbGV0ZUNlbGxIYW5kbGVyLCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIH1cbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDVVRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoISgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHlpbmcgdG8gdGhlIGNsaXBib2FyZCBpcyBhc3luYyBzbyB3ZSBtdXN0IGNhcHR1cmUgdGhlIGRhdGFcbiAgICAgIC8vIGJlZm9yZSB3ZSBkZWxldGUgaXRcbiAgICAgIHZvaWQgY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIENsaXBib2FyZEV2ZW50KSA/IGV2ZW50IDogbnVsbCwgJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbikpO1xuICAgICAgY29uc3QgaW50ZXJjZXB0ZWQgPSAkZGVsZXRlQ2VsbEhhbmRsZXIoZXZlbnQpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZVRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50ZXJjZXB0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPUk1BVF9URVhUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZU9ic2VydmVyLiRmb3JtYXRDZWxscyhwYXlsb2FkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBmb3JtYXRUeXBlID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoYW5jaG9yTm9kZSkgfHwgISRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFsaWduIHRoZSB0YWJsZSBpZiB0aGUgZW50aXJlIHRhYmxlIGlzIHNlbGVjdGVkXG4gICAgaWYgKCRpc0Z1bGxUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHRhYmxlTm9kZS5zZXRGb3JtYXQoZm9ybWF0VHlwZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlTWFwLCBhbmNob3JDZWxsLCBmb2N1c0NlbGxdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvck5vZGUsIGZvY3VzTm9kZSk7XG4gICAgY29uc3QgbWF4Um93ID0gTWF0aC5tYXgoYW5jaG9yQ2VsbC5zdGFydFJvdyArIGFuY2hvckNlbGwuY2VsbC5fX3Jvd1NwYW4gLSAxLCBmb2N1c0NlbGwuc3RhcnRSb3cgKyBmb2N1c0NlbGwuY2VsbC5fX3Jvd1NwYW4gLSAxKTtcbiAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChhbmNob3JDZWxsLnN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5jZWxsLl9fY29sU3BhbiAtIDEsIGZvY3VzQ2VsbC5zdGFydENvbHVtbiArIGZvY3VzQ2VsbC5jZWxsLl9fY29sU3BhbiAtIDEpO1xuICAgIGNvbnN0IG1pblJvdyA9IE1hdGgubWluKGFuY2hvckNlbGwuc3RhcnRSb3csIGZvY3VzQ2VsbC5zdGFydFJvdyk7XG4gICAgY29uc3QgbWluQ29sdW1uID0gTWF0aC5taW4oYW5jaG9yQ2VsbC5zdGFydENvbHVtbiwgZm9jdXNDZWxsLnN0YXJ0Q29sdW1uKTtcbiAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSBtaW5Sb3c7IGkgPD0gbWF4Um93OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBtaW5Db2x1bW47IGogPD0gbWF4Q29sdW1uOyBqKyspIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRhYmxlTWFwW2ldW2pdLmNlbGw7XG4gICAgICAgIGlmICh2aXNpdGVkLmhhcyhjZWxsKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQuYWRkKGNlbGwpO1xuICAgICAgICBjZWxsLnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgICAgY29uc3QgY2VsbENoaWxkcmVuID0gY2VsbC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNlbGxDaGlsZHJlbi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2VsbENoaWxkcmVuW2tdO1xuICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIGNoaWxkLnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZU9ic2VydmVyLiRjbGVhckhpZ2hsaWdodCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBlZGdlUG9zaXRpb24gPSAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSk7XG4gICAgICAgIGlmIChlZGdlUG9zaXRpb24pIHtcbiAgICAgICAgICAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUsIFskY3JlYXRlVGV4dE5vZGUocGF5bG9hZCldKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgaWYgKGhhc1RhYkhhbmRsZXIpIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9UQUJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgICAgaWYgKHRhYmxlQ2VsbE5vZGUgPT09IG51bGwgfHwgIXRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZSh0YWJsZUNlbGxOb2RlKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICRzZWxlY3RBZGphY2VudENlbGwodGFibGVDZWxsTm9kZSwgZXZlbnQuc2hpZnRLZXkgPyAncHJldmlvdXMnIDogJ25leHQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgfVxuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPQ1VTX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIHJldHVybiB0YWJsZU5vZGUuaXNTZWxlY3RlZCgpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCAoc2VsZWN0aW9uUGF5bG9hZCwgZGlzcGF0Y2hFZGl0b3IpID0+IHtcbiAgICBpZiAoZWRpdG9yICE9PSBkaXNwYXRjaEVkaXRvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBub2RlcyxcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBzZWxlY3Rpb25QYXlsb2FkO1xuICAgIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gICAgY29uc3QgaXNUYWJsZVNlbGVjdGlvbiA9ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgaXNSYW5nZVNlbGVjdGlvbiA9ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgaXNTZWxlY3Rpb25JbnNpZGVPZkdyaWQgPSBpc1JhbmdlU2VsZWN0aW9uICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSkgIT09IG51bGwgJiYgJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpICE9PSBudWxsIHx8IGlzVGFibGVTZWxlY3Rpb247XG4gICAgaWYgKG5vZGVzLmxlbmd0aCAhPT0gMSB8fCAhJGlzVGFibGVOb2RlKG5vZGVzWzBdKSB8fCAhaXNTZWxlY3Rpb25JbnNpZGVPZkdyaWQgfHwgYW5jaG9yQW5kRm9jdXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgY29uc3QgW2FuY2hvckNlbGxOb2RlLCBhbmNob3JSb3dOb2RlLCBncmlkTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1cy5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGxOb2RlKSB8fCAhJGlzVGFibGVSb3dOb2RlKGFuY2hvclJvd05vZGUpIHx8ICEkaXNUYWJsZU5vZGUoZ3JpZE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRlbXBsYXRlR3JpZCA9IG5vZGVzWzBdO1xuICAgIGNvbnN0IFtpbml0aWFsR3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZE5vZGUsIGFuY2hvckNlbGxOb2RlLCBmb2N1c0NlbGxOb2RlKTtcbiAgICBjb25zdCBbdGVtcGxhdGVHcmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRlbXBsYXRlR3JpZCwgbnVsbCwgbnVsbCk7XG4gICAgY29uc3QgaW5pdGlhbFJvd0NvdW50ID0gaW5pdGlhbEdyaWRNYXAubGVuZ3RoO1xuICAgIGNvbnN0IGluaXRpYWxDb2xDb3VudCA9IGluaXRpYWxSb3dDb3VudCA+IDAgPyBpbml0aWFsR3JpZE1hcFswXS5sZW5ndGggOiAwO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHJhbmdlIHNlbGVjdGlvbiwgd2UnbGwgZml0IHRoZSB0ZW1wbGF0ZSBncmlkIGludG8gdGhlXG4gICAgLy8gdGFibGUsIGdyb3dpbmcgdGhlIHRhYmxlIGlmIG5lY2Vzc2FyeS5cbiAgICBsZXQgc3RhcnRSb3cgPSBhbmNob3JDZWxsTWFwLnN0YXJ0Um93O1xuICAgIGxldCBzdGFydENvbCA9IGFuY2hvckNlbGxNYXAuc3RhcnRDb2x1bW47XG4gICAgbGV0IGFmZmVjdGVkUm93Q291bnQgPSB0ZW1wbGF0ZUdyaWRNYXAubGVuZ3RoO1xuICAgIGxldCBhZmZlY3RlZENvbENvdW50ID0gYWZmZWN0ZWRSb3dDb3VudCA+IDAgPyB0ZW1wbGF0ZUdyaWRNYXBbMF0ubGVuZ3RoIDogMDtcbiAgICBpZiAoaXNUYWJsZVNlbGVjdGlvbikge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHRhYmxlIHNlbGVjdGlvbiwgd2UnbGwgb25seSBtb2RpZnkgdGhlIGNlbGxzIHdpdGhpblxuICAgICAgLy8gdGhlIHNlbGVjdGlvbiBib3VuZGFyeS5cbiAgICAgIGNvbnN0IHNlbGVjdGlvbkJvdW5kYXJ5ID0gJGNvbXB1dGVUYWJsZUNlbGxSZWN0Qm91bmRhcnkoaW5pdGlhbEdyaWRNYXAsIGFuY2hvckNlbGxNYXAsIGZvY3VzQ2VsbE1hcCk7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Sb3dDb3VudCA9IHNlbGVjdGlvbkJvdW5kYXJ5Lm1heFJvdyAtIHNlbGVjdGlvbkJvdW5kYXJ5Lm1pblJvdyArIDE7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db2xDb3VudCA9IHNlbGVjdGlvbkJvdW5kYXJ5Lm1heENvbHVtbiAtIHNlbGVjdGlvbkJvdW5kYXJ5Lm1pbkNvbHVtbiArIDE7XG4gICAgICBzdGFydFJvdyA9IHNlbGVjdGlvbkJvdW5kYXJ5Lm1pblJvdztcbiAgICAgIHN0YXJ0Q29sID0gc2VsZWN0aW9uQm91bmRhcnkubWluQ29sdW1uO1xuICAgICAgYWZmZWN0ZWRSb3dDb3VudCA9IE1hdGgubWluKGFmZmVjdGVkUm93Q291bnQsIHNlbGVjdGlvblJvd0NvdW50KTtcbiAgICAgIGFmZmVjdGVkQ29sQ291bnQgPSBNYXRoLm1pbihhZmZlY3RlZENvbENvdW50LCBzZWxlY3Rpb25Db2xDb3VudCk7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAxOiBVbm1lcmdlIGFsbCBtZXJnZWQgY2VsbHMgd2l0aGluIHRoZSBhZmZlY3RlZCBhcmVhXG4gICAgbGV0IGRpZFBlcmZvcm1NZXJnZU9wZXJhdGlvbnMgPSBmYWxzZTtcbiAgICBjb25zdCBsYXN0Um93Rm9yVW5tZXJnZSA9IE1hdGgubWluKGluaXRpYWxSb3dDb3VudCwgc3RhcnRSb3cgKyBhZmZlY3RlZFJvd0NvdW50KSAtIDE7XG4gICAgY29uc3QgbGFzdENvbEZvclVubWVyZ2UgPSBNYXRoLm1pbihpbml0aWFsQ29sQ291bnQsIHN0YXJ0Q29sICsgYWZmZWN0ZWRDb2xDb3VudCkgLSAxO1xuICAgIGNvbnN0IHVubWVyZ2VkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCByb3cgPSBzdGFydFJvdzsgcm93IDw9IGxhc3RSb3dGb3JVbm1lcmdlOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gc3RhcnRDb2w7IGNvbCA8PSBsYXN0Q29sRm9yVW5tZXJnZTsgY29sKyspIHtcbiAgICAgICAgY29uc3QgY2VsbE1hcCA9IGluaXRpYWxHcmlkTWFwW3Jvd11bY29sXTtcbiAgICAgICAgaWYgKHVubWVyZ2VkS2V5cy5oYXMoY2VsbE1hcC5jZWxsLmdldEtleSgpKSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBjZWxsIHdhcyBhIG1lcmdlZCBjZWxsIHRoYXQgd2FzIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsTWFwLmNlbGwuX19yb3dTcGFuID09PSAxICYmIGNlbGxNYXAuY2VsbC5fX2NvbFNwYW4gPT09IDEpIHtcbiAgICAgICAgICBjb250aW51ZTsgLy8gY2VsbCBpcyBub3QgYSBtZXJnZWQgY2VsbFxuICAgICAgICB9XG4gICAgICAgICR1bm1lcmdlQ2VsbE5vZGUoY2VsbE1hcC5jZWxsKTtcbiAgICAgICAgdW5tZXJnZWRLZXlzLmFkZChjZWxsTWFwLmNlbGwuZ2V0S2V5KCkpO1xuICAgICAgICBkaWRQZXJmb3JtTWVyZ2VPcGVyYXRpb25zID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IFtpbnRlcmltR3JpZE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhncmlkTm9kZS5nZXRXcml0YWJsZSgpLCBudWxsLCBudWxsKTtcblxuICAgIC8vIFN0ZXAgMjogRXhwYW5kIGN1cnJlbnQgdGFibGUgKGlmIG5lZWRlZClcbiAgICBjb25zdCByb3dzVG9JbnNlcnQgPSBhZmZlY3RlZFJvd0NvdW50IC0gaW5pdGlhbFJvd0NvdW50ICsgc3RhcnRSb3c7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9JbnNlcnQ7IGkrKykge1xuICAgICAgY29uc3QgY2VsbE1hcCA9IGludGVyaW1HcmlkTWFwW2luaXRpYWxSb3dDb3VudCAtIDFdWzBdO1xuICAgICAgJGluc2VydFRhYmxlUm93QXROb2RlKGNlbGxNYXAuY2VsbCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbHNUb0luc2VydCA9IGFmZmVjdGVkQ29sQ291bnQgLSBpbml0aWFsQ29sQ291bnQgKyBzdGFydENvbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHNUb0luc2VydDsgaSsrKSB7XG4gICAgICBjb25zdCBjZWxsTWFwID0gaW50ZXJpbUdyaWRNYXBbMF1baW5pdGlhbENvbENvdW50IC0gMV07XG4gICAgICAkaW5zZXJ0VGFibGVDb2x1bW5BdE5vZGUoY2VsbE1hcC5jZWxsLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICAgIFtpbnRlcmltR3JpZE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhncmlkTm9kZS5nZXRXcml0YWJsZSgpLCBudWxsLCBudWxsKTtcblxuICAgIC8vIFN0ZXAgMzogTWVyZ2UgY2VsbHMgYW5kIHNldCBjZWxsIGNvbnRlbnQsIHRvIG1hdGNoIHRlbXBsYXRlIGdyaWRcbiAgICBmb3IgKGxldCByb3cgPSBzdGFydFJvdzsgcm93IDwgc3RhcnRSb3cgKyBhZmZlY3RlZFJvd0NvdW50OyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gc3RhcnRDb2w7IGNvbCA8IHN0YXJ0Q29sICsgYWZmZWN0ZWRDb2xDb3VudDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVSb3cgPSByb3cgLSBzdGFydFJvdztcbiAgICAgICAgY29uc3QgdGVtcGxhdGVDb2wgPSBjb2wgLSBzdGFydENvbDtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVDZWxsTWFwID0gdGVtcGxhdGVHcmlkTWFwW3RlbXBsYXRlUm93XVt0ZW1wbGF0ZUNvbF07XG4gICAgICAgIGlmICh0ZW1wbGF0ZUNlbGxNYXAuc3RhcnRSb3cgIT09IHRlbXBsYXRlUm93IHx8IHRlbXBsYXRlQ2VsbE1hcC5zdGFydENvbHVtbiAhPT0gdGVtcGxhdGVDb2wpIHtcbiAgICAgICAgICBjb250aW51ZTsgLy8gY2VsbCBpcyBhIG1lcmdlZCBjZWxsIHRoYXQgd2FzIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlQ2VsbCA9IHRlbXBsYXRlQ2VsbE1hcC5jZWxsO1xuICAgICAgICBpZiAodGVtcGxhdGVDZWxsLl9fcm93U3BhbiAhPT0gMSB8fCB0ZW1wbGF0ZUNlbGwuX19jb2xTcGFuICE9PSAxKSB7XG4gICAgICAgICAgY29uc3QgY2VsbHNUb01lcmdlID0gW107XG4gICAgICAgICAgY29uc3QgbGFzdFJvd0Zvck1lcmdlID0gTWF0aC5taW4ocm93ICsgdGVtcGxhdGVDZWxsLl9fcm93U3Bhbiwgc3RhcnRSb3cgKyBhZmZlY3RlZFJvd0NvdW50KSAtIDE7XG4gICAgICAgICAgY29uc3QgbGFzdENvbEZvck1lcmdlID0gTWF0aC5taW4oY29sICsgdGVtcGxhdGVDZWxsLl9fY29sU3Bhbiwgc3RhcnRDb2wgKyBhZmZlY3RlZENvbENvdW50KSAtIDE7XG4gICAgICAgICAgZm9yIChsZXQgciA9IHJvdzsgciA8PSBsYXN0Um93Rm9yTWVyZ2U7IHIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNvbDsgYyA8PSBsYXN0Q29sRm9yTWVyZ2U7IGMrKykge1xuICAgICAgICAgICAgICBjb25zdCBjZWxsTWFwID0gaW50ZXJpbUdyaWRNYXBbcl1bY107XG4gICAgICAgICAgICAgIGNlbGxzVG9NZXJnZS5wdXNoKGNlbGxNYXAuY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICRtZXJnZUNlbGxzKGNlbGxzVG9NZXJnZSk7XG4gICAgICAgICAgZGlkUGVyZm9ybU1lcmdlT3BlcmF0aW9ucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNlbGxcbiAgICAgICAgfSA9IGludGVyaW1HcmlkTWFwW3Jvd11bY29sXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGlsZHJlbiA9IGNlbGwuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgdGVtcGxhdGVDZWxsLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgICBjZWxsLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGwuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvcmlnaW5hbENoaWxkcmVuLmZvckVhY2gobiA9PiBuLnJlbW92ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzVGFibGVTZWxlY3Rpb24gJiYgZGlkUGVyZm9ybU1lcmdlT3BlcmF0aW9ucykge1xuICAgICAgLy8gcmVzZXQgdGhlIHRhYmxlIHNlbGVjdGlvbiBpbiBjYXNlIHRoZSBhbmNob3Igb3IgZm9jdXMgY2VsbCB3YXNcbiAgICAgIC8vIHJlbW92ZWQgdmlhIG1lcmdlIG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IFtmaW5hbEdyaWRNYXBdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2soZ3JpZE5vZGUuZ2V0V3JpdGFibGUoKSwgbnVsbCwgbnVsbCk7XG4gICAgICBjb25zdCBuZXdBbmNob3JDZWxsTWFwID0gZmluYWxHcmlkTWFwW2FuY2hvckNlbGxNYXAuc3RhcnRSb3ddW2FuY2hvckNlbGxNYXAuc3RhcnRDb2x1bW5dO1xuICAgICAgbmV3QW5jaG9yQ2VsbE1hcC5jZWxsLnNlbGVjdEVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgY29uc3QgbmV4dEZvY3VzID0gdGFibGVPYnNlcnZlci5nZXRBbmRDbGVhck5leHRGb2N1cygpO1xuICAgIGlmIChuZXh0Rm9jdXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9jdXNDZWxsXG4gICAgICB9ID0gbmV4dEZvY3VzO1xuICAgICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSkge1xuICAgICAgICBpZiAoZm9jdXNDZWxsLnggPT09IHRhYmxlT2JzZXJ2ZXIuZm9jdXNYICYmIGZvY3VzQ2VsbC55ID09PSB0YWJsZU9ic2VydmVyLmZvY3VzWSkge1xuICAgICAgICAgIC8vIFRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSB0aGUgY29ycmVjdCB0YWJsZSBzZWxlY3Rpb25cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGZvY3VzQ2VsbCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZm9jdXNDZWxsICE9PSB0YWJsZU9ic2VydmVyLmFuY2hvckNlbGwgJiYgJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdGlvbiBoYXMgY3Jvc3NlZCBjZWxsc1xuICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oZm9jdXNDZWxsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZENoZWNrU2VsZWN0aW9uID0gdGFibGVPYnNlcnZlci5nZXRBbmRDbGVhclNob3VsZENoZWNrU2VsZWN0aW9uKCk7XG4gICAgLy8gSWYgdGhleSBwcmVzc2VkIHRoZSBkb3duIGFycm93IHdpdGggdGhlIHNlbGVjdGlvbiBvdXRzaWRlIG9mIHRoZVxuICAgIC8vIHRhYmxlLCBhbmQgdGhlbiB0aGUgc2VsZWN0aW9uIGVuZHMgdXAgaW4gdGhlIHRhYmxlIGJ1dCBub3QgaW4gdGhlXG4gICAgLy8gZmlyc3QgY2VsbCwgdGhlbiBtb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGZpcnN0IGNlbGwuXG4gICAgaWYgKHNob3VsZENoZWNrU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgY29uc3QgYW5jaG9yQ2VsbCA9ICRmaW5kQ2VsbE5vZGUoYW5jaG9yKTtcbiAgICAgIGlmIChhbmNob3JDZWxsICE9PSBudWxsICYmICRpc1RhYmxlUm93Tm9kZShmaXJzdFJvdykpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gZmlyc3RSb3cuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShmaXJzdENlbGwpICYmIHRhYmxlTm9kZS5pcygkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvckNlbGwsIG5vZGUgPT4gbm9kZS5pcyh0YWJsZU5vZGUpIHx8IG5vZGUuaXMoZmlyc3RDZWxsKSkpKSB7XG4gICAgICAgICAgLy8gVGhlIHNlbGVjdGlvbiBtb3ZlZCB0byB0aGUgdGFibGUsIGJ1dCBub3QgaW4gdGhlIGZpcnN0IGNlbGxcbiAgICAgICAgICBmaXJzdENlbGwuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgICAvLyBVc2luZyBleHBsaWNpdCBjb21wYXJpc29uIHdpdGggdGFibGUgbm9kZSB0byBlbnN1cmUgaXQncyBub3QgYSBuZXN0ZWQgdGFibGVcbiAgICAgIC8vIGFzIGluIHRoYXQgY2FzZSB3ZSdsbCBsZWF2ZSBzZWxlY3Rpb24gcmVzb2x2aW5nIHRvIHRoYXQgdGFibGVcbiAgICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRDZWxsTm9kZShhbmNob3JOb2RlKTtcbiAgICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9ICEhKGFuY2hvckNlbGxOb2RlICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShhbmNob3JDZWxsTm9kZSkpKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSAhIShmb2N1c0NlbGxOb2RlICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShmb2N1c0NlbGxOb2RlKSkpO1xuICAgICAgY29uc3QgaXNQYXJ0aWFsbHlXaXRoaW5UYWJsZSA9IGlzQW5jaG9ySW5zaWRlICE9PSBpc0ZvY3VzSW5zaWRlO1xuICAgICAgY29uc3QgaXNXaXRoaW5UYWJsZSA9IGlzQW5jaG9ySW5zaWRlICYmIGlzRm9jdXNJbnNpZGU7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICAgIGlmIChpc1BhcnRpYWxseVdpdGhpblRhYmxlKSB7XG4gICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICBpZiAoaXNGb2N1c0luc2lkZSkge1xuICAgICAgICAgIGNvbnN0IFt0YWJsZU1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgZm9jdXNDZWxsTm9kZSwgZm9jdXNDZWxsTm9kZSk7XG4gICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF0uY2VsbDtcbiAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsO1xuICAgICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoaXNCYWNrd2FyZCA/IGZpcnN0Q2VsbC5nZXRLZXkoKSA6IGxhc3RDZWxsLmdldEtleSgpLCBpc0JhY2t3YXJkID8gZmlyc3RDZWxsLmdldENoaWxkcmVuU2l6ZSgpIDogbGFzdENlbGwuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBbmNob3JJbnNpZGUpIHtcbiAgICAgICAgICBjb25zdCBbdGFibGVNYXBdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvckNlbGxOb2RlLCBhbmNob3JDZWxsTm9kZSk7XG4gICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF0uY2VsbDtcbiAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIGlzQmFja3dhcmQsIHNldCB0aGUgYW5jaG9yIHRvIGJlIGF0IHRoZSBlbmQgb2YgdGhlIHRhYmxlIHNvIHRoYXQgd2hlbiB0aGUgY3Vyc29yIG1vdmVzIG91dHNpZGUgb2ZcbiAgICAgICAgICAgKiB0aGUgdGFibGUgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiwgdGhlIGVudGlyZSB0YWJsZSB3aWxsIGJlIHNlbGVjdGVkIGZyb20gaXRzIGVuZC5cbiAgICAgICAgICAgKiBPdGhlcndpc2UsIGlmIGZvcndhcmQsIHNldCB0aGUgYW5jaG9yIHRvIGJlIGF0IHRoZSBzdGFydCBvZiB0aGUgdGFibGUgc28gdGhhdCB3aGVuIHRoZSBmb2N1cyBpcyBkcmFnZ2VkXG4gICAgICAgICAgICogb3V0c2lkZSB0aCBlbmQgb2YgdGhlIHRhYmxlLCBpdCB3aWxsIHN0YXJ0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgdGFibGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQoaXNCYWNrd2FyZCA/IGxhc3RDZWxsLmdldEtleSgpIDogZmlyc3RDZWxsLmdldEtleSgpLCBpc0JhY2t3YXJkID8gbGFzdENlbGwuZ2V0Q2hpbGRyZW5TaXplKCkgOiAwLCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlT2JzZXJ2ZXIpO1xuICAgICAgfSBlbHNlIGlmIChpc1dpdGhpblRhYmxlKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gc2VsZWN0aW9uIHNwYW5zIGFjcm9zcyBtdWx0aXBsZSBjZWxscyBidXQgc3RpbGxcbiAgICAgICAgLy8gaGFzIHJhbmdlIHNlbGVjdGlvbiwgdGhlbiB3ZSBjb252ZXJ0IGl0IGludG8gdGFibGUgc2VsZWN0aW9uXG4gICAgICAgIGlmICghYW5jaG9yQ2VsbE5vZGUuaXMoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGFuY2hvckNlbGxOb2RlKSk7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGZvY3VzQ2VsbE5vZGUpLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGhlIHBvaW50ZXIgdHlwZSBpcyB0b3VjaCBhbmQgdGhlIGN1cnJlbnQgYW5kXG4gICAgICAgIC8vIHByZXZpb3VzIHNlbGVjdGlvbiBhcmUgY29sbGFwc2VkLCBhbmQgdGhlIHByZXZpb3VzIGFuY2hvciBhbmQgY3VycmVudFxuICAgICAgICAvLyBmb2N1cyBjZWxsIG5vZGVzIGFyZSBkaWZmZXJlbnQsIHRoZW4gd2UgY29udmVydCBpdCBpbnRvIHRhYmxlIHNlbGVjdGlvblxuICAgICAgICAvLyBIb3dldmVyLCBvbmx5IGRvIHRoaXMgaWYgdGhlIHRhYmxlIG9ic2VydmVyIGlzIGFjdGl2ZWx5IHNlbGVjdGluZyAodXNlciBkcmFnZ2luZylcbiAgICAgICAgLy8gdG8gcHJldmVudCB1bndhbnRlZCBzZWxlY3Rpb25zIHdoZW4gc2ltcGx5IHRhcHBpbmcgYmV0d2VlbiBjZWxscyBvbiBtb2JpbGVcbiAgICAgICAgaWYgKHRhYmxlT2JzZXJ2ZXIucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiAkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2QW5jaG9yQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKHByZXZTZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgICAgICAgaWYgKHByZXZBbmNob3JDZWxsTm9kZSAmJiAhcHJldkFuY2hvckNlbGxOb2RlLmlzKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIHByZXZBbmNob3JDZWxsTm9kZSkpO1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGZvY3VzQ2VsbE5vZGUpLCB0cnVlKTtcbiAgICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIucG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uICYmICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmIHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVOb2RlLmdldEtleSgpKSB7XG4gICAgICAvLyBpZiBzZWxlY3Rpb24gZ29lcyBvdXRzaWRlIG9mIHRoZSB0YWJsZSB3ZSBuZWVkIHRvIGNoYW5nZSBpdCB0byBSYW5nZSBzZWxlY3Rpb25cbiAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3JXaW5kb3cpO1xuICAgICAgaWYgKGRvbVNlbGVjdGlvbiAmJiBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSAmJiBkb21TZWxlY3Rpb24uZm9jdXNOb2RlKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbVNlbGVjdGlvbi5mb2N1c05vZGUpO1xuICAgICAgICBjb25zdCBpc0ZvY3VzT3V0c2lkZSA9IGZvY3VzTm9kZSAmJiAhdGFibGVOb2RlLmlzUGFyZW50T2YoZm9jdXNOb2RlKTtcbiAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgICAgICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSBhbmNob3JOb2RlICYmIHRhYmxlTm9kZS5pc1BhcmVudE9mKGFuY2hvck5vZGUpO1xuICAgICAgICBpZiAoaXNGb2N1c091dHNpZGUgJiYgaXNBbmNob3JJbnNpZGUgJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbShkb21TZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICAgICAgaWYgKG5ld1NlbGVjdGlvbikge1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQodGFibGVOb2RlLmdldEtleSgpLCBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gdGFibGVOb2RlLmdldENoaWxkcmVuU2l6ZSgpIDogMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSAmJiB0YWJsZU9ic2VydmVyLnRhYmxlU2VsZWN0aW9uICYmICF0YWJsZU9ic2VydmVyLnRhYmxlU2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24udGFibGVLZXkgPT09IHRhYmxlT2JzZXJ2ZXIudGFibGVOb2RlS2V5KSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgJGlzVGFibGVTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVPYnNlcnZlci50YWJsZU5vZGVLZXkpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci4kdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhYmxlT2JzZXJ2ZXIuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgJiYgIXRhYmxlTm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICRyZW1vdmVIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZU9ic2VydmVyKTtcbiAgICB9IGVsc2UgaWYgKCF0YWJsZU9ic2VydmVyLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzICYmIHRhYmxlTm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICRhZGRIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZU9ic2VydmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VQb3NpdGlvbiA9ICRnZXRUYWJsZUVkZ2VDdXJzb3JQb3NpdGlvbihlZGl0b3IsIHNlbGVjdGlvbiwgdGFibGVOb2RlKTtcbiAgICBpZiAoZWRnZVBvc2l0aW9uKSB7XG4gICAgICAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICByZXR1cm4gdGFibGVPYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGRldGFjaFRhYmxlT2JzZXJ2ZXJGcm9tVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVPYnNlcnZlcikge1xuICBpZiAoZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSA9PT0gdGFibGVPYnNlcnZlcikge1xuICAgIGRlbGV0ZSB0YWJsZUVsZW1lbnRbTEVYSUNBTF9FTEVNRU5UX0tFWV07XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaFRhYmxlT2JzZXJ2ZXJUb1RhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpIHtcbiAgaWYgKCEoZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSA9PT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYHRhYmxlRWxlbWVudCBhbHJlYWR5IGhhcyBhbiBhdHRhY2hlZCBUYWJsZU9ic2VydmVyYCk7XG4gIH1cbiAgdGFibGVFbGVtZW50W0xFWElDQUxfRUxFTUVOVF9LRVldID0gdGFibGVPYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGdldFRhYmxlT2JzZXJ2ZXJGcm9tVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCkge1xuICByZXR1cm4gdGFibGVFbGVtZW50W0xFWElDQUxfRUxFTUVOVF9LRVldIHx8IG51bGw7XG59XG5mdW5jdGlvbiBnZXRET01DZWxsRnJvbVRhcmdldChub2RlKSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBjdXJyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdURCcgfHwgbm9kZU5hbWUgPT09ICdUSCcpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgICBjb25zdCBjZWxsID0gY3VycmVudE5vZGUuX2NlbGw7XG4gICAgICBpZiAoY2VsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERPTUNlbGxJblRhYmxlRnJvbVRhcmdldCh0YWJsZSwgbm9kZSkge1xuICBpZiAoIXRhYmxlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGNlbGwgPSBudWxsO1xuICBmb3IgKGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7IGN1cnJlbnROb2RlICE9IG51bGw7IGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZSkge1xuICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdGFibGUpIHtcbiAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlTmFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ1REJyB8fCBub2RlTmFtZSA9PT0gJ1RIJykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNlbGwgPSBjdXJyZW50Tm9kZS5fY2VsbCB8fCBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFRhYmxlKHRhYmxlTm9kZSwgZG9tKSB7XG4gIGNvbnN0IHRhYmxlRWxlbWVudCA9IGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGUsIGRvbSk7XG4gIGNvbnN0IGRvbVJvd3MgPSBbXTtcbiAgY29uc3QgZ3JpZCA9IHtcbiAgICBjb2x1bW5zOiAwLFxuICAgIGRvbVJvd3MsXG4gICAgcm93czogMFxuICB9O1xuICBsZXQgY3VycmVudE5vZGUgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndHInKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGRvbVJvd3MubGVuZ3RoID0gMDtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlTWFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTWFtZSA9PT0gJ1REJyB8fCBub2RlTWFtZSA9PT0gJ1RIJykge1xuICAgICAgY29uc3QgZWxlbSA9IGN1cnJlbnROb2RlO1xuICAgICAgY29uc3QgY2VsbCA9IHtcbiAgICAgICAgZWxlbSxcbiAgICAgICAgaGFzQmFja2dyb3VuZENvbG9yOiBlbGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciAhPT0gJycsXG4gICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcblxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGN1cnJlbnROb2RlLl9jZWxsID0gY2VsbDtcbiAgICAgIGxldCByb3cgPSBkb21Sb3dzW3ldO1xuICAgICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvdyA9IGRvbVJvd3NbeV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvd1t4XSA9IGNlbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY3VycmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIGlmIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmc7XG4gICAgaWYgKHNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgeCsrO1xuICAgICAgY3VycmVudE5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHkrKztcbiAgICAgIHggPSAwO1xuICAgICAgY3VycmVudE5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICBncmlkLmNvbHVtbnMgPSB4ICsgMTtcbiAgZ3JpZC5yb3dzID0geSArIDE7XG4gIHJldHVybiBncmlkO1xufVxuZnVuY3Rpb24gJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRhYmxlLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgc2VsZWN0ZWRDZWxsTm9kZXMgPSBuZXcgU2V0KHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5nZXROb2RlcygpIDogW10pO1xuICAkZm9yRWFjaFRhYmxlQ2VsbCh0YWJsZSwgKGNlbGwsIGxleGljYWxOb2RlKSA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBpZiAoc2VsZWN0ZWRDZWxsTm9kZXMuaGFzKGxleGljYWxOb2RlKSkge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAkYWRkSGlnaGxpZ2h0VG9ET00oZWRpdG9yLCBjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcbiAgICAgIGlmICghZWxlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uICRmb3JFYWNoVGFibGVDZWxsKGdyaWQsIGNiKSB7XG4gIGNvbnN0IHtcbiAgICBkb21Sb3dzXG4gIH0gPSBncmlkO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IGRvbVJvd3MubGVuZ3RoOyB5KyspIHtcbiAgICBjb25zdCByb3cgPSBkb21Sb3dzW3ldO1xuICAgIGlmICghcm93KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCByb3cubGVuZ3RoOyB4KyspIHtcbiAgICAgIGNvbnN0IGNlbGwgPSByb3dbeF07XG4gICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXhpY2FsTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG4gICAgICBpZiAobGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY2IoY2VsbCwgbGV4aWNhbE5vZGUsIHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVTZWxlY3Rpb24pIHtcbiAgdGFibGVTZWxlY3Rpb24uJGRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAkZm9yRWFjaFRhYmxlQ2VsbCh0YWJsZVNlbGVjdGlvbi50YWJsZSwgY2VsbCA9PiB7XG4gICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgJGFkZEhpZ2hsaWdodFRvRE9NKGVkaXRvciwgY2VsbCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlT2JzZXJ2ZXIpIHtcbiAgdGFibGVPYnNlcnZlci4kZW5hYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgJGZvckVhY2hUYWJsZUNlbGwodGFibGVPYnNlcnZlci50YWJsZSwgY2VsbCA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcbiAgICBpZiAoIWVsZW0uZ2V0QXR0cmlidXRlKCdzdHlsZScpKSB7XG4gICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gJHNlbGVjdEFkamFjZW50Q2VsbCh0YWJsZUNlbGxOb2RlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3Qgc2libGluZ01ldGhvZCA9IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gJ2dldE5leHRTaWJsaW5nJyA6ICdnZXRQcmV2aW91c1NpYmxpbmcnO1xuICBjb25zdCBjaGlsZE1ldGhvZCA9IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gJ2dldEZpcnN0Q2hpbGQnIDogJ2dldExhc3RDaGlsZCc7XG4gIGNvbnN0IHNpYmxpbmcgPSB0YWJsZUNlbGxOb2RlW3NpYmxpbmdNZXRob2RdKCk7XG4gIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgIHJldHVybiBzaWJsaW5nLnNlbGVjdEVuZCgpO1xuICB9XG4gIGNvbnN0IHBhcmVudFJvdyA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQodGFibGVDZWxsTm9kZSwgJGlzVGFibGVSb3dOb2RlKTtcbiAgaWYgKCEocGFyZW50Um93ICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgc2VsZWN0QWRqYWNlbnRDZWxsOiBDZWxsIG5vdCBpbiB0YWJsZSByb3dgKTtcbiAgfVxuICBmb3IgKGxldCBuZXh0Um93ID0gcGFyZW50Um93W3NpYmxpbmdNZXRob2RdKCk7ICRpc1RhYmxlUm93Tm9kZShuZXh0Um93KTsgbmV4dFJvdyA9IG5leHRSb3dbc2libGluZ01ldGhvZF0oKSkge1xuICAgIGNvbnN0IGNoaWxkID0gbmV4dFJvd1tjaGlsZE1ldGhvZF0oKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gY2hpbGQuc2VsZWN0RW5kKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcmVudFRhYmxlID0gJGZpbmRNYXRjaGluZ1BhcmVudChwYXJlbnRSb3csICRpc1RhYmxlTm9kZSk7XG4gIGlmICghKHBhcmVudFRhYmxlICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgc2VsZWN0QWRqYWNlbnRDZWxsOiBSb3cgbm90IGluIHRhYmxlYCk7XG4gIH1cbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ25leHQnID8gcGFyZW50VGFibGUuc2VsZWN0TmV4dCgpIDogcGFyZW50VGFibGUuc2VsZWN0UHJldmlvdXMoKTtcbn1cbmNvbnN0IHNlbGVjdFRhYmxlTm9kZUluRGlyZWN0aW9uID0gKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZSwgeCwgeSwgZGlyZWN0aW9uKSA9PiB7XG4gIGNvbnN0IGlzRm9yd2FyZCA9IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnO1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgIGlmICh4ICE9PSAoaXNGb3J3YXJkID8gdGFibGVPYnNlcnZlci50YWJsZS5jb2x1bW5zIC0gMSA6IDApKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4ICsgKGlzRm9yd2FyZCA/IDEgOiAtMSksIHksIHRhYmxlT2JzZXJ2ZXIudGFibGUpLCBpc0ZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHkgIT09IChpc0ZvcndhcmQgPyB0YWJsZU9ic2VydmVyLnRhYmxlLnJvd3MgLSAxIDogMCkpIHtcbiAgICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coaXNGb3J3YXJkID8gMCA6IHRhYmxlT2JzZXJ2ZXIudGFibGUuY29sdW1ucyAtIDEsIHkgKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgdGFibGVPYnNlcnZlci50YWJsZSksIGlzRm9yd2FyZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRm9yd2FyZCkge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ3VwJzpcbiAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5IC0gMSwgdGFibGVPYnNlcnZlci50YWJsZSksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnZG93bic6XG4gICAgICBpZiAoeSAhPT0gdGFibGVPYnNlcnZlci50YWJsZS5yb3dzIC0gMSkge1xuICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCwgeSArIDEsIHRhYmxlT2JzZXJ2ZXIudGFibGUpLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0Q29ybmVyKHJlY3QsIGNlbGxWYWx1ZSkge1xuICBsZXQgY29sTmFtZTtcbiAgbGV0IHJvd05hbWU7XG4gIGlmIChjZWxsVmFsdWUuc3RhcnRDb2x1bW4gPT09IHJlY3QubWluQ29sdW1uKSB7XG4gICAgY29sTmFtZSA9ICdtaW5Db2x1bW4nO1xuICB9IGVsc2UgaWYgKGNlbGxWYWx1ZS5zdGFydENvbHVtbiArIGNlbGxWYWx1ZS5jZWxsLl9fY29sU3BhbiAtIDEgPT09IHJlY3QubWF4Q29sdW1uKSB7XG4gICAgY29sTmFtZSA9ICdtYXhDb2x1bW4nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjZWxsVmFsdWUuc3RhcnRSb3cgPT09IHJlY3QubWluUm93KSB7XG4gICAgcm93TmFtZSA9ICdtaW5Sb3cnO1xuICB9IGVsc2UgaWYgKGNlbGxWYWx1ZS5zdGFydFJvdyArIGNlbGxWYWx1ZS5jZWxsLl9fcm93U3BhbiAtIDEgPT09IHJlY3QubWF4Um93KSB7XG4gICAgcm93TmFtZSA9ICdtYXhSb3cnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBbY29sTmFtZSwgcm93TmFtZV07XG59XG5mdW5jdGlvbiBnZXRDb3JuZXJPclRocm93KHJlY3QsIGNlbGxWYWx1ZSkge1xuICBjb25zdCBjb3JuZXIgPSBnZXRDb3JuZXIocmVjdCwgY2VsbFZhbHVlKTtcbiAgaWYgKCEoY29ybmVyICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0Q29ybmVyT3JUaHJvdzogY2VsbCAke2NlbGxWYWx1ZS5jZWxsLmdldEtleSgpfSBpcyBub3QgYXQgYSBjb3JuZXIgb2YgcmVjdGApO1xuICB9XG4gIHJldHVybiBjb3JuZXI7XG59XG5mdW5jdGlvbiBvcHBvc2l0ZUNvcm5lcihbY29sTmFtZSwgcm93TmFtZV0pIHtcbiAgcmV0dXJuIFtjb2xOYW1lID09PSAnbWluQ29sdW1uJyA/ICdtYXhDb2x1bW4nIDogJ21pbkNvbHVtbicsIHJvd05hbWUgPT09ICdtaW5Sb3cnID8gJ21heFJvdycgOiAnbWluUm93J107XG59XG5mdW5jdGlvbiBjZWxsQXRDb3JuZXJPclRocm93KHRhYmxlTWFwLCByZWN0LCBbY29sTmFtZSwgcm93TmFtZV0pIHtcbiAgY29uc3Qgcm93TnVtID0gcmVjdFtyb3dOYW1lXTtcbiAgY29uc3Qgcm93TWFwID0gdGFibGVNYXBbcm93TnVtXTtcbiAgaWYgKCEocm93TWFwICE9PSB1bmRlZmluZWQpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBjZWxsQXRDb3JuZXJPclRocm93OiAke3Jvd05hbWV9ID0gJHtTdHJpbmcocm93TnVtKX0gbWlzc2luZyBpbiB0YWJsZU1hcGApO1xuICB9XG4gIGNvbnN0IGNvbE51bSA9IHJlY3RbY29sTmFtZV07XG4gIGNvbnN0IGNlbGwgPSByb3dNYXBbY29sTnVtXTtcbiAgaWYgKCEoY2VsbCAhPT0gdW5kZWZpbmVkKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgY2VsbEF0Q29ybmVyT3JUaHJvdzogJHtjb2xOYW1lfSA9ICR7U3RyaW5nKGNvbE51bSl9IG1pc3NpbmcgaW4gdGFibGVNYXBgKTtcbiAgfVxuICByZXR1cm4gY2VsbDtcbn1cbmZ1bmN0aW9uICRleHRyYWN0UmVjdENvcm5lcnModGFibGVNYXAsIGFuY2hvckNlbGxWYWx1ZSwgbmV3Rm9jdXNDZWxsVmFsdWUpIHtcbiAgLy8gV2UgYXJlIHN1cmUgdGhhdCB0aGUgZm9jdXMgbm93IGVpdGhlciBjb250cmFjdHMgb3IgZXhwYW5kcyB0aGUgcmVjdFxuICAvLyBidXQgYm90aCB0aGUgYW5jaG9yIGFuZCBmb2N1cyBtaWdodCBiZSBtb3ZlZCB0byBlbnN1cmUgYSByZWN0YW5nbGVcbiAgLy8gZ2l2ZW4gYSBwb3RlbnRpYWxseSByYWdnZWQgbWVyZ2Ugc2hhcGVcbiAgY29uc3QgcmVjdCA9ICRjb21wdXRlVGFibGVDZWxsUmVjdEJvdW5kYXJ5KHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIG5ld0ZvY3VzQ2VsbFZhbHVlKTtcbiAgY29uc3QgYW5jaG9yQ29ybmVyID0gZ2V0Q29ybmVyKHJlY3QsIGFuY2hvckNlbGxWYWx1ZSk7XG4gIGlmIChhbmNob3JDb3JuZXIpIHtcbiAgICByZXR1cm4gW2NlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIGFuY2hvckNvcm5lciksIGNlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIG9wcG9zaXRlQ29ybmVyKGFuY2hvckNvcm5lcikpXTtcbiAgfVxuICBjb25zdCBuZXdGb2N1c0Nvcm5lciA9IGdldENvcm5lcihyZWN0LCBuZXdGb2N1c0NlbGxWYWx1ZSk7XG4gIGlmIChuZXdGb2N1c0Nvcm5lcikge1xuICAgIHJldHVybiBbY2VsbEF0Q29ybmVyT3JUaHJvdyh0YWJsZU1hcCwgcmVjdCwgb3Bwb3NpdGVDb3JuZXIobmV3Rm9jdXNDb3JuZXIpKSwgY2VsbEF0Q29ybmVyT3JUaHJvdyh0YWJsZU1hcCwgcmVjdCwgbmV3Rm9jdXNDb3JuZXIpXTtcbiAgfVxuICAvLyBUT0RPIHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlIGFyYml0cmFyeSwgdXNlIHRoZSBjbG9zZXN0IGNvcm5lciBpbnN0ZWFkXG4gIGNvbnN0IG5ld0FuY2hvckNvcm5lciA9IFsnbWluQ29sdW1uJywgJ21pblJvdyddO1xuICByZXR1cm4gW2NlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIG5ld0FuY2hvckNvcm5lciksIGNlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIG9wcG9zaXRlQ29ybmVyKG5ld0FuY2hvckNvcm5lcikpXTtcbn1cbmZ1bmN0aW9uICRhZGp1c3RGb2N1c0luRGlyZWN0aW9uKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIGZvY3VzQ2VsbFZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgcmVjdCA9ICRjb21wdXRlVGFibGVDZWxsUmVjdEJvdW5kYXJ5KHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIGZvY3VzQ2VsbFZhbHVlKTtcbiAgY29uc3Qgc3BhbnMgPSAkY29tcHV0ZVRhYmxlQ2VsbFJlY3RTcGFucyh0YWJsZU1hcCwgcmVjdCk7XG4gIGNvbnN0IHtcbiAgICB0b3BTcGFuLFxuICAgIGxlZnRTcGFuLFxuICAgIGJvdHRvbVNwYW4sXG4gICAgcmlnaHRTcGFuXG4gIH0gPSBzcGFucztcbiAgY29uc3QgYW5jaG9yQ29ybmVyID0gZ2V0Q29ybmVyT3JUaHJvdyhyZWN0LCBhbmNob3JDZWxsVmFsdWUpO1xuICBjb25zdCBbZm9jdXNDb2x1bW4sIGZvY3VzUm93XSA9IG9wcG9zaXRlQ29ybmVyKGFuY2hvckNvcm5lcik7XG4gIGxldCBmQ29sID0gcmVjdFtmb2N1c0NvbHVtbl07XG4gIGxldCBmUm93ID0gcmVjdFtmb2N1c1Jvd107XG4gIGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgIGZDb2wgKz0gZm9jdXNDb2x1bW4gPT09ICdtYXhDb2x1bW4nID8gMSA6IGxlZnRTcGFuO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJykge1xuICAgIGZDb2wgLT0gZm9jdXNDb2x1bW4gPT09ICdtaW5Db2x1bW4nID8gMSA6IHJpZ2h0U3BhbjtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgIGZSb3cgKz0gZm9jdXNSb3cgPT09ICdtYXhSb3cnID8gMSA6IHRvcFNwYW47XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgZlJvdyAtPSBmb2N1c1JvdyA9PT0gJ21pblJvdycgPyAxIDogYm90dG9tU3BhbjtcbiAgfVxuICBjb25zdCB0YXJnZXRSb3dNYXAgPSB0YWJsZU1hcFtmUm93XTtcbiAgaWYgKHRhcmdldFJvd01hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5ld0ZvY3VzQ2VsbFZhbHVlID0gdGFyZ2V0Um93TWFwW2ZDb2xdO1xuICBpZiAobmV3Rm9jdXNDZWxsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBXZSBjYW4gYmUgY2VydGFpbiB0aGF0IGFuY2hvckNlbGxWYWx1ZSBhbmQgbmV3Rm9jdXNDZWxsVmFsdWUgYXJlXG4gIC8vIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGRlc2lyZWQgc2VsZWN0aW9uLCBidXQgd2UgYXJlIG5vdCBjZXJ0YWluIGlmXG4gIC8vIHRoZXkgbmVlZCB0byBiZSBleHBhbmRlZCBvciBub3QgdG8gbWFpbnRhaW4gYSByZWN0YW5ndWxhciBzaGFwZVxuICBjb25zdCBbZmluYWxBbmNob3JDZWxsLCBmaW5hbEZvY3VzQ2VsbF0gPSAkZXh0cmFjdFJlY3RDb3JuZXJzKHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIG5ld0ZvY3VzQ2VsbFZhbHVlKTtcbiAgY29uc3QgYW5jaG9yRE9NID0gJGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZU9yVGhyb3codGFibGVPYnNlcnZlciwgZmluYWxBbmNob3JDZWxsLmNlbGwpO1xuICBjb25zdCBmb2N1c0RPTSA9ICRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGZpbmFsRm9jdXNDZWxsLmNlbGwpO1xuICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTSk7XG4gIHRhYmxlT2JzZXJ2ZXIuJHNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihmb2N1c0RPTSwgdHJ1ZSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgLy8gVE9ETyB0aGlzIHNob3VsZCBwcm9iYWJseSByZXR1cm4gZmFsc2UgaWYgdGhlcmUncyBhbiB1bnJlbGF0ZWRcbiAgICAvLyAgICAgIHNoYWRvdyByb290IGJldHdlZW4gdGhlIG5vZGUgYW5kIHRoZSB0YWJsZSAoZS5nLiBhbm90aGVyIHRhYmxlLFxuICAgIC8vICAgICAgY29sbGFwc2libGUsIGV0Yy4pXG4gICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgIHJldHVybiBpc0FuY2hvckluc2lkZSAmJiBpc0ZvY3VzSW5zaWRlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRpc0Z1bGxUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmICh0YWJsZU5vZGUgJiYgYW5jaG9yTm9kZSAmJiBmb2N1c05vZGUpIHtcbiAgICAgIGNvbnN0IFttYXBdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvck5vZGUsIGZvY3VzTm9kZSk7XG4gICAgICByZXR1cm4gYW5jaG9yTm9kZS5nZXRLZXkoKSA9PT0gbWFwWzBdWzBdLmNlbGwuZ2V0S2V5KCkgJiYgZm9jdXNOb2RlLmdldEtleSgpID09PSBtYXBbbWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsLmdldEtleSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbCwgZnJvbVN0YXJ0KSB7XG4gIGlmIChmcm9tU3RhcnQpIHtcbiAgICB0YWJsZUNlbGwuc2VsZWN0U3RhcnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZUNlbGwuc2VsZWN0RW5kKCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpIHtcbiAgY29uc3QgZWxlbWVudCA9IGNlbGwuZWxlbTtcbiAgY29uc3QgZWRpdG9yVGhlbWVDbGFzc2VzID0gZWRpdG9yLl9jb25maWcudGhlbWU7XG4gIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShlbGVtZW50KTtcbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIExleGljYWxOb2RlIGZyb20gVGFibGUgQ2VsbCBET01Ob2RlYCk7XG4gIH1cbiAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBlZGl0b3JUaGVtZUNsYXNzZXMudGFibGVDZWxsU2VsZWN0ZWQpO1xufVxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBjZWxsLmVsZW07XG4gIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShlbGVtZW50KTtcbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIExleGljYWxOb2RlIGZyb20gVGFibGUgQ2VsbCBET01Ob2RlYCk7XG4gIH1cbiAgY29uc3QgZWRpdG9yVGhlbWVDbGFzc2VzID0gZWRpdG9yLl9jb25maWcudGhlbWU7XG4gIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCBlZGl0b3JUaGVtZUNsYXNzZXMudGFibGVDZWxsU2VsZWN0ZWQpO1xufVxuZnVuY3Rpb24gJGZpbmRDZWxsTm9kZShub2RlKSB7XG4gIGNvbnN0IGNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgcmV0dXJuICRpc1RhYmxlQ2VsbE5vZGUoY2VsbE5vZGUpID8gY2VsbE5vZGUgOiBudWxsO1xufVxuZnVuY3Rpb24gJGZpbmRUYWJsZU5vZGUobm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsICRpc1RhYmxlTm9kZSk7XG4gIHJldHVybiAkaXNUYWJsZU5vZGUodGFibGVOb2RlKSA/IHRhYmxlTm9kZSA6IG51bGw7XG59XG5mdW5jdGlvbiAkZ2V0QmxvY2tQYXJlbnRJZkZpcnN0Tm9kZShub2RlKSB7XG4gIGZvciAobGV0IHByZXZOb2RlID0gbm9kZSwgY3VycmVudE5vZGUgPSBub2RlOyBjdXJyZW50Tm9kZSAhPT0gbnVsbDsgcHJldk5vZGUgPSBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKSkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChjdXJyZW50Tm9kZSAhPT0gcHJldk5vZGUgJiYgY3VycmVudE5vZGUuZ2V0Rmlyc3RDaGlsZCgpICE9PSBwcmV2Tm9kZSkge1xuICAgICAgICAvLyBOb3QgdGhlIGZpcnN0IGNoaWxkIG9yIHRoZSBpbml0aWFsIG5vZGVcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCFjdXJyZW50Tm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkaGFuZGxlSG9yaXpvbnRhbEFycm93S2V5UmFuZ2VTZWxlY3Rpb24oZWRpdG9yLCBldmVudCwgc2VsZWN0aW9uLCBhbHRlciwgaXNCYWNrd2FyZCwgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSB7XG4gIGNvbnN0IGluaXRpYWxGb2N1cyA9ICRjYXJldEZyb21Qb2ludChzZWxlY3Rpb24uZm9jdXMsIGlzQmFja3dhcmQgPyAncHJldmlvdXMnIDogJ25leHQnKTtcbiAgaWYgKCRpc0V4dGVuZGFibGVUZXh0UG9pbnRDYXJldChpbml0aWFsRm9jdXMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBsYXN0Q2FyZXQgPSBpbml0aWFsRm9jdXM7XG4gIC8vIFRhYmxlQ2VsbE5vZGUgaXMgdGhlIG9ubHkgc2hhZG93IHJvb3Qgd2UgYXJlIGludGVyZXN0ZWQgaW4gcGllcmNpbmcgc29cbiAgLy8gd2UgZmluZCB0aGUgbGFzdCBpbnRlcm5hbCBjYXJldCBhbmQgdGhlbiBjaGVjayBpdHMgcGFyZW50XG4gIGZvciAoY29uc3QgbmV4dENhcmV0IG9mICRleHRlbmRDYXJldFRvUmFuZ2UoaW5pdGlhbEZvY3VzKS5pdGVyTm9kZUNhcmV0cygnc2hhZG93Um9vdCcpKSB7XG4gICAgaWYgKCEoJGlzU2libGluZ0NhcmV0KG5leHRDYXJldCkgJiYgJGlzRWxlbWVudE5vZGUobmV4dENhcmV0Lm9yaWdpbikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxhc3RDYXJldCA9IG5leHRDYXJldDtcbiAgfVxuICBjb25zdCBsYXN0Q2FyZXRQYXJlbnQgPSBsYXN0Q2FyZXQuZ2V0UGFyZW50QXRDYXJldCgpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobGFzdENhcmV0UGFyZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhbmNob3JDZWxsID0gbGFzdENhcmV0UGFyZW50O1xuICBjb25zdCBmb2N1c0NhcmV0ID0gJGZpbmROZXh0VGFibGVDZWxsKCRnZXRTaWJsaW5nQ2FyZXQoYW5jaG9yQ2VsbCwgbGFzdENhcmV0LmRpcmVjdGlvbikpO1xuICBjb25zdCBhbmNob3JDZWxsVGFibGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvckNlbGwsICRpc1RhYmxlTm9kZSk7XG4gIGlmICghKGFuY2hvckNlbGxUYWJsZSAmJiBhbmNob3JDZWxsVGFibGUuaXModGFibGVOb2RlKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYW5jaG9yQ2VsbERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yQ2VsbC5nZXRLZXkoKSk7XG4gIGNvbnN0IGFuY2hvckRPTUNlbGwgPSBnZXRET01DZWxsRnJvbVRhcmdldChhbmNob3JDZWxsRE9NKTtcbiAgaWYgKCFhbmNob3JDZWxsRE9NIHx8ICFhbmNob3JET01DZWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFuY2hvckNlbGxUYWJsZUVsZW1lbnQgPSAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZShlZGl0b3IsIGFuY2hvckNlbGxUYWJsZSk7XG4gIHRhYmxlT2JzZXJ2ZXIudGFibGUgPSBhbmNob3JDZWxsVGFibGVFbGVtZW50O1xuICBpZiAoIWZvY3VzQ2FyZXQpIHtcbiAgICBpZiAoYWx0ZXIgPT09ICdleHRlbmQnKSB7XG4gICAgICAvLyBleHRlbmQgdGhlIHNlbGVjdGlvbiBmcm9tIGEgcmFuZ2UgaW5zaWRlIHRoZSBjZWxsIHRvIGEgdGFibGUgc2VsZWN0aW9uIG9mIHRoZSBjZWxsXG4gICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTUNlbGwpO1xuICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTUNlbGwsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGl0IHRoZSB0YWJsZVxuICAgICAgY29uc3Qgb3V0ZXJGb2N1c0NhcmV0ID0gJGdldFRhYmxlRXhpdENhcmV0KCRnZXRTaWJsaW5nQ2FyZXQoYW5jaG9yQ2VsbFRhYmxlLCBpbml0aWFsRm9jdXMuZGlyZWN0aW9uKSk7XG4gICAgICAkc2V0UG9pbnRGcm9tQ2FyZXQoc2VsZWN0aW9uLmFuY2hvciwgb3V0ZXJGb2N1c0NhcmV0KTtcbiAgICAgICRzZXRQb2ludEZyb21DYXJldChzZWxlY3Rpb24uZm9jdXMsIG91dGVyRm9jdXNDYXJldCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFsdGVyID09PSAnZXh0ZW5kJykge1xuICAgIGNvbnN0IGZvY3VzRE9NQ2VsbCA9IGdldERPTUNlbGxGcm9tVGFyZ2V0KGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZm9jdXNDYXJldC5vcmlnaW4uZ2V0S2V5KCkpKTtcbiAgICBpZiAoIWZvY3VzRE9NQ2VsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTUNlbGwpO1xuICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihmb2N1c0RPTUNlbGwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGFsdGVyID09PSAnbW92ZSdcbiAgICBjb25zdCBpbm5lckZvY3VzQ2FyZXQgPSAkbm9ybWFsaXplQ2FyZXQoZm9jdXNDYXJldCk7XG4gICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5hbmNob3IsIGlubmVyRm9jdXNDYXJldCk7XG4gICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5mb2N1cywgaW5uZXJGb2N1c0NhcmV0KTtcbiAgfVxuICBzdG9wRXZlbnQoZXZlbnQpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUV4aXRDYXJldChpbml0aWFsQ2FyZXQpIHtcbiAgY29uc3QgYWRqYWNlbnQgPSAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0KGluaXRpYWxDYXJldCk7XG4gIHJldHVybiAkaXNDaGlsZENhcmV0KGFkamFjZW50KSA/ICRub3JtYWxpemVDYXJldChhZGphY2VudCkgOiBpbml0aWFsQ2FyZXQ7XG59XG5mdW5jdGlvbiAkZmluZE5leHRUYWJsZUNlbGwoaW5pdGlhbENhcmV0KSB7XG4gIGZvciAoY29uc3QgbmV4dENhcmV0IG9mICRleHRlbmRDYXJldFRvUmFuZ2UoaW5pdGlhbENhcmV0KS5pdGVyTm9kZUNhcmV0cygncm9vdCcpKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3JpZ2luXG4gICAgfSA9IG5leHRDYXJldDtcbiAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShvcmlnaW4pKSB7XG4gICAgICAvLyBub3Qgc3VyZSB3aHkgdHMgaXNuJ3QgbmFycm93aW5nIGhlcmUgKGV2ZW4gaWYgdGhlIGd1YXJkIGlzIG9uIG5leHRDYXJldC5vcmlnaW4pXG4gICAgICAvLyBidXQgcmV0dXJuaW5nIGEgbmV3IGNhcmV0IGlzIGZpbmVcbiAgICAgIGlmICgkaXNDaGlsZENhcmV0KG5leHRDYXJldCkpIHtcbiAgICAgICAgcmV0dXJuICRnZXRDaGlsZENhcmV0KG9yaWdpbiwgaW5pdGlhbENhcmV0LmRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghJGlzVGFibGVSb3dOb2RlKG9yaWdpbikpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCBkaXJlY3Rpb24sIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlcikge1xuICBpZiAoKGRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBkaXJlY3Rpb24gPT09ICdkb3duJykgJiYgaXNUeXBlYWhlYWRNZW51SW5WaWV3KGVkaXRvcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSAkZ2V0QmxvY2tQYXJlbnRJZkZpcnN0Tm9kZShzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpKTtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpYmxpbmdOb2RlID0gcGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZU5vZGUoc2libGluZ05vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQoc2libGluZ05vZGUuZ2V0UGFyZW50T3JUaHJvdygpLmdldEtleSgpLCBzaWJsaW5nTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpLCAnZWxlbWVudCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpYmxpbmdOb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoZGlyZWN0aW9uID09PSAndXAnIHx8IGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSkge1xuICAgICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgICBjb25zdCBpc1RhYmxlVW5zZWxlY3QgPSAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgKGRpcmVjdGlvbiA9PT0gJ3VwJyAmJiAhc2VsZWN0aW9uLmlzQmFja3dhcmQoKSB8fCBkaXJlY3Rpb24gPT09ICdkb3duJyAmJiBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpKTtcbiAgICAgICAgaWYgKGlzVGFibGVVbnNlbGVjdCkge1xuICAgICAgICAgIGxldCBmb2N1c1BhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzTm9kZSwgbiA9PiAkaXNUYWJsZU5vZGUobikpO1xuICAgICAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGZvY3VzUGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGZvY3VzUGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXNQYXJlbnROb2RlLCAkaXNUYWJsZU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9jdXNQYXJlbnROb2RlICE9PSB0YWJsZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb2N1c1BhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGRpcmVjdGlvbiA9PT0gJ2Rvd24nID8gZm9jdXNQYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCkgOiBmb2N1c1BhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgICAgaWYgKCFzaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBuZXdPZmZzZXQgPSAwO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgICAgICAgICBuZXdPZmZzZXQgPSBzaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbmV3Rm9jdXNOb2RlID0gc2libGluZztcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdENlbGwgPSBzaWJsaW5nLmdldExhc3RDaGlsZCgpO1xuICAgICAgICAgICAgICBuZXdGb2N1c05vZGUgPSBsYXN0Q2VsbCA/IGxhc3RDZWxsIDogc2libGluZztcbiAgICAgICAgICAgICAgbmV3T2Zmc2V0ID0gJGlzVGV4dE5vZGUobmV3Rm9jdXNOb2RlKSA/IG5ld0ZvY3VzTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQobmV3Rm9jdXNOb2RlLmdldEtleSgpLCBuZXdPZmZzZXQsICRpc1RleHROb2RlKG5ld0ZvY3VzTm9kZSkgPyAndGV4dCcgOiAnZWxlbWVudCcpO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoZm9jdXNOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IHNlbGVjdGlvbi5nZXROb2RlcygpW3NlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCAtIDFdIDogc2VsZWN0aW9uLmdldE5vZGVzKClbMF07XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kUGFyZW50VGFibGVDZWxsTm9kZUluVGFibGUodGFibGVOb2RlLCBzZWxlY3RlZE5vZGUpO1xuICAgICAgICAgICAgaWYgKHRhYmxlQ2VsbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3REZXNjZW5kYW50ID0gdGFibGVOb2RlLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IHRhYmxlTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgICBpZiAoIWZpcnN0RGVzY2VuZGFudCB8fCAhbGFzdERlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgW2ZpcnN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGZpcnN0RGVzY2VuZGFudCk7XG4gICAgICAgICAgICAgIGNvbnN0IFtsYXN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGxhc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsQ29vcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGZpcnN0Q2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0Q2VsbENvb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShsYXN0Q2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdENlbGxET00gPSB0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coZmlyc3RDZWxsQ29vcmRzLngsIGZpcnN0Q2VsbENvb3Jkcy55LCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdENlbGxET00gPSB0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3cobGFzdENlbGxDb29yZHMueCwgbGFzdENlbGxDb29yZHMueSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oZmlyc3RDZWxsRE9NKTtcbiAgICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGxhc3RDZWxsRE9NLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZm9jdXNQYXJlbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1c05vZGUsIG4gPT4gJGlzRWxlbWVudE5vZGUobikgJiYgIW4uaXNJbmxpbmUoKSk7XG4gICAgICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNQYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgZm9jdXNQYXJlbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1c1BhcmVudE5vZGUsICRpc1RhYmxlTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm9jdXNQYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBkaXJlY3Rpb24gPT09ICdkb3duJyA/IGZvY3VzUGFyZW50Tm9kZS5nZXROZXh0U2libGluZygpIDogZm9jdXNQYXJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgICAgIGlmICgkaXNUYWJsZU5vZGUoc2libGluZykgJiYgdGFibGVPYnNlcnZlci50YWJsZU5vZGVLZXkgPT09IHNpYmxpbmcuZ2V0S2V5KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IHNpYmxpbmcuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IHNpYmxpbmcuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgICAgIGlmICghZmlyc3REZXNjZW5kYW50IHx8ICFsYXN0RGVzY2VuZGFudCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbZmlyc3RDZWxsTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQoZmlyc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgIGNvbnN0IFtsYXN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGxhc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmZvY3VzLnNldCgoZGlyZWN0aW9uID09PSAndXAnID8gZmlyc3RDZWxsTm9kZSA6IGxhc3RDZWxsTm9kZSkuZ2V0S2V5KCksIGRpcmVjdGlvbiA9PT0gJ3VwJyA/IDAgOiBsYXN0Q2VsbE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJyAmJiAkaXNTY3JvbGxhYmxlVGFibGVzQWN0aXZlKGVkaXRvcikpIHtcbiAgICAgIC8vIEVuYWJsZSBGaXJlZm94IHdvcmthcm91bmRcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0U2hvdWxkQ2hlY2tTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyB8fCBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgY29uc3QgYWx0ZXIgPSBldmVudC5zaGlmdEtleSA/ICdleHRlbmQnIDogJ21vdmUnO1xuICAgICAgcmV0dXJuICRoYW5kbGVIb3Jpem9udGFsQXJyb3dLZXlSYW5nZVNlbGVjdGlvbihlZGl0b3IsIGV2ZW50LCBzZWxlY3Rpb24sIGFsdGVyLCBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcsIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlcik7XG4gICAgfVxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXMuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsTm9kZSkgfHwgIWFuY2hvckNlbGxOb2RlLmlzKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuY2hvckNlbGxUYWJsZSA9ICRmaW5kVGFibGVOb2RlKGFuY2hvckNlbGxOb2RlKTtcbiAgICAgIGlmIChhbmNob3JDZWxsVGFibGUgIT09IHRhYmxlTm9kZSAmJiBhbmNob3JDZWxsVGFibGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBhbmNob3JDZWxsVGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KGFuY2hvckNlbGxUYWJsZSwgZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JDZWxsVGFibGUuZ2V0S2V5KCkpKTtcbiAgICAgICAgaWYgKGFuY2hvckNlbGxUYWJsZUVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIudGFibGUgPSBnZXRUYWJsZShhbmNob3JDZWxsVGFibGUsIGFuY2hvckNlbGxUYWJsZUVsZW1lbnQpO1xuICAgICAgICAgIHJldHVybiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgZGlyZWN0aW9uLCBhbmNob3JDZWxsVGFibGUsIHRhYmxlT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3JDZWxsRG9tID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JDZWxsTm9kZS5fX2tleSk7XG4gICAgICBjb25zdCBhbmNob3JET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvci5rZXkpO1xuICAgICAgaWYgKGFuY2hvckRPTSA9PSBudWxsIHx8IGFuY2hvckNlbGxEb20gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgZWRnZVNlbGVjdGlvblJlY3Q7XG4gICAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgICBlZGdlU2VsZWN0aW9uUmVjdCA9IGFuY2hvckRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihnZXRFZGl0b3JXaW5kb3coZWRpdG9yKSk7XG4gICAgICAgIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgZWRnZVNlbGVjdGlvblJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkZ2VDaGlsZCA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IGFuY2hvckNlbGxOb2RlLmdldEZpcnN0Q2hpbGQoKSA6IGFuY2hvckNlbGxOb2RlLmdldExhc3RDaGlsZCgpO1xuICAgICAgaWYgKGVkZ2VDaGlsZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkZ2VDaGlsZERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZWRnZUNoaWxkLl9fa2V5KTtcbiAgICAgIGlmIChlZGdlQ2hpbGRET00gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGdlUmVjdCA9IGVkZ2VDaGlsZERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGlzRXhpdGluZyA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IGVkZ2VSZWN0LnRvcCA+IGVkZ2VTZWxlY3Rpb25SZWN0LnRvcCAtIGVkZ2VTZWxlY3Rpb25SZWN0LmhlaWdodCA6IGVkZ2VTZWxlY3Rpb25SZWN0LmJvdHRvbSArIGVkZ2VTZWxlY3Rpb25SZWN0LmhlaWdodCA+IGVkZ2VSZWN0LmJvdHRvbTtcbiAgICAgIGlmIChpc0V4aXRpbmcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgY29uc3QgY29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBjb25zdCBjZWxsID0gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGNvcmRzLngsIGNvcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCk7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGNlbGwsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxlY3RUYWJsZU5vZGVJbkRpcmVjdGlvbih0YWJsZU9ic2VydmVyLCB0YWJsZU5vZGUsIGNvcmRzLngsIGNvcmRzLnksIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgY29uc3QgW3RhYmxlTm9kZUZyb21TZWxlY3Rpb25dID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlRnJvbVNlbGVjdGlvbikpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGhhbmRsZUFycm93S2V5OiBUYWJsZVNlbGVjdGlvbi5nZXROb2RlcygpWzBdIGV4cGVjdGVkIHRvIGJlIFRhYmxlTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBnZXRUYWJsZUVsZW1lbnQodGFibGVOb2RlRnJvbVNlbGVjdGlvbiwgZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGVGcm9tU2VsZWN0aW9uLmdldEtleSgpKSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGxOb2RlKSB8fCAhJGlzVGFibGVOb2RlKHRhYmxlTm9kZUZyb21TZWxlY3Rpb24pIHx8IHRhYmxlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRhYmxlT2JzZXJ2ZXIuJHVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCBncmlkID0gZ2V0VGFibGUodGFibGVOb2RlRnJvbVNlbGVjdGlvbiwgdGFibGVFbGVtZW50KTtcbiAgICBjb25zdCBjb3Jkc0FuY2hvciA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShhbmNob3JDZWxsTm9kZSwgZ3JpZCk7XG4gICAgY29uc3QgYW5jaG9yQ2VsbCA9IHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhjb3Jkc0FuY2hvci54LCBjb3Jkc0FuY2hvci55LCBncmlkKTtcbiAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckNlbGwpO1xuICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBjb25zdCBbdGFibGVNYXAsIGFuY2hvclZhbHVlLCBmb2N1c1ZhbHVlXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBhbmNob3JDZWxsTm9kZSwgZm9jdXNDZWxsTm9kZSk7XG4gICAgICByZXR1cm4gJGFkanVzdEZvY3VzSW5EaXJlY3Rpb24odGFibGVPYnNlcnZlciwgdGFibGVNYXAsIGFuY2hvclZhbHVlLCBmb2N1c1ZhbHVlLCBkaXJlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb2N1c0NlbGxOb2RlLnNlbGVjdEVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuZnVuY3Rpb24gaXNUeXBlYWhlYWRNZW51SW5WaWV3KGVkaXRvcikge1xuICAvLyBUaGVyZSBpcyBubyBpbmJ1aWx0IHdheSB0byBjaGVjayBpZiB0aGUgY29tcG9uZW50IHBpY2tlciBpcyBpbiB2aWV3XG4gIC8vIGJ1dCB3ZSBjYW4gY2hlY2sgaWYgdGhlIHJvb3QgRE9NIGVsZW1lbnQgaGFzIHRoZSBhcmlhLWNvbnRyb2xzIGF0dHJpYnV0ZSBcInR5cGVhaGVhZC1tZW51XCIuXG4gIGNvbnN0IHJvb3QgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgaWYgKCFyb290KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiByb290Lmhhc0F0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpICYmIHJvb3QuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykgPT09ICd0eXBlYWhlYWQtbWVudSc7XG59XG5mdW5jdGlvbiAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBpZiAoZWRnZVBvc2l0aW9uID09PSAnZmlyc3QnKSB7XG4gICAgdGFibGVOb2RlLmluc2VydEJlZm9yZShwYXJhZ3JhcGhOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZU5vZGUuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoTm9kZSk7XG4gIH1cbiAgcGFyYWdyYXBoTm9kZS5hcHBlbmQoLi4uKGNoaWxkcmVuIHx8IFtdKSk7XG4gIHBhcmFncmFwaE5vZGUuc2VsZWN0RW5kKCk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGVQYXJlbnQgPSB0YWJsZU5vZGUuZ2V0UGFyZW50KCk7XG4gIGlmICghdGFibGVOb2RlUGFyZW50KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFRPRE86IEFkZCBzdXBwb3J0IGZvciBuZXN0ZWQgdGFibGVzXG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihnZXRFZGl0b3JXaW5kb3coZWRpdG9yKSk7XG4gIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIGNvbnN0IHRhYmxlTm9kZVBhcmVudERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGFibGVOb2RlUGFyZW50LmdldEtleSgpKTtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KHRhYmxlTm9kZSwgZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGUuZ2V0S2V5KCkpKTtcbiAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgc2NlbmFyaW8gd2hlcmUgdGhlXG4gIC8vIG5hdGl2ZSBzZWxlY3Rpb24gYW5jaG9yIGlzOlxuICAvLyAtIGF0IG9yIGluc2lkZSB0aGUgdGFibGUncyBwYXJlbnQgRE9NXG4gIC8vIC0gYW5kIE5PVCBhdCBvciBpbnNpZGUgdGhlIHRhYmxlIERPTVxuICAvLyBJdCBtYXkgYmUgYWRqYWNlbnQgdG8gdGhlIHRhYmxlIERPTSAoZS5nLiBpbiBhIHdyYXBwZXIpXG4gIGlmICghZG9tQW5jaG9yTm9kZSB8fCAhdGFibGVOb2RlUGFyZW50RE9NIHx8ICF0YWJsZUVsZW1lbnQgfHwgIXRhYmxlTm9kZVBhcmVudERPTS5jb250YWlucyhkb21BbmNob3JOb2RlKSB8fCB0YWJsZUVsZW1lbnQuY29udGFpbnMoZG9tQW5jaG9yTm9kZSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgaWYgKCFhbmNob3JDZWxsTm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgcGFyZW50VGFibGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvckNlbGxOb2RlLCBuID0+ICRpc1RhYmxlTm9kZShuKSk7XG4gIGlmICghJGlzVGFibGVOb2RlKHBhcmVudFRhYmxlKSB8fCAhcGFyZW50VGFibGUuaXModGFibGVOb2RlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgW3RhYmxlTWFwLCBjZWxsVmFsdWVdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvckNlbGxOb2RlLCBhbmNob3JDZWxsTm9kZSk7XG4gIGNvbnN0IGZpcnN0Q2VsbCA9IHRhYmxlTWFwWzBdWzBdO1xuICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdW3RhYmxlTWFwWzBdLmxlbmd0aCAtIDFdO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3csXG4gICAgc3RhcnRDb2x1bW5cbiAgfSA9IGNlbGxWYWx1ZTtcbiAgY29uc3QgaXNBdEZpcnN0Q2VsbCA9IHN0YXJ0Um93ID09PSBmaXJzdENlbGwuc3RhcnRSb3cgJiYgc3RhcnRDb2x1bW4gPT09IGZpcnN0Q2VsbC5zdGFydENvbHVtbjtcbiAgY29uc3QgaXNBdExhc3RDZWxsID0gc3RhcnRSb3cgPT09IGxhc3RDZWxsLnN0YXJ0Um93ICYmIHN0YXJ0Q29sdW1uID09PSBsYXN0Q2VsbC5zdGFydENvbHVtbjtcbiAgaWYgKGlzQXRGaXJzdENlbGwpIHtcbiAgICByZXR1cm4gJ2ZpcnN0JztcbiAgfSBlbHNlIGlmIChpc0F0TGFzdENlbGwpIHtcbiAgICByZXR1cm4gJ2xhc3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHRhYmxlTm9kZVxuICB9ID0gdGFibGVPYnNlcnZlci4kbG9va3VwKCk7XG4gIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgcmV0dXJuIHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhjdXJyZW50Q29yZHMueCwgY3VycmVudENvcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xufVxuZnVuY3Rpb24gJGdldE5lYXJlc3RUYWJsZUNlbGxJblRhYmxlRnJvbURPTU5vZGUodGFibGVOb2RlLCBzdGFydGluZ0RPTSwgZWRpdG9yU3RhdGUpIHtcbiAgcmV0dXJuICRmaW5kUGFyZW50VGFibGVDZWxsTm9kZUluVGFibGUodGFibGVOb2RlLCAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShzdGFydGluZ0RPTSwgZWRpdG9yU3RhdGUpKTtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRGl2RWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50JDEoZWxlbWVudCkgJiYgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0RJVic7XG59XG5mdW5jdGlvbiB1cGRhdGVDb2xncm91cChkb20sIGNvbmZpZywgY29sQ291bnQsIGNvbFdpZHRocykge1xuICBjb25zdCBjb2xHcm91cCA9IGRvbS5xdWVyeVNlbGVjdG9yKCdjb2xncm91cCcpO1xuICBpZiAoIWNvbEdyb3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgY29sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sJyk7XG4gICAgY29uc3Qgd2lkdGggPSBjb2xXaWR0aHMgJiYgY29sV2lkdGhzW2ldO1xuICAgIGlmICh3aWR0aCkge1xuICAgICAgY29sLnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgIH1cbiAgICBjb2xzLnB1c2goY29sKTtcbiAgfVxuICBjb2xHcm91cC5yZXBsYWNlQ2hpbGRyZW4oLi4uY29scyk7XG59XG5mdW5jdGlvbiBzZXRSb3dTdHJpcGluZyhkb20sIGNvbmZpZywgcm93U3RyaXBpbmcpIHtcbiAgaWYgKHJvd1N0cmlwaW5nKSB7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIGNvbmZpZy50aGVtZS50YWJsZVJvd1N0cmlwaW5nKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtcm93LXN0cmlwaW5nJywgJ3RydWUnKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCBjb25maWcudGhlbWUudGFibGVSb3dTdHJpcGluZyk7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLXJvdy1zdHJpcGluZycpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRGcm96ZW5Db2x1bW5zKGRvbSwgdGFibGVFbGVtZW50LCBjb25maWcsIGZyb3plbkNvbHVtbkNvdW50KSB7XG4gIGlmIChmcm96ZW5Db2x1bW5Db3VudCA+IDApIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuQ29sdW1uKTtcbiAgICB0YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLWNvbHVtbicsICd0cnVlJyk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuQ29sdW1uKTtcbiAgICB0YWJsZUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLWNvbHVtbicpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRGcm96ZW5Sb3dzKGRvbSwgdGFibGVFbGVtZW50LCBjb25maWcsIGZyb3plblJvd0NvdW50KSB7XG4gIGlmIChmcm96ZW5Sb3dDb3VudCA+IDApIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuUm93KTtcbiAgICB0YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLXJvdycsICd0cnVlJyk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuUm93KTtcbiAgICB0YWJsZUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLXJvdycpO1xuICB9XG59XG5mdW5jdGlvbiBhbGlnblRhYmxlRWxlbWVudChkb20sIGNvbmZpZywgZm9ybWF0VHlwZSkge1xuICBpZiAoIWNvbmZpZy50aGVtZS50YWJsZUFsaWdubWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZW1vdmVDbGFzc2VzID0gW107XG4gIGNvbnN0IGFkZENsYXNzZXMgPSBbXTtcbiAgZm9yIChjb25zdCBmb3JtYXQgb2YgWydjZW50ZXInLCAncmlnaHQnXSkge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBjb25maWcudGhlbWUudGFibGVBbGlnbm1lbnRbZm9ybWF0XTtcbiAgICBpZiAoIWNsYXNzZXMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAoZm9ybWF0ID09PSBmb3JtYXRUeXBlID8gYWRkQ2xhc3NlcyA6IHJlbW92ZUNsYXNzZXMpLnB1c2goY2xhc3Nlcyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgLi4ucmVtb3ZlQ2xhc3Nlcyk7XG4gIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5hZGRDbGFzc2VzKTtcbn1cbmNvbnN0IHNjcm9sbGFibGVFZGl0b3JzID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uICRpc1Njcm9sbGFibGVUYWJsZXNBY3RpdmUoZWRpdG9yID0gJGdldEVkaXRvcigpKSB7XG4gIHJldHVybiBzY3JvbGxhYmxlRWRpdG9ycy5oYXMoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIHNldFNjcm9sbGFibGVUYWJsZXNBY3RpdmUoZWRpdG9yLCBhY3RpdmUpIHtcbiAgaWYgKGFjdGl2ZSkge1xuICAgIGlmICghZWRpdG9yLl9jb25maWcudGhlbWUudGFibGVTY3JvbGxhYmxlV3JhcHBlcikge1xuICAgICAgY29uc29sZS53YXJuKCdUYWJsZU5vZGU6IGhhc0hvcml6b250YWxTY3JvbGwgaXMgYWN0aXZlIGJ1dCB0aGVtZS50YWJsZVNjcm9sbGFibGVXcmFwcGVyIGlzIG5vdCBkZWZpbmVkLicpO1xuICAgIH1cbiAgICBzY3JvbGxhYmxlRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgfSBlbHNlIHtcbiAgICBzY3JvbGxhYmxlRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgfVxufVxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZSc7XG4gIH1cbiAgZ2V0Q29sV2lkdGhzKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fY29sV2lkdGhzO1xuICB9XG4gIHNldENvbFdpZHRocyhjb2xXaWR0aHMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIC8vIE5PVEU6IE5vZGUgcHJvcGVydGllcyBzaG91bGQgYmUgaW1tdXRhYmxlLiBGcmVlemUgdG8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uLlxuICAgIHNlbGYuX19jb2xXaWR0aHMgPSBjb2xXaWR0aHMgIT09IHVuZGVmaW5lZCAmJiB0cnVlID8gT2JqZWN0LmZyZWV6ZShjb2xXaWR0aHMpIDogY29sV2lkdGhzO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZU5vZGUobm9kZS5fX2tleSk7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpIHtcbiAgICBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSk7XG4gICAgdGhpcy5fX2NvbFdpZHRocyA9IHByZXZOb2RlLl9fY29sV2lkdGhzO1xuICAgIHRoaXMuX19yb3dTdHJpcGluZyA9IHByZXZOb2RlLl9fcm93U3RyaXBpbmc7XG4gICAgdGhpcy5fX2Zyb3plbkNvbHVtbkNvdW50ID0gcHJldk5vZGUuX19mcm96ZW5Db2x1bW5Db3VudDtcbiAgICB0aGlzLl9fZnJvemVuUm93Q291bnQgPSBwcmV2Tm9kZS5fX2Zyb3plblJvd0NvdW50O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhYmxlOiBfbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlVGFibGVOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRSb3dTdHJpcGluZyhzZXJpYWxpemVkTm9kZS5yb3dTdHJpcGluZyB8fCBmYWxzZSkuc2V0RnJvemVuQ29sdW1ucyhzZXJpYWxpemVkTm9kZS5mcm96ZW5Db2x1bW5Db3VudCB8fCAwKS5zZXRGcm96ZW5Sb3dzKHNlcmlhbGl6ZWROb2RlLmZyb3plblJvd0NvdW50IHx8IDApLnNldENvbFdpZHRocyhzZXJpYWxpemVkTm9kZS5jb2xXaWR0aHMpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3Jvd1N0cmlwaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fX2Zyb3plbkNvbHVtbkNvdW50ID0gMDtcbiAgICB0aGlzLl9fZnJvemVuUm93Q291bnQgPSAwO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGNvbFdpZHRoczogdGhpcy5nZXRDb2xXaWR0aHMoKSxcbiAgICAgIGZyb3plbkNvbHVtbkNvdW50OiB0aGlzLl9fZnJvemVuQ29sdW1uQ291bnQgPyB0aGlzLl9fZnJvemVuQ29sdW1uQ291bnQgOiB1bmRlZmluZWQsXG4gICAgICBmcm96ZW5Sb3dDb3VudDogdGhpcy5fX2Zyb3plblJvd0NvdW50ID8gdGhpcy5fX2Zyb3plblJvd0NvdW50IDogdW5kZWZpbmVkLFxuICAgICAgcm93U3RyaXBpbmc6IHRoaXMuX19yb3dTdHJpcGluZyA/IHRoaXMuX19yb3dTdHJpcGluZyA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCwgc2VsZWN0aW9uLCBkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBkZXN0aW5hdGlvbiA9PT0gJ2h0bWwnO1xuICB9XG4gIGdldERPTVNsb3QoZWxlbWVudCkge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9ICFpc0hUTUxUYWJsZUVsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykgOiBlbGVtZW50O1xuICAgIGlmICghaXNIVE1MVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFibGVOb2RlLmdldERPTVNsb3Q6IGNyZWF0ZURPTSgpIGRpZCBub3QgcmV0dXJuIGEgdGFibGVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldERPTVNsb3QoZWxlbWVudCkud2l0aEVsZW1lbnQodGFibGVFbGVtZW50KS53aXRoQWZ0ZXIodGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvbGdyb3VwJykpO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcsIGVkaXRvcikge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgaWYgKHRoaXMuX19zdHlsZSkge1xuICAgICAgdGFibGVFbGVtZW50LnN0eWxlLmNzc1RleHQgPSB0aGlzLl9fc3R5bGU7XG4gICAgfVxuICAgIGNvbnN0IGNvbEdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnKTtcbiAgICB0YWJsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY29sR3JvdXApO1xuICAgIHNldERPTVVubWFuYWdlZChjb2xHcm91cCk7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCh0YWJsZUVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZSk7XG4gICAgdGhpcy51cGRhdGVUYWJsZUVsZW1lbnQobnVsbCwgdGFibGVFbGVtZW50LCBjb25maWcpO1xuICAgIGlmICgkaXNTY3JvbGxhYmxlVGFibGVzQWN0aXZlKGVkaXRvcikpIHtcbiAgICAgIGNvbnN0IHdyYXBwZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb25zdCBjbGFzc2VzID0gY29uZmlnLnRoZW1lLnRhYmxlU2Nyb2xsYWJsZVdyYXBwZXI7XG4gICAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KHdyYXBwZXJFbGVtZW50LCBjbGFzc2VzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSAnb3ZlcmZsb3cteDogYXV0bzsnO1xuICAgICAgfVxuICAgICAgd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGFibGVFbGVtZW50KTtcbiAgICAgIHRoaXMudXBkYXRlVGFibGVXcmFwcGVyKG51bGwsIHdyYXBwZXJFbGVtZW50LCB0YWJsZUVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICByZXR1cm4gd3JhcHBlckVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZUVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlVGFibGVXcmFwcGVyKHByZXZOb2RlLCB0YWJsZVdyYXBwZXIsIHRhYmxlRWxlbWVudCwgY29uZmlnKSB7XG4gICAgaWYgKHRoaXMuX19mcm96ZW5Db2x1bW5Db3VudCAhPT0gKHByZXZOb2RlID8gcHJldk5vZGUuX19mcm96ZW5Db2x1bW5Db3VudCA6IDApKSB7XG4gICAgICBzZXRGcm96ZW5Db2x1bW5zKHRhYmxlV3JhcHBlciwgdGFibGVFbGVtZW50LCBjb25maWcsIHRoaXMuX19mcm96ZW5Db2x1bW5Db3VudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fZnJvemVuUm93Q291bnQgIT09IChwcmV2Tm9kZSA/IHByZXZOb2RlLl9fZnJvemVuUm93Q291bnQgOiAwKSkge1xuICAgICAgc2V0RnJvemVuUm93cyh0YWJsZVdyYXBwZXIsIHRhYmxlRWxlbWVudCwgY29uZmlnLCB0aGlzLl9fZnJvemVuUm93Q291bnQpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUYWJsZUVsZW1lbnQocHJldk5vZGUsIHRhYmxlRWxlbWVudCwgY29uZmlnKSB7XG4gICAgaWYgKHRoaXMuX19zdHlsZSAhPT0gKHByZXZOb2RlID8gcHJldk5vZGUuX19zdHlsZSA6ICcnKSkge1xuICAgICAgdGFibGVFbGVtZW50LnN0eWxlLmNzc1RleHQgPSB0aGlzLl9fc3R5bGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fcm93U3RyaXBpbmcgIT09IChwcmV2Tm9kZSA/IHByZXZOb2RlLl9fcm93U3RyaXBpbmcgOiBmYWxzZSkpIHtcbiAgICAgIHNldFJvd1N0cmlwaW5nKHRhYmxlRWxlbWVudCwgY29uZmlnLCB0aGlzLl9fcm93U3RyaXBpbmcpO1xuICAgIH1cbiAgICB1cGRhdGVDb2xncm91cCh0YWJsZUVsZW1lbnQsIGNvbmZpZywgdGhpcy5nZXRDb2x1bW5Db3VudCgpLCB0aGlzLmdldENvbFdpZHRocygpKTtcbiAgICBhbGlnblRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIGNvbmZpZywgdGhpcy5nZXRGb3JtYXRUeXBlKCkpO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBzbG90ID0gdGhpcy5nZXRET01TbG90KGRvbSk7XG4gICAgY29uc3QgdGFibGVFbGVtZW50ID0gc2xvdC5lbGVtZW50O1xuICAgIGlmIChkb20gPT09IHRhYmxlRWxlbWVudCA9PT0gJGlzU2Nyb2xsYWJsZVRhYmxlc0FjdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzSFRNTERpdkVsZW1lbnQoZG9tKSkge1xuICAgICAgdGhpcy51cGRhdGVUYWJsZVdyYXBwZXIocHJldk5vZGUsIGRvbSwgdGFibGVFbGVtZW50LCBjb25maWcpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRhYmxlRWxlbWVudChwcmV2Tm9kZSwgdGFibGVFbGVtZW50LCBjb25maWcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qgc3VwZXJFeHBvcnQgPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyRXhwb3J0O1xuICAgIHJldHVybiB7XG4gICAgICBhZnRlcjogdGFibGVFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKHN1cGVyRXhwb3J0LmFmdGVyKSB7XG4gICAgICAgICAgdGFibGVFbGVtZW50ID0gc3VwZXJFeHBvcnQuYWZ0ZXIodGFibGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSFRNTFRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpICYmIGlzSFRNTEVsZW1lbnQkMSh0YWJsZUVsZW1lbnQpKSB7XG4gICAgICAgICAgdGFibGVFbGVtZW50ID0gdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0hUTUxUYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFsaWduVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgZWRpdG9yLl9jb25maWcsIHRoaXMuZ2V0Rm9ybWF0VHlwZSgpKTtcblxuICAgICAgICAvLyBTY2FuIHRoZSB0YWJsZSBtYXAgdG8gYnVpbGQgYSBtYXAgb2YgdGFibGUgY2VsbCBrZXkgdG8gdGhlIGNvbHVtbnMgaXQgbmVlZHNcbiAgICAgICAgY29uc3QgW3RhYmxlTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRoaXMsIG51bGwsIG51bGwpO1xuICAgICAgICBjb25zdCBjZWxsVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcFJvdyBvZiB0YWJsZU1hcCkge1xuICAgICAgICAgIGZvciAoY29uc3QgbWFwVmFsdWUgb2YgbWFwUm93KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBtYXBWYWx1ZS5jZWxsLmdldEtleSgpO1xuICAgICAgICAgICAgaWYgKCFjZWxsVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIGNlbGxWYWx1ZXMuc2V0KGtleSwge1xuICAgICAgICAgICAgICAgIGNvbFNwYW46IG1hcFZhbHVlLmNlbGwuZ2V0Q29sU3BhbigpLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBtYXBWYWx1ZS5zdGFydENvbHVtblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2FuIHRoZSBET00gdG8gZmluZCB0aGUgdGFibGUgY2VsbCBrZXlzIHRoYXQgd2VyZSB1c2VkIGFuZCBtYXJrIHRob3NlIGNvbHVtbnNcbiAgICAgICAgY29uc3Qga25vd25Db2x1bW5zID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGNlbGxET00gb2YgdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IHRyID4gW2RhdGEtdGVtcG9yYXJ5LXRhYmxlLWNlbGwtbGV4aWNhbC1rZXldJykpIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBjZWxsRE9NLmdldEF0dHJpYnV0ZSgnZGF0YS10ZW1wb3JhcnktdGFibGUtY2VsbC1sZXhpY2FsLWtleScpO1xuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxTcGFuID0gY2VsbFZhbHVlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGNlbGxET00ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRlbXBvcmFyeS10YWJsZS1jZWxsLWxleGljYWwta2V5Jyk7XG4gICAgICAgICAgICBpZiAoY2VsbFNwYW4pIHtcbiAgICAgICAgICAgICAgY2VsbFZhbHVlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsU3Bhbi5jb2xTcGFuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrbm93bkNvbHVtbnMuYWRkKGkgKyBjZWxsU3Bhbi5zdGFydENvbHVtbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2xncm91cCBhbmQgY29sdW1ucyBpbiB0aGUgZXhwb3J0XG4gICAgICAgIGNvbnN0IGNvbEdyb3VwID0gdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJzpzY29wZSA+IGNvbGdyb3VwJyk7XG4gICAgICAgIGlmIChjb2xHcm91cCkge1xuICAgICAgICAgIC8vIE9ubHkgaW5jbHVkZSB0aGUgPGNvbCAvPiBmb3Igcm93cyB0aGF0IGFyZSBpbiB0aGUgb3V0cHV0XG4gICAgICAgICAgY29uc3QgY29scyA9IEFycmF5LmZyb20odGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IGNvbGdyb3VwID4gY29sJykpLmZpbHRlcigoZG9tLCBpKSA9PiBrbm93bkNvbHVtbnMuaGFzKGkpKTtcbiAgICAgICAgICBjb2xHcm91cC5yZXBsYWNlQ2hpbGRyZW4oLi4uY29scyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcmFwIGRpcmVjdCBkZXNjZW5kYW50IHJvd3MgaW4gYSB0Ym9keSBmb3IgZXhwb3J0XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnOnNjb3BlID4gdHInKTtcbiAgICAgICAgaWYgKHJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHRCb2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICB0Qm9keS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWJsZUVsZW1lbnQuYXBwZW5kKHRCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFibGVFbGVtZW50O1xuICAgICAgfSxcbiAgICAgIGVsZW1lbnQ6ICFpc0hUTUxUYWJsZUVsZW1lbnQoZWxlbWVudCkgJiYgaXNIVE1MRWxlbWVudCQxKGVsZW1lbnQpID8gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpIDogZWxlbWVudFxuICAgIH07XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgcm93cyxcbiAgICAgIGRvbVJvd3NcbiAgICB9ID0gdGFibGU7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb3dzOyB5KyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgICBpZiAocm93ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvdy5sZW5ndGg7IHgrKykge1xuICAgICAgICBjb25zdCBjZWxsID0gcm93W3hdO1xuICAgICAgICBpZiAoY2VsbCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGVsZW1cbiAgICAgICAgfSA9IGNlbGw7XG4gICAgICAgIGNvbnN0IGNlbGxOb2RlID0gJGdldE5lYXJlc3RUYWJsZUNlbGxJblRhYmxlRnJvbURPTU5vZGUodGhpcywgZWxlbSk7XG4gICAgICAgIGlmIChjZWxsTm9kZSAhPT0gbnVsbCAmJiB0YWJsZUNlbGxOb2RlLmlzKGNlbGxOb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDZWxsIG5vdCBmb3VuZCBpbiB0YWJsZS4nKTtcbiAgfVxuICBnZXRET01DZWxsRnJvbUNvcmRzKHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZG9tUm93c1xuICAgIH0gPSB0YWJsZTtcbiAgICBjb25zdCByb3cgPSBkb21Sb3dzW3ldO1xuICAgIGlmIChyb3cgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0geCA8IHJvdy5sZW5ndGggPyB4IDogcm93Lmxlbmd0aCAtIDE7XG4gICAgY29uc3QgY2VsbCA9IHJvd1tpbmRleF07XG4gICAgaWYgKGNlbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xuICB9XG4gIGdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0RE9NQ2VsbEZyb21Db3Jkcyh4LCB5LCB0YWJsZSk7XG4gICAgaWYgKCFjZWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlbGwgbm90IGZvdW5kIGF0IGNvcmRzLicpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbiAgfVxuICBnZXRDZWxsTm9kZUZyb21Db3Jkcyh4LCB5LCB0YWJsZSkge1xuICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldERPTUNlbGxGcm9tQ29yZHMoeCwgeSwgdGFibGUpO1xuICAgIGlmIChjZWxsID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoY2VsbC5lbGVtKTtcbiAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5LCB0YWJsZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHksIHRhYmxlKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBhdCBjb3JkcyBub3QgVGFibGVDZWxsTm9kZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZ2V0Um93U3RyaXBpbmcoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRMYXRlc3QoKS5fX3Jvd1N0cmlwaW5nKTtcbiAgfVxuICBzZXRSb3dTdHJpcGluZyhuZXdSb3dTdHJpcGluZykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3Jvd1N0cmlwaW5nID0gbmV3Um93U3RyaXBpbmc7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgc2V0RnJvemVuQ29sdW1ucyhjb2x1bW5Db3VudCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zyb3plbkNvbHVtbkNvdW50ID0gY29sdW1uQ291bnQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0RnJvemVuQ29sdW1ucygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2Zyb3plbkNvbHVtbkNvdW50O1xuICB9XG4gIHNldEZyb3plblJvd3Mocm93Q291bnQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19mcm96ZW5Sb3dDb3VudCA9IHJvd0NvdW50O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldEZyb3plblJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19mcm96ZW5Sb3dDb3VudDtcbiAgfVxuICBjYW5TZWxlY3RCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRDb2x1bW5Db3VudCgpIHtcbiAgICBjb25zdCBmaXJzdFJvdyA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICghZmlyc3RSb3cpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgY29sdW1uQ291bnQgPSAwO1xuICAgIGZpcnN0Um93LmdldENoaWxkcmVuKCkuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGNlbGwpKSB7XG4gICAgICAgIGNvbHVtbkNvdW50ICs9IGNlbGwuZ2V0Q29sU3BhbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb2x1bW5Db3VudDtcbiAgfVxufVxuZnVuY3Rpb24gJGdldEVsZW1lbnRGb3JUYWJsZU5vZGUoZWRpdG9yLCB0YWJsZU5vZGUpIHtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGUuZ2V0S2V5KCkpO1xuICBpZiAoISh0YWJsZUVsZW1lbnQgIT09IG51bGwpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZTogVGFibGUgRWxlbWVudCBOb3QgRm91bmRgKTtcbiAgfVxuICByZXR1cm4gZ2V0VGFibGUodGFibGVOb2RlLCB0YWJsZUVsZW1lbnQpO1xufVxuZnVuY3Rpb24gJGNvbnZlcnRUYWJsZUVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkY3JlYXRlVGFibGVOb2RlKCk7XG4gIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLXJvdy1zdHJpcGluZycpKSB7XG4gICAgdGFibGVOb2RlLnNldFJvd1N0cmlwaW5nKHRydWUpO1xuICB9XG4gIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLWZyb3plbi1jb2x1bW4nKSkge1xuICAgIHRhYmxlTm9kZS5zZXRGcm96ZW5Db2x1bW5zKDEpO1xuICB9XG4gIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLWZyb3plbi1yb3cnKSkge1xuICAgIHRhYmxlTm9kZS5zZXRGcm96ZW5Sb3dzKDEpO1xuICB9XG4gIGNvbnN0IGNvbEdyb3VwID0gZG9tTm9kZS5xdWVyeVNlbGVjdG9yKCc6c2NvcGUgPiBjb2xncm91cCcpO1xuICBpZiAoY29sR3JvdXApIHtcbiAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29sIG9mIGNvbEdyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IGNvbCcpKSB7XG4gICAgICBsZXQgd2lkdGggPSBjb2wuc3R5bGUud2lkdGggfHwgJyc7XG4gICAgICBpZiAoIVBJWEVMX1ZBTFVFX1JFR19FWFAudGVzdCh3aWR0aCkpIHtcbiAgICAgICAgLy8gQWxzbyBzdXBwb3J0IGRlcHJlY2F0ZWQgd2lkdGggYXR0cmlidXRlIGZvciBnb29nbGUgZG9jc1xuICAgICAgICB3aWR0aCA9IGNvbC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgJyc7XG4gICAgICAgIGlmICghL15cXGQrJC8udGVzdCh3aWR0aCkpIHtcbiAgICAgICAgICBjb2x1bW5zID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb2x1bW5zLnB1c2gocGFyc2VGbG9hdCh3aWR0aCkpO1xuICAgIH1cbiAgICBpZiAoY29sdW1ucykge1xuICAgICAgdGFibGVOb2RlLnNldENvbFdpZHRocyhjb2x1bW5zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogY2hpbGRyZW4gPT4gJGRlc2NlbmRhbnRzTWF0Y2hpbmcoY2hpbGRyZW4sICRpc1RhYmxlUm93Tm9kZSksXG4gICAgbm9kZTogdGFibGVOb2RlXG4gIH07XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJsZU5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlTm9kZTtcbn1cblxuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29tbWFuZExpc3RlbmVyKHtcbiAgcm93cyxcbiAgY29sdW1ucyxcbiAgaW5jbHVkZUhlYWRlcnNcbn0pIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpIHx8ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICBpZiAoIXNlbGVjdGlvbiB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFByZXZlbnQgbmVzdGVkIHRhYmxlcyBieSBjaGVja2luZyBpZiB3ZSdyZSBhbHJlYWR5IGluc2lkZSBhIHRhYmxlXG4gIGlmICgkZmluZFRhYmxlTm9kZShzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdGFibGVOb2RlID0gJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zKE51bWJlcihyb3dzKSwgTnVtYmVyKGNvbHVtbnMpLCBpbmNsdWRlSGVhZGVycyk7XG4gICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCh0YWJsZU5vZGUpO1xuICBjb25zdCBmaXJzdERlc2NlbmRhbnQgPSB0YWJsZU5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGlmICgkaXNUZXh0Tm9kZShmaXJzdERlc2NlbmRhbnQpKSB7XG4gICAgZmlyc3REZXNjZW5kYW50LnNlbGVjdCgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJHRhYmxlQ2VsbFRyYW5zZm9ybShub2RlKSB7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKG5vZGUuZ2V0UGFyZW50KCkpKSB7XG4gICAgLy8gVGFibGVDZWxsTm9kZSBtdXN0IGJlIGEgY2hpbGQgb2YgVGFibGVSb3dOb2RlLlxuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH0gZWxzZSBpZiAobm9kZS5pc0VtcHR5KCkpIHtcbiAgICAvLyBUYWJsZUNlbGxOb2RlIHNob3VsZCBuZXZlciBiZSBlbXB0eVxuICAgIG5vZGUuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICB9XG59XG5mdW5jdGlvbiAkdGFibGVSb3dUcmFuc2Zvcm0obm9kZSkge1xuICBpZiAoISRpc1RhYmxlTm9kZShub2RlLmdldFBhcmVudCgpKSkge1xuICAgIC8vIFRhYmxlUm93Tm9kZSBtdXN0IGJlIGEgY2hpbGQgb2YgVGFibGVOb2RlLlxuICAgIC8vIFRPRE86IEZ1dHVyZSBzdXBwb3J0IG9mIHRib2R5L3RoZWFkL3Rmb290IG1heSBjaGFuZ2UgdGhpc1xuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH0gZWxzZSB7XG4gICAgJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzKG5vZGUsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiAkdGFibGVUcmFuc2Zvcm0obm9kZSkge1xuICAvLyBUYWJsZVJvd05vZGUgaXMgdGhlIG9ubHkgdmFsaWQgY2hpbGQgZm9yIFRhYmxlTm9kZVxuICAvLyBUT0RPOiBGdXR1cmUgc3VwcG9ydCBvZiB0Ym9keS90aGVhZC90Zm9vdC9jYXB0aW9uIG1heSBjaGFuZ2UgdGhpc1xuICAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHMobm9kZSwgJGlzVGFibGVSb3dOb2RlKTtcbiAgY29uc3QgW2dyaWRNYXBdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2sobm9kZSwgbnVsbCwgbnVsbCk7XG4gIGNvbnN0IG1heFJvd0xlbmd0aCA9IGdyaWRNYXAucmVkdWNlKChjdXJMZW5ndGgsIHJvdykgPT4ge1xuICAgIHJldHVybiBNYXRoLm1heChjdXJMZW5ndGgsIHJvdy5sZW5ndGgpO1xuICB9LCAwKTtcbiAgY29uc3Qgcm93Tm9kZXMgPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZE1hcC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHJvd05vZGUgPSByb3dOb2Rlc1tpXTtcbiAgICBpZiAoIXJvd05vZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShyb3dOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUYWJsZVBsdWdpbjogRXhwZWN0aW5nIGFsbCBjaGlsZHJlbiBvZiBUYWJsZU5vZGUgdG8gYmUgVGFibGVSb3dOb2RlLCBmb3VuZCAke3Jvd05vZGUuY29uc3RydWN0b3IubmFtZX0gKHR5cGUgJHtyb3dOb2RlLmdldFR5cGUoKX0pYCk7XG4gICAgfVxuICAgIGNvbnN0IHJvd0xlbmd0aCA9IGdyaWRNYXBbaV0ucmVkdWNlKChhY2MsIGNlbGwpID0+IGNlbGwgPyAxICsgYWNjIDogYWNjLCAwKTtcbiAgICBpZiAocm93TGVuZ3RoID09PSBtYXhSb3dMZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gcm93TGVuZ3RoOyBqIDwgbWF4Um93TGVuZ3RoOyArK2opIHtcbiAgICAgIC8vIFRPRE86IGluaGVyaXQgaGVhZGVyIHN0YXRlIGZyb20gYW5vdGhlciBoZWFkZXIgb3IgYm9keVxuICAgICAgY29uc3QgbmV3Q2VsbCA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKCk7XG4gICAgICBuZXdDZWxsLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKTtcbiAgICAgIHJvd05vZGUuYXBwZW5kKG5ld0NlbGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHRhYmxlQ2xpY2tDb21tYW5kKGV2ZW50KSB7XG4gIGlmIChldmVudC5kZXRhaWwgPCAzIHx8ICFpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdGFydE5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShldmVudC50YXJnZXQpO1xuICBpZiAoc3RhcnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoYmxvY2tOb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3ROb2RlID0gYmxvY2tOb2RlLmdldFBhcmVudCgpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUocm9vdE5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGJsb2NrTm9kZS5zZWxlY3QoMCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgdHJhbnNmb3JtIHRvIGVuc3VyZSB0aGF0IGFsbCBUYWJsZUNlbGxOb2RlIGhhdmUgYSBjb2xTcGFuIGFuZCByb3dTcGFuIG9mIDEuXG4gKiBUaGlzIHNob3VsZCBvbmx5IGJlIHJlZ2lzdGVyZWQgd2hlbiB5b3UgZG8gbm90IHdhbnQgdG8gc3VwcG9ydCBtZXJnZWQgY2VsbHMuXG4gKlxuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yXG4gKiBAcmV0dXJucyBBbiB1bnJlZ2lzdGVyIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFibGVDZWxsVW5tZXJnZVRyYW5zZm9ybShlZGl0b3IpIHtcbiAgcmV0dXJuIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGFibGVDZWxsTm9kZSwgbm9kZSA9PiB7XG4gICAgaWYgKG5vZGUuZ2V0Q29sU3BhbigpID4gMSB8fCBub2RlLmdldFJvd1NwYW4oKSA+IDEpIHtcbiAgICAgIC8vIFdoZW4gd2UgaGF2ZSByb3dTcGFuIHdlIGhhdmUgdG8gbWFwIHRoZSBlbnRpcmUgVGFibGUgdG8gdW5kZXJzdGFuZCB3aGVyZSB0aGUgbmV3IENlbGxzXG4gICAgICAvLyBmaXQgYmVzdDsgbGV0J3MgYW5hbHl6ZSBhbGwgQ2VsbHMgYXQgb25jZSB0byBzYXZlIHVzIGZyb20gZnVydGhlciB0cmFuc2Zvcm0gaXRlcmF0aW9uc1xuICAgICAgY29uc3QgWywsIGdyaWROb2RlXSA9ICRnZXROb2RlVHJpcGxldChub2RlKTtcbiAgICAgIGNvbnN0IFtncmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZE5vZGUsIG5vZGUsIG5vZGUpO1xuICAgICAgLy8gVE9ETyB0aGlzIGZ1bmN0aW9uIGV4cGVjdHMgVGFibGVzIHRvIGJlIG5vcm1hbGl6ZWQuIExvb2sgaW50byB0aGlzIG9uY2UgaXQgZXhpc3RzXG4gICAgICBjb25zdCByb3dzQ291bnQgPSBncmlkTWFwLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNvbHVtbnNDb3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICAgICAgbGV0IHJvdyA9IGdyaWROb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZU5vZGUgZmlyc3QgY2hpbGQgdG8gYmUgYSBSb3dOb2RlYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB1bm1lcmdlZCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzQ291bnQ7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgIHJvdyA9IHJvdy5nZXROZXh0U2libGluZygpO1xuICAgICAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGZpcnN0IGNoaWxkIHRvIGJlIGEgUm93Tm9kZWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFzdFJvd0NlbGwgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbnNDb3VudDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgY2VsbE1hcCA9IGdyaWRNYXBbaV1bal07XG4gICAgICAgICAgY29uc3QgY2VsbCA9IGNlbGxNYXAuY2VsbDtcbiAgICAgICAgICBpZiAoY2VsbE1hcC5zdGFydFJvdyA9PT0gaSAmJiBjZWxsTWFwLnN0YXJ0Q29sdW1uID09PSBqKSB7XG4gICAgICAgICAgICBsYXN0Um93Q2VsbCA9IGNlbGw7XG4gICAgICAgICAgICB1bm1lcmdlZC5wdXNoKGNlbGwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2VsbC5nZXRDb2xTcGFuKCkgPiAxIHx8IGNlbGwuZ2V0Um93U3BhbigpID4gMSkge1xuICAgICAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGwpKSB7XG4gICAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGNlbGwgdG8gYmUgYSBUYWJsZUNlbGxOb2RlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdDZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY2VsbC5fX2hlYWRlclN0YXRlKTtcbiAgICAgICAgICAgIGlmIChsYXN0Um93Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0Um93Q2VsbC5pbnNlcnRBZnRlcihuZXdDZWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRpbnNlcnRGaXJzdCQxKHJvdywgbmV3Q2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdW5tZXJnZWQpIHtcbiAgICAgICAgY2VsbC5zZXRDb2xTcGFuKDEpO1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFibGVTZWxlY3Rpb25PYnNlcnZlcihlZGl0b3IsIGhhc1RhYkhhbmRsZXIgPSB0cnVlKSB7XG4gIGNvbnN0IHRhYmxlU2VsZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgaW5pdGlhbGl6ZVRhYmxlTm9kZSA9ICh0YWJsZU5vZGUsIG5vZGVLZXksIGRvbSkgPT4ge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGUsIGRvbSk7XG4gICAgY29uc3QgdGFibGVTZWxlY3Rpb24gPSBhcHBseVRhYmxlSGFuZGxlcnModGFibGVOb2RlLCB0YWJsZUVsZW1lbnQsIGVkaXRvciwgaGFzVGFiSGFuZGxlcik7XG4gICAgdGFibGVTZWxlY3Rpb25zLnNldChub2RlS2V5LCBbdGFibGVTZWxlY3Rpb24sIHRhYmxlRWxlbWVudF0pO1xuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lciA9IGVkaXRvci5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIoVGFibGVOb2RlLCBub2RlTXV0YXRpb25zID0+IHtcbiAgICBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW25vZGVLZXksIG11dGF0aW9uXSBvZiBub2RlTXV0YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlU2VsZWN0aW9uID0gdGFibGVTZWxlY3Rpb25zLmdldChub2RlS2V5KTtcbiAgICAgICAgaWYgKG11dGF0aW9uID09PSAnY3JlYXRlZCcgfHwgbXV0YXRpb24gPT09ICd1cGRhdGVkJykge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhYmxlTm9kZSxcbiAgICAgICAgICAgIHRhYmxlRWxlbWVudFxuICAgICAgICAgIH0gPSAkZ2V0VGFibGVBbmRFbGVtZW50QnlLZXkobm9kZUtleSk7XG4gICAgICAgICAgaWYgKHRhYmxlU2VsZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVUYWJsZU5vZGUodGFibGVOb2RlLCBub2RlS2V5LCB0YWJsZUVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGFibGVFbGVtZW50ICE9PSB0YWJsZVNlbGVjdGlvblsxXSkge1xuICAgICAgICAgICAgLy8gVGhlIHVwZGF0ZSBjcmVhdGVkIGEgbmV3IERPTSBub2RlLCBkZXN0cm95IHRoZSBleGlzdGluZyBUYWJsZU9ic2VydmVyXG4gICAgICAgICAgICB0YWJsZVNlbGVjdGlvblswXS5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRhYmxlU2VsZWN0aW9ucy5kZWxldGUobm9kZUtleSk7XG4gICAgICAgICAgICBpbml0aWFsaXplVGFibGVOb2RlKHRhYmxlTm9kZSwgbm9kZUtleSwgdGFibGVFbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobXV0YXRpb24gPT09ICdkZXN0cm95ZWQnKSB7XG4gICAgICAgICAgaWYgKHRhYmxlU2VsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhYmxlU2VsZWN0aW9uWzBdLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb25zLmRlbGV0ZShub2RlS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBlZGl0b3JcbiAgICB9KTtcbiAgfSwge1xuICAgIHNraXBJbml0aWFsaXphdGlvbjogZmFsc2VcbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdW5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIoKTtcbiAgICAvLyBIb29rIG1pZ2h0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBzbyBjbGVhbmluZyB1cCB0YWJsZXMgbGlzdGVuZXJzIGFzIHdlbGwsXG4gICAgLy8gYXMgaXQnbGwgYmUgcmVpbml0aWFsaXplZCBkdXJpbmcgcmVjdXJyaW5nIGNhbGxcbiAgICBmb3IgKGNvbnN0IFssIFt0YWJsZVNlbGVjdGlvbl1dIG9mIHRhYmxlU2VsZWN0aW9ucykge1xuICAgICAgdGFibGVTZWxlY3Rpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBJTlNFUlRfVEFCTEVfQ09NTUFORCBsaXN0ZW5lciBhbmQgdGhlIHRhYmxlIGludGVncml0eSB0cmFuc2Zvcm1zLiBUaGVcbiAqIHRhYmxlIHNlbGVjdGlvbiBvYnNlcnZlciBzaG91bGQgYmUgcmVnaXN0ZXJlZCBzZXBhcmF0ZWx5IGFmdGVyIHRoaXMgd2l0aFxuICoge0BsaW5rIHJlZ2lzdGVyVGFibGVTZWxlY3Rpb25PYnNlcnZlcn0uXG4gKlxuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yXG4gKiBAcmV0dXJucyBBbiB1bnJlZ2lzdGVyIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFibGVQbHVnaW4oZWRpdG9yKSB7XG4gIGlmICghZWRpdG9yLmhhc05vZGVzKFtUYWJsZU5vZGVdKSkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFibGVQbHVnaW46IFRhYmxlTm9kZSBpcyBub3QgcmVnaXN0ZXJlZCBvbiBlZGl0b3JgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfVEFCTEVfQ09NTUFORCwgJGluc2VydFRhYmxlQ29tbWFuZExpc3RlbmVyLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgKHtcbiAgICBub2RlcyxcbiAgICBzZWxlY3Rpb25cbiAgfSwgZGlzcGF0Y2hFZGl0b3IpID0+IHtcbiAgICBpZiAoZWRpdG9yICE9PSBkaXNwYXRjaEVkaXRvciB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc0luc2lkZVRhYmxlQ2VsbCA9ICRmaW5kVGFibGVOb2RlKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKSAhPT0gbnVsbDtcbiAgICByZXR1cm4gaXNJbnNpZGVUYWJsZUNlbGwgJiYgbm9kZXMuc29tZSgkaXNUYWJsZU5vZGUpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ0xJQ0tfQ09NTUFORCwgJHRhYmxlQ2xpY2tDb21tYW5kLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGFibGVOb2RlLCAkdGFibGVUcmFuc2Zvcm0pLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKFRhYmxlUm93Tm9kZSwgJHRhYmxlUm93VHJhbnNmb3JtKSwgZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShUYWJsZUNlbGxOb2RlLCAkdGFibGVDZWxsVHJhbnNmb3JtKSk7XG59XG5cbmV4cG9ydCB7ICRjb21wdXRlVGFibGVNYXAsICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrLCAkY3JlYXRlVGFibGVDZWxsTm9kZSwgJGNyZWF0ZVRhYmxlTm9kZSwgJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zLCAkY3JlYXRlVGFibGVSb3dOb2RlLCAkY3JlYXRlVGFibGVTZWxlY3Rpb24sICRjcmVhdGVUYWJsZVNlbGVjdGlvbkZyb20sICRkZWxldGVUYWJsZUNvbHVtbiwgJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb24sICRkZWxldGVUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMLCAkZGVsZXRlVGFibGVSb3dBdFNlbGVjdGlvbiwgJGRlbGV0ZVRhYmxlUm93X19FWFBFUklNRU5UQUwsICRmaW5kQ2VsbE5vZGUsICRmaW5kVGFibGVOb2RlLCAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZSwgJGdldE5vZGVUcmlwbGV0LCAkZ2V0VGFibGVBbmRFbGVtZW50QnlLZXksICRnZXRUYWJsZUNlbGxOb2RlRnJvbUxleGljYWxOb2RlLCAkZ2V0VGFibGVDZWxsTm9kZVJlY3QsICRnZXRUYWJsZUNvbHVtbkluZGV4RnJvbVRhYmxlQ2VsbE5vZGUsICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93LCAkZ2V0VGFibGVSb3dJbmRleEZyb21UYWJsZUNlbGxOb2RlLCAkZ2V0VGFibGVSb3dOb2RlRnJvbVRhYmxlQ2VsbE5vZGVPclRocm93LCAkaW5zZXJ0VGFibGVDb2x1bW4sICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9uLCAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCwgJGluc2VydFRhYmxlUm93LCAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbiwgJGluc2VydFRhYmxlUm93X19FWFBFUklNRU5UQUwsICRpc1Njcm9sbGFibGVUYWJsZXNBY3RpdmUsICRpc1RhYmxlQ2VsbE5vZGUsICRpc1RhYmxlTm9kZSwgJGlzVGFibGVSb3dOb2RlLCAkaXNUYWJsZVNlbGVjdGlvbiwgJG1lcmdlQ2VsbHMsICRyZW1vdmVUYWJsZVJvd0F0SW5kZXgsICR1bm1lcmdlQ2VsbCwgSU5TRVJUX1RBQkxFX0NPTU1BTkQsIFRhYmxlQ2VsbEhlYWRlclN0YXRlcywgVGFibGVDZWxsTm9kZSwgVGFibGVOb2RlLCBUYWJsZU9ic2VydmVyLCBUYWJsZVJvd05vZGUsIGFwcGx5VGFibGVIYW5kbGVycywgZ2V0RE9NQ2VsbEZyb21UYXJnZXQsIGdldFRhYmxlRWxlbWVudCwgZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQsIHJlZ2lzdGVyVGFibGVDZWxsVW5tZXJnZVRyYW5zZm9ybSwgcmVnaXN0ZXJUYWJsZVBsdWdpbiwgcmVnaXN0ZXJUYWJsZVNlbGVjdGlvbk9ic2VydmVyLCBzZXRTY3JvbGxhYmxlVGFibGVzQWN0aXZlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lexical/table/LexicalTable.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/text/LexicalText.dev.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@lexical/text/LexicalText.dev.mjs ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $canShowPlaceholder: function() { return /* binding */ $canShowPlaceholder; },\n/* harmony export */   $canShowPlaceholderCurry: function() { return /* binding */ $canShowPlaceholderCurry; },\n/* harmony export */   $findTextIntersectionFromCharacters: function() { return /* binding */ $findTextIntersectionFromCharacters; },\n/* harmony export */   $isRootTextContentEmpty: function() { return /* binding */ $isRootTextContentEmpty; },\n/* harmony export */   $isRootTextContentEmptyCurry: function() { return /* binding */ $isRootTextContentEmptyCurry; },\n/* harmony export */   $rootTextContent: function() { return /* binding */ $rootTextContent; },\n/* harmony export */   registerLexicalTextEntity: function() { return /* binding */ registerLexicalTextEntity; }\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(topBlock)) {\n      return false;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topBlock)) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        formatDevErrorMessage(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStIOztBQUUvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBLFFBQVEseURBQWdCO0FBQ3hCO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCLFdBQVcseURBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNsRDtBQUNBLGFBQWEsb0RBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsb0RBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixvREFBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsNkNBQVE7QUFDeEU7QUFDQTtBQUNBOztBQUVrTSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYubWpzP2ZiNzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkZ2V0Um9vdCwgJGlzRGVjb3JhdG9yTm9kZSwgJGlzRWxlbWVudE5vZGUsICRpc1BhcmFncmFwaE5vZGUsICRpc1RleHROb2RlLCBUZXh0Tm9kZSwgJGNyZWF0ZVRleHROb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByb290J3MgdGV4dCBjb250ZW50LlxuICogQHJldHVybnMgVGhlIHJvb3QncyB0ZXh0IGNvbnRlbnQuXG4gKi9cbmZ1bmN0aW9uICRyb290VGV4dENvbnRlbnQoKSB7XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICByZXR1cm4gcm9vdC5nZXRUZXh0Q29udGVudCgpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgcm9vdCBoYXMgYW55IHRleHQgY29udGVudCBhbmQgY2FuIHRyaW0gYW55IHdoaXRlc3BhY2UgaWYgaXQgZG9lcy5cbiAqIEBwYXJhbSBpc0VkaXRvckNvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcGFyYW0gdHJpbSAtIFNob3VsZCB0aGUgcm9vdCB0ZXh0IGhhdmUgaXRzIHdoaXRlc3BhY2VkIHRyaW1tZWQ/IERlZmF1bHRzIHRvIHRydWUuXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRleHQgY29udGVudCBpcyBlbXB0eSwgZmFsc2UgaWYgdGhlcmUgaXMgdGV4dCBvciBpc0VkaXRvckNvbXBvc2luZyBpcyB0cnVlLlxuICovXG5mdW5jdGlvbiAkaXNSb290VGV4dENvbnRlbnRFbXB0eShpc0VkaXRvckNvbXBvc2luZywgdHJpbSA9IHRydWUpIHtcbiAgaWYgKGlzRWRpdG9yQ29tcG9zaW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCB0ZXh0ID0gJHJvb3RUZXh0Q29udGVudCgpO1xuICBpZiAodHJpbSkge1xuICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgfVxuICByZXR1cm4gdGV4dCA9PT0gJyc7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMge0BsaW5rICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5fVxuICogQHBhcmFtIGlzRWRpdG9yQ29tcG9zaW5nIC0gSXMgdGhlIGVkaXRvciBpbiBjb21wb3NpdGlvbiBtb2RlIGR1ZSB0byBhbiBhY3RpdmUgSW5wdXQgTWV0aG9kIEVkaXRvcj9cbiAqIEBwYXJhbSB0cmltIC0gU2hvdWxkIHRoZSByb290IHRleHQgaGF2ZSBpdHMgd2hpdGVzcGFjZWQgdHJpbW1lZD8gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyAkaXNSb290VGV4dENvbnRlbnRFbXB0eSBiYXNlZCBvbiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5Q3VycnkoaXNFZGl0b3JDb21wb3NpbmcsIHRyaW0pIHtcbiAgcmV0dXJuICgpID0+ICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5KGlzRWRpdG9yQ29tcG9zaW5nLCB0cmltKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGlucHV0IHNob3VsZCBzaG93IHRoZSBwbGFjZWhvbGRlci4gSWYgYW55dGhpbmcgaXMgaW5cbiAqIGluIHRoZSByb290IHRoZSBwbGFjZWhvbGRlciBzaG91bGQgbm90IGJlIHNob3duLlxuICogQHBhcmFtIGlzQ29tcG9zaW5nIC0gSXMgdGhlIGVkaXRvciBpbiBjb21wb3NpdGlvbiBtb2RlIGR1ZSB0byBhbiBhY3RpdmUgSW5wdXQgTWV0aG9kIEVkaXRvcj9cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IHNob3VsZCBzaG93IHRoZSBwbGFjZWhvbGRlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkY2FuU2hvd1BsYWNlaG9sZGVyKGlzQ29tcG9zaW5nKSB7XG4gIGlmICghJGlzUm9vdFRleHRDb250ZW50RW1wdHkoaXNDb21wb3NpbmcsIGZhbHNlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgY29uc3QgY2hpbGRyZW4gPSByb290LmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRvcEJsb2NrID0gY2hpbGRyZW5baV07XG4gICAgaWYgKCRpc0RlY29yYXRvck5vZGUodG9wQmxvY2spKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNFbGVtZW50Tm9kZSh0b3BCbG9jaykpIHtcbiAgICAgIGlmICghJGlzUGFyYWdyYXBoTm9kZSh0b3BCbG9jaykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRvcEJsb2NrLl9faW5kZW50ICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvcEJsb2NrQ2hpbGRyZW4gPSB0b3BCbG9jay5nZXRDaGlsZHJlbigpO1xuICAgICAgY29uc3QgdG9wQmxvY2tDaGlsZHJlbkxlbmd0aCA9IHRvcEJsb2NrQ2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0b3BCbG9ja0NoaWxkcmVuTGVuZ3RoOyBzKyspIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSB0b3BCbG9ja0NoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoISRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBleGVjdXRlcyB7QGxpbmsgJGNhblNob3dQbGFjZWhvbGRlcn1cbiAqIEBwYXJhbSBpc0VkaXRvckNvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgJGNhblNob3dQbGFjZWhvbGRlciB3aXRoIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5KGlzRWRpdG9yQ29tcG9zaW5nKSB7XG4gIHJldHVybiAoKSA9PiAkY2FuU2hvd1BsYWNlaG9sZGVyKGlzRWRpdG9yQ29tcG9zaW5nKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIEZpbmRzIGEgVGV4dE5vZGUgd2l0aCBhIHNpemUgbGFyZ2VyIHRoYW4gdGFyZ2V0Q2hhcmFjdGVycyBhbmQgcmV0dXJuc1xuICogdGhlIG5vZGUgYWxvbmcgd2l0aCB0aGUgcmVtYWluaW5nIGxlbmd0aCBvZiB0aGUgdGV4dC5cbiAqIEBwYXJhbSByb290IC0gVGhlIFJvb3ROb2RlLlxuICogQHBhcmFtIHRhcmdldENoYXJhY3RlcnMgLSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgd2hvc2UgVGV4dE5vZGUgbXVzdCBiZSBsYXJnZXIgdGhhbi5cbiAqIEByZXR1cm5zIFRoZSBUZXh0Tm9kZSBhbmQgdGhlIGludGVyc2VjdGlvbnMgb2Zmc2V0LCBvciBudWxsIGlmIG5vIFRleHROb2RlIGlzIGZvdW5kLlxuICovXG5mdW5jdGlvbiAkZmluZFRleHRJbnRlcnNlY3Rpb25Gcm9tQ2hhcmFjdGVycyhyb290LCB0YXJnZXRDaGFyYWN0ZXJzKSB7XG4gIGxldCBub2RlID0gcm9vdC5nZXRGaXJzdENoaWxkKCk7XG4gIGxldCBjdXJyZW50Q2hhcmFjdGVycyA9IDA7XG4gIG1haW5Mb29wOiB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoYXJhY3RlcnMgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgaWYgKGN1cnJlbnRDaGFyYWN0ZXJzICsgY2hhcmFjdGVycyA+IHRhcmdldENoYXJhY3RlcnMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIG9mZnNldDogdGFyZ2V0Q2hhcmFjdGVycyAtIGN1cnJlbnRDaGFyYWN0ZXJzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjdXJyZW50Q2hhcmFjdGVycyArPSBjaGFyYWN0ZXJzO1xuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBub2RlID0gc2libGluZztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAocGFyZW50U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gcGFyZW50U2libGluZztcbiAgICAgICAgY29udGludWUgbWFpbkxvb3A7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHR1cGxlIHRoYXQgY2FuIGJlIHJlc3RlZCAoLi4uKSBpbnRvIG1lcmdlUmVnaXN0ZXIgdG8gY2xlYW4gdXBcbiAqIG5vZGUgdHJhbnNmb3JtcyBsaXN0ZW5lcnMgdGhhdCB0cmFuc2Zvcm1zIHRleHQgaW50byBhbm90aGVyIG5vZGUsIGVnLiBhIEhhc2h0YWdOb2RlLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoXG4gICAgICAuLi5yZWdpc3RlckxleGljYWxUZXh0RW50aXR5KGVkaXRvciwgZ2V0TWF0Y2gsIHRhcmdldE5vZGUsIGNyZWF0ZU5vZGUpLFxuICAgICk7XG4gIH0sIFtjcmVhdGVOb2RlLCBlZGl0b3IsIGdldE1hdGNoLCB0YXJnZXROb2RlXSk7XG4gKiBgYGBcbiAqIFdoZXJlIHRhcmdldE5vZGUgaXMgdGhlIHR5cGUgb2Ygbm9kZSBjb250YWluaW5nIHRoZSB0ZXh0IHlvdSB3YW50IHRvIHRyYW5zZm9ybSAobGlrZSBhIHRleHQgaW5wdXQpLFxuICogdGhlbiBnZXRNYXRjaCB1c2VzIGEgcmVnZXggdG8gZmluZCBhIG1hdGNoaW5nIHRleHQgYW5kIGNyZWF0ZXMgdGhlIHByb3BlciBub2RlIHRvIGluY2x1ZGUgdGhlIG1hdGNoaW5nIHRleHQuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGdldE1hdGNoIC0gRmluZHMgYSBtYXRjaGluZyBzdHJpbmcgdGhhdCBzYXRpc2ZpZXMgYSByZWdleCBleHByZXNzaW9uLlxuICogQHBhcmFtIHRhcmdldE5vZGUgLSBUaGUgbm9kZSB0eXBlIHRoYXQgY29udGFpbnMgdGV4dCB0byBtYXRjaCB3aXRoLiBlZy4gSGFzaHRhZ05vZGVcbiAqIEBwYXJhbSBjcmVhdGVOb2RlIC0gQSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgbm9kZSB0byBjb250YWluIHRoZSBtYXRjaGVkIHRleHQuIGVnIGNyZWF0ZUhhc2h0YWdOb2RlXG4gKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIHRoZSBwbGFpbiB0ZXh0IGFuZCByZXZlcnNlIG5vZGUgdHJhbnNmb3JtIGxpc3RlbmVycy5cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eShlZGl0b3IsIGdldE1hdGNoLCB0YXJnZXROb2RlLCBjcmVhdGVOb2RlKSB7XG4gIGNvbnN0IGlzVGFyZ2V0Tm9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgdGFyZ2V0Tm9kZTtcbiAgfTtcbiAgY29uc3QgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dCA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKG5vZGUuZ2V0VGV4dENvbnRlbnQoKSk7XG4gICAgdGV4dE5vZGUuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0KCkpO1xuICAgIG5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gIH07XG4gIGNvbnN0IGdldE1vZGUgPSBub2RlID0+IHtcbiAgICByZXR1cm4gbm9kZS5nZXRMYXRlc3QoKS5fX21vZGU7XG4gIH07XG4gIGNvbnN0ICR0ZXh0Tm9kZVRyYW5zZm9ybSA9IG5vZGUgPT4ge1xuICAgIGlmICghbm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcHJldlNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGxldCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgbGV0IG1hdGNoO1xuICAgIGlmICgkaXNUZXh0Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVGV4dCA9IHByZXZTaWJsaW5nLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCBjb21iaW5lZFRleHQgPSBwcmV2aW91c1RleHQgKyB0ZXh0O1xuICAgICAgY29uc3QgcHJldk1hdGNoID0gZ2V0TWF0Y2goY29tYmluZWRUZXh0KTtcbiAgICAgIGlmIChpc1RhcmdldE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICAgIGlmIChwcmV2TWF0Y2ggPT09IG51bGwgfHwgZ2V0TW9kZShwcmV2U2libGluZykgIT09IDApIHtcbiAgICAgICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KHByZXZTaWJsaW5nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IHByZXZNYXRjaC5lbmQgLSBwcmV2aW91c1RleHQubGVuZ3RoO1xuICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgY29uc3QgY29uY2F0VGV4dCA9IHRleHQuc2xpY2UoMCwgZGlmZik7XG4gICAgICAgICAgICBjb25zdCBuZXdUZXh0Q29udGVudCA9IHByZXZpb3VzVGV4dCArIGNvbmNhdFRleHQ7XG4gICAgICAgICAgICBwcmV2U2libGluZy5zZWxlY3QoKTtcbiAgICAgICAgICAgIHByZXZTaWJsaW5nLnNldFRleHRDb250ZW50KG5ld1RleHRDb250ZW50KTtcbiAgICAgICAgICAgIGlmIChkaWZmID09PSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nVGV4dCA9IHRleHQuc2xpY2UoZGlmZik7XG4gICAgICAgICAgICAgIG5vZGUuc2V0VGV4dENvbnRlbnQocmVtYWluaW5nVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZNYXRjaCA9PT0gbnVsbCB8fCBwcmV2TWF0Y2guc3RhcnQgPCBwcmV2aW91c1RleHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHByZXZNYXRjaExlbmd0aFRvU2tpcCA9IDA7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBtYXRjaCA9IGdldE1hdGNoKHRleHQpO1xuICAgICAgbGV0IG5leHRUZXh0ID0gbWF0Y2ggPT09IG51bGwgPyAnJyA6IHRleHQuc2xpY2UobWF0Y2guZW5kKTtcbiAgICAgIHRleHQgPSBuZXh0VGV4dDtcbiAgICAgIGlmIChuZXh0VGV4dCA9PT0gJycpIHtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBjdXJyZW50Tm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgbmV4dFRleHQgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpICsgbmV4dFNpYmxpbmcuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgICAgICBjb25zdCBuZXh0TWF0Y2ggPSBnZXRNYXRjaChuZXh0VGV4dCk7XG4gICAgICAgICAgaWYgKG5leHRNYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlzVGFyZ2V0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgICAgICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChuZXh0U2libGluZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXh0U2libGluZy5tYXJrRGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHRNYXRjaC5zdGFydCAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaC5zdGFydCA9PT0gMCAmJiAkaXNUZXh0Tm9kZShwcmV2U2libGluZykgJiYgcHJldlNpYmxpbmcuaXNUZXh0RW50aXR5KCkpIHtcbiAgICAgICAgcHJldk1hdGNoTGVuZ3RoVG9Ta2lwICs9IG1hdGNoLmVuZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgbm9kZVRvUmVwbGFjZTtcbiAgICAgIGlmIChtYXRjaC5zdGFydCA9PT0gMCkge1xuICAgICAgICBbbm9kZVRvUmVwbGFjZSwgY3VycmVudE5vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KG1hdGNoLmVuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBbLCBub2RlVG9SZXBsYWNlLCBjdXJyZW50Tm9kZV0gPSBjdXJyZW50Tm9kZS5zcGxpdFRleHQobWF0Y2guc3RhcnQgKyBwcmV2TWF0Y2hMZW5ndGhUb1NraXAsIG1hdGNoLmVuZCArIHByZXZNYXRjaExlbmd0aFRvU2tpcCk7XG4gICAgICB9XG4gICAgICBpZiAoIShub2RlVG9SZXBsYWNlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJHsnbm9kZVRvUmVwbGFjZSd9IHNob3VsZCBub3QgYmUgdW5kZWZpbmVkLiBZb3UgbWF5IHdhbnQgdG8gY2hlY2sgc3BsaXRPZmZzZXRzIHBhc3NlZCB0byB0aGUgc3BsaXRUZXh0LmApO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVwbGFjZW1lbnROb2RlID0gY3JlYXRlTm9kZShub2RlVG9SZXBsYWNlKTtcbiAgICAgIHJlcGxhY2VtZW50Tm9kZS5zZXRGb3JtYXQobm9kZVRvUmVwbGFjZS5nZXRGb3JtYXQoKSk7XG4gICAgICBub2RlVG9SZXBsYWNlLnJlcGxhY2UocmVwbGFjZW1lbnROb2RlKTtcbiAgICAgIGlmIChjdXJyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHByZXZNYXRjaExlbmd0aFRvU2tpcCA9IDA7XG4gICAgICBwcmV2U2libGluZyA9IHJlcGxhY2VtZW50Tm9kZTtcbiAgICB9XG4gIH07XG4gIGNvbnN0ICRyZXZlcnNlTm9kZVRyYW5zZm9ybSA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgY29uc3QgbWF0Y2ggPSBnZXRNYXRjaCh0ZXh0KTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwgfHwgbWF0Y2guc3RhcnQgIT09IDApIHtcbiAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0ZXh0Lmxlbmd0aCA+IG1hdGNoLmVuZCkge1xuICAgICAgLy8gVGhpcyB3aWxsIHNwbGl0IG91dCB0aGUgcmVzdCBvZiB0aGUgdGV4dCBhcyBzaW1wbGUgdGV4dFxuICAgICAgbm9kZS5zcGxpdFRleHQobWF0Y2guZW5kKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJldlNpYmxpbmcgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShwcmV2U2libGluZykgJiYgcHJldlNpYmxpbmcuaXNUZXh0RW50aXR5KCkpIHtcbiAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQocHJldlNpYmxpbmcpO1xuICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChub2RlKTtcbiAgICB9XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKCRpc1RleHROb2RlKG5leHRTaWJsaW5nKSAmJiBuZXh0U2libGluZy5pc1RleHRFbnRpdHkoKSkge1xuICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChuZXh0U2libGluZyk7XG5cbiAgICAgIC8vIFRoaXMgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCBpbiB0aGUgcHJldmlvdXMgYmxvY2tcbiAgICAgIGlmIChpc1RhcmdldE5vZGUobm9kZSkpIHtcbiAgICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHJlbW92ZVBsYWluVGV4dFRyYW5zZm9ybSA9IGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGV4dE5vZGUsICR0ZXh0Tm9kZVRyYW5zZm9ybSk7XG4gIGNvbnN0IHJlbW92ZVJldmVyc2VOb2RlVHJhbnNmb3JtID0gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybSh0YXJnZXROb2RlLCAkcmV2ZXJzZU5vZGVUcmFuc2Zvcm0pO1xuICByZXR1cm4gW3JlbW92ZVBsYWluVGV4dFRyYW5zZm9ybSwgcmVtb3ZlUmV2ZXJzZU5vZGVUcmFuc2Zvcm1dO1xufVxuXG5leHBvcnQgeyAkY2FuU2hvd1BsYWNlaG9sZGVyLCAkY2FuU2hvd1BsYWNlaG9sZGVyQ3VycnksICRmaW5kVGV4dEludGVyc2VjdGlvbkZyb21DaGFyYWN0ZXJzLCAkaXNSb290VGV4dENvbnRlbnRFbXB0eSwgJGlzUm9vdFRleHRDb250ZW50RW1wdHlDdXJyeSwgJHJvb3RUZXh0Q29udGVudCwgcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@lexical/text/LexicalText.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!**********************************************************!*\
  !*** ./node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $descendantsMatching: function() { return /* binding */ $descendantsMatching; },\n/* harmony export */   $dfs: function() { return /* binding */ $dfs; },\n/* harmony export */   $dfsIterator: function() { return /* binding */ $dfsIterator; },\n/* harmony export */   $filter: function() { return /* binding */ $filter; },\n/* harmony export */   $findMatchingParent: function() { return /* binding */ $findMatchingParent; },\n/* harmony export */   $firstToLastIterator: function() { return /* binding */ $firstToLastIterator; },\n/* harmony export */   $getAdjacentCaret: function() { return /* binding */ $getAdjacentCaret; },\n/* harmony export */   $getAdjacentSiblingOrParentSiblingCaret: function() { return /* binding */ $getAdjacentSiblingOrParentSiblingCaret; },\n/* harmony export */   $getDepth: function() { return /* binding */ $getDepth; },\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: function() { return /* binding */ $getNearestBlockElementAncestorOrThrow; },\n/* harmony export */   $getNearestNodeOfType: function() { return /* binding */ $getNearestNodeOfType; },\n/* harmony export */   $getNextRightPreorderNode: function() { return /* binding */ $getNextRightPreorderNode; },\n/* harmony export */   $getNextSiblingOrParentSibling: function() { return /* binding */ $getNextSiblingOrParentSibling; },\n/* harmony export */   $insertFirst: function() { return /* binding */ $insertFirst; },\n/* harmony export */   $insertNodeToNearestRoot: function() { return /* binding */ $insertNodeToNearestRoot; },\n/* harmony export */   $insertNodeToNearestRootAtCaret: function() { return /* binding */ $insertNodeToNearestRootAtCaret; },\n/* harmony export */   $isEditorIsNestedEditor: function() { return /* binding */ $isEditorIsNestedEditor; },\n/* harmony export */   $lastToFirstIterator: function() { return /* binding */ $lastToFirstIterator; },\n/* harmony export */   $restoreEditorState: function() { return /* binding */ $restoreEditorState; },\n/* harmony export */   $reverseDfs: function() { return /* binding */ $reverseDfs; },\n/* harmony export */   $reverseDfsIterator: function() { return /* binding */ $reverseDfsIterator; },\n/* harmony export */   $splitNode: function() { return /* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode; },\n/* harmony export */   $unwrapAndFilterDescendants: function() { return /* binding */ $unwrapAndFilterDescendants; },\n/* harmony export */   $unwrapNode: function() { return /* binding */ $unwrapNode; },\n/* harmony export */   $wrapNodeInElement: function() { return /* binding */ $wrapNodeInElement; },\n/* harmony export */   CAN_USE_BEFORE_INPUT: function() { return /* binding */ CAN_USE_BEFORE_INPUT; },\n/* harmony export */   CAN_USE_DOM: function() { return /* binding */ CAN_USE_DOM; },\n/* harmony export */   IS_ANDROID: function() { return /* binding */ IS_ANDROID; },\n/* harmony export */   IS_ANDROID_CHROME: function() { return /* binding */ IS_ANDROID_CHROME; },\n/* harmony export */   IS_APPLE: function() { return /* binding */ IS_APPLE; },\n/* harmony export */   IS_APPLE_WEBKIT: function() { return /* binding */ IS_APPLE_WEBKIT; },\n/* harmony export */   IS_CHROME: function() { return /* binding */ IS_CHROME; },\n/* harmony export */   IS_FIREFOX: function() { return /* binding */ IS_FIREFOX; },\n/* harmony export */   IS_IOS: function() { return /* binding */ IS_IOS; },\n/* harmony export */   IS_SAFARI: function() { return /* binding */ IS_SAFARI; },\n/* harmony export */   addClassNamesToElement: function() { return /* binding */ addClassNamesToElement; },\n/* harmony export */   calculateZoomLevel: function() { return /* binding */ calculateZoomLevel; },\n/* harmony export */   isBlockDomNode: function() { return /* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode; },\n/* harmony export */   isHTMLAnchorElement: function() { return /* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement; },\n/* harmony export */   isHTMLElement: function() { return /* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement; },\n/* harmony export */   isInlineDomNode: function() { return /* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode; },\n/* harmony export */   isMimeType: function() { return /* binding */ isMimeType; },\n/* harmony export */   makeStateWrapper: function() { return /* binding */ makeStateWrapper; },\n/* harmony export */   markSelection: function() { return /* binding */ markSelection; },\n/* harmony export */   mediaFileReader: function() { return /* binding */ mediaFileReader; },\n/* harmony export */   mergeRegister: function() { return /* binding */ mergeRegister; },\n/* harmony export */   objectKlassEquals: function() { return /* binding */ objectKlassEquals; },\n/* harmony export */   positionNodeOnRange: function() { return /* binding */ mlcPositionNodeOnRange; },\n/* harmony export */   registerNestedElementResolver: function() { return /* binding */ registerNestedElementResolver; },\n/* harmony export */   removeClassNamesFromElement: function() { return /* binding */ removeClassNamesFromElement; },\n/* harmony export */   selectionAlwaysOnDisplay: function() { return /* binding */ selectionAlwaysOnDisplay; }\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"./node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"./node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't necessarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $getOrderedSelectionPoints(selection) {\n  const points = selection.getStartEndPoints();\n  return selection.isBackward() ? [points[1], points[0]] : points;\n}\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const textDOM = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMTextNode)(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, start, startNode, startDOM, end, endNode, endDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  range.setStart(...rangeTargetFromPoint(start, startNode, startDOM));\n  range.setEnd(...rangeTargetFromPoint(end, endNode, endDOM));\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const [start, end] = $getOrderedSelectionPoints(selection);\n      const currentStartNode = start.getNode();\n      const currentStartNodeKey = currentStartNode.getKey();\n      const currentStartOffset = start.offset;\n      const currentEndNode = end.getNode();\n      const currentEndNodeKey = currentEndNode.getKey();\n      const currentEndOffset = end.offset;\n      const currentStartNodeDOM = editor.getElementByKey(currentStartNodeKey);\n      const currentEndNodeDOM = editor.getElementByKey(currentEndNodeKey);\n      const differentStartDOM = previousAnchorNode === null || currentStartNodeDOM !== previousAnchorNodeDOM || currentStartOffset !== previousAnchorOffset || currentStartNodeKey !== previousAnchorNode.getKey();\n      const differentEndDOM = previousFocusNode === null || currentEndNodeDOM !== previousFocusNodeDOM || currentEndOffset !== previousFocusOffset || currentEndNodeKey !== previousFocusNode.getKey();\n      if ((differentStartDOM || differentEndDOM) && currentStartNodeDOM !== null && currentEndNodeDOM !== null) {\n        const range = rangeFromPoints(editor, start, currentStartNode, currentStartNodeDOM, end, currentEndNode, currentEndNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentStartNode;\n      previousAnchorNodeDOM = currentStartNodeDOM;\n      previousAnchorOffset = currentStartOffset;\n      previousFocusNode = currentEndNode;\n      previousFocusNodeDOM = currentEndNodeDOM;\n      previousFocusOffset = currentEndOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\n\n/**\n * Get the adjacent caret in the same direction\n *\n * @param caret A caret or null\n * @returns `caret.getAdjacentCaret()` or `null`\n */\nfunction $getAdjacentCaret(caret) {\n  return caret ? caret.getAdjacentCaret() : null;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfs(startNode, endNode) {\n  return Array.from($reverseDfsIterator(startNode, endNode));\n}\n\n/**\n * $dfs iterator (left to right). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('next', startNode, endNode);\n}\nfunction $getEndCaret(startNode, direction) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(startNode, direction));\n  return rval && rval[0];\n}\nfunction $dfsCaretIterator(direction, startNode, endNode) {\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const start = startNode || root;\n  const startCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(start) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(start, direction) : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(start, direction);\n  const startDepth = $getDepth(start);\n  const endCaret = endNode ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaretOrSelf)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(endNode, direction))) : $getEndCaret(start, direction);\n  let depth = startDepth;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.makeStepwiseIterator)({\n    hasNext: state => state !== null,\n    initial: startCaret,\n    map: state => ({\n      depth,\n      node: state.origin\n    }),\n    step: state => {\n      if (state.isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(state)) {\n        depth++;\n      }\n      const rval = $getAdjacentSiblingOrParentSiblingCaret(state);\n      if (!rval || rval[0].isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      depth += rval[1];\n      return rval[0];\n    }\n  });\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node, 'next'));\n  return rval && [rval[0].origin, rval[1]];\n}\nfunction $getDepth(node) {\n  let depth = -1;\n  for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to parent and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  const startCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaretOrSelf)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(startingNode, 'previous'));\n  const next = $getAdjacentSiblingOrParentSiblingCaret(startCaret, 'root');\n  return next && next[0].origin;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('previous', startNode, endNode);\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      formatDevErrorMessage(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  let initialCaret;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    initialCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, 'next');\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      const lastNode = nodes[nodes.length - 1];\n      if (lastNode) {\n        initialCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(lastNode, 'next');\n      }\n    }\n    initialCaret = initialCaret || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)(), 'previous').getFlipped().insert((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n  const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);\n  const adjacent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(insertCaret);\n  const selectionCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(adjacent) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(adjacent) : insertCaret;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelectionFromCaretRange)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCollapsedCaretRange)(selectionCaret));\n  return node.getLatest();\n}\n\n/**\n * If the insertion caret is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be inserted there, otherwise the parent nodes will be split according to the\n * given options.\n * @param node - The node to be inserted\n * @param caret - The location to insert or split from\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRootAtCaret(node, caret, options) {\n  let insertCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCaretInDirection)(caret, 'next');\n  for (let nextCaret = insertCaret; nextCaret; nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitAtPointCaretNext)(nextCaret, options)) {\n    insertCaret = nextCaret;\n  }\n  if (!!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextPointCaret)(insertCaret)) {\n    formatDevErrorMessage(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);\n  }\n  insertCaret.insert(node.isInline() ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().append(node) : node);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCaretInDirection)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node.getLatest(), 'next'), caret.direction);\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframes)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(parent, 'next').insert(node);\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || (child => node.insertAfter(child)));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = Array.from(children).reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return $childIterator((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(node, 'next'));\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return $childIterator((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(node, 'previous'));\n}\nfunction $childIterator(startCaret) {\n  const seen = new Set() ;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.makeStepwiseIterator)({\n    hasNext: lexical__WEBPACK_IMPORTED_MODULE_0__.$isSiblingCaret,\n    initial: startCaret.getAdjacentCaret(),\n    map: caret => {\n      const origin = caret.origin.getLatest();\n      if (seen !== null) {\n        const key = origin.getKey();\n        if (!!seen.has(key)) {\n          formatDevErrorMessage(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      return origin;\n    },\n    step: caret => caret.getAdjacentCaret()\n  });\n}\n\n/**\n * Replace this node with its children\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$rewindSiblingCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node, 'next')).splice(1, node.getChildren());\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = 'root') {\n  let depthDiff = 0;\n  let caret = startCaret;\n  let nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(caret);\n  while (nextCaret === null) {\n    depthDiff--;\n    nextCaret = caret.getParentCaret(rootMode);\n    if (!nextCaret) {\n      return null;\n    }\n    caret = nextCaret;\n    nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(caret);\n  }\n  return nextCaret && [nextCaret, depthDiff];\n}\n\n/**\n * A wrapper that creates bound functions and methods for the\n * StateConfig to save some boilerplate when defining methods\n * or exporting only the accessors from your modules rather\n * than exposing the StateConfig directly.\n */\n\n/**\n * EXPERIMENTAL\n *\n * A convenience interface for working with {@link $getState} and\n * {@link $setState}.\n *\n * @param stateConfig The stateConfig to wrap with convenience functionality\n * @returns a StateWrapper\n */\nfunction makeStateWrapper(stateConfig) {\n  const $get = node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getState)(node, stateConfig);\n  const $set = (node, valueOrUpdater) => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setState)(node, stateConfig, valueOrUpdater);\n  return {\n    $get,\n    $set,\n    accessors: [$get, $set],\n    makeGetterMethod: () => function $getter() {\n      return $get(this);\n    },\n    makeSetterMethod: () => function $setter(valueOrUpdater) {\n      return $set(this, valueOrUpdater);\n    },\n    stateConfig\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxleGljYWwvdXRpbHMvTGV4aWNhbFV0aWxzLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZ2hCO0FBQ3RhO0FBQzdDOztBQUU3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQiwyRUFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzREFBYTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHVEQUFjO0FBQzlDLG9CQUFvQix1REFBYztBQUNsQztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNEQUFhO0FBQ3JDLFdBQVcsMERBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvQ0FBb0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx5REFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpREFBUTtBQUN2QjtBQUNBLHFCQUFxQix1REFBYyxVQUFVLHVEQUFjLHFCQUFxQix5REFBZ0I7QUFDaEc7QUFDQSw2QkFBNkIsK0RBQXNCLENBQUMsNkRBQW9CLENBQUMseURBQWdCO0FBQ3pGO0FBQ0EsU0FBUyw2REFBb0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0RBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx5REFBZ0I7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsb0JBQW9CO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw2REFBb0IsQ0FBQyx5REFBZ0I7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCx1REFBYztBQUN6RSxPQUFPLHVEQUFjO0FBQ3JCO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZEQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNEQUFhO0FBQ2Y7O0FBRUE7QUFDQSxxRUFBcUUsa0NBQWtDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFhLE1BQU0sOERBQXFCO0FBQzVEO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkIsbUJBQW1CLHdEQUFlO0FBQ2xDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5REFBZ0I7QUFDdkM7QUFDQTtBQUNBLG1DQUFtQyx1REFBYyxDQUFDLGlEQUFRLG9DQUFvQyw2REFBb0I7QUFDbEg7QUFDQTtBQUNBLG1CQUFtQiwrREFBc0I7QUFDekMseUJBQXlCLHNEQUFhLGFBQWEsd0RBQWU7QUFDbEUsRUFBRSxvRUFBMkIsQ0FBQyxnRUFBdUI7QUFDckQ7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RCxrQ0FBa0M7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkRBQW9CO0FBQ3hDLG9DQUFvQyxXQUFXLFlBQVksK0RBQXNCO0FBQ2pGO0FBQ0E7QUFDQSxRQUFRLDBEQUFpQjtBQUN6QjtBQUNBO0FBQ0EsdUNBQXVDLDZEQUFvQjtBQUMzRCxTQUFTLDZEQUFvQixDQUFDLHlEQUFnQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHVEQUFjO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZLGNBQWMsY0FBYztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsa0NBQWtDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MscUJBQXFCO0FBQ3JEO0FBQ0E7QUFDQSxNQUFNLFNBQVMsdURBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFjO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1REFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQSxTQUFTLDZEQUFvQjtBQUM3QixhQUFhLG9EQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRixhQUFhO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsNERBQW1CLENBQUMseURBQWdCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFzQjtBQUN0QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQsSUFBSSxnQkFBZ0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrREFBUztBQUNoQyx5Q0FBeUMsa0RBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUU4NkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3V0aWxzL0xleGljYWxVdGlscy5kZXYubWpzPzhhYTMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzRWxlbWVudE5vZGUsIGdldERPTVRleHROb2RlLCAkZ2V0Um9vdCwgJGdldENoaWxkQ2FyZXQsICRnZXRTaWJsaW5nQ2FyZXQsICRnZXRBZGphY2VudENoaWxkQ2FyZXQsICRnZXRDaGlsZENhcmV0T3JTZWxmLCBtYWtlU3RlcHdpc2VJdGVyYXRvciwgJGlzQ2hpbGRDYXJldCwgJGNsb25lV2l0aFByb3BlcnRpZXMsICRzZXRTZWxlY3Rpb24sICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGNhcmV0RnJvbVBvaW50LCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJG5vcm1hbGl6ZUNhcmV0LCAkc2V0U2VsZWN0aW9uRnJvbUNhcmV0UmFuZ2UsICRnZXRDb2xsYXBzZWRDYXJldFJhbmdlLCAkZ2V0Q2FyZXRJbkRpcmVjdGlvbiwgJHNwbGl0QXRQb2ludENhcmV0TmV4dCwgJGlzVGV4dFBvaW50Q2FyZXQsICRpc1NpYmxpbmdDYXJldCwgJHJld2luZFNpYmxpbmdDYXJldCwgJGdldFN0YXRlLCAkc2V0U3RhdGUgfSBmcm9tICdsZXhpY2FsJztcbmV4cG9ydCB7ICRzcGxpdE5vZGUsIGlzQmxvY2tEb21Ob2RlLCBpc0hUTUxBbmNob3JFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0lubGluZURvbU5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlIH0gZnJvbSAnQGxleGljYWwvc2VsZWN0aW9uJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscy5cblxuZnVuY3Rpb24gZm9ybWF0RGV2RXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NJDEgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGRvY3VtZW50TW9kZSA9IENBTl9VU0VfRE9NJDEgJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQgPyBkb2N1bWVudC5kb2N1bWVudE1vZGUgOiBudWxsO1xuY29uc3QgSVNfQVBQTEUkMSA9IENBTl9VU0VfRE9NJDEgJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19GSVJFRk9YJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUJDEgPSBDQU5fVVNFX0RPTSQxICYmICdJbnB1dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSA/ICdnZXRUYXJnZXRSYW5nZXMnIGluIG5ldyB3aW5kb3cuSW5wdXRFdmVudCgnaW5wdXQnKSA6IGZhbHNlO1xuY29uc3QgSVNfU0FGQVJJJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9WZXJzaW9uXFwvW1xcZC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgSVNfSU9TJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG5jb25zdCBJU19BTkRST0lEJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9BbmRyb2lkLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vLyBLZWVwIHRoZXNlIGluIGNhc2Ugd2UgbmVlZCB0byB1c2UgdGhlbSBpbiB0aGUgZnV0dXJlLlxuLy8gZXhwb3J0IGNvbnN0IElTX1dJTkRPV1M6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAvV2luLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCBJU19DSFJPTUUkMSA9IENBTl9VU0VfRE9NJDEgJiYgL14oPz0uKkNocm9tZSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4vLyBleHBvcnQgY29uc3QgY2FuVXNlVGV4dElucHV0RXZlbnQ6IGJvb2xlYW4gPSBDQU5fVVNFX0RPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZTtcblxuY29uc3QgSVNfQU5EUk9JRF9DSFJPTUUkMSA9IENBTl9VU0VfRE9NJDEgJiYgSVNfQU5EUk9JRCQxICYmIElTX0NIUk9NRSQxO1xuY29uc3QgSVNfQVBQTEVfV0VCS0lUJDEgPSBDQU5fVVNFX0RPTSQxICYmIC9BcHBsZVdlYktpdFxcL1tcXGQuXSsvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIUlTX0NIUk9NRSQxO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcykge1xuICBjb25zdCBydmFsID0gW107XG4gIGZvciAoY29uc3QgY2xhc3NOYW1lIG9mIGNsYXNzTmFtZXMpIHtcbiAgICBpZiAoY2xhc3NOYW1lICYmIHR5cGVvZiBjbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBmb3IgKGNvbnN0IFtzXSBvZiBjbGFzc05hbWUubWF0Y2hBbGwoL1xcUysvZykpIHtcbiAgICAgICAgcnZhbC5wdXNoKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcnZhbDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSBhbGwgZnVuY3Rpb25zIHBhc3NlZCB3aGVuIGNhbGxlZC4gSXQgaXMgZ2VuZXJhbGx5IHVzZWRcbiAqIHRvIHJlZ2lzdGVyIG11bHRpcGxlIGxleGljYWwgbGlzdGVuZXJzIGFuZCB0aGVuIHRlYXIgdGhlbSBkb3duIHdpdGggYSBzaW5nbGUgZnVuY3Rpb24gY2FsbCwgc3VjaFxuICogYXMgUmVhY3QncyB1c2VFZmZlY3QgaG9vay5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQxIGxvZ2ljKSxcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDIgbG9naWMpLFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMyBsb2dpYylcbiAqICAgKVxuICogfSwgW2VkaXRvcl0pXG4gKiBgYGBcbiAqIEluIHRoaXMgY2FzZSwgdXNlRWZmZWN0IGlzIHJldHVybmluZyB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYnkgbWVyZ2VSZWdpc3RlciBhcyBhIGNsZWFudXBcbiAqIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGVpdGhlciB0aGUgdXNlRWZmZWN0IHJ1bnMgYWdhaW4gKGR1ZSB0byBvbmUgb2YgaXRzIGRlcGVuZGVuY2llc1xuICogdXBkYXRpbmcpIG9yIHRoZSBjb21wb25lbnQgaXQgcmVzaWRlcyBpbiB1bm1vdW50cy5cbiAqIE5vdGUgdGhlIGZ1bmN0aW9ucyBkb24ndCBuZWNlc3NhcmlseSBuZWVkIHRvIGJlIGluIGFuIGFycmF5IGFzIGFsbCBhcmd1bWVudHNcbiAqIGFyZSBjb25zaWRlcmVkIHRvIGJlIHRoZSBmdW5jIGFyZ3VtZW50IGFuZCBzcHJlYWQgZnJvbSB0aGVyZS5cbiAqIFRoZSBvcmRlciBvZiBjbGVhbnVwIGlzIHRoZSByZXZlcnNlIG9mIHRoZSBhcmd1bWVudCBvcmRlci4gR2VuZXJhbGx5IGl0IGlzXG4gKiBleHBlY3RlZCB0aGF0IHRoZSBmaXJzdCBcImFjcXVpcmVcIiB3aWxsIGJlIFwicmVsZWFzZWRcIiBsYXN0IChMSUZPIG9yZGVyKSxcbiAqIGJlY2F1c2UgYSBsYXRlciBzdGVwIG1heSBoYXZlIHNvbWUgZGVwZW5kZW5jeSBvbiBhbiBlYXJsaWVyIG9uZS5cbiAqIEBwYXJhbSBmdW5jIC0gQW4gYXJyYXkgb2YgY2xlYW51cCBmdW5jdGlvbnMgbWVhbnQgdG8gYmUgZXhlY3V0ZWQgYnkgdGhlIHJldHVybmVkIGZ1bmN0aW9uLlxuICogQHJldHVybnMgdGhlIGZ1bmN0aW9uIHdoaWNoIGV4ZWN1dGVzIGFsbCB0aGUgcGFzc2VkIGNsZWFudXAgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZVJlZ2lzdGVyKC4uLmZ1bmMpIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gZnVuYy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgZnVuY1tpXSgpO1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCB0aGUgcmVmZXJlbmNlcyBhbmQgbWFrZSBmdXR1cmUgY2FsbHMgYSBuby1vcFxuICAgIGZ1bmMubGVuZ3RoID0gMDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiBweCh2YWx1ZSkge1xuICByZXR1cm4gYCR7dmFsdWV9cHhgO1xufVxuXG5jb25zdCBtdXRhdGlvbk9ic2VydmVyQ29uZmlnID0ge1xuICBhdHRyaWJ1dGVzOiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhOiB0cnVlLFxuICBjaGlsZExpc3Q6IHRydWUsXG4gIHN1YnRyZWU6IHRydWVcbn07XG5mdW5jdGlvbiBwcmVwZW5kRE9NTm9kZShwYXJlbnQsIG5vZGUpIHtcbiAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG59XG5cbi8qKlxuICogUGxhY2Ugb25lIG9yIG11bHRpcGxlIG5ld2x5IGNyZWF0ZWQgTm9kZXMgYXQgdGhlIHBhc3NlZCBSYW5nZSdzIHBvc2l0aW9uLlxuICogTXVsdGlwbGUgbm9kZXMgd2lsbCBvbmx5IGJlIGNyZWF0ZWQgd2hlbiB0aGUgUmFuZ2Ugc3BhbnMgbXVsdGlwbGUgbGluZXMgKGFrYVxuICogY2xpZW50IHJlY3RzKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBjb21lIHBhcnRpY3VsYXJseSB1c2VmdWwgdG8gaGlnaGxpZ2h0IHBhcnRpY3VsYXIgcGFydHMgb2ZcbiAqIHRoZSB0ZXh0IHdpdGhvdXQgaW50ZXJmZXJpbmcgd2l0aCB0aGUgRWRpdG9yU3RhdGUsIHRoYXQgd2lsbCBvZnRlbiByZXBsaWNhdGVcbiAqIHRoZSBzdGF0ZSBhY3Jvc3MgY29sbGFiIGFuZCBjbGlwYm9hcmQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhY2NvdW50cyBmb3IgRE9NIHVwZGF0ZXMgd2hpY2ggY2FuIG1vZGlmeSB0aGUgcGFzc2VkIFJhbmdlLlxuICogSGVuY2UsIHRoZSBmdW5jdGlvbiByZXR1cm4gdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gbWxjUG9zaXRpb25Ob2RlT25SYW5nZShlZGl0b3IsIHJhbmdlLCBvblJlcG9zaXRpb24pIHtcbiAgbGV0IHJvb3RET01Ob2RlID0gbnVsbDtcbiAgbGV0IHBhcmVudERPTU5vZGUgPSBudWxsO1xuICBsZXQgb2JzZXJ2ZXIgPSBudWxsO1xuICBsZXQgbGFzdE5vZGVzID0gW107XG4gIGNvbnN0IHdyYXBwZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHdyYXBwZXJOb2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgZnVuY3Rpb24gcG9zaXRpb24oKSB7XG4gICAgaWYgKCEocm9vdERPTU5vZGUgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFVuZXhwZWN0ZWQgbnVsbCByb290RE9NTm9kZWApO1xuICAgIH1cbiAgICBpZiAoIShwYXJlbnRET01Ob2RlICE9PSBudWxsKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBVbmV4cGVjdGVkIG51bGwgcGFyZW50RE9NTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiBwYXJlbnRMZWZ0LFxuICAgICAgdG9wOiBwYXJlbnRUb3BcbiAgICB9ID0gcGFyZW50RE9NTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCByZWN0cyA9IGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpO1xuICAgIGlmICghd3JhcHBlck5vZGUuaXNDb25uZWN0ZWQpIHtcbiAgICAgIHByZXBlbmRET01Ob2RlKHBhcmVudERPTU5vZGUsIHdyYXBwZXJOb2RlKTtcbiAgICB9XG4gICAgbGV0IGhhc1JlcG9zaXRpb25lZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgIC8vIFRyeSB0byByZXVzZSB0aGUgcHJldmlvdXNseSBjcmVhdGVkIE5vZGUgd2hlbiBwb3NzaWJsZSwgbm8gbmVlZCB0b1xuICAgICAgLy8gcmVtb3ZlL2NyZWF0ZSBvbiB0aGUgbW9zdCBjb21tb24gY2FzZSByZXBvc2l0aW9uIGNhc2VcbiAgICAgIGNvbnN0IHJlY3ROb2RlID0gbGFzdE5vZGVzW2ldIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgY29uc3QgcmVjdE5vZGVTdHlsZSA9IHJlY3ROb2RlLnN0eWxlO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgcmVjdE5vZGVTdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsZWZ0ID0gcHgocmVjdC5sZWZ0IC0gcGFyZW50TGVmdCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS5sZWZ0ICE9PSBsZWZ0KSB7XG4gICAgICAgIHJlY3ROb2RlU3R5bGUubGVmdCA9IGxlZnQ7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0b3AgPSBweChyZWN0LnRvcCAtIHBhcmVudFRvcCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS50b3AgIT09IHRvcCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS50b3AgPSB0b3A7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB3aWR0aCA9IHB4KHJlY3Qud2lkdGgpO1xuICAgICAgaWYgKHJlY3ROb2RlU3R5bGUud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgIHJlY3ROb2RlLnN0eWxlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBoZWlnaHQgPSBweChyZWN0LmhlaWdodCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICByZWN0Tm9kZS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGhhc1JlcG9zaXRpb25lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVjdE5vZGUucGFyZW50Tm9kZSAhPT0gd3JhcHBlck5vZGUpIHtcbiAgICAgICAgd3JhcHBlck5vZGUuYXBwZW5kKHJlY3ROb2RlKTtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxhc3ROb2Rlc1tpXSA9IHJlY3ROb2RlO1xuICAgIH1cbiAgICB3aGlsZSAobGFzdE5vZGVzLmxlbmd0aCA+IHJlY3RzLmxlbmd0aCkge1xuICAgICAgbGFzdE5vZGVzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAoaGFzUmVwb3NpdGlvbmVkKSB7XG4gICAgICBvblJlcG9zaXRpb24obGFzdE5vZGVzKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICBwYXJlbnRET01Ob2RlID0gbnVsbDtcbiAgICByb290RE9NTm9kZSA9IG51bGw7XG4gICAgaWYgKG9ic2VydmVyICE9PSBudWxsKSB7XG4gICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuICAgIG9ic2VydmVyID0gbnVsbDtcbiAgICB3cmFwcGVyTm9kZS5yZW1vdmUoKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgbGFzdE5vZGVzKSB7XG4gICAgICBub2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgICBsYXN0Tm9kZXMgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiByZXN0YXJ0KCkge1xuICAgIGNvbnN0IGN1cnJlbnRSb290RE9NTm9kZSA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChjdXJyZW50Um9vdERPTU5vZGUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdG9wKCk7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRQYXJlbnRET01Ob2RlID0gY3VycmVudFJvb3RET01Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGN1cnJlbnRQYXJlbnRET01Ob2RlKSkge1xuICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICB9XG4gICAgc3RvcCgpO1xuICAgIHJvb3RET01Ob2RlID0gY3VycmVudFJvb3RET01Ob2RlO1xuICAgIHBhcmVudERPTU5vZGUgPSBjdXJyZW50UGFyZW50RE9NTm9kZTtcbiAgICBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKG11dGF0aW9ucyA9PiB7XG4gICAgICBjb25zdCBuZXh0Um9vdERPTU5vZGUgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICAgIGNvbnN0IG5leHRQYXJlbnRET01Ob2RlID0gbmV4dFJvb3RET01Ob2RlICYmIG5leHRSb290RE9NTm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgaWYgKG5leHRSb290RE9NTm9kZSAhPT0gcm9vdERPTU5vZGUgfHwgbmV4dFBhcmVudERPTU5vZGUgIT09IHBhcmVudERPTU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlc3RhcnQoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIGlmICghd3JhcHBlck5vZGUuY29udGFpbnMobXV0YXRpb24udGFyZ2V0KSkge1xuICAgICAgICAgIC8vIFRPRE8gdGhyb3R0bGVcbiAgICAgICAgICByZXR1cm4gcG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoY3VycmVudFBhcmVudERPTU5vZGUsIG11dGF0aW9uT2JzZXJ2ZXJDb25maWcpO1xuICAgIHBvc2l0aW9uKCk7XG4gIH1cbiAgY29uc3QgcmVtb3ZlUm9vdExpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyUm9vdExpc3RlbmVyKHJlc3RhcnQpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJlbW92ZVJvb3RMaXN0ZW5lcigpO1xuICAgIHN0b3AoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkZ2V0T3JkZXJlZFNlbGVjdGlvblBvaW50cyhzZWxlY3Rpb24pIHtcbiAgY29uc3QgcG9pbnRzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIHJldHVybiBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gW3BvaW50c1sxXSwgcG9pbnRzWzBdXSA6IHBvaW50cztcbn1cbmZ1bmN0aW9uIHJhbmdlVGFyZ2V0RnJvbVBvaW50KHBvaW50LCBub2RlLCBkb20pIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0JyB8fCAhJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCB0ZXh0RE9NID0gZ2V0RE9NVGV4dE5vZGUoZG9tKSB8fCBkb207XG4gICAgcmV0dXJuIFt0ZXh0RE9NLCBwb2ludC5vZmZzZXRdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHNsb3QgPSBub2RlLmdldERPTVNsb3QoZG9tKTtcbiAgICByZXR1cm4gW3Nsb3QuZWxlbWVudCwgc2xvdC5nZXRGaXJzdENoaWxkT2Zmc2V0KCkgKyBwb2ludC5vZmZzZXRdO1xuICB9XG59XG5mdW5jdGlvbiByYW5nZUZyb21Qb2ludHMoZWRpdG9yLCBzdGFydCwgc3RhcnROb2RlLCBzdGFydERPTSwgZW5kLCBlbmROb2RlLCBlbmRET00pIHtcbiAgY29uc3QgZWRpdG9yRG9jdW1lbnQgPSBlZGl0b3IuX3dpbmRvdyA/IGVkaXRvci5fd2luZG93LmRvY3VtZW50IDogZG9jdW1lbnQ7XG4gIGNvbnN0IHJhbmdlID0gZWRpdG9yRG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoLi4ucmFuZ2VUYXJnZXRGcm9tUG9pbnQoc3RhcnQsIHN0YXJ0Tm9kZSwgc3RhcnRET00pKTtcbiAgcmFuZ2Uuc2V0RW5kKC4uLnJhbmdlVGFyZ2V0RnJvbVBvaW50KGVuZCwgZW5kTm9kZSwgZW5kRE9NKSk7XG4gIHJldHVybiByYW5nZTtcbn1cbi8qKlxuICogUGxhY2Ugb25lIG9yIG11bHRpcGxlIG5ld2x5IGNyZWF0ZWQgTm9kZXMgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBNdWx0aXBsZVxuICogbm9kZXMgd2lsbCBvbmx5IGJlIGNyZWF0ZWQgd2hlbiB0aGUgc2VsZWN0aW9uIHNwYW5zIG11bHRpcGxlIGxpbmVzIChha2FcbiAqIGNsaWVudCByZWN0cykuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gY29tZSB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBzaG93IHRoZSBzZWxlY3Rpb24gYnV0IHRoZVxuICogZWRpdG9yIGhhcyBiZWVuIGZvY3VzZWQgYXdheS5cbiAqL1xuZnVuY3Rpb24gbWFya1NlbGVjdGlvbihlZGl0b3IsIG9uUmVwb3NpdGlvbikge1xuICBsZXQgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzQW5jaG9yTm9kZURPTSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0FuY2hvck9mZnNldCA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzTm9kZSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzTm9kZURPTSA9IG51bGw7XG4gIGxldCBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IHJlbW92ZVJhbmdlTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgZnVuY3Rpb24gY29tcHV0ZShlZGl0b3JTdGF0ZSkge1xuICAgIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgcHJldmlvdXNBbmNob3JOb2RlID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNBbmNob3JPZmZzZXQgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzRm9jdXNPZmZzZXQgPSBudWxsO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIgPSAoKSA9PiB7fTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgW3N0YXJ0LCBlbmRdID0gJGdldE9yZGVyZWRTZWxlY3Rpb25Qb2ludHMoc2VsZWN0aW9uKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGFydE5vZGUgPSBzdGFydC5nZXROb2RlKCk7XG4gICAgICBjb25zdCBjdXJyZW50U3RhcnROb2RlS2V5ID0gY3VycmVudFN0YXJ0Tm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGFydE9mZnNldCA9IHN0YXJ0Lm9mZnNldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbmROb2RlID0gZW5kLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbmROb2RlS2V5ID0gY3VycmVudEVuZE5vZGUuZ2V0S2V5KCk7XG4gICAgICBjb25zdCBjdXJyZW50RW5kT2Zmc2V0ID0gZW5kLm9mZnNldDtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGFydE5vZGVET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGN1cnJlbnRTdGFydE5vZGVLZXkpO1xuICAgICAgY29uc3QgY3VycmVudEVuZE5vZGVET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGN1cnJlbnRFbmROb2RlS2V5KTtcbiAgICAgIGNvbnN0IGRpZmZlcmVudFN0YXJ0RE9NID0gcHJldmlvdXNBbmNob3JOb2RlID09PSBudWxsIHx8IGN1cnJlbnRTdGFydE5vZGVET00gIT09IHByZXZpb3VzQW5jaG9yTm9kZURPTSB8fCBjdXJyZW50U3RhcnRPZmZzZXQgIT09IHByZXZpb3VzQW5jaG9yT2Zmc2V0IHx8IGN1cnJlbnRTdGFydE5vZGVLZXkgIT09IHByZXZpb3VzQW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGRpZmZlcmVudEVuZERPTSA9IHByZXZpb3VzRm9jdXNOb2RlID09PSBudWxsIHx8IGN1cnJlbnRFbmROb2RlRE9NICE9PSBwcmV2aW91c0ZvY3VzTm9kZURPTSB8fCBjdXJyZW50RW5kT2Zmc2V0ICE9PSBwcmV2aW91c0ZvY3VzT2Zmc2V0IHx8IGN1cnJlbnRFbmROb2RlS2V5ICE9PSBwcmV2aW91c0ZvY3VzTm9kZS5nZXRLZXkoKTtcbiAgICAgIGlmICgoZGlmZmVyZW50U3RhcnRET00gfHwgZGlmZmVyZW50RW5kRE9NKSAmJiBjdXJyZW50U3RhcnROb2RlRE9NICE9PSBudWxsICYmIGN1cnJlbnRFbmROb2RlRE9NICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VGcm9tUG9pbnRzKGVkaXRvciwgc3RhcnQsIGN1cnJlbnRTdGFydE5vZGUsIGN1cnJlbnRTdGFydE5vZGVET00sIGVuZCwgY3VycmVudEVuZE5vZGUsIGN1cnJlbnRFbmROb2RlRE9NKTtcbiAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lcigpO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyID0gbWxjUG9zaXRpb25Ob2RlT25SYW5nZShlZGl0b3IsIHJhbmdlLCBkb21Ob2RlcyA9PiB7XG4gICAgICAgICAgaWYgKG9uUmVwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGRvbU5vZGUgb2YgZG9tTm9kZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgZG9tTm9kZVN0eWxlID0gZG9tTm9kZS5zdHlsZTtcbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5iYWNrZ3JvdW5kICE9PSAnSGlnaGxpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5iYWNrZ3JvdW5kID0gJ0hpZ2hsaWdodCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5jb2xvciAhPT0gJ0hpZ2hsaWdodFRleHQnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLmNvbG9yID0gJ0hpZ2hsaWdodFRleHQnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUubWFyZ2luVG9wICE9PSBweCgtMS41KSkge1xuICAgICAgICAgICAgICAgIGRvbU5vZGVTdHlsZS5tYXJnaW5Ub3AgPSBweCgtMS41KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLnBhZGRpbmdUb3AgIT09IHB4KDQpKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLnBhZGRpbmdUb3AgPSBweCg0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLnBhZGRpbmdCb3R0b20gIT09IHB4KDApKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLnBhZGRpbmdCb3R0b20gPSBweCgwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvblJlcG9zaXRpb24oZG9tTm9kZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBwcmV2aW91c0FuY2hvck5vZGUgPSBjdXJyZW50U3RhcnROb2RlO1xuICAgICAgcHJldmlvdXNBbmNob3JOb2RlRE9NID0gY3VycmVudFN0YXJ0Tm9kZURPTTtcbiAgICAgIHByZXZpb3VzQW5jaG9yT2Zmc2V0ID0gY3VycmVudFN0YXJ0T2Zmc2V0O1xuICAgICAgcHJldmlvdXNGb2N1c05vZGUgPSBjdXJyZW50RW5kTm9kZTtcbiAgICAgIHByZXZpb3VzRm9jdXNOb2RlRE9NID0gY3VycmVudEVuZE5vZGVET007XG4gICAgICBwcmV2aW91c0ZvY3VzT2Zmc2V0ID0gY3VycmVudEVuZE9mZnNldDtcbiAgICB9KTtcbiAgfVxuICBjb21wdXRlKGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpKTtcbiAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyVXBkYXRlTGlzdGVuZXIoKHtcbiAgICBlZGl0b3JTdGF0ZVxuICB9KSA9PiBjb21wdXRlKGVkaXRvclN0YXRlKSksICgpID0+IHtcbiAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdGlvbkFsd2F5c09uRGlzcGxheShlZGl0b3IpIHtcbiAgbGV0IHJlbW92ZVNlbGVjdGlvbk1hcmsgPSBudWxsO1xuICBjb25zdCBvblNlbGVjdGlvbkNoYW5nZSA9ICgpID0+IHtcbiAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICAgIGNvbnN0IGVkaXRvclJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgY29uc3QgaXNTZWxlY3Rpb25JbnNpZGVFZGl0b3IgPSBkb21BbmNob3JOb2RlICE9PSBudWxsICYmIGVkaXRvclJvb3RFbGVtZW50ICE9PSBudWxsICYmIGVkaXRvclJvb3RFbGVtZW50LmNvbnRhaW5zKGRvbUFuY2hvck5vZGUpO1xuICAgIGlmIChpc1NlbGVjdGlvbkluc2lkZUVkaXRvcikge1xuICAgICAgaWYgKHJlbW92ZVNlbGVjdGlvbk1hcmsgIT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlU2VsZWN0aW9uTWFyaygpO1xuICAgICAgICByZW1vdmVTZWxlY3Rpb25NYXJrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHJlbW92ZVNlbGVjdGlvbk1hcmsgPT09IG51bGwpIHtcbiAgICAgICAgcmVtb3ZlU2VsZWN0aW9uTWFyayA9IG1hcmtTZWxlY3Rpb24oZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAocmVtb3ZlU2VsZWN0aW9uTWFyayAhPT0gbnVsbCkge1xuICAgICAgcmVtb3ZlU2VsZWN0aW9uTWFyaygpO1xuICAgIH1cbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBvblNlbGVjdGlvbkNoYW5nZSk7XG4gIH07XG59XG5cbi8vIEhvdGZpeCB0byBleHBvcnQgdGhlc2Ugd2l0aCBpbmxpbmVkIHR5cGVzICM1OTE4XG5jb25zdCBDQU5fVVNFX0JFRk9SRV9JTlBVVCA9IENBTl9VU0VfQkVGT1JFX0lOUFVUJDE7XG5jb25zdCBDQU5fVVNFX0RPTSA9IENBTl9VU0VfRE9NJDE7XG5jb25zdCBJU19BTkRST0lEID0gSVNfQU5EUk9JRCQxO1xuY29uc3QgSVNfQU5EUk9JRF9DSFJPTUUgPSBJU19BTkRST0lEX0NIUk9NRSQxO1xuY29uc3QgSVNfQVBQTEUgPSBJU19BUFBMRSQxO1xuY29uc3QgSVNfQVBQTEVfV0VCS0lUID0gSVNfQVBQTEVfV0VCS0lUJDE7XG5jb25zdCBJU19DSFJPTUUgPSBJU19DSFJPTUUkMTtcbmNvbnN0IElTX0ZJUkVGT1ggPSBJU19GSVJFRk9YJDE7XG5jb25zdCBJU19JT1MgPSBJU19JT1MkMTtcbmNvbnN0IElTX1NBRkFSSSA9IElTX1NBRkFSSSQxO1xuXG4vKipcbiAqIFRha2VzIGFuIEhUTUwgZWxlbWVudCBhbmQgYWRkcyB0aGUgY2xhc3NOYW1lcyBwYXNzZWQgd2l0aGluIGFuIGFycmF5LFxuICogaWdub3JpbmcgYW55IG5vbi1zdHJpbmcgdHlwZXMuIEEgc3BhY2UgY2FuIGJlIHVzZWQgdG8gYWRkIG11bHRpcGxlIGNsYXNzZXNcbiAqIGVnLiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIFsnZWxlbWVudC1pbm5lciBhY3RpdmUnLCB0cnVlLCBudWxsXSlcbiAqIHdpbGwgYWRkIGJvdGggJ2VsZW1lbnQtaW5uZXInIGFuZCAnYWN0aXZlJyBhcyBjbGFzc2VzIHRvIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIGFkZGVkXG4gKiBAcGFyYW0gY2xhc3NOYW1lcyAtIEFuIGFycmF5IGRlZmluaW5nIHRoZSBjbGFzcyBuYW1lcyB0byBhZGQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcyk7XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5cbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCByZW1vdmVzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byByZW1vdmUgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCBbJ2FjdGl2ZSBzbWFsbCcsIHRydWUsIG51bGxdKVxuICogd2lsbCByZW1vdmUgYm90aCB0aGUgJ2FjdGl2ZScgYW5kICdzbWFsbCcgY2xhc3NlcyBmcm9tIHRoYXQgZWxlbWVudC5cbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGNsYXNzZXMgYXJlIHJlbW92ZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIHJlbW92ZSBmcm9tIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCAuLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IGNsYXNzZXNUb1JlbW92ZSA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoLi4uY2xhc3NOYW1lcyk7XG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBmaWxlIHR5cGUgbWF0Y2hlcyB0aGUgdHlwZXMgcGFzc2VkIHdpdGhpbiB0aGUgYWNjZXB0YWJsZU1pbWVUeXBlcyBhcnJheSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogVGhlIHR5cGVzIHBhc3NlZCBtdXN0IGJlIHN0cmluZ3MgYW5kIGFyZSBDQVNFLVNFTlNJVElWRS5cbiAqIGVnLiBpZiBmaWxlIGlzIG9mIHR5cGUgJ3RleHQnIGFuZCBhY2NlcHRhYmxlTWltZVR5cGVzID0gWydURVhUJywgJ0lNQUdFJ10gdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGZhbHNlLlxuICogQHBhcmFtIGZpbGUgLSBUaGUgZmlsZSB5b3Ugd2FudCB0byB0eXBlIGNoZWNrLlxuICogQHBhcmFtIGFjY2VwdGFibGVNaW1lVHlwZXMgLSBBbiBhcnJheSBvZiBzdHJpbmdzIG9mIHR5cGVzIHdoaWNoIHRoZSBmaWxlIGlzIGNoZWNrZWQgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgaXMgYW4gYWNjZXB0YWJsZSBtaW1lIHR5cGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNNaW1lVHlwZShmaWxlLCBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gIGZvciAoY29uc3QgYWNjZXB0YWJsZVR5cGUgb2YgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICAgIGlmIChmaWxlLnR5cGUuc3RhcnRzV2l0aChhY2NlcHRhYmxlVHlwZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogTGV4aWNhbCBGaWxlIFJlYWRlciB3aXRoOlxuICogIDEuIE1JTUUgdHlwZSBzdXBwb3J0XG4gKiAgMi4gYmF0Y2hlZCByZXN1bHRzIChIaXN0b3J5UGx1Z2luIGNvbXBhdGliaWxpdHkpXG4gKiAgMy4gT3JkZXIgYXdhcmUgKHJlc3BlY3RzIHRoZSBvcmRlciB3aGVuIG11bHRpcGxlIEZpbGVzIGFyZSBwYXNzZWQpXG4gKlxuICogY29uc3QgZmlsZXNSZXN1bHQgPSBhd2FpdCBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIFsnaW1hZ2UvJ10pO1xuICogZmlsZXNSZXN1bHQuZm9yRWFjaChmaWxlID0+IGVkaXRvci5kaXNwYXRjaENvbW1hbmQoJ0lOU0VSVF9JTUFHRScsIFxcXFx7XG4gKiAgIHNyYzogZmlsZS5yZXN1bHQsXG4gKiBcXFxcfSkpO1xuICovXG5mdW5jdGlvbiBtZWRpYUZpbGVSZWFkZXIoZmlsZXMsIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgY29uc3QgZmlsZXNJdGVyYXRvciA9IGZpbGVzW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBwcm9jZXNzZWQgPSBbXTtcbiAgICBjb25zdCBoYW5kbGVOZXh0RmlsZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZG9uZSxcbiAgICAgICAgdmFsdWU6IGZpbGVcbiAgICAgIH0gPSBmaWxlc0l0ZXJhdG9yLm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHByb2Nlc3NlZCk7XG4gICAgICB9XG4gICAgICBjb25zdCBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCByZWplY3QpO1xuICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBmaWxlUmVhZGVyLnJlc3VsdDtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcHJvY2Vzc2VkLnB1c2goe1xuICAgICAgICAgICAgZmlsZSxcbiAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpc01pbWVUeXBlKGZpbGUsIGFjY2VwdGFibGVNaW1lVHlwZXMpKSB7XG4gICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBoYW5kbGVOZXh0RmlsZSgpO1xuICB9KTtcbn1cbi8qKlxuICogXCJEZXB0aC1GaXJzdCBTZWFyY2hcIiBzdGFydHMgYXQgdGhlIHJvb3QvdG9wIG5vZGUgb2YgYSB0cmVlIGFuZCBnb2VzIGFzIGZhciBhcyBpdCBjYW4gZG93biBhIGJyYW5jaCBlbmRcbiAqIGJlZm9yZSBiYWNrdHJhY2tpbmcgYW5kIGZpbmRpbmcgYSBuZXcgcGF0aC4gQ29uc2lkZXIgc29sdmluZyBhIG1hemUgYnkgaHVnZ2luZyBlaXRoZXIgd2FsbCwgbW92aW5nIGRvd24gYVxuICogYnJhbmNoIHVudGlsIHlvdSBoaXQgYSBkZWFkLWVuZCAobGVhZikgYW5kIGJhY2t0cmFja2luZyB0byBmaW5kIHRoZSBuZWFyZXN0IGJyYW5jaGluZyBwYXRoIGFuZCByZXBlYXQuXG4gKiBJdCB3aWxsIHRoZW4gcmV0dXJuIGFsbCB0aGUgbm9kZXMgZm91bmQgaW4gdGhlIHNlYXJjaCBpbiBhbiBhcnJheSBvZiBvYmplY3RzLlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgc3RhcnQgYXQgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBlbmROb2RlIC0gVGhlIG5vZGUgdG8gZW5kIHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgZmluZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG9iamVjdHMgb2YgYWxsIHRoZSBub2RlcyBmb3VuZCBieSB0aGUgc2VhcmNoLCBpbmNsdWRpbmcgdGhlaXIgZGVwdGggaW50byB0aGUgdHJlZS5cbiAqIFxcXFx7ZGVwdGg6IG51bWJlciwgbm9kZTogTGV4aWNhbE5vZGVcXFxcfSBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgc3RhcnQgbm9kZSkuXG4gKi9cbmZ1bmN0aW9uICRkZnMoc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKCRkZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFkamFjZW50IGNhcmV0IGluIHRoZSBzYW1lIGRpcmVjdGlvblxuICpcbiAqIEBwYXJhbSBjYXJldCBBIGNhcmV0IG9yIG51bGxcbiAqIEByZXR1cm5zIGBjYXJldC5nZXRBZGphY2VudENhcmV0KClgIG9yIGBudWxsYFxuICovXG5mdW5jdGlvbiAkZ2V0QWRqYWNlbnRDYXJldChjYXJldCkge1xuICByZXR1cm4gY2FyZXQgPyBjYXJldC5nZXRBZGphY2VudENhcmV0KCkgOiBudWxsO1xufVxuXG4vKipcbiAqICRkZnMgaXRlcmF0b3IgKHJpZ2h0IHRvIGxlZnQpLiBUcmVlIHRyYXZlcnNhbCBpcyBkb25lIG9uIHRoZSBmbHkgYXMgbmV3IHZhbHVlcyBhcmUgcmVxdWVzdGVkIHdpdGggTygxKSBtZW1vcnkuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGVuZE5vZGUgLSBUaGUgbm9kZSB0byBlbmQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gaXRlcmF0b3IsIGVhY2ggeWllbGRlZCB2YWx1ZSBpcyBhIERGU05vZGUuIEl0IHdpbGwgYWx3YXlzIHJldHVybiBhdCBsZWFzdCAxIG5vZGUgKHRoZSBzdGFydCBub2RlKS5cbiAqL1xuZnVuY3Rpb24gJHJldmVyc2VEZnMoc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKCRyZXZlcnNlRGZzSXRlcmF0b3Ioc3RhcnROb2RlLCBlbmROb2RlKSk7XG59XG5cbi8qKlxuICogJGRmcyBpdGVyYXRvciAobGVmdCB0byByaWdodCkuIFRyZWUgdHJhdmVyc2FsIGlzIGRvbmUgb24gdGhlIGZseSBhcyBuZXcgdmFsdWVzIGFyZSByZXF1ZXN0ZWQgd2l0aCBPKDEpIG1lbW9yeS5cbiAqIEBwYXJhbSBzdGFydE5vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIHN0YXJ0IGF0IHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gZW5kTm9kZSAtIFRoZSBub2RlIHRvIGVuZCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIGZpbmQgYWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBzdGFydGluZ05vZGUuXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciwgZWFjaCB5aWVsZGVkIHZhbHVlIGlzIGEgREZTTm9kZS4gSXQgd2lsbCBhbHdheXMgcmV0dXJuIGF0IGxlYXN0IDEgbm9kZSAodGhlIHN0YXJ0IG5vZGUpLlxuICovXG5mdW5jdGlvbiAkZGZzSXRlcmF0b3Ioc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIHJldHVybiAkZGZzQ2FyZXRJdGVyYXRvcignbmV4dCcsIHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XG59XG5mdW5jdGlvbiAkZ2V0RW5kQ2FyZXQoc3RhcnROb2RlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgcnZhbCA9ICRnZXRBZGphY2VudFNpYmxpbmdPclBhcmVudFNpYmxpbmdDYXJldCgkZ2V0U2libGluZ0NhcmV0KHN0YXJ0Tm9kZSwgZGlyZWN0aW9uKSk7XG4gIHJldHVybiBydmFsICYmIHJ2YWxbMF07XG59XG5mdW5jdGlvbiAkZGZzQ2FyZXRJdGVyYXRvcihkaXJlY3Rpb24sIHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgY29uc3Qgc3RhcnQgPSBzdGFydE5vZGUgfHwgcm9vdDtcbiAgY29uc3Qgc3RhcnRDYXJldCA9ICRpc0VsZW1lbnROb2RlKHN0YXJ0KSA/ICRnZXRDaGlsZENhcmV0KHN0YXJ0LCBkaXJlY3Rpb24pIDogJGdldFNpYmxpbmdDYXJldChzdGFydCwgZGlyZWN0aW9uKTtcbiAgY29uc3Qgc3RhcnREZXB0aCA9ICRnZXREZXB0aChzdGFydCk7XG4gIGNvbnN0IGVuZENhcmV0ID0gZW5kTm9kZSA/ICRnZXRBZGphY2VudENoaWxkQ2FyZXQoJGdldENoaWxkQ2FyZXRPclNlbGYoJGdldFNpYmxpbmdDYXJldChlbmROb2RlLCBkaXJlY3Rpb24pKSkgOiAkZ2V0RW5kQ2FyZXQoc3RhcnQsIGRpcmVjdGlvbik7XG4gIGxldCBkZXB0aCA9IHN0YXJ0RGVwdGg7XG4gIHJldHVybiBtYWtlU3RlcHdpc2VJdGVyYXRvcih7XG4gICAgaGFzTmV4dDogc3RhdGUgPT4gc3RhdGUgIT09IG51bGwsXG4gICAgaW5pdGlhbDogc3RhcnRDYXJldCxcbiAgICBtYXA6IHN0YXRlID0+ICh7XG4gICAgICBkZXB0aCxcbiAgICAgIG5vZGU6IHN0YXRlLm9yaWdpblxuICAgIH0pLFxuICAgIHN0ZXA6IHN0YXRlID0+IHtcbiAgICAgIGlmIChzdGF0ZS5pc1NhbWVOb2RlQ2FyZXQoZW5kQ2FyZXQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCRpc0NoaWxkQ2FyZXQoc3RhdGUpKSB7XG4gICAgICAgIGRlcHRoKys7XG4gICAgICB9XG4gICAgICBjb25zdCBydmFsID0gJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0KHN0YXRlKTtcbiAgICAgIGlmICghcnZhbCB8fCBydmFsWzBdLmlzU2FtZU5vZGVDYXJldChlbmRDYXJldCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBkZXB0aCArPSBydmFsWzFdO1xuICAgICAgcmV0dXJuIHJ2YWxbMF07XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBOb2RlIHNpYmxpbmcgd2hlbiB0aGlzIGV4aXN0cywgb3RoZXJ3aXNlIHRoZSBjbG9zZXN0IHBhcmVudCBzaWJsaW5nLiBGb3IgZXhhbXBsZVxuICogUiAtPiBQIC0+IFQxLCBUMlxuICogICAtPiBQMlxuICogcmV0dXJucyBUMiBmb3Igbm9kZSBUMSwgUDIgZm9yIG5vZGUgVDIsIGFuZCBudWxsIGZvciBub2RlIFAyLlxuICogQHBhcmFtIG5vZGUgTGV4aWNhbE5vZGUuXG4gKiBAcmV0dXJucyBBbiBhcnJheSAodHVwbGUpIGNvbnRhaW5pbmcgdGhlIGZvdW5kIExleGljYWwgbm9kZSBhbmQgdGhlIGRlcHRoIGRpZmZlcmVuY2UsIG9yIG51bGwsIGlmIHRoaXMgbm9kZSBkb2Vzbid0IGV4aXN0LlxuICovXG5mdW5jdGlvbiAkZ2V0TmV4dFNpYmxpbmdPclBhcmVudFNpYmxpbmcobm9kZSkge1xuICBjb25zdCBydmFsID0gJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0KCRnZXRTaWJsaW5nQ2FyZXQobm9kZSwgJ25leHQnKSk7XG4gIHJldHVybiBydmFsICYmIFtydmFsWzBdLm9yaWdpbiwgcnZhbFsxXV07XG59XG5mdW5jdGlvbiAkZ2V0RGVwdGgobm9kZSkge1xuICBsZXQgZGVwdGggPSAtMTtcbiAgZm9yIChsZXQgaW5uZXJOb2RlID0gbm9kZTsgaW5uZXJOb2RlICE9PSBudWxsOyBpbm5lck5vZGUgPSBpbm5lck5vZGUuZ2V0UGFyZW50KCkpIHtcbiAgICBkZXB0aCsrO1xuICB9XG4gIHJldHVybiBkZXB0aDtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhIHJpZ2h0LXRvLWxlZnQgcHJlb3JkZXIgdHJlZSB0cmF2ZXJzYWwuXG4gKiBGcm9tIHRoZSBzdGFydGluZyBub2RlIGl0IGdvZXMgdG8gdGhlIHJpZ2h0bW9zdCBjaGlsZCwgdGhhbiBiYWNrdHJhY2tzIHRvIHBhcmVudCBhbmQgZmluZHMgbmV3IHJpZ2h0bW9zdCBwYXRoLlxuICogSXQgd2lsbCByZXR1cm4gdGhlIG5leHQgbm9kZSBpbiB0cmF2ZXJzYWwgc2VxdWVuY2UgYWZ0ZXIgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIFRoZSB0cmF2ZXJzYWwgaXMgc2ltaWxhciB0byAkZGZzIGZ1bmN0aW9ucyBhYm92ZSwgYnV0IHRoZSBub2RlcyBhcmUgdmlzaXRlZCByaWdodC10by1sZWZ0LCBub3QgbGVmdC10by1yaWdodC5cbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5leHQgbm9kZSBpbiBwcmUtb3JkZXIgcmlnaHQgdG8gbGVmdCB0cmF2ZXJzYWwgc2VxdWVuY2Ugb3IgYG51bGxgLCBpZiB0aGUgbm9kZSBkb2VzIG5vdCBleGlzdFxuICovXG5mdW5jdGlvbiAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlKHN0YXJ0aW5nTm9kZSkge1xuICBjb25zdCBzdGFydENhcmV0ID0gJGdldENoaWxkQ2FyZXRPclNlbGYoJGdldFNpYmxpbmdDYXJldChzdGFydGluZ05vZGUsICdwcmV2aW91cycpKTtcbiAgY29uc3QgbmV4dCA9ICRnZXRBZGphY2VudFNpYmxpbmdPclBhcmVudFNpYmxpbmdDYXJldChzdGFydENhcmV0LCAncm9vdCcpO1xuICByZXR1cm4gbmV4dCAmJiBuZXh0WzBdLm9yaWdpbjtcbn1cblxuLyoqXG4gKiAkZGZzIGl0ZXJhdG9yIChyaWdodCB0byBsZWZ0KS4gVHJlZSB0cmF2ZXJzYWwgaXMgZG9uZSBvbiB0aGUgZmx5IGFzIG5ldyB2YWx1ZXMgYXJlIHJlcXVlc3RlZCB3aXRoIE8oMSkgbWVtb3J5LlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgc3RhcnQgYXQgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBlbmROb2RlIC0gVGhlIG5vZGUgdG8gZW5kIHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgZmluZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yLCBlYWNoIHlpZWxkZWQgdmFsdWUgaXMgYSBERlNOb2RlLiBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgc3RhcnQgbm9kZSkuXG4gKi9cbmZ1bmN0aW9uICRyZXZlcnNlRGZzSXRlcmF0b3Ioc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIHJldHVybiAkZGZzQ2FyZXRJdGVyYXRvcigncHJldmlvdXMnLCBzdGFydE5vZGUsIGVuZE5vZGUpO1xufVxuXG4vKipcbiAqIFRha2VzIGEgbm9kZSBhbmQgdHJhdmVyc2VzIHVwIGl0cyBhbmNlc3RvcnMgKHRvd2FyZCB0aGUgcm9vdCBub2RlKVxuICogaW4gb3JkZXIgdG8gZmluZCBhIHNwZWNpZmljIHR5cGUgb2Ygbm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gdGhlIG5vZGUgdG8gYmVnaW4gc2VhcmNoaW5nLlxuICogQHBhcmFtIGtsYXNzIC0gYW4gaW5zdGFuY2Ugb2YgdGhlIHR5cGUgb2Ygbm9kZSB0byBsb29rIGZvci5cbiAqIEByZXR1cm5zIHRoZSBub2RlIG9mIHR5cGUga2xhc3MgdGhhdCB3YXMgcGFzc2VkLCBvciBudWxsIGlmIG5vbmUgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uICRnZXROZWFyZXN0Tm9kZU9mVHlwZShub2RlLCBrbGFzcykge1xuICBsZXQgcGFyZW50ID0gbm9kZTtcbiAgd2hpbGUgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgaWYgKHBhcmVudCBpbnN0YW5jZW9mIGtsYXNzKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBub2RlIG9mIHRoZSBuZWFyZXN0IGFuY2VzdG9yLCBvdGhlcndpc2UgdGhyb3dzIGFuIGVycm9yLlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBzdGFydGluZyBub2RlIG9mIHRoZSBzZWFyY2hcbiAqIEByZXR1cm5zIFRoZSBhbmNlc3RvciBub2RlIGZvdW5kXG4gKi9cbmZ1bmN0aW9uICRnZXROZWFyZXN0QmxvY2tFbGVtZW50QW5jZXN0b3JPclRocm93KHN0YXJ0Tm9kZSkge1xuICBjb25zdCBibG9ja05vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0Tm9kZSwgbm9kZSA9PiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKTtcbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShibG9ja05vZGUpKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBub2RlICR7c3RhcnROb2RlLl9fa2V5fSB0byBoYXZlIGNsb3Nlc3QgYmxvY2sgZWxlbWVudCBub2RlLmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmxvY2tOb2RlO1xufVxuLyoqXG4gKiBTdGFydHMgd2l0aCBhIG5vZGUgYW5kIG1vdmVzIHVwIHRoZSB0cmVlICh0b3dhcmQgdGhlIHJvb3Qgbm9kZSkgdG8gZmluZCBhIG1hdGNoaW5nIG5vZGUgYmFzZWQgb25cbiAqIHRoZSBzZWFyY2ggcGFyYW1ldGVycyBvZiB0aGUgZmluZEZuLiAoQ29uc2lkZXIgSmF2YVNjcmlwdHMnIC5maW5kKCkgZnVuY3Rpb24gd2hlcmUgYSB0ZXN0aW5nIGZ1bmN0aW9uIG11c3QgYmVcbiAqIHBhc3NlZCBhcyBhbiBhcmd1bWVudC4gZWcuIGlmKCAobm9kZSkgPT4gbm9kZS5fX3R5cGUgPT09ICdkaXYnKSApIHJldHVybiB0cnVlOyBvdGhlcndpc2UgcmV0dXJuIGZhbHNlXG4gKiBAcGFyYW0gc3RhcnRpbmdOb2RlIC0gVGhlIG5vZGUgd2hlcmUgdGhlIHNlYXJjaCBzdGFydHMuXG4gKiBAcGFyYW0gZmluZEZuIC0gQSB0ZXN0aW5nIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBjdXJyZW50IG5vZGUgc2F0aXNmaWVzIHRoZSB0ZXN0aW5nIHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyBBIHBhcmVudCBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgZmluZEZuIHBhcmFtZXRlcnMsIG9yIG51bGwgaWYgb25lIHdhc24ndCBmb3VuZC5cbiAqL1xuY29uc3QgJGZpbmRNYXRjaGluZ1BhcmVudCA9IChzdGFydGluZ05vZGUsIGZpbmRGbikgPT4ge1xuICBsZXQgY3VyciA9IHN0YXJ0aW5nTm9kZTtcbiAgd2hpbGUgKGN1cnIgIT09ICRnZXRSb290KCkgJiYgY3VyciAhPSBudWxsKSB7XG4gICAgaWYgKGZpbmRGbihjdXJyKSkge1xuICAgICAgcmV0dXJuIGN1cnI7XG4gICAgfVxuICAgIGN1cnIgPSBjdXJyLmdldFBhcmVudCgpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXNvbHZlIG5lc3RlZCBlbGVtZW50IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgaW50byBhIHNpbmdsZSBub2RlIG9mIHRoYXQgdHlwZS5cbiAqIEl0IGlzIGdlbmVyYWxseSB1c2VkIGZvciBtYXJrcy9jb21tZW50aW5nXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yXG4gKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIFRoZSB0YXJnZXQgZm9yIHRoZSBuZXN0ZWQgZWxlbWVudCB0byBiZSBleHRyYWN0ZWQgZnJvbS5cbiAqIEBwYXJhbSBjbG9uZU5vZGUgLSBTZWUge0BsaW5rICRjcmVhdGVNYXJrTm9kZX1cbiAqIEBwYXJhbSBoYW5kbGVPdmVybGFwIC0gSGFuZGxlcyBhbnkgb3ZlcmxhcCBiZXR3ZWVuIHRoZSBub2RlIHRvIGV4dHJhY3QgYW5kIHRoZSB0YXJnZXROb2RlXG4gKiBAcmV0dXJucyBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJOZXN0ZWRFbGVtZW50UmVzb2x2ZXIoZWRpdG9yLCB0YXJnZXROb2RlLCBjbG9uZU5vZGUsIGhhbmRsZU92ZXJsYXApIHtcbiAgY29uc3QgJGlzVGFyZ2V0Tm9kZSA9IG5vZGUgPT4ge1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgdGFyZ2V0Tm9kZTtcbiAgfTtcbiAgY29uc3QgJGZpbmRNYXRjaCA9IG5vZGUgPT4ge1xuICAgIC8vIEZpcnN0IHZhbGlkYXRlIHdlIGRvbid0IGhhdmUgYW55IGNoaWxkcmVuIHRoYXQgYXJlIG9mIHRoZSB0YXJnZXQsXG4gICAgLy8gYXMgd2UgbmVlZCB0byBoYW5kbGUgdGhlbSBmaXJzdC5cbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKCRpc1RhcmdldE5vZGUoY2hpbGQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgbGV0IGNoaWxkTm9kZSA9IG5vZGU7XG4gICAgd2hpbGUgKHBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkTm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICgkaXNUYXJnZXROb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpbGQ6IGNoaWxkTm9kZSxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIGNvbnN0ICRlbGVtZW50Tm9kZVRyYW5zZm9ybSA9IG5vZGUgPT4ge1xuICAgIGNvbnN0IG1hdGNoID0gJGZpbmRNYXRjaChub2RlKTtcbiAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2hpbGQsXG4gICAgICAgIHBhcmVudFxuICAgICAgfSA9IG1hdGNoO1xuXG4gICAgICAvLyBTaW1wbGUgcGF0aCwgd2UgY2FuIG1vdmUgY2hpbGQgb3V0IGFuZCBzaWJsaW5ncyBpbnRvIGEgbmV3IHBhcmVudC5cblxuICAgICAgaWYgKGNoaWxkLmlzKG5vZGUpKSB7XG4gICAgICAgIGhhbmRsZU92ZXJsYXAocGFyZW50LCBub2RlKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmdzID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmdzKCk7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nc0xlbmd0aCA9IG5leHRTaWJsaW5ncy5sZW5ndGg7XG4gICAgICAgIHBhcmVudC5pbnNlcnRBZnRlcihjaGlsZCk7XG4gICAgICAgIGlmIChuZXh0U2libGluZ3NMZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjb25zdCBuZXdQYXJlbnQgPSBjbG9uZU5vZGUocGFyZW50KTtcbiAgICAgICAgICBjaGlsZC5pbnNlcnRBZnRlcihuZXdQYXJlbnQpO1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFNpYmxpbmdzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1BhcmVudC5hcHBlbmQobmV4dFNpYmxpbmdzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJlbnQuY2FuQmVFbXB0eSgpICYmIHBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0odGFyZ2V0Tm9kZSwgJGVsZW1lbnROb2RlVHJhbnNmb3JtKTtcbn1cblxuLyoqXG4gKiBDbG9uZXMgdGhlIGVkaXRvciBhbmQgbWFya3MgaXQgYXMgZGlydHkgdG8gYmUgcmVjb25jaWxlZC4gSWYgdGhlcmUgd2FzIGEgc2VsZWN0aW9uLFxuICogaXQgd291bGQgYmUgc2V0IGJhY2sgdG8gaXRzIHByZXZpb3VzIHN0YXRlLCBvciBudWxsIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqIEBwYXJhbSBlZGl0b3JTdGF0ZSAtIFRoZSBlZGl0b3IncyBzdGF0ZVxuICovXG5mdW5jdGlvbiAkcmVzdG9yZUVkaXRvclN0YXRlKGVkaXRvciwgZWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgRlVMTF9SRUNPTkNJTEUgPSAyO1xuICBjb25zdCBub2RlTWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCBhY3RpdmVFZGl0b3JTdGF0ZSA9IGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlO1xuICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIGVkaXRvclN0YXRlLl9ub2RlTWFwKSB7XG4gICAgbm9kZU1hcC5zZXQoa2V5LCAkY2xvbmVXaXRoUHJvcGVydGllcyhub2RlKSk7XG4gIH1cbiAgaWYgKGFjdGl2ZUVkaXRvclN0YXRlKSB7XG4gICAgYWN0aXZlRWRpdG9yU3RhdGUuX25vZGVNYXAgPSBub2RlTWFwO1xuICB9XG4gIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IGVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uID09PSBudWxsID8gbnVsbCA6IHNlbGVjdGlvbi5jbG9uZSgpKTtcbn1cblxuLyoqXG4gKiBJZiB0aGUgc2VsZWN0ZWQgaW5zZXJ0aW9uIGFyZWEgaXMgdGhlIHJvb3Qvc2hhZG93IHJvb3Qgbm9kZSAoc2VlIHtAbGluayBsZXhpY2FsISRpc1Jvb3RPclNoYWRvd1Jvb3R9KSxcbiAqIHRoZSBub2RlIHdpbGwgYmUgYXBwZW5kZWQgdGhlcmUsIG90aGVyd2lzZSwgaXQgd2lsbCBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGluc2VydGlvbiBhcmVhLlxuICogSWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uIHdoZXJlIHRoZSBub2RlIGlzIHRvIGJlIGluc2VydGVkLCBpdCB3aWxsIGJlIGFwcGVuZGVkIGFmdGVyIGFueSBjdXJyZW50IG5vZGVzXG4gKiB3aXRoaW4gdGhlIHRyZWUsIGFzIGEgY2hpbGQgb2YgdGhlIHJvb3Qgbm9kZS4gQSBwYXJhZ3JhcGggd2lsbCB0aGVuIGJlIGFkZGVkIGFmdGVyIHRoZSBpbnNlcnRlZCBub2RlIGFuZCBzZWxlY3RlZC5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgaW5zZXJ0ZWRcbiAqIEByZXR1cm5zIFRoZSBub2RlIGFmdGVyIGl0cyBpbnNlcnRpb25cbiAqL1xuZnVuY3Rpb24gJGluc2VydE5vZGVUb05lYXJlc3RSb290KG5vZGUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpIHx8ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICBsZXQgaW5pdGlhbENhcmV0O1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGluaXRpYWxDYXJldCA9ICRjYXJldEZyb21Qb2ludChzZWxlY3Rpb24uZm9jdXMsICduZXh0Jyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNlbGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgY29uc3QgbGFzdE5vZGUgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSkge1xuICAgICAgICBpbml0aWFsQ2FyZXQgPSAkZ2V0U2libGluZ0NhcmV0KGxhc3ROb2RlLCAnbmV4dCcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpbml0aWFsQ2FyZXQgPSBpbml0aWFsQ2FyZXQgfHwgJGdldENoaWxkQ2FyZXQoJGdldFJvb3QoKSwgJ3ByZXZpb3VzJykuZ2V0RmxpcHBlZCgpLmluc2VydCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKTtcbiAgfVxuICBjb25zdCBpbnNlcnRDYXJldCA9ICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdEF0Q2FyZXQobm9kZSwgaW5pdGlhbENhcmV0KTtcbiAgY29uc3QgYWRqYWNlbnQgPSAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0KGluc2VydENhcmV0KTtcbiAgY29uc3Qgc2VsZWN0aW9uQ2FyZXQgPSAkaXNDaGlsZENhcmV0KGFkamFjZW50KSA/ICRub3JtYWxpemVDYXJldChhZGphY2VudCkgOiBpbnNlcnRDYXJldDtcbiAgJHNldFNlbGVjdGlvbkZyb21DYXJldFJhbmdlKCRnZXRDb2xsYXBzZWRDYXJldFJhbmdlKHNlbGVjdGlvbkNhcmV0KSk7XG4gIHJldHVybiBub2RlLmdldExhdGVzdCgpO1xufVxuXG4vKipcbiAqIElmIHRoZSBpbnNlcnRpb24gY2FyZXQgaXMgdGhlIHJvb3Qvc2hhZG93IHJvb3Qgbm9kZSAoc2VlIHtAbGluayBsZXhpY2FsISRpc1Jvb3RPclNoYWRvd1Jvb3R9KSxcbiAqIHRoZSBub2RlIHdpbGwgYmUgaW5zZXJ0ZWQgdGhlcmUsIG90aGVyd2lzZSB0aGUgcGFyZW50IG5vZGVzIHdpbGwgYmUgc3BsaXQgYWNjb3JkaW5nIHRvIHRoZVxuICogZ2l2ZW4gb3B0aW9ucy5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgaW5zZXJ0ZWRcbiAqIEBwYXJhbSBjYXJldCAtIFRoZSBsb2NhdGlvbiB0byBpbnNlcnQgb3Igc3BsaXQgZnJvbVxuICogQHJldHVybnMgVGhlIG5vZGUgYWZ0ZXIgaXRzIGluc2VydGlvblxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3RBdENhcmV0KG5vZGUsIGNhcmV0LCBvcHRpb25zKSB7XG4gIGxldCBpbnNlcnRDYXJldCA9ICRnZXRDYXJldEluRGlyZWN0aW9uKGNhcmV0LCAnbmV4dCcpO1xuICBmb3IgKGxldCBuZXh0Q2FyZXQgPSBpbnNlcnRDYXJldDsgbmV4dENhcmV0OyBuZXh0Q2FyZXQgPSAkc3BsaXRBdFBvaW50Q2FyZXROZXh0KG5leHRDYXJldCwgb3B0aW9ucykpIHtcbiAgICBpbnNlcnRDYXJldCA9IG5leHRDYXJldDtcbiAgfVxuICBpZiAoISEkaXNUZXh0UG9pbnRDYXJldChpbnNlcnRDYXJldCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdEF0Q2FyZXQ6IEFuIHVuYXR0YWNoZWQgVGV4dE5vZGUgY2FuIG5vdCBiZSBzcGxpdGApO1xuICB9XG4gIGluc2VydENhcmV0Lmluc2VydChub2RlLmlzSW5saW5lKCkgPyAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpLmFwcGVuZChub2RlKSA6IG5vZGUpO1xuICByZXR1cm4gJGdldENhcmV0SW5EaXJlY3Rpb24oJGdldFNpYmxpbmdDYXJldChub2RlLmdldExhdGVzdCgpLCAnbmV4dCcpLCBjYXJldC5kaXJlY3Rpb24pO1xufVxuXG4vKipcbiAqIFdyYXBzIHRoZSBub2RlIGludG8gYW5vdGhlciBub2RlIGNyZWF0ZWQgZnJvbSBhIGNyZWF0ZUVsZW1lbnROb2RlIGZ1bmN0aW9uLCBlZy4gJGNyZWF0ZVBhcmFncmFwaE5vZGVcbiAqIEBwYXJhbSBub2RlIC0gTm9kZSB0byBiZSB3cmFwcGVkLlxuICogQHBhcmFtIGNyZWF0ZUVsZW1lbnROb2RlIC0gQ3JlYXRlcyBhIG5ldyBsZXhpY2FsIGVsZW1lbnQgdG8gd3JhcCB0aGUgdG8tYmUtd3JhcHBlZCBub2RlIGFuZCByZXR1cm5zIGl0LlxuICogQHJldHVybnMgQSBuZXcgbGV4aWNhbCBlbGVtZW50IHdpdGggdGhlIHByZXZpb3VzIG5vZGUgYXBwZW5kZWQgd2l0aGluIChhcyBhIGNoaWxkLCBpbmNsdWRpbmcgaXRzIGNoaWxkcmVuKS5cbiAqL1xuZnVuY3Rpb24gJHdyYXBOb2RlSW5FbGVtZW50KG5vZGUsIGNyZWF0ZUVsZW1lbnROb2RlKSB7XG4gIGNvbnN0IGVsZW1lbnROb2RlID0gY3JlYXRlRWxlbWVudE5vZGUoKTtcbiAgbm9kZS5yZXBsYWNlKGVsZW1lbnROb2RlKTtcbiAgZWxlbWVudE5vZGUuYXBwZW5kKG5vZGUpO1xuICByZXR1cm4gZWxlbWVudE5vZGU7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbi8qKlxuICogQHBhcmFtIG9iamVjdCA9IFRoZSBpbnN0YW5jZSBvZiB0aGUgdHlwZVxuICogQHBhcmFtIG9iamVjdENsYXNzID0gVGhlIGNsYXNzIG9mIHRoZSB0eXBlXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBvYmplY3QgaXMgaGFzIHRoZSBzYW1lIEtsYXNzIG9mIHRoZSBvYmplY3RDbGFzcywgaWdub3JpbmcgdGhlIGRpZmZlcmVuY2UgYWNyb3NzIHdpbmRvdyAoZS5nLiBkaWZmZXJlbnQgaWZyYW1lcylcbiAqL1xuZnVuY3Rpb24gb2JqZWN0S2xhc3NFcXVhbHMob2JqZWN0LCBvYmplY3RDbGFzcykge1xuICByZXR1cm4gb2JqZWN0ICE9PSBudWxsID8gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkuY29uc3RydWN0b3IubmFtZSA9PT0gb2JqZWN0Q2xhc3MubmFtZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEZpbHRlciB0aGUgbm9kZXNcbiAqIEBwYXJhbSBub2RlcyBBcnJheSBvZiBub2RlcyB0aGF0IG5lZWRzIHRvIGJlIGZpbHRlcmVkXG4gKiBAcGFyYW0gZmlsdGVyRm4gQSBmaWx0ZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIG5vZGUgaWYgdGhlIGN1cnJlbnQgbm9kZSBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiBvdGhlcndpc2UgbnVsbFxuICogQHJldHVybnMgQXJyYXkgb2YgZmlsdGVyZWQgbm9kZXNcbiAqL1xuXG5mdW5jdGlvbiAkZmlsdGVyKG5vZGVzLCBmaWx0ZXJGbikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBmaWx0ZXJGbihub2Rlc1tpXSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBBcHBlbmRzIHRoZSBub2RlIGJlZm9yZSB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIHBhcmVudCBub2RlXG4gKiBAcGFyYW0gcGFyZW50IEEgcGFyZW50IG5vZGVcbiAqIEBwYXJhbSBub2RlIE5vZGUgdGhhdCBuZWVkcyB0byBiZSBhcHBlbmRlZFxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Rmlyc3QocGFyZW50LCBub2RlKSB7XG4gICRnZXRDaGlsZENhcmV0KHBhcmVudCwgJ25leHQnKS5pbnNlcnQobm9kZSk7XG59XG5sZXQgTkVFRFNfTUFOVUFMX1pPT00gPSBJU19GSVJFRk9YIHx8ICFDQU5fVVNFX0RPTSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gbmVlZHNNYW51YWxab29tKCkge1xuICBpZiAoTkVFRFNfTUFOVUFMX1pPT00gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIElmIHRoZSBicm93c2VyIGltcGxlbWVudHMgc3RhbmRhcmRpemVkIENTUyB6b29tLCB0aGVuIHRoZSBjbGllbnQgcmVjdFxuICAgIC8vIHdpbGwgYmUgd2lkZXIgYWZ0ZXIgem9vbSBpcyBhcHBsaWVkXG4gICAgLy8gaHR0cHM6Ly9jaHJvbWVzdGF0dXMuY29tL2ZlYXR1cmUvNTE5ODI1NDg2ODUyOTE1MlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9sZXhpY2FsL2lzc3Vlcy82ODYzXG4gICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyBvcGFjaXR5OiAwOyB3aWR0aDogMTAwcHg7IGxlZnQ6IC0xMDAwcHg7JztcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpdik7XG4gICAgY29uc3Qgbm9ab29tID0gZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGRpdi5zdHlsZS5zZXRQcm9wZXJ0eSgnem9vbScsICcyJyk7XG4gICAgTkVFRFNfTUFOVUFMX1pPT00gPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPT09IG5vWm9vbS53aWR0aDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG4gIH1cbiAgcmV0dXJuIE5FRURTX01BTlVBTF9aT09NO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHpvb20gbGV2ZWwgb2YgYW4gZWxlbWVudCBhcyBhIHJlc3VsdCBvZiB1c2luZ1xuICogY3NzIHpvb20gcHJvcGVydHkuIEZvciBicm93c2VycyB0aGF0IGltcGxlbWVudCBzdGFuZGFyZGl6ZWQgQ1NTXG4gKiB6b29tIChGaXJlZm94LCBDaHJvbWUgPj0gMTI4KSwgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gMS5cbiAqIEBwYXJhbSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZVpvb21MZXZlbChlbGVtZW50KSB7XG4gIGxldCB6b29tID0gMTtcbiAgaWYgKG5lZWRzTWFudWFsWm9vbSgpKSB7XG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgIHpvb20gKj0gTnVtYmVyKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3pvb20nKSk7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gem9vbTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGVkaXRvciBpcyBhIG5lc3RlZCBlZGl0b3IgY3JlYXRlZCBieSBMZXhpY2FsTmVzdGVkQ29tcG9zZXJcbiAqL1xuZnVuY3Rpb24gJGlzRWRpdG9ySXNOZXN0ZWRFZGl0b3IoZWRpdG9yKSB7XG4gIHJldHVybiBlZGl0b3IuX3BhcmVudEVkaXRvciAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBBIGRlcHRoIGZpcnN0IGxhc3QtdG8tZmlyc3QgdHJhdmVyc2FsIG9mIHJvb3QgdGhhdCBzdG9wcyBhdCBlYWNoIG5vZGUgdGhhdCBtYXRjaGVzXG4gKiAkcHJlZGljYXRlIGFuZCBlbnN1cmVzIHRoYXQgaXRzIHBhcmVudCBpcyByb290LiBUaGlzIGlzIHR5cGljYWxseSB1c2VkIHRvIGRpc2NhcmRcbiAqIGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgd3JhcHBpbmcgbm9kZXMuIEZvciBleGFtcGxlLCBhIFRhYmxlTm9kZSBtdXN0IG9ubHkgaGF2ZVxuICogVGFibGVSb3dOb2RlIGFzIGNoaWxkcmVuLCBidXQgYW4gaW1wb3J0ZXIgbWlnaHQgYWRkIGludmFsaWQgbm9kZXMgYmFzZWQgb25cbiAqIGNhcHRpb24sIHRib2R5LCB0aGVhZCwgZXRjLiBhbmQgdGhpcyB3aWxsIHVud3JhcCBhbmQgZGlzY2FyZCB0aG9zZS5cbiAqXG4gKiBAcGFyYW0gcm9vdCBUaGUgcm9vdCB0byBzdGFydCB0aGUgdHJhdmVyc2FsXG4gKiBAcGFyYW0gJHByZWRpY2F0ZSBTaG91bGQgcmV0dXJuIHRydWUgZm9yIG5vZGVzIHRoYXQgYXJlIHBlcm1pdHRlZCB0byBiZSBjaGlsZHJlbiBvZiByb290XG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoaXMgdW53cmFwcGVkIG9yIHJlbW92ZWQgYW55IG5vZGVzXG4gKi9cbmZ1bmN0aW9uICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50cyhyb290LCAkcHJlZGljYXRlKSB7XG4gIHJldHVybiAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHNJbXBsKHJvb3QsICRwcmVkaWNhdGUsIG51bGwpO1xufVxuZnVuY3Rpb24gJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzSW1wbChyb290LCAkcHJlZGljYXRlLCAkb25TdWNjZXNzKSB7XG4gIGxldCBkaWRNdXRhdGUgPSBmYWxzZTtcbiAgZm9yIChjb25zdCBub2RlIG9mICRsYXN0VG9GaXJzdEl0ZXJhdG9yKHJvb3QpKSB7XG4gICAgaWYgKCRwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgIGlmICgkb25TdWNjZXNzICE9PSBudWxsKSB7XG4gICAgICAgICRvblN1Y2Nlc3Mobm9kZSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZGlkTXV0YXRlID0gdHJ1ZTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50c0ltcGwobm9kZSwgJHByZWRpY2F0ZSwgJG9uU3VjY2VzcyB8fCAoY2hpbGQgPT4gbm9kZS5pbnNlcnRBZnRlcihjaGlsZCkpKTtcbiAgICB9XG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgfVxuICByZXR1cm4gZGlkTXV0YXRlO1xufVxuXG4vKipcbiAqIEEgZGVwdGggZmlyc3QgdHJhdmVyc2FsIG9mIHRoZSBjaGlsZHJlbiBhcnJheSB0aGF0IHN0b3BzIGF0IGFuZCBjb2xsZWN0c1xuICogZWFjaCBub2RlIHRoYXQgYCRwcmVkaWNhdGVgIG1hdGNoZXMuIFRoaXMgaXMgdHlwaWNhbGx5IHVzZWQgdG8gZGlzY2FyZFxuICogaW52YWxpZCBvciB1bnN1cHBvcnRlZCB3cmFwcGluZyBub2RlcyBvbiBhIGNoaWxkcmVuIGFycmF5IGluIHRoZSBgYWZ0ZXJgXG4gKiBvZiBhbiB7QGxpbmsgbGV4aWNhbCFET01Db252ZXJzaW9uT3V0cHV0fS4gRm9yIGV4YW1wbGUsIGEgVGFibGVOb2RlIG11c3Qgb25seSBoYXZlXG4gKiBUYWJsZVJvd05vZGUgYXMgY2hpbGRyZW4sIGJ1dCBhbiBpbXBvcnRlciBtaWdodCBhZGQgaW52YWxpZCBub2RlcyBiYXNlZCBvblxuICogY2FwdGlvbiwgdGJvZHksIHRoZWFkLCBldGMuIGFuZCB0aGlzIHdpbGwgdW53cmFwIGFuZCBkaXNjYXJkIHRob3NlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVhZC1vbmx5IGFuZCBwZXJmb3JtcyBubyBtdXRhdGlvbiBvcGVyYXRpb25zLCB3aGljaCBtYWtlc1xuICogaXQgc3VpdGFibGUgZm9yIGltcG9ydCBhbmQgZXhwb3J0IHB1cnBvc2VzIGJ1dCBsaWtlbHkgbm90IGZvciBhbnkgaW4tcGxhY2VcbiAqIG11dGF0aW9uLiBZb3Ugc2hvdWxkIHVzZSB7QGxpbmsgJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzfSBmb3IgaW4tcGxhY2VcbiAqIG11dGF0aW9ucyBzdWNoIGFzIG5vZGUgdHJhbnNmb3Jtcy5cbiAqXG4gKiBAcGFyYW0gY2hpbGRyZW4gVGhlIGNoaWxkcmVuIHRvIHRyYXZlcnNlXG4gKiBAcGFyYW0gJHByZWRpY2F0ZSBTaG91bGQgcmV0dXJuIHRydWUgZm9yIG5vZGVzIHRoYXQgYXJlIHBlcm1pdHRlZCB0byBiZSBjaGlsZHJlbiBvZiByb290XG4gKiBAcmV0dXJucyBUaGUgY2hpbGRyZW4gb3IgdGhlaXIgZGVzY2VuZGFudHMgdGhhdCBtYXRjaCAkcHJlZGljYXRlXG4gKi9cblxuZnVuY3Rpb24gJGRlc2NlbmRhbnRzTWF0Y2hpbmcoY2hpbGRyZW4sICRwcmVkaWNhdGUpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHN0YWNrID0gQXJyYXkuZnJvbShjaGlsZHJlbikucmV2ZXJzZSgpO1xuICBmb3IgKGxldCBjaGlsZCA9IHN0YWNrLnBvcCgpOyBjaGlsZCAhPT0gdW5kZWZpbmVkOyBjaGlsZCA9IHN0YWNrLnBvcCgpKSB7XG4gICAgaWYgKCRwcmVkaWNhdGUoY2hpbGQpKSB7XG4gICAgICByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JhbmRjaGlsZCBvZiAkbGFzdFRvRmlyc3RJdGVyYXRvcihjaGlsZCkpIHtcbiAgICAgICAgc3RhY2sucHVzaChncmFuZGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gaXRlcmF0b3IgdGhhdCB5aWVsZHMgZWFjaCBjaGlsZCBvZiBub2RlIGZyb20gZmlyc3QgdG8gbGFzdCwgdGFraW5nXG4gKiBjYXJlIHRvIHByZXNlcnZlIHRoZSBuZXh0IHNpYmxpbmcgYmVmb3JlIHlpZWxkaW5nIHRoZSB2YWx1ZSBpbiBjYXNlIHRoZSBjYWxsZXJcbiAqIHJlbW92ZXMgdGhlIHlpZWxkZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB3aG9zZSBjaGlsZHJlbiB0byBpdGVyYXRlXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciBvZiB0aGUgbm9kZSdzIGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uICRmaXJzdFRvTGFzdEl0ZXJhdG9yKG5vZGUpIHtcbiAgcmV0dXJuICRjaGlsZEl0ZXJhdG9yKCRnZXRDaGlsZENhcmV0KG5vZGUsICduZXh0JykpO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBpdGVyYXRvciB0aGF0IHlpZWxkcyBlYWNoIGNoaWxkIG9mIG5vZGUgZnJvbSBsYXN0IHRvIGZpcnN0LCB0YWtpbmdcbiAqIGNhcmUgdG8gcHJlc2VydmUgdGhlIHByZXZpb3VzIHNpYmxpbmcgYmVmb3JlIHlpZWxkaW5nIHRoZSB2YWx1ZSBpbiBjYXNlIHRoZSBjYWxsZXJcbiAqIHJlbW92ZXMgdGhlIHlpZWxkZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB3aG9zZSBjaGlsZHJlbiB0byBpdGVyYXRlXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciBvZiB0aGUgbm9kZSdzIGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uICRsYXN0VG9GaXJzdEl0ZXJhdG9yKG5vZGUpIHtcbiAgcmV0dXJuICRjaGlsZEl0ZXJhdG9yKCRnZXRDaGlsZENhcmV0KG5vZGUsICdwcmV2aW91cycpKTtcbn1cbmZ1bmN0aW9uICRjaGlsZEl0ZXJhdG9yKHN0YXJ0Q2FyZXQpIHtcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKSA7XG4gIHJldHVybiBtYWtlU3RlcHdpc2VJdGVyYXRvcih7XG4gICAgaGFzTmV4dDogJGlzU2libGluZ0NhcmV0LFxuICAgIGluaXRpYWw6IHN0YXJ0Q2FyZXQuZ2V0QWRqYWNlbnRDYXJldCgpLFxuICAgIG1hcDogY2FyZXQgPT4ge1xuICAgICAgY29uc3Qgb3JpZ2luID0gY2FyZXQub3JpZ2luLmdldExhdGVzdCgpO1xuICAgICAgaWYgKHNlZW4gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gb3JpZ2luLmdldEtleSgpO1xuICAgICAgICBpZiAoISFzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkY2hpbGRJdGVyYXRvcjogQ3ljbGUgZGV0ZWN0ZWQsIG5vZGUgd2l0aCBrZXkgJHtTdHJpbmcoa2V5KX0gaGFzIGFscmVhZHkgYmVlbiB0cmF2ZXJzZWRgKTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9LFxuICAgIHN0ZXA6IGNhcmV0ID0+IGNhcmV0LmdldEFkamFjZW50Q2FyZXQoKVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXBsYWNlIHRoaXMgbm9kZSB3aXRoIGl0cyBjaGlsZHJlblxuICpcbiAqIEBwYXJhbSBub2RlIFRoZSBFbGVtZW50Tm9kZSB0byB1bndyYXAgYW5kIHJlbW92ZVxuICovXG5mdW5jdGlvbiAkdW53cmFwTm9kZShub2RlKSB7XG4gICRyZXdpbmRTaWJsaW5nQ2FyZXQoJGdldFNpYmxpbmdDYXJldChub2RlLCAnbmV4dCcpKS5zcGxpY2UoMSwgbm9kZS5nZXRDaGlsZHJlbigpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBOb2RlIHNpYmxpbmcgd2hlbiB0aGlzIGV4aXN0cywgb3RoZXJ3aXNlIHRoZSBjbG9zZXN0IHBhcmVudCBzaWJsaW5nLiBGb3IgZXhhbXBsZVxuICogUiAtPiBQIC0+IFQxLCBUMlxuICogICAtPiBQMlxuICogcmV0dXJucyBUMiBmb3Igbm9kZSBUMSwgUDIgZm9yIG5vZGUgVDIsIGFuZCBudWxsIGZvciBub2RlIFAyLlxuICogQHBhcmFtIG5vZGUgTGV4aWNhbE5vZGUuXG4gKiBAcmV0dXJucyBBbiBhcnJheSAodHVwbGUpIGNvbnRhaW5pbmcgdGhlIGZvdW5kIExleGljYWwgbm9kZSBhbmQgdGhlIGRlcHRoIGRpZmZlcmVuY2UsIG9yIG51bGwsIGlmIHRoaXMgbm9kZSBkb2Vzbid0IGV4aXN0LlxuICovXG5mdW5jdGlvbiAkZ2V0QWRqYWNlbnRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nQ2FyZXQoc3RhcnRDYXJldCwgcm9vdE1vZGUgPSAncm9vdCcpIHtcbiAgbGV0IGRlcHRoRGlmZiA9IDA7XG4gIGxldCBjYXJldCA9IHN0YXJ0Q2FyZXQ7XG4gIGxldCBuZXh0Q2FyZXQgPSAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0KGNhcmV0KTtcbiAgd2hpbGUgKG5leHRDYXJldCA9PT0gbnVsbCkge1xuICAgIGRlcHRoRGlmZi0tO1xuICAgIG5leHRDYXJldCA9IGNhcmV0LmdldFBhcmVudENhcmV0KHJvb3RNb2RlKTtcbiAgICBpZiAoIW5leHRDYXJldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNhcmV0ID0gbmV4dENhcmV0O1xuICAgIG5leHRDYXJldCA9ICRnZXRBZGphY2VudENoaWxkQ2FyZXQoY2FyZXQpO1xuICB9XG4gIHJldHVybiBuZXh0Q2FyZXQgJiYgW25leHRDYXJldCwgZGVwdGhEaWZmXTtcbn1cblxuLyoqXG4gKiBBIHdyYXBwZXIgdGhhdCBjcmVhdGVzIGJvdW5kIGZ1bmN0aW9ucyBhbmQgbWV0aG9kcyBmb3IgdGhlXG4gKiBTdGF0ZUNvbmZpZyB0byBzYXZlIHNvbWUgYm9pbGVycGxhdGUgd2hlbiBkZWZpbmluZyBtZXRob2RzXG4gKiBvciBleHBvcnRpbmcgb25seSB0aGUgYWNjZXNzb3JzIGZyb20geW91ciBtb2R1bGVzIHJhdGhlclxuICogdGhhbiBleHBvc2luZyB0aGUgU3RhdGVDb25maWcgZGlyZWN0bHkuXG4gKi9cblxuLyoqXG4gKiBFWFBFUklNRU5UQUxcbiAqXG4gKiBBIGNvbnZlbmllbmNlIGludGVyZmFjZSBmb3Igd29ya2luZyB3aXRoIHtAbGluayAkZ2V0U3RhdGV9IGFuZFxuICoge0BsaW5rICRzZXRTdGF0ZX0uXG4gKlxuICogQHBhcmFtIHN0YXRlQ29uZmlnIFRoZSBzdGF0ZUNvbmZpZyB0byB3cmFwIHdpdGggY29udmVuaWVuY2UgZnVuY3Rpb25hbGl0eVxuICogQHJldHVybnMgYSBTdGF0ZVdyYXBwZXJcbiAqL1xuZnVuY3Rpb24gbWFrZVN0YXRlV3JhcHBlcihzdGF0ZUNvbmZpZykge1xuICBjb25zdCAkZ2V0ID0gbm9kZSA9PiAkZ2V0U3RhdGUobm9kZSwgc3RhdGVDb25maWcpO1xuICBjb25zdCAkc2V0ID0gKG5vZGUsIHZhbHVlT3JVcGRhdGVyKSA9PiAkc2V0U3RhdGUobm9kZSwgc3RhdGVDb25maWcsIHZhbHVlT3JVcGRhdGVyKTtcbiAgcmV0dXJuIHtcbiAgICAkZ2V0LFxuICAgICRzZXQsXG4gICAgYWNjZXNzb3JzOiBbJGdldCwgJHNldF0sXG4gICAgbWFrZUdldHRlck1ldGhvZDogKCkgPT4gZnVuY3Rpb24gJGdldHRlcigpIHtcbiAgICAgIHJldHVybiAkZ2V0KHRoaXMpO1xuICAgIH0sXG4gICAgbWFrZVNldHRlck1ldGhvZDogKCkgPT4gZnVuY3Rpb24gJHNldHRlcih2YWx1ZU9yVXBkYXRlcikge1xuICAgICAgcmV0dXJuICRzZXQodGhpcywgdmFsdWVPclVwZGF0ZXIpO1xuICAgIH0sXG4gICAgc3RhdGVDb25maWdcbiAgfTtcbn1cblxuZXhwb3J0IHsgJGRlc2NlbmRhbnRzTWF0Y2hpbmcsICRkZnMsICRkZnNJdGVyYXRvciwgJGZpbHRlciwgJGZpbmRNYXRjaGluZ1BhcmVudCwgJGZpcnN0VG9MYXN0SXRlcmF0b3IsICRnZXRBZGphY2VudENhcmV0LCAkZ2V0QWRqYWNlbnRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nQ2FyZXQsICRnZXREZXB0aCwgJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3csICRnZXROZWFyZXN0Tm9kZU9mVHlwZSwgJGdldE5leHRSaWdodFByZW9yZGVyTm9kZSwgJGdldE5leHRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nLCAkaW5zZXJ0Rmlyc3QsICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCwgJGluc2VydE5vZGVUb05lYXJlc3RSb290QXRDYXJldCwgJGlzRWRpdG9ySXNOZXN0ZWRFZGl0b3IsICRsYXN0VG9GaXJzdEl0ZXJhdG9yLCAkcmVzdG9yZUVkaXRvclN0YXRlLCAkcmV2ZXJzZURmcywgJHJldmVyc2VEZnNJdGVyYXRvciwgJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzLCAkdW53cmFwTm9kZSwgJHdyYXBOb2RlSW5FbGVtZW50LCBDQU5fVVNFX0JFRk9SRV9JTlBVVCwgQ0FOX1VTRV9ET00sIElTX0FORFJPSUQsIElTX0FORFJPSURfQ0hST01FLCBJU19BUFBMRSwgSVNfQVBQTEVfV0VCS0lULCBJU19DSFJPTUUsIElTX0ZJUkVGT1gsIElTX0lPUywgSVNfU0FGQVJJLCBhZGRDbGFzc05hbWVzVG9FbGVtZW50LCBjYWxjdWxhdGVab29tTGV2ZWwsIGlzTWltZVR5cGUsIG1ha2VTdGF0ZVdyYXBwZXIsIG1hcmtTZWxlY3Rpb24sIG1lZGlhRmlsZVJlYWRlciwgbWVyZ2VSZWdpc3Rlciwgb2JqZWN0S2xhc3NFcXVhbHMsIG1sY1Bvc2l0aW9uTm9kZU9uUmFuZ2UgYXMgcG9zaXRpb25Ob2RlT25SYW5nZSwgcmVnaXN0ZXJOZXN0ZWRFbGVtZW50UmVzb2x2ZXIsIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCwgc2VsZWN0aW9uQWx3YXlzT25EaXNwbGF5IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@lexical/utils/LexicalUtils.dev.mjs\n"));

/***/ }),

/***/ "./node_modules/lexical/Lexical.dev.mjs":
/*!**********************************************!*\
  !*** ./node_modules/lexical/Lexical.dev.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addUpdateTag: function() { return /* binding */ $addUpdateTag; },\n/* harmony export */   $applyNodeReplacement: function() { return /* binding */ $applyNodeReplacement; },\n/* harmony export */   $caretFromPoint: function() { return /* binding */ $caretFromPoint; },\n/* harmony export */   $caretRangeFromSelection: function() { return /* binding */ $caretRangeFromSelection; },\n/* harmony export */   $cloneWithProperties: function() { return /* binding */ $cloneWithProperties; },\n/* harmony export */   $comparePointCaretNext: function() { return /* binding */ $comparePointCaretNext; },\n/* harmony export */   $copyNode: function() { return /* binding */ $copyNode; },\n/* harmony export */   $create: function() { return /* binding */ $create; },\n/* harmony export */   $createLineBreakNode: function() { return /* binding */ $createLineBreakNode; },\n/* harmony export */   $createNodeSelection: function() { return /* binding */ $createNodeSelection; },\n/* harmony export */   $createParagraphNode: function() { return /* binding */ $createParagraphNode; },\n/* harmony export */   $createPoint: function() { return /* binding */ $createPoint; },\n/* harmony export */   $createRangeSelection: function() { return /* binding */ $createRangeSelection; },\n/* harmony export */   $createRangeSelectionFromDom: function() { return /* binding */ $createRangeSelectionFromDom; },\n/* harmony export */   $createTabNode: function() { return /* binding */ $createTabNode; },\n/* harmony export */   $createTextNode: function() { return /* binding */ $createTextNode; },\n/* harmony export */   $extendCaretToRange: function() { return /* binding */ $extendCaretToRange; },\n/* harmony export */   $getAdjacentChildCaret: function() { return /* binding */ $getAdjacentChildCaret; },\n/* harmony export */   $getAdjacentNode: function() { return /* binding */ $getAdjacentNode; },\n/* harmony export */   $getAdjacentSiblingOrParentSiblingCaret: function() { return /* binding */ $getAdjacentSiblingOrParentSiblingCaret; },\n/* harmony export */   $getCaretInDirection: function() { return /* binding */ $getCaretInDirection; },\n/* harmony export */   $getCaretRange: function() { return /* binding */ $getCaretRange; },\n/* harmony export */   $getCaretRangeInDirection: function() { return /* binding */ $getCaretRangeInDirection; },\n/* harmony export */   $getCharacterOffsets: function() { return /* binding */ $getCharacterOffsets; },\n/* harmony export */   $getChildCaret: function() { return /* binding */ $getChildCaret; },\n/* harmony export */   $getChildCaretAtIndex: function() { return /* binding */ $getChildCaretAtIndex; },\n/* harmony export */   $getChildCaretOrSelf: function() { return /* binding */ $getChildCaretOrSelf; },\n/* harmony export */   $getCollapsedCaretRange: function() { return /* binding */ $getCollapsedCaretRange; },\n/* harmony export */   $getCommonAncestor: function() { return /* binding */ $getCommonAncestor; },\n/* harmony export */   $getCommonAncestorResultBranchOrder: function() { return /* binding */ $getCommonAncestorResultBranchOrder; },\n/* harmony export */   $getEditor: function() { return /* binding */ $getEditor; },\n/* harmony export */   $getNearestNodeFromDOMNode: function() { return /* binding */ $getNearestNodeFromDOMNode; },\n/* harmony export */   $getNearestRootOrShadowRoot: function() { return /* binding */ $getNearestRootOrShadowRoot; },\n/* harmony export */   $getNodeByKey: function() { return /* binding */ $getNodeByKey; },\n/* harmony export */   $getNodeByKeyOrThrow: function() { return /* binding */ $getNodeByKeyOrThrow; },\n/* harmony export */   $getPreviousSelection: function() { return /* binding */ $getPreviousSelection; },\n/* harmony export */   $getRoot: function() { return /* binding */ $getRoot; },\n/* harmony export */   $getSelection: function() { return /* binding */ $getSelection; },\n/* harmony export */   $getSiblingCaret: function() { return /* binding */ $getSiblingCaret; },\n/* harmony export */   $getState: function() { return /* binding */ $getState; },\n/* harmony export */   $getStateChange: function() { return /* binding */ $getStateChange; },\n/* harmony export */   $getTextContent: function() { return /* binding */ $getTextContent; },\n/* harmony export */   $getTextNodeOffset: function() { return /* binding */ $getTextNodeOffset; },\n/* harmony export */   $getTextPointCaret: function() { return /* binding */ $getTextPointCaret; },\n/* harmony export */   $getTextPointCaretSlice: function() { return /* binding */ $getTextPointCaretSlice; },\n/* harmony export */   $getWritableNodeState: function() { return /* binding */ $getWritableNodeState; },\n/* harmony export */   $hasAncestor: function() { return /* binding */ $hasAncestor; },\n/* harmony export */   $hasUpdateTag: function() { return /* binding */ $hasUpdateTag; },\n/* harmony export */   $insertNodes: function() { return /* binding */ $insertNodes; },\n/* harmony export */   $isBlockElementNode: function() { return /* binding */ $isBlockElementNode; },\n/* harmony export */   $isChildCaret: function() { return /* binding */ $isChildCaret; },\n/* harmony export */   $isDecoratorNode: function() { return /* binding */ $isDecoratorNode; },\n/* harmony export */   $isElementNode: function() { return /* binding */ $isElementNode; },\n/* harmony export */   $isExtendableTextPointCaret: function() { return /* binding */ $isExtendableTextPointCaret; },\n/* harmony export */   $isInlineElementOrDecoratorNode: function() { return /* binding */ $isInlineElementOrDecoratorNode; },\n/* harmony export */   $isLeafNode: function() { return /* binding */ $isLeafNode; },\n/* harmony export */   $isLineBreakNode: function() { return /* binding */ $isLineBreakNode; },\n/* harmony export */   $isNodeCaret: function() { return /* binding */ $isNodeCaret; },\n/* harmony export */   $isNodeSelection: function() { return /* binding */ $isNodeSelection; },\n/* harmony export */   $isParagraphNode: function() { return /* binding */ $isParagraphNode; },\n/* harmony export */   $isRangeSelection: function() { return /* binding */ $isRangeSelection; },\n/* harmony export */   $isRootNode: function() { return /* binding */ $isRootNode; },\n/* harmony export */   $isRootOrShadowRoot: function() { return /* binding */ $isRootOrShadowRoot; },\n/* harmony export */   $isSiblingCaret: function() { return /* binding */ $isSiblingCaret; },\n/* harmony export */   $isTabNode: function() { return /* binding */ $isTabNode; },\n/* harmony export */   $isTextNode: function() { return /* binding */ $isTextNode; },\n/* harmony export */   $isTextPointCaret: function() { return /* binding */ $isTextPointCaret; },\n/* harmony export */   $isTextPointCaretSlice: function() { return /* binding */ $isTextPointCaretSlice; },\n/* harmony export */   $isTokenOrSegmented: function() { return /* binding */ $isTokenOrSegmented; },\n/* harmony export */   $isTokenOrTab: function() { return /* binding */ $isTokenOrTab; },\n/* harmony export */   $nodesOfType: function() { return /* binding */ $nodesOfType; },\n/* harmony export */   $normalizeCaret: function() { return /* binding */ $normalizeCaret; },\n/* harmony export */   $normalizeSelection__EXPERIMENTAL: function() { return /* binding */ $normalizeSelection; },\n/* harmony export */   $onUpdate: function() { return /* binding */ $onUpdate; },\n/* harmony export */   $parseSerializedNode: function() { return /* binding */ $parseSerializedNode; },\n/* harmony export */   $removeTextFromCaretRange: function() { return /* binding */ $removeTextFromCaretRange; },\n/* harmony export */   $rewindSiblingCaret: function() { return /* binding */ $rewindSiblingCaret; },\n/* harmony export */   $selectAll: function() { return /* binding */ $selectAll; },\n/* harmony export */   $setCompositionKey: function() { return /* binding */ $setCompositionKey; },\n/* harmony export */   $setPointFromCaret: function() { return /* binding */ $setPointFromCaret; },\n/* harmony export */   $setSelection: function() { return /* binding */ $setSelection; },\n/* harmony export */   $setSelectionFromCaretRange: function() { return /* binding */ $setSelectionFromCaretRange; },\n/* harmony export */   $setState: function() { return /* binding */ $setState; },\n/* harmony export */   $splitAtPointCaretNext: function() { return /* binding */ $splitAtPointCaretNext; },\n/* harmony export */   $splitNode: function() { return /* binding */ $splitNode; },\n/* harmony export */   $updateRangeSelectionFromCaretRange: function() { return /* binding */ $updateRangeSelectionFromCaretRange; },\n/* harmony export */   ArtificialNode__DO_NOT_USE: function() { return /* binding */ ArtificialNode__DO_NOT_USE; },\n/* harmony export */   BLUR_COMMAND: function() { return /* binding */ BLUR_COMMAND; },\n/* harmony export */   CAN_REDO_COMMAND: function() { return /* binding */ CAN_REDO_COMMAND; },\n/* harmony export */   CAN_UNDO_COMMAND: function() { return /* binding */ CAN_UNDO_COMMAND; },\n/* harmony export */   CLEAR_EDITOR_COMMAND: function() { return /* binding */ CLEAR_EDITOR_COMMAND; },\n/* harmony export */   CLEAR_HISTORY_COMMAND: function() { return /* binding */ CLEAR_HISTORY_COMMAND; },\n/* harmony export */   CLICK_COMMAND: function() { return /* binding */ CLICK_COMMAND; },\n/* harmony export */   COLLABORATION_TAG: function() { return /* binding */ COLLABORATION_TAG; },\n/* harmony export */   COMMAND_PRIORITY_CRITICAL: function() { return /* binding */ COMMAND_PRIORITY_CRITICAL; },\n/* harmony export */   COMMAND_PRIORITY_EDITOR: function() { return /* binding */ COMMAND_PRIORITY_EDITOR; },\n/* harmony export */   COMMAND_PRIORITY_HIGH: function() { return /* binding */ COMMAND_PRIORITY_HIGH; },\n/* harmony export */   COMMAND_PRIORITY_LOW: function() { return /* binding */ COMMAND_PRIORITY_LOW; },\n/* harmony export */   COMMAND_PRIORITY_NORMAL: function() { return /* binding */ COMMAND_PRIORITY_NORMAL; },\n/* harmony export */   CONTROLLED_TEXT_INSERTION_COMMAND: function() { return /* binding */ CONTROLLED_TEXT_INSERTION_COMMAND; },\n/* harmony export */   COPY_COMMAND: function() { return /* binding */ COPY_COMMAND; },\n/* harmony export */   CUT_COMMAND: function() { return /* binding */ CUT_COMMAND; },\n/* harmony export */   DELETE_CHARACTER_COMMAND: function() { return /* binding */ DELETE_CHARACTER_COMMAND; },\n/* harmony export */   DELETE_LINE_COMMAND: function() { return /* binding */ DELETE_LINE_COMMAND; },\n/* harmony export */   DELETE_WORD_COMMAND: function() { return /* binding */ DELETE_WORD_COMMAND; },\n/* harmony export */   DRAGEND_COMMAND: function() { return /* binding */ DRAGEND_COMMAND; },\n/* harmony export */   DRAGOVER_COMMAND: function() { return /* binding */ DRAGOVER_COMMAND; },\n/* harmony export */   DRAGSTART_COMMAND: function() { return /* binding */ DRAGSTART_COMMAND; },\n/* harmony export */   DROP_COMMAND: function() { return /* binding */ DROP_COMMAND; },\n/* harmony export */   DecoratorNode: function() { return /* binding */ DecoratorNode; },\n/* harmony export */   ElementNode: function() { return /* binding */ ElementNode; },\n/* harmony export */   FOCUS_COMMAND: function() { return /* binding */ FOCUS_COMMAND; },\n/* harmony export */   FORMAT_ELEMENT_COMMAND: function() { return /* binding */ FORMAT_ELEMENT_COMMAND; },\n/* harmony export */   FORMAT_TEXT_COMMAND: function() { return /* binding */ FORMAT_TEXT_COMMAND; },\n/* harmony export */   HISTORIC_TAG: function() { return /* binding */ HISTORIC_TAG; },\n/* harmony export */   HISTORY_MERGE_TAG: function() { return /* binding */ HISTORY_MERGE_TAG; },\n/* harmony export */   HISTORY_PUSH_TAG: function() { return /* binding */ HISTORY_PUSH_TAG; },\n/* harmony export */   INDENT_CONTENT_COMMAND: function() { return /* binding */ INDENT_CONTENT_COMMAND; },\n/* harmony export */   INSERT_LINE_BREAK_COMMAND: function() { return /* binding */ INSERT_LINE_BREAK_COMMAND; },\n/* harmony export */   INSERT_PARAGRAPH_COMMAND: function() { return /* binding */ INSERT_PARAGRAPH_COMMAND; },\n/* harmony export */   INSERT_TAB_COMMAND: function() { return /* binding */ INSERT_TAB_COMMAND; },\n/* harmony export */   INTERNAL_$isBlock: function() { return /* binding */ INTERNAL_$isBlock; },\n/* harmony export */   IS_ALL_FORMATTING: function() { return /* binding */ IS_ALL_FORMATTING; },\n/* harmony export */   IS_BOLD: function() { return /* binding */ IS_BOLD; },\n/* harmony export */   IS_CODE: function() { return /* binding */ IS_CODE; },\n/* harmony export */   IS_HIGHLIGHT: function() { return /* binding */ IS_HIGHLIGHT; },\n/* harmony export */   IS_ITALIC: function() { return /* binding */ IS_ITALIC; },\n/* harmony export */   IS_STRIKETHROUGH: function() { return /* binding */ IS_STRIKETHROUGH; },\n/* harmony export */   IS_SUBSCRIPT: function() { return /* binding */ IS_SUBSCRIPT; },\n/* harmony export */   IS_SUPERSCRIPT: function() { return /* binding */ IS_SUPERSCRIPT; },\n/* harmony export */   IS_UNDERLINE: function() { return /* binding */ IS_UNDERLINE; },\n/* harmony export */   KEY_ARROW_DOWN_COMMAND: function() { return /* binding */ KEY_ARROW_DOWN_COMMAND; },\n/* harmony export */   KEY_ARROW_LEFT_COMMAND: function() { return /* binding */ KEY_ARROW_LEFT_COMMAND; },\n/* harmony export */   KEY_ARROW_RIGHT_COMMAND: function() { return /* binding */ KEY_ARROW_RIGHT_COMMAND; },\n/* harmony export */   KEY_ARROW_UP_COMMAND: function() { return /* binding */ KEY_ARROW_UP_COMMAND; },\n/* harmony export */   KEY_BACKSPACE_COMMAND: function() { return /* binding */ KEY_BACKSPACE_COMMAND; },\n/* harmony export */   KEY_DELETE_COMMAND: function() { return /* binding */ KEY_DELETE_COMMAND; },\n/* harmony export */   KEY_DOWN_COMMAND: function() { return /* binding */ KEY_DOWN_COMMAND; },\n/* harmony export */   KEY_ENTER_COMMAND: function() { return /* binding */ KEY_ENTER_COMMAND; },\n/* harmony export */   KEY_ESCAPE_COMMAND: function() { return /* binding */ KEY_ESCAPE_COMMAND; },\n/* harmony export */   KEY_MODIFIER_COMMAND: function() { return /* binding */ KEY_MODIFIER_COMMAND; },\n/* harmony export */   KEY_SPACE_COMMAND: function() { return /* binding */ KEY_SPACE_COMMAND; },\n/* harmony export */   KEY_TAB_COMMAND: function() { return /* binding */ KEY_TAB_COMMAND; },\n/* harmony export */   LineBreakNode: function() { return /* binding */ LineBreakNode; },\n/* harmony export */   MOVE_TO_END: function() { return /* binding */ MOVE_TO_END; },\n/* harmony export */   MOVE_TO_START: function() { return /* binding */ MOVE_TO_START; },\n/* harmony export */   NODE_STATE_KEY: function() { return /* binding */ NODE_STATE_KEY; },\n/* harmony export */   OUTDENT_CONTENT_COMMAND: function() { return /* binding */ OUTDENT_CONTENT_COMMAND; },\n/* harmony export */   PASTE_COMMAND: function() { return /* binding */ PASTE_COMMAND; },\n/* harmony export */   PASTE_TAG: function() { return /* binding */ PASTE_TAG; },\n/* harmony export */   ParagraphNode: function() { return /* binding */ ParagraphNode; },\n/* harmony export */   REDO_COMMAND: function() { return /* binding */ REDO_COMMAND; },\n/* harmony export */   REMOVE_TEXT_COMMAND: function() { return /* binding */ REMOVE_TEXT_COMMAND; },\n/* harmony export */   RootNode: function() { return /* binding */ RootNode; },\n/* harmony export */   SELECTION_CHANGE_COMMAND: function() { return /* binding */ SELECTION_CHANGE_COMMAND; },\n/* harmony export */   SELECTION_INSERT_CLIPBOARD_NODES_COMMAND: function() { return /* binding */ SELECTION_INSERT_CLIPBOARD_NODES_COMMAND; },\n/* harmony export */   SELECT_ALL_COMMAND: function() { return /* binding */ SELECT_ALL_COMMAND; },\n/* harmony export */   SKIP_COLLAB_TAG: function() { return /* binding */ SKIP_COLLAB_TAG; },\n/* harmony export */   SKIP_DOM_SELECTION_TAG: function() { return /* binding */ SKIP_DOM_SELECTION_TAG; },\n/* harmony export */   SKIP_SCROLL_INTO_VIEW_TAG: function() { return /* binding */ SKIP_SCROLL_INTO_VIEW_TAG; },\n/* harmony export */   TEXT_TYPE_TO_FORMAT: function() { return /* binding */ TEXT_TYPE_TO_FORMAT; },\n/* harmony export */   TabNode: function() { return /* binding */ TabNode; },\n/* harmony export */   TextNode: function() { return /* binding */ TextNode; },\n/* harmony export */   UNDO_COMMAND: function() { return /* binding */ UNDO_COMMAND; },\n/* harmony export */   buildImportMap: function() { return /* binding */ buildImportMap; },\n/* harmony export */   createCommand: function() { return /* binding */ createCommand; },\n/* harmony export */   createEditor: function() { return /* binding */ createEditor; },\n/* harmony export */   createSharedNodeState: function() { return /* binding */ createSharedNodeState; },\n/* harmony export */   createState: function() { return /* binding */ createState; },\n/* harmony export */   flipDirection: function() { return /* binding */ flipDirection; },\n/* harmony export */   getDOMOwnerDocument: function() { return /* binding */ getDOMOwnerDocument; },\n/* harmony export */   getDOMSelection: function() { return /* binding */ getDOMSelection; },\n/* harmony export */   getDOMSelectionFromTarget: function() { return /* binding */ getDOMSelectionFromTarget; },\n/* harmony export */   getDOMTextNode: function() { return /* binding */ getDOMTextNode; },\n/* harmony export */   getEditorPropertyFromDOMNode: function() { return /* binding */ getEditorPropertyFromDOMNode; },\n/* harmony export */   getNearestEditorFromDOMNode: function() { return /* binding */ getNearestEditorFromDOMNode; },\n/* harmony export */   getRegisteredNode: function() { return /* binding */ getRegisteredNode; },\n/* harmony export */   getRegisteredNodeOrThrow: function() { return /* binding */ getRegisteredNodeOrThrow; },\n/* harmony export */   isBlockDomNode: function() { return /* binding */ isBlockDomNode; },\n/* harmony export */   isCurrentlyReadOnlyMode: function() { return /* binding */ isCurrentlyReadOnlyMode; },\n/* harmony export */   isDOMDocumentNode: function() { return /* binding */ isDOMDocumentNode; },\n/* harmony export */   isDOMNode: function() { return /* binding */ isDOMNode; },\n/* harmony export */   isDOMTextNode: function() { return /* binding */ isDOMTextNode; },\n/* harmony export */   isDOMUnmanaged: function() { return /* binding */ isDOMUnmanaged; },\n/* harmony export */   isDocumentFragment: function() { return /* binding */ isDocumentFragment; },\n/* harmony export */   isExactShortcutMatch: function() { return /* binding */ isExactShortcutMatch; },\n/* harmony export */   isHTMLAnchorElement: function() { return /* binding */ isHTMLAnchorElement; },\n/* harmony export */   isHTMLElement: function() { return /* binding */ isHTMLElement; },\n/* harmony export */   isInlineDomNode: function() { return /* binding */ isInlineDomNode; },\n/* harmony export */   isLexicalEditor: function() { return /* binding */ isLexicalEditor; },\n/* harmony export */   isModifierMatch: function() { return /* binding */ isModifierMatch; },\n/* harmony export */   isSelectionCapturedInDecoratorInput: function() { return /* binding */ isSelectionCapturedInDecoratorInput; },\n/* harmony export */   isSelectionWithinEditor: function() { return /* binding */ isSelectionWithinEditor; },\n/* harmony export */   makeStepwiseIterator: function() { return /* binding */ makeStepwiseIterator; },\n/* harmony export */   removeFromParent: function() { return /* binding */ removeFromParent; },\n/* harmony export */   resetRandomKey: function() { return /* binding */ resetRandomKey; },\n/* harmony export */   setDOMUnmanaged: function() { return /* binding */ setDOMUnmanaged; },\n/* harmony export */   setNodeIndentFromDOM: function() { return /* binding */ setNodeIndentFromDOM; }\n/* harmony export */ });\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID = CAN_USE_DOM && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME = CAN_USE_DOM && IS_ANDROID && IS_CHROME;\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// DOM\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3;\nconst DOM_DOCUMENT_TYPE = 9;\nconst DOM_DOCUMENT_FRAGMENT_TYPE = 11;\n\n// Reconciling\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2;\n\n// Text node modes\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2;\n// IS_INERT = 3\n\n// Text node formatting\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_LOWERCASE = 1 << 8;\nconst IS_UPPERCASE = 1 << 9;\nconst IS_CAPITALIZE = 1 << 10;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT | IS_LOWERCASE | IS_UPPERCASE | IS_CAPITALIZE;\n\n// Text node details\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1;\n\n// Element node formatting\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6;\n\n// Reconciliation\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b';\n\n// For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n';\n\n// For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF';\n\n// eslint-disable-next-line no-misleading-character-class\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']');\n// eslint-disable-next-line no-misleading-character-class\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  capitalize: IS_CAPITALIZE,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  lowercase: IS_LOWERCASE,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE,\n  uppercase: IS_UPPERCASE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\nconst NODE_STATE_KEY = '$';\nconst PROTOTYPE_CONFIG_METHOD = '$config';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n      delete decorators[key];\n    }\n  }\n}\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n  while (child !== null) {\n    const childKey = child.__key;\n    // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      }\n\n      // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n      nodeMapDelete.push(childKey);\n    }\n    child = child.getNextSibling();\n  }\n}\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap;\n  // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n  const nodeMapDelete = [];\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        }\n        // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// The time between a text entry event and the mutation observer firing.\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcessingMutations() {\n  return isProcessingMutations;\n}\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\nfunction isManagedLineBreak(dom, target, editor) {\n  const isBR = dom.nodeName === 'BR';\n  const lexicalLineBreak = target.__lexicalLineBreak;\n  return lexicalLineBreak && (dom === lexicalLineBreak || isBR && dom.previousSibling === lexicalLineBreak) || isBR && getNodeKeyFromDOMNode(dom, editor) !== undefined;\n}\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\nfunction $handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(getWindow(editor));\n  let anchorOffset = null;\n  let focusOffset = null;\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n  const text = target.nodeValue;\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n  return isDOMTextNode(targetDOM) && targetNode.isAttached();\n}\nfunction $getNearestManagedNodePairFromDOMNode(startingDOM, editor, editorState, rootElement) {\n  for (let dom = startingDOM; dom && !isDOMUnmanaged(dom); dom = getParentElement(dom)) {\n    const key = getNodeKeyFromDOMNode(dom, editor);\n    if (key !== undefined) {\n      const node = $getNodeByKey(key, editorState);\n      if (node) {\n        // All decorator nodes are unmanaged\n        return $isDecoratorNode(node) || !isHTMLElement(dom) ? undefined : [dom, node];\n      }\n    } else if (dom === rootElement) {\n      return [rootElement, internalGetRoot(editorState)];\n    }\n  }\n}\nfunction flushMutations(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n  try {\n    updateEditorSync(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement();\n      // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        const pair = $getNearestManagedNodePairFromDOMNode(targetDOM, editor, currentEditorState, rootElement);\n        if (!pair) {\n          continue;\n        }\n        const [nodeDOM, targetNode] = pair;\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (\n          // TODO there is an edge case here if a mutation happens too quickly\n          //      after text input, it may never be handled since we do not\n          //      track the ignored mutations in any way\n          shouldFlushTextMutations && $isTextNode(targetNode) && isDOMTextNode(targetDOM) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            $handleTextMutation(targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true;\n          // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n          const addedDOMs = mutation.addedNodes;\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = $getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && !isManagedLineBreak(addedDOM, parentDOM, editor)) {\n              if (IS_FIREFOX) {\n                const possibleText = (isHTMLElement(addedDOM) ? addedDOM.innerText : null) || addedDOM.nodeValue;\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n              if (isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n            if (removedDOMsLength !== unremovedBRs) {\n              badDOMTargets.set(nodeDOM, targetNode);\n            }\n          }\n        }\n      }\n\n      // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n      if (badDOMTargets.size > 0) {\n        for (const [nodeDOM, targetNode] of badDOMTargets) {\n          targetNode.reconcileObservedMutation(nodeDOM, editor);\n        }\n      }\n\n      // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n      const records = observer.takeRecords();\n\n      // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        }\n\n        // Clear any of those removal mutations\n        observer.takeRecords();\n      }\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          $setSelection(selection);\n        }\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    flushMutations(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    flushMutations(editor, mutations, observer);\n  });\n}\n\n/**\n * Get the value type (V) from a StateConfig\n */\n\n/**\n * Get the key type (K) from a StateConfig\n */\n\n/**\n * A value type, or an updater for that value type. For use with\n * {@link $setState} or any user-defined wrappers around it.\n */\n\n/**\n * A type alias to make it easier to define setter methods on your node class\n *\n * @example\n * ```ts\n * const fooState = createState(\"foo\", { parse: ... });\n * class MyClass extends TextNode {\n *   // ...\n *   setFoo(valueOrUpdater: StateValueOrUpdater<typeof fooState>): this {\n *     return $setState(this, fooState, valueOrUpdater);\n *   }\n * }\n * ```\n */\n\n// eslint-disable-next-line @typescript-eslint/ban-types\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n/**\n * The NodeState JSON produced by this LexicalNode\n */\n\n/**\n * Configure a value to be used with StateConfig.\n *\n * The value type should be inferred from the definition of parse.\n *\n * If the value type is not JSON serializable, then unparse must also be provided.\n *\n * Values should be treated as immutable, much like React.useState. Mutating\n * stored values directly will cause unpredictable behavior, is not supported,\n * and may trigger errors in the future.\n *\n * @example\n * ```ts\n * const numberOrNullState = createState('numberOrNull', {parse: (v) => typeof v === 'number' ? v : null});\n * //    ^? State<'numberOrNull', StateValueConfig<number | null>>\n * const numberState = createState('number', {parse: (v) => typeof v === 'number' ? v : 0});\n * //    ^? State<'number', StateValueConfig<number>>\n * ```\n *\n * Only the parse option is required, it is generally not useful to\n * override `unparse` or `isEqual`. However, if you are using\n * non-primitive types such as Array, Object, Date, or something\n * more exotic then you would want to override this. In these\n * cases you might want to reach for third party libraries.\n *\n * @example\n * ```ts\n * const isoDateState = createState('isoDate', {\n *   parse: (v): null | Date => {\n *     const date = typeof v === 'string' ? new Date(v) : null;\n *     return date && !isNaN(date.valueOf()) ? date : null;\n *   }\n *   isEqual: (a, b) => a === b || (a && b && a.valueOf() === b.valueOf()),\n *   unparse: (v) => v && v.toString()\n * });\n * ```\n *\n * You may find it easier to write a parse function using libraries like\n * zod, valibot, ajv, Effect, TypeBox, etc. perhaps with a wrapper function.\n */\n\n/**\n * The return value of {@link createState}, for use with\n * {@link $getState} and {@link $setState}.\n */\nclass StateConfig {\n  /** The string key used when serializing this state to JSON */\n\n  /** The parse function from the StateValueConfig passed to createState */\n\n  /**\n   * The unparse function from the StateValueConfig passed to createState,\n   * with a default that is simply a pass-through that assumes the value is\n   * JSON serializable.\n   */\n\n  /**\n   * An equality function from the StateValueConfig, with a default of\n   * Object.is.\n   */\n\n  /**\n   * The result of `stateValueConfig.parse(undefined)`, which is computed only\n   * once and used as the default value. When the current value `isEqual` to\n   * the `defaultValue`, it will not be serialized to JSON.\n   */\n\n  constructor(key, stateValueConfig) {\n    this.key = key;\n    this.parse = stateValueConfig.parse.bind(stateValueConfig);\n    this.unparse = (stateValueConfig.unparse || coerceToJSON).bind(stateValueConfig);\n    this.isEqual = (stateValueConfig.isEqual || Object.is).bind(stateValueConfig);\n    this.defaultValue = this.parse(undefined);\n  }\n}\n\n/**\n * For advanced use cases, using this type is not recommended unless\n * it is required (due to TypeScript's lack of features like\n * higher-kinded types).\n *\n * A {@link StateConfig} type with any key and any value that can be\n * used in situations where the key and value type can not be known,\n * such as in a generic constraint when working with a collection of\n * StateConfig.\n *\n * {@link StateConfigKey} and {@link StateConfigValue} will be\n * useful when this is used as a generic constraint.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * Create a StateConfig for the given string key and StateValueConfig.\n *\n * The key must be locally unique. In dev you will get a key collision error\n * when you use two separate StateConfig on the same node with the same key.\n *\n * The returned StateConfig value should be used with {@link $getState} and\n * {@link $setState}.\n *\n * @param key The key to use\n * @param valueConfig Configuration for the value type\n * @returns a StateConfig\n */\nfunction createState(key, valueConfig) {\n  return new StateConfig(key, valueConfig);\n}\n\n/**\n * The accessor for working with node state. This will read the value for the\n * state on the given node, and will return `stateConfig.defaultValue` if the\n * state has never been set on this node.\n *\n * The `version` parameter is optional and should generally be `'latest'`,\n * consistent with the behavior of other node methods and functions,\n * but for certain use cases such as `updateDOM` you may have a need to\n * use `'direct'` to read the state from a previous version of the node.\n *\n * For very advanced use cases, you can expect that 'direct' does not\n * require an editor state, just like directly accessing other properties\n * of a node without an accessor (e.g. `textNode.__text`).\n *\n * @param node Any LexicalNode\n * @param stateConfig The configuration of the state to read\n * @param version The default value 'latest' will read the latest version of the node state, 'direct' will read the version that is stored on this LexicalNode which not reflect the version used in the current editor state\n * @returns The current value from the state, or the default value provided by the configuration.\n */\nfunction $getState(node, stateConfig, version = 'latest') {\n  const latestOrDirectNode = version === 'latest' ? node.getLatest() : node;\n  const state = latestOrDirectNode.__state;\n  if (state) {\n    $checkCollision(node, stateConfig, state);\n    return state.getValue(stateConfig);\n  }\n  return stateConfig.defaultValue;\n}\n\n/**\n * Given two versions of a node and a stateConfig, compare their state values\n * using `$getState(nodeVersion, stateConfig, 'direct')`.\n * If the values are equal according to `stateConfig.isEqual`, return `null`,\n * otherwise return `[value, prevValue]`.\n *\n * This is useful for implementing updateDOM. Note that the `'direct'`\n * version argument is used for both nodes.\n *\n * @param node Any LexicalNode\n * @param prevNode A previous version of node\n * @param stateConfig The configuration of the state to read\n * @returns `[value, prevValue]` if changed, otherwise `null`\n */\nfunction $getStateChange(node, prevNode, stateConfig) {\n  const value = $getState(node, stateConfig, 'direct');\n  const prevValue = $getState(prevNode, stateConfig, 'direct');\n  return stateConfig.isEqual(value, prevValue) ? null : [value, prevValue];\n}\n\n/**\n * Set the state defined by stateConfig on node. Like with `React.useState`\n * you may directly specify the value or use an updater function that will\n * be called with the previous value of the state on that node (which will\n * be the `stateConfig.defaultValue` if not set).\n *\n * When an updater function is used, the node will only be marked dirty if\n * `stateConfig.isEqual(prevValue, value)` is false.\n *\n * @example\n * ```ts\n * const toggle = createState('toggle', {parse: Boolean});\n * // set it direction\n * $setState(node, counterState, true);\n * // use an updater\n * $setState(node, counterState, (prev) => !prev);\n * ```\n *\n * @param node The LexicalNode to set the state on\n * @param stateConfig The configuration for this state\n * @param valueOrUpdater The value or updater function\n * @returns node\n */\nfunction $setState(node, stateConfig, valueOrUpdater) {\n  errorOnReadOnly();\n  let value;\n  if (typeof valueOrUpdater === 'function') {\n    const latest = node.getLatest();\n    const prevValue = $getState(latest, stateConfig);\n    value = valueOrUpdater(prevValue);\n    if (stateConfig.isEqual(prevValue, value)) {\n      return latest;\n    }\n  } else {\n    value = valueOrUpdater;\n  }\n  const writable = node.getWritable();\n  const state = $getWritableNodeState(writable);\n  $checkCollision(node, stateConfig, state);\n  state.updateFromKnown(stateConfig, value);\n  return writable;\n}\n\n/**\n * @internal\n *\n * Register the config to this node's sharedConfigMap and throw an exception in\n * `true` when a collision is detected.\n */\nfunction $checkCollision(node, stateConfig, state) {\n  {\n    const collision = state.sharedNodeState.sharedConfigMap.get(stateConfig.key);\n    if (collision !== undefined && collision !== stateConfig) {\n      {\n        formatDevErrorMessage(`$setState: State key collision ${JSON.stringify(stateConfig.key)} detected in ${node.constructor.name} node with type ${node.getType()} and key ${node.getKey()}. Only one StateConfig with a given key should be used on a node.`);\n      }\n    }\n  }\n}\n\n/**\n * @internal\n *\n * Opaque state to be stored on the editor's RegisterNode for use by NodeState\n */\n\n/**\n * @internal\n *\n * Create the state to store on RegisteredNode\n */\nfunction createSharedNodeState(nodeConfig) {\n  const sharedConfigMap = new Map();\n  const flatKeys = new Set();\n  for (let klass = typeof nodeConfig === 'function' ? nodeConfig : nodeConfig.replace; klass.prototype && klass.prototype.getType !== undefined; klass = Object.getPrototypeOf(klass)) {\n    const {\n      ownNodeConfig\n    } = getStaticNodeConfig(klass);\n    if (ownNodeConfig && ownNodeConfig.stateConfigs) {\n      for (const requiredStateConfig of ownNodeConfig.stateConfigs) {\n        let stateConfig;\n        if ('stateConfig' in requiredStateConfig) {\n          stateConfig = requiredStateConfig.stateConfig;\n          if (requiredStateConfig.flat) {\n            flatKeys.add(stateConfig.key);\n          }\n        } else {\n          stateConfig = requiredStateConfig;\n        }\n        sharedConfigMap.set(stateConfig.key, stateConfig);\n      }\n    }\n  }\n  return {\n    flatKeys,\n    sharedConfigMap\n  };\n}\n\n/**\n * @internal\n *\n * A Map of string keys to state configurations to be shared across nodes\n * and/or node versions.\n */\n\n/**\n * @internal\n */\nclass NodeState {\n  /**\n   * @internal\n   *\n   * Track the (versioned) node that this NodeState was created for, to\n   * facilitate copy-on-write for NodeState. When a LexicalNode is cloned,\n   * it will *reference* the NodeState from its prevNode. From the nextNode\n   * you can continue to read state without copying, but the first $setState\n   * will trigger a copy of the prevNode's NodeState with the node property\n   * updated.\n   */\n\n  /**\n   * @internal\n   *\n   * State that has already been parsed in a get state, so it is safe. (can be returned with\n   * just a cast since the proof was given before).\n   *\n   * Note that it uses StateConfig, so in addition to (1) the CURRENT VALUE, it has access to\n   * (2) the State key (3) the DEFAULT VALUE and (4) the PARSE FUNCTION\n   */\n\n  /**\n   * @internal\n   *\n   * A copy of serializedNode[NODE_STATE_KEY] that is made when JSON is\n   * imported but has not been parsed yet.\n   *\n   * It stays here until a get state requires us to parse it, and since we\n   * then know the value is safe we move it to knownState.\n   *\n   * Note that since only string keys are used here, we can only allow this\n   * state to pass-through on export or on the next version since there is\n   * no known value configuration. This pass-through is to support scenarios\n   * where multiple versions of the editor code are working in parallel so\n   * an old version of your code doesnt erase metadata that was\n   * set by a newer version of your code.\n   */\n\n  /**\n   * @internal\n   *\n   * This sharedNodeState is preserved across all instances of a given\n   * node type in an editor and remains writable. It is how keys are resolved\n   * to configuration.\n   */\n\n  /**\n   * @internal\n   *\n   * The count of known or unknown keys in this state, ignoring the\n   * intersection between the two sets.\n   */\n\n  /**\n   * @internal\n   */\n  constructor(node, sharedNodeState, unknownState = undefined, knownState = new Map(), size = undefined) {\n    this.node = node;\n    this.sharedNodeState = sharedNodeState;\n    this.unknownState = unknownState;\n    this.knownState = knownState;\n    const {\n      sharedConfigMap\n    } = this.sharedNodeState;\n    const computedSize = size !== undefined ? size : computeSize(sharedConfigMap, unknownState, knownState);\n    {\n      if (!(size === undefined || computedSize === size)) {\n        formatDevErrorMessage(`NodeState: size != computedSize (${String(size)} != ${String(computedSize)})`);\n      }\n      for (const stateConfig of knownState.keys()) {\n        if (!sharedConfigMap.has(stateConfig.key)) {\n          formatDevErrorMessage(`NodeState: sharedConfigMap missing knownState key ${stateConfig.key}`);\n        }\n      }\n    }\n    this.size = computedSize;\n  }\n\n  /**\n   * @internal\n   *\n   * Get the value from knownState, or parse it from unknownState\n   * if it contains the given key.\n   *\n   * Updates the sharedConfigMap when no known state is found.\n   * Updates unknownState and knownState when an unknownState is parsed.\n   */\n  getValue(stateConfig) {\n    const known = this.knownState.get(stateConfig);\n    if (known !== undefined) {\n      return known;\n    }\n    this.sharedNodeState.sharedConfigMap.set(stateConfig.key, stateConfig);\n    let parsed = stateConfig.defaultValue;\n    if (this.unknownState && stateConfig.key in this.unknownState) {\n      const jsonValue = this.unknownState[stateConfig.key];\n      if (jsonValue !== undefined) {\n        parsed = stateConfig.parse(jsonValue);\n      }\n      // Only update if the key was unknown\n      this.updateFromKnown(stateConfig, parsed);\n    }\n    return parsed;\n  }\n\n  /**\n   * @internal\n   *\n   * Used only for advanced use cases, such as collab. The intent here is to\n   * allow you to diff states with a more stable interface than the properties\n   * of this class.\n   */\n  getInternalState() {\n    return [this.unknownState, this.knownState];\n  }\n\n  /**\n   * Encode this NodeState to JSON in the format that its node expects.\n   * This returns `{[NODE_STATE_KEY]?: UnknownStateRecord}` rather than\n   * `UnknownStateRecord | undefined` so that we can support flattening\n   * specific entries in the future when nodes can declare what\n   * their required StateConfigs are.\n   */\n  toJSON() {\n    const state = {\n      ...this.unknownState\n    };\n    const flatState = {};\n    for (const [stateConfig, v] of this.knownState) {\n      if (stateConfig.isEqual(v, stateConfig.defaultValue)) {\n        delete state[stateConfig.key];\n      } else {\n        state[stateConfig.key] = stateConfig.unparse(v);\n      }\n    }\n    for (const key of this.sharedNodeState.flatKeys) {\n      if (key in state) {\n        flatState[key] = state[key];\n        delete state[key];\n      }\n    }\n    if (undefinedIfEmpty(state)) {\n      flatState[NODE_STATE_KEY] = state;\n    }\n    return flatState;\n  }\n\n  /**\n   * @internal\n   *\n   * A NodeState is writable when the node to update matches\n   * the node associated with the NodeState. This basically\n   * mirrors how the EditorState NodeMap works, but in a\n   * bottom-up organization rather than a top-down organization.\n   *\n   * This allows us to implement the same \"copy on write\"\n   * pattern for state, without having the state version\n   * update every time the node version changes (e.g. when\n   * its parent or siblings change).\n   *\n   * @param node The node to associate with the state\n   * @returns The next writable state\n   */\n  getWritable(node) {\n    if (this.node === node) {\n      return this;\n    }\n    const {\n      sharedNodeState,\n      unknownState\n    } = this;\n    const nextKnownState = new Map(this.knownState);\n    return new NodeState(node, sharedNodeState, parseAndPruneNextUnknownState(sharedNodeState.sharedConfigMap, nextKnownState, unknownState), nextKnownState, this.size);\n  }\n\n  /** @internal */\n  updateFromKnown(stateConfig, value) {\n    const key = stateConfig.key;\n    this.sharedNodeState.sharedConfigMap.set(key, stateConfig);\n    const {\n      knownState,\n      unknownState\n    } = this;\n    if (!(knownState.has(stateConfig) || unknownState && key in unknownState)) {\n      if (unknownState) {\n        delete unknownState[key];\n        this.unknownState = undefinedIfEmpty(unknownState);\n      }\n      this.size++;\n    }\n    knownState.set(stateConfig, value);\n  }\n\n  /**\n   * @internal\n   *\n   * This is intended for advanced use cases only, such\n   * as collab or dev tools.\n   *\n   * Update a single key value pair from unknown state,\n   * parsing it if the key is known to this node. This is\n   * basically like updateFromJSON, but the effect is\n   * isolated to a single entry.\n   *\n   * @param k The string key from an UnknownStateRecord\n   * @param v The unknown value from an UnknownStateRecord\n   */\n  updateFromUnknown(k, v) {\n    const stateConfig = this.sharedNodeState.sharedConfigMap.get(k);\n    if (stateConfig) {\n      this.updateFromKnown(stateConfig, stateConfig.parse(v));\n    } else {\n      this.unknownState = this.unknownState || {};\n      if (!(k in this.unknownState)) {\n        this.size++;\n      }\n      this.unknownState[k] = v;\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Reset all existing state to default or empty values,\n   * and perform any updates from the given unknownState.\n   *\n   * This is used when initializing a node's state from JSON,\n   * or when resetting a node's state from JSON.\n   *\n   * @param unknownState The new state in serialized form\n   */\n  updateFromJSON(unknownState) {\n    const {\n      knownState\n    } = this;\n    // Reset all known state to defaults\n    for (const stateConfig of knownState.keys()) {\n      knownState.set(stateConfig, stateConfig.defaultValue);\n    }\n    // Since we are resetting all state to this new record,\n    // the size starts at the number of known keys\n    // and will be updated as we traverse the new state\n    this.size = knownState.size;\n    this.unknownState = undefined;\n    if (unknownState) {\n      for (const [k, v] of Object.entries(unknownState)) {\n        this.updateFromUnknown(k, v);\n      }\n    }\n  }\n}\n\n/**\n * @internal\n *\n * Only for direct use in very advanced integrations, such as lexical-yjs.\n * Typically you would only use {@link createState}, {@link $getState}, and\n * {@link $setState}. This is effectively the preamble for {@link $setState}.\n */\nfunction $getWritableNodeState(node) {\n  const writable = node.getWritable();\n  const state = writable.__state ? writable.__state.getWritable(writable) : new NodeState(writable, $getSharedNodeState(writable));\n  writable.__state = state;\n  return state;\n}\n\n/**\n * @internal\n *\n * Get the SharedNodeState for a node on this editor\n */\nfunction $getSharedNodeState(node) {\n  return node.__state ? node.__state.sharedNodeState : getRegisteredNodeOrThrow($getEditor(), node.getType()).sharedNodeState;\n}\n\n/**\n * @internal\n *\n * This is used to implement LexicalNode.updateFromJSON and is\n * not intended to be exported from the package.\n *\n * @param node any LexicalNode\n * @param unknownState undefined or a serialized State\n * @returns A writable version of node, with the state set.\n */\nfunction $updateStateFromJSON(node, serialized) {\n  const writable = node.getWritable();\n  const unknownState = serialized[NODE_STATE_KEY];\n  let parseState = unknownState;\n  for (const k of $getSharedNodeState(writable).flatKeys) {\n    if (k in serialized) {\n      if (parseState === undefined || parseState === unknownState) {\n        parseState = {\n          ...unknownState\n        };\n      }\n      parseState[k] = serialized[k];\n    }\n  }\n  if (writable.__state || parseState) {\n    $getWritableNodeState(node).updateFromJSON(parseState);\n  }\n  return writable;\n}\n\n/**\n * @internal\n *\n * Return true if the two nodes have equivalent NodeState, to be used\n * to determine when TextNode are being merged, not a lot of use cases\n * otherwise.\n */\nfunction nodeStatesAreEquivalent(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a && b && a.size !== b.size) {\n    return false;\n  }\n  const keys = new Set();\n  return !(a && hasUnequalMapEntry(keys, a, b) || b && hasUnequalMapEntry(keys, b, a) || a && hasUnequalRecordEntry(keys, a, b) || b && hasUnequalRecordEntry(keys, b, a));\n}\n\n/**\n * Compute the number of distinct keys that will be in a NodeState\n */\nfunction computeSize(sharedConfigMap, unknownState, knownState) {\n  let size = knownState.size;\n  if (unknownState) {\n    for (const k in unknownState) {\n      const sharedConfig = sharedConfigMap.get(k);\n      if (!sharedConfig || !knownState.has(sharedConfig)) {\n        size++;\n      }\n    }\n  }\n  return size;\n}\n\n/**\n * @internal\n *\n * Return obj if it is an object with at least one property, otherwise\n * return undefined.\n */\nfunction undefinedIfEmpty(obj) {\n  if (obj) {\n    for (const key in obj) {\n      return obj;\n    }\n  }\n  return undefined;\n}\n\n/**\n * @internal\n *\n * Cast the given v to unknown\n */\nfunction coerceToJSON(v) {\n  return v;\n}\n\n/**\n * @internal\n *\n * Parse all knowable values in an UnknownStateRecord into nextKnownState\n * and return the unparsed values in a new UnknownStateRecord. Returns\n * undefined if no unknown values remain.\n */\nfunction parseAndPruneNextUnknownState(sharedConfigMap, nextKnownState, unknownState) {\n  let nextUnknownState = undefined;\n  if (unknownState) {\n    for (const [k, v] of Object.entries(unknownState)) {\n      const stateConfig = sharedConfigMap.get(k);\n      if (stateConfig) {\n        if (!nextKnownState.has(stateConfig)) {\n          nextKnownState.set(stateConfig, stateConfig.parse(v));\n        }\n      } else {\n        nextUnknownState = nextUnknownState || {};\n        nextUnknownState[k] = v;\n      }\n    }\n  }\n  return nextUnknownState;\n}\n\n/**\n * @internal\n *\n * Compare each entry of sourceState.knownState that is not in keys to\n * otherState (or the default value if otherState is undefined.\n * Note that otherState will return the defaultValue as well if it\n * has never been set. Any checked entry's key will be added to keys.\n *\n * @returns true if any difference is found, false otherwise\n */\nfunction hasUnequalMapEntry(keys, sourceState, otherState) {\n  for (const [stateConfig, value] of sourceState.knownState) {\n    if (keys.has(stateConfig.key)) {\n      continue;\n    }\n    keys.add(stateConfig.key);\n    const otherValue = otherState ? otherState.getValue(stateConfig) : stateConfig.defaultValue;\n    if (otherValue !== value && !stateConfig.isEqual(otherValue, value)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @internal\n *\n * Compare each entry of sourceState.unknownState that is not in keys to\n * otherState.unknownState (or undefined if otherState is undefined).\n * Any checked entry's key will be added to keys.\n *\n * Notably since we have already checked hasUnequalMapEntry on both sides,\n * we do not do any parsing or checking of knownState.\n *\n * @returns true if any difference is found, false otherwise\n */\nfunction hasUnequalRecordEntry(keys, sourceState, otherState) {\n  const {\n    unknownState\n  } = sourceState;\n  const otherUnknownState = otherState ? otherState.unknownState : undefined;\n  if (unknownState) {\n    for (const [key, value] of Object.entries(unknownState)) {\n      if (keys.has(key)) {\n        continue;\n      }\n      keys.add(key);\n      const otherValue = otherUnknownState ? otherUnknownState[key] : undefined;\n      if (value !== otherValue) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * @internal\n *\n * Clones the NodeState for a given node. Handles aliasing if the state references the from node.\n */\nfunction $cloneNodeState(from, to) {\n  const state = from.__state;\n  return state && state.node === from ? state.getWritable(to) : state;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  const node1State = node1.__state;\n  const node2State = node2.__state;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style) && (node1.__state === null || node1State === node2State || nodeStatesAreEquivalent(node1State, node2State));\n}\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  }\n\n  // Backward\n  let previousNode;\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  }\n\n  // Forward\n  let nextNode;\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text', true);\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element', true);\n  }\n}\n\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet subTreeTextFormat = null;\nlet subTreeTextStyle = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  }\n\n  // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\nconst DEFAULT_INDENT_VALUE = '40px';\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\nfunction $createNode(key, slot) {\n  const node = activeNextNodeMap.get(key);\n  if (node === undefined) {\n    {\n      formatDevErrorMessage(`createNode: node does not exist in nodeMap`);\n    }\n  }\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1);\n\n  // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      $createChildrenWithDirection(children, endIndex, node, dom);\n    }\n    const format = node.__format;\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n      // Decorators are always non editable\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (slot !== null) {\n    slot.insertChild(dom);\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\nfunction $createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  $createChildren(children, element, 0, endIndex, element.getDOMSlot(dom));\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\nfunction $createChildren(children, element, _startIndex, endIndex, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n  for (; startIndex <= endIndex; ++startIndex) {\n    $createNode(children[startIndex], slot);\n    const node = activeNextNodeMap.get(children[startIndex]);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  const dom = slot.element;\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction isLastChildLineBreakOrDecorator(element, nodeMap) {\n  if (element) {\n    const lastKey = element.__last;\n    if (lastKey) {\n      const node = nodeMap.get(lastKey);\n      if (node) {\n        return $isLineBreakNode(node) ? 'line-break' : $isDecoratorNode(node) && node.isInline() ? 'decorator' : null;\n      }\n    }\n    return 'empty';\n  }\n  return null;\n}\n\n// If we end an element with a LineBreakNode, then we need to add an additional <br>\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = isLastChildLineBreakOrDecorator(prevElement, activePrevNodeMap);\n  const nextLineBreak = isLastChildLineBreakOrDecorator(nextElement, activeNextNodeMap);\n  if (prevLineBreak !== nextLineBreak) {\n    nextElement.getDOMSlot(dom).setManagedLineBreak(nextLineBreak);\n  }\n}\nfunction reconcileTextFormat(element) {\n  if (subTreeTextFormat != null && subTreeTextFormat !== element.__textFormat && !activeEditorStateReadOnly) {\n    element.setTextFormat(subTreeTextFormat);\n  }\n}\nfunction reconcileTextStyle(element) {\n  if (subTreeTextStyle !== '' && subTreeTextStyle !== element.__textStyle && !activeEditorStateReadOnly) {\n    element.setTextStyle(subTreeTextStyle);\n  }\n}\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent || '';\n  const previousDirection = dom.__lexicalDir || '';\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined;\n\n      // Remove the old theme classes if they exist\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = normalizeClassNames(previousDirectionTheme);\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        }\n\n        // @ts-ignore: intentional\n        classList.remove(...previousDirectionTheme);\n      }\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = normalizeClassNames(nextDirectionTheme);\n            // @ts-expect-error: intentional\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        }\n\n        // Update direction\n        dom.dir = direction;\n      }\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n    activeTextDirection = direction;\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent;\n    dom.__lexicalDir = direction;\n  }\n}\nfunction $reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  subTreeTextFormat = null;\n  subTreeTextStyle = '';\n  $reconcileChildren(prevElement, nextElement, nextElement.getDOMSlot(dom));\n  reconcileBlockDirection(nextElement, dom);\n  reconcileTextFormat(nextElement);\n  reconcileTextStyle(nextElement);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n    if (node === undefined) {\n      {\n        formatDevErrorMessage(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n  return children;\n}\nfunction $reconcileChildren(prevElement, nextElement, slot) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n  const dom = slot.element;\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFirstChildKey = nextElement.__first;\n    if (prevFirstChildKey === nextFirstChildKey) {\n      $reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = $createNode(nextFirstChildKey, null);\n      try {\n        dom.replaceChild(replacementDOM, lastDOM);\n      } catch (error) {\n        if (typeof error === 'object' && error != null) {\n          const msg = `${error.toString()} Parent: ${dom.tagName}, new child: {tag: ${replacementDOM.tagName} key: ${nextFirstChildKey}}, old child: {tag: ${lastDOM.tagName}, key: ${prevFirstChildKey}}.`;\n          throw new Error(msg);\n        } else {\n          throw error;\n        }\n      }\n      destroyNode(prevFirstChildKey, null);\n    }\n    const nextChildNode = activeNextNodeMap.get(nextFirstChildKey);\n    if ($isTextNode(nextChildNode)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = nextChildNode.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = nextChildNode.getStyle();\n      }\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n    if (!(prevChildren.length === prevChildrenSize)) {\n      formatDevErrorMessage(`$reconcileChildren: prevChildren.length !== prevChildrenSize`);\n    }\n    if (!(nextChildren.length === nextChildrenSize)) {\n      formatDevErrorMessage(`$reconcileChildren: nextChildren.length !== nextChildrenSize`);\n    }\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        $createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, slot);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        const canUseFastPath = slot.after == null && slot.before == null && slot.element.__lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, slot);\n    }\n  }\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  }\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\nfunction $reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      formatDevErrorMessage(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key);\n\n  // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      }\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n    return dom;\n  }\n  // If the node key doesn't point to the same instance in both maps,\n  // it was cloned. If it's also dirty, we mark it as mutated.\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  }\n\n  // Update node. If it returns true, we need to unmount and re-create the node\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = $createNode(key, null);\n    if (parentDOM === null) {\n      {\n        formatDevErrorMessage(`reconcileNode: parentDOM is null`);\n      }\n    }\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n    const nextFormat = nextNode.__format;\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n    if (isDirty) {\n      $reconcileChildrenWithDirection(prevNode, nextNode, dom);\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    const nextRootNode = nextNode.getWritable();\n    nextRootNode.__cachedText = editorTextContent;\n    nextNode = nextRootNode;\n  }\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n  return dom;\n}\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n  pendingDecorators[key] = decorator;\n}\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n  return nextSibling;\n}\nfunction $reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, slot) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = slot.getFirstChild();\n  let prevIndex = 0;\n  let nextIndex = 0;\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, slot.element);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        $createNode(nextKey, slot.withBefore(siblingDOM));\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling($reconcileNode(nextKey, slot.element));\n        } else {\n          slot.withBefore(siblingDOM).insertChild(childDOM);\n          $reconcileNode(nextKey, slot.element);\n        }\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n    const node = activeNextNodeMap.get(nextKey);\n    if (node !== null && $isTextNode(node)) {\n      if (subTreeTextFormat === null) {\n        subTreeTextFormat = node.getFormat();\n      }\n      if (subTreeTextStyle === '') {\n        subTreeTextStyle = node.getStyle();\n      }\n    }\n  }\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    $createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, slot.withBefore(insertDOM));\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, slot.element);\n  }\n}\nfunction $reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = '';\n  // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);\n  // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  $reconcileNode('root', null);\n  // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n  activeEditor$1 = undefined;\n  // @ts-ignore\n  activeEditorNodes = undefined;\n  // @ts-ignore\n  activeDirtyElements = undefined;\n  // @ts-ignore\n  activeDirtyLeaves = undefined;\n  // @ts-ignore\n  activePrevNodeMap = undefined;\n  // @ts-ignore\n  activeNextNodeMap = undefined;\n  // @ts-ignore\n  activeEditorConfig = undefined;\n  // @ts-ignore\n  activePrevKeyToDOMMap = undefined;\n  // @ts-ignore\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap;\n  setNodeKeyOnDOMNode(dom, editor, key);\n  keyToDOMMap.set(key, dom);\n}\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      formatDevErrorMessage(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/*@__INLINE__*/\nfunction warnOnlyOnce(message) {\n  {\n    let run = false;\n    return () => {\n      if (!run) {\n        console.warn(message);\n      }\n      run = true;\n    };\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction createCommand(type) {\n  return {\n    type\n  };\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst SELECTION_INSERT_CLIPBOARD_NODES_COMMAND = createCommand('SELECTION_INSERT_CLIPBOARD_NODES_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\n/**\n * Dispatched to delete a character, the payload will be `true` if the deletion\n * is backwards (backspace or delete on macOS) and `false` if forwards\n * (delete or Fn+Delete on macOS).\n */\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\n/**\n * Dispatched to insert a line break. With a false payload the\n * cursor moves to the new line (Shift+Enter), with a true payload the cursor\n * does not move (Ctrl+O on macOS).\n */\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\n/**\n * Dispatched to delete a word, the payload will be `true` if the deletion is\n * backwards (Ctrl+Backspace or Opt+Delete on macOS), and `false` if\n * forwards (Ctrl+Delete or Fn+Opt+Delete on macOS).\n */\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\n/**\n * Dispatched to delete a line, the payload will be `true` if the deletion is\n * backwards (Cmd+Delete on macOS), and `false` if forwards\n * (Fn+Cmd+Delete on macOS).\n */\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\n/**\n * Dispatched to format the selected text.\n */\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\n/**\n * Dispatched on undo (Cmd+Z on macOS, Ctrl+Z elsewhere).\n */\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\n/**\n * Dispatched on redo (Shift+Cmd+Z on macOS, Shift+Ctrl+Z or Ctrl+Y elsewhere).\n */\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\n/**\n * Dispatched when any key is pressed.\n */\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\n/**\n * Dispatched when the `'ArrowRight'` key is pressed.\n * The shift modifier key may also be down.\n */\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\n/**\n * Dispatched when the move to end keyboard shortcut is pressed,\n * (Cmd+Right on macOS; Ctrl+Right elsewhere).\n */\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\n/**\n * Dispatched when the `'ArrowLeft'` key is pressed.\n * The shift modifier key may also be down.\n */\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\n/**\n * Dispatched when the move to start keyboard shortcut is pressed,\n * (Cmd+Left on macOS; Ctrl+Left elsewhere).\n */\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\n/**\n * Dispatched when the `'ArrowUp'` key is pressed.\n * The shift and/or alt (option) modifier keys may also be down.\n */\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\n/**\n * Dispatched when the `'ArrowDown'` key is pressed.\n * The shift and/or alt (option) modifier keys may also be down.\n */\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\n/**\n * Dispatched when the enter key is pressed, may also be called with a null\n * payload when the intent is to insert a newline. The shift modifier key\n * must be down, any other modifier keys may also be down.\n */\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\n/**\n * Dispatched whenever the space (`' '`) key is pressed, any modifier\n * keys may be down.\n */\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\n/**\n * Dispatched whenever the `'Backspace'` key is pressed, the shift\n * modifier key may be down.\n */\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\n/**\n * Dispatched whenever the `'Escape'` key is pressed, any modifier\n * keys may be down.\n */\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\n/**\n * Dispatched whenever the `'Delete'` key is pressed (Fn+Delete on macOS).\n */\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\n/**\n * Dispatched whenever the `'Tab'` key is pressed. The shift modifier key\n * may be down.\n */\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\n/**\n * Dispatched on a copy event, either via the clipboard or a KeyboardEvent\n * (Cmd+C on macOS, Ctrl+C elsewhere).\n */\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\n/**\n * Dispatched on a cut event, either via the clipboard or a KeyboardEvent\n * (Cmd+X on macOS, Ctrl+X elsewhere).\n */\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\n/**\n * Dispatched on the select all keyboard shortcut\n * (Cmd+A on macOS, Ctrl+A elsehwere).\n */\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\n/**\n * @deprecated in v0.31.0, use KEY_DOWN_COMMAND and check for modifiers\n * directly.\n *\n * Dispatched after any KeyboardEvent when modifiers are pressed\n */\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = null;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nconst rootElementsRegistered = new WeakMap();\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet isSafariEndingComposition = false;\nlet safariEndCompositionEventData = '';\nlet postDeleteSelectionToRestore = null;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0];\n\n// This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(getWindow(editor));\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key ||\n  // If we're working with a non-text node.\n  !$isTextNode(anchorNode) ||\n  // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT ||\n  // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 ||\n  // TODO consider if there are other scenarios when multiple code units\n  //      should be addressed here\n  doesContainSurrogatePair(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() ||\n  // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) ||\n  // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 ||\n  // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) ||\n  // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) ||\n  // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style ||\n  // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return isDOMTextNode(domNode) && domNode.nodeValue !== null && offset !== 0 && offset !== domNode.nodeValue.length;\n}\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false;\n\n    // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset) && !postDeleteSelectionToRestore) {\n      return;\n    }\n  }\n  updateEditorSync(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n    let selection = $getSelection();\n\n    // Restore selection in the event of incorrect rightward shift after deletion\n    if (postDeleteSelectionToRestore && $isRangeSelection(selection) && selection.isCollapsed()) {\n      const curAnchor = selection.anchor;\n      const prevAnchor = postDeleteSelectionToRestore.anchor;\n      if (\n      // Rightward shift in same node\n      curAnchor.key === prevAnchor.key && curAnchor.offset === prevAnchor.offset + 1 ||\n      // Or rightward shift into sibling node\n      curAnchor.offset === 1 && prevAnchor.getNode().is(curAnchor.getNode().getPreviousSibling())) {\n        // Restore selection\n        selection = postDeleteSelectionToRestore.clone();\n        $setSelection(selection);\n      }\n    }\n    postDeleteSelectionToRestore = null;\n\n    // Update the selection format\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        }\n\n        // If we have marked a collapsed selection format, and we're\n        // within the given time range  then attempt to use that format\n        // instead of getting the format from the anchor node.\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n        const root = $getRoot();\n        const isRootTextContentEmpty = editor.isComposing() === false && root.getTextContent() === '';\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          $updateSelectionFormatStyle(selection, lastFormat, lastStyle);\n        } else {\n          if (anchor.type === 'text') {\n            if (!$isTextNode(anchorNode)) {\n              formatDevErrorMessage(`Point.getNode() must return TextNode when type is text`);\n            }\n            $updateSelectionFormatStyleFromTextNode(selection, anchorNode);\n          } else if (anchor.type === 'element' && !isRootTextContentEmpty) {\n            if (!$isElementNode(anchorNode)) {\n              formatDevErrorMessage(`Point.getNode() must return ElementNode when type is element`);\n            }\n            const lastNode = anchor.getNode();\n            if (\n            // This previously applied to all ParagraphNode\n            lastNode.isEmpty()) {\n              $updateSelectionFormatStyleFromElementNode(selection, lastNode);\n            } else {\n              $updateSelectionFormatStyle(selection, 0, '');\n            }\n          }\n        }\n      } else {\n        const anchorKey = anchor.key;\n        const focus = selection.focus;\n        const focusKey = focus.key;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n        const isBackward = selection.isBackward();\n        const startOffset = isBackward ? focusOffset : anchorOffset;\n        const endOffset = isBackward ? anchorOffset : focusOffset;\n        const startKey = isBackward ? focusKey : anchorKey;\n        const endKey = isBackward ? anchorKey : focusKey;\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n          const textContentSize = node.getTextContentSize();\n          if ($isTextNode(node) && textContentSize !== 0 &&\n          // Exclude empty text nodes at boundaries resulting from user's selection\n          !(i === 0 && node.__key === startKey && startOffset === textContentSize || i === nodesLength - 1 && node.__key === endKey && endOffset === 0)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n}\nfunction $updateSelectionFormatStyle(selection, format, style) {\n  if (selection.format !== format || selection.style !== style) {\n    selection.format = format;\n    selection.style = style;\n    selection.dirty = true;\n  }\n}\nfunction $updateSelectionFormatStyleFromTextNode(selection, node) {\n  const format = node.getFormat();\n  const style = node.getStyle();\n  $updateSelectionFormatStyle(selection, format, style);\n}\nfunction $updateSelectionFormatStyleFromElementNode(selection, node) {\n  const format = node.getTextFormat();\n  const style = node.getTextStyle();\n  $updateSelectionFormatStyle(selection, format, style);\n}\n\n// This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\nfunction onClick(event, editor) {\n  updateEditorSync(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(getWindow(editor));\n    const lastSelection = $getPreviousSelection();\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Triple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n          if (anchorNode !== focusNode) {\n            const parentNode = $findMatchingParent(anchorNode, node => $isElementNode(node) && !node.isInline());\n            if ($isElementNode(parentNode)) {\n              parentNode.select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch' || event.pointerType === 'pen') {\n        // This is used to update the selection on touch devices (including Apple Pencil) when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n          const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n          $setSelection(newSelection);\n        }\n      }\n    }\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n  if (isDOMNode(target) && pointerType !== 'touch' && pointerType !== 'pen' && event.button === 0) {\n    updateEditorSync(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n  const targetRanges = event.getTargetRanges();\n  if (targetRanges.length === 0) {\n    return null;\n  }\n  return targetRanges[0];\n}\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !$isTokenOrTab(anchorNode) || !$isTokenOrTab(focusNode);\n}\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 'MediaLast' && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event);\n\n  // We let the browser do its own thing for composition.\n  if (inputType === 'deleteCompositionText' ||\n  // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n  updateEditorSync(editor, () => {\n    const selection = $getSelection();\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n        $setSelection(prevSelection.clone());\n      }\n      if ($isRangeSelection(selection)) {\n        const isSelectionAnchorSameAsFocus = selection.anchor.key === selection.focus.key;\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && isSelectionAnchorSameAsFocus) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0;\n          // Fixes an Android bug where selection flickers when backspacing\n          setTimeout(() => {\n            updateEditorSync(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            if (!$isTextNode(anchorNode)) {\n              formatDevErrorMessage(`Anchor node must be a TextNode`);\n            }\n            $updateSelectionFormatStyleFromTextNode(selection, anchorNode);\n          }\n        } else {\n          $setCompositionKey(null);\n          event.preventDefault();\n          // Chromium Android at the moment seems to ignore the preventDefault\n          // on 'deleteContentBackward' and still deletes the content. Which leads\n          // to multiple deletions. So we let the browser handle the deletion in this case.\n          const selectedNode = selection.anchor.getNode();\n          const selectedNodeText = selectedNode.getTextContent();\n          // When the target node has `canInsertTextAfter` set to false, the first deletion\n          // doesn't have an effect, so we need to handle it with Lexical.\n          const selectedNodeCanInsertTextAfter = selectedNode.canInsertTextAfter();\n          const hasSelectedAllTextInNode = selection.anchor.offset === 0 && selection.focus.offset === selectedNodeText.length;\n          let shouldLetBrowserHandleDelete = IS_ANDROID_CHROME && isSelectionAnchorSameAsFocus && !hasSelectedAllTextInNode && selectedNodeCanInsertTextAfter;\n          // Check if selection is collapsed and if the previous node is a decorator node\n          // If so, the browser will not be able to handle the deletion\n          if (shouldLetBrowserHandleDelete && selection.isCollapsed()) {\n            shouldLetBrowserHandleDelete = !$isDecoratorNode($getAdjacentNode(selection.anchor, true));\n          }\n          if (!shouldLetBrowserHandleDelete) {\n            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n            // When deleting across paragraphs, Chrome on Android incorrectly shifts the selection rightwards\n            // We save the correct selection to restore later during handling of selectionchange event\n            const selectionAfterDelete = $getSelection();\n            if (IS_ANDROID_CHROME && $isRangeSelection(selectionAfterDelete) && selectionAfterDelete.isCollapsed()) {\n              postDeleteSelectionToRestore = selectionAfterDelete;\n              // Cleanup in case selectionchange does not fire\n              setTimeout(() => postDeleteSelectionToRestore = null);\n            }\n          }\n        }\n        return;\n      }\n    }\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n    const data = event.data;\n\n    // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    }\n\n    // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n    event.preventDefault();\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n\n          // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n          break;\n        }\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n          break;\n        }\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n      // NO-OP\n    }\n  });\n}\nfunction onInput(event, editor) {\n  // Note that the MutationObserver may or may not have already fired,\n  // but the the DOM and selection may have already changed.\n  // See also:\n  // - https://github.com/facebook/lexical/issues/7028\n  // - https://github.com/facebook/lexical/pull/794\n\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditorSync(editor, () => {\n    if (isHTMLElement(event.target) && $isSelectionCapturedInDecorator(event.target)) {\n      return;\n    }\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(getWindow(editor));\n      if (domSelection === null) {\n        return;\n      }\n      const isBackward = selection.isBackward();\n      const startOffset = isBackward ? selection.anchor.offset : selection.focus.offset;\n      const endOffset = isBackward ? selection.focus.offset : selection.anchor.offset;\n      // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, startOffset) + data + anchorNode.getTextContent().slice(startOffset + endOffset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n      const textLength = data.length;\n\n      // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      }\n\n      // This ensures consistency on Android.\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData);\n\n      // onInput always fires after onCompositionEnd for FF.\n      if (isFirefoxEndingComposition) {\n        $onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    }\n\n    // Also flush any other mutations that might have occurred\n    // since the change.\n    $flushMutations();\n  }, {\n    event\n  });\n  unprocessedBeforeInputData = null;\n}\nfunction onCompositionStart(event, editor) {\n  updateEditorSync(editor, () => {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n      if (\n      // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY ||\n      // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || $isTextNode(node) && node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\nfunction $onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null);\n\n  // Handle termination of composition.\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n      return;\n    }\n\n    // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n  $updateSelectedTextFromDOM(true, editor, data);\n}\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else if (!IS_IOS && (IS_SAFARI || IS_APPLE_WEBKIT)) {\n    // Fixhttps://github.com/facebook/lexical/pull/7061\n    // In safari, onCompositionEnd triggers before keydown\n    // This will cause an extra character to be deleted when exiting the IME\n    // Therefore, a flag is used to mark that the keydown event is triggered after onCompositionEnd\n    // Ensure that an extra character is not deleted due to the backspace event being triggered in the keydown event.\n    isSafariEndingComposition = true;\n    safariEndCompositionEventData = event.data;\n  } else {\n    updateEditorSync(editor, () => {\n      $onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.key;\n  if (editor.isComposing()) {\n    return;\n  }\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n  if (event.key == null) {\n    return;\n  }\n  if (isSafariEndingComposition && isBackspace(event)) {\n    updateEditorSync(editor, () => {\n      $onCompositionEndImpl(editor, safariEndCompositionEventData);\n    });\n    isSafariEndingComposition = false;\n    safariEndCompositionEventData = '';\n    return;\n  }\n  if (isMoveForward(event)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(event)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(event)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(event)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(event)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(event)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(event)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(event)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(event)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(event)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(event)) {\n    if (isBackspace(event)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(event)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(event)) {\n    if (isDelete(event)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(event)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(event)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n    if (prevSelection !== null && !$isRangeSelection(prevSelection)) {\n      // Only RangeSelection can use the native cut/copy/select all\n      if (isCopy(event)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(event)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(event)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      }\n    } else if (isSelectAll(event)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n  if (isModifier(event)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n  if (eventHandles === undefined) {\n    eventHandles = [];\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n  return eventHandles;\n}\n\n// Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\nconst activeNestedEditorsMap = new Map();\nfunction onDocumentSelectionChange(event) {\n  const domSelection = getDOMSelectionFromTarget(event.target);\n  if (domSelection === null) {\n    return;\n  }\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n  if (nextActiveEditor === null) {\n    return;\n  }\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditorSync(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n      if (isHTMLElement(domAnchorNode) || isDOMTextNode(domAnchorNode)) {\n        // If the user is attempting to click selection back onto text, then\n        // we should attempt create a range selection.\n        // When we click on an empty paragraph node or the end of a paragraph that ends\n        // with an image/poll, the nodeType will be ELEMENT_NODE\n        const newSelection = $internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor, event);\n        $setSelection(newSelection);\n      }\n    });\n  }\n\n  // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n  onSelectionChange(domSelection, nextActiveEditor, true);\n\n  // If newly selected editor is nested, then add it to the map, clean map otherwise\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined || documentRootElementsCount < 1) {\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  rootElementsRegistered.set(doc, (documentRootElementsCount || 0) + 1);\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      if (editor.isEditable() || eventName === 'click') {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n      stopLexicalPropagation(event);\n      const isEditable = editor.isEditable();\n      switch (eventName) {\n        case 'cut':\n          return isEditable && dispatchCommand(editor, CUT_COMMAND, event);\n        case 'copy':\n          return dispatchCommand(editor, COPY_COMMAND, event);\n        case 'paste':\n          return isEditable && dispatchCommand(editor, PASTE_COMMAND, event);\n        case 'dragstart':\n          return isEditable && dispatchCommand(editor, DRAGSTART_COMMAND, event);\n        case 'dragover':\n          return isEditable && dispatchCommand(editor, DRAGOVER_COMMAND, event);\n        case 'dragend':\n          return isEditable && dispatchCommand(editor, DRAGEND_COMMAND, event);\n        case 'focus':\n          return isEditable && dispatchCommand(editor, FOCUS_COMMAND, event);\n        case 'blur':\n          {\n            return isEditable && dispatchCommand(editor, BLUR_COMMAND, event);\n          }\n        case 'drop':\n          return isEditable && dispatchCommand(editor, DROP_COMMAND, event);\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nconst rootElementNotRegisteredWarning = warnOnlyOnce('Root element not registered');\nfunction removeRootElementEvents(rootElement) {\n  const doc = rootElement.ownerDocument;\n  const documentRootElementsCount = rootElementsRegistered.get(doc);\n  if (documentRootElementsCount === undefined) {\n    // This can happen if setRootElement() failed\n    rootElementNotRegisteredWarning();\n    return;\n  }\n\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  const newCount = documentRootElementsCount - 1;\n  if (!(newCount >= 0)) {\n    formatDevErrorMessage(`Root element count less than 0`);\n  }\n  rootElementsRegistered.set(doc, newCount);\n  if (newCount === 0) {\n    doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n  }\n  const editor = getEditorPropertyFromDOMNode(rootElement);\n  if (isLexicalEditor(editor)) {\n    cleanActiveNestedEditorsMap(editor);\n    // @ts-expect-error: internal field\n    rootElement.__lexicalEditor = null;\n  } else if (editor) {\n    {\n      formatDevErrorMessage(`Attempted to remove event handlers from a node that does not belong to this build of Lexical`);\n    }\n  }\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  }\n\n  // @ts-expect-error: internal field\n  rootElement.__lexicalEventHandles = [];\n}\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * The base type for all serialized nodes\n */\n\n/**\n * EXPERIMENTAL\n * The configuration of a node returned by LexicalNode.$config()\n *\n * @example\n * ```ts\n * class CustomText extends TextNode {\n *   $config() {\n *     return this.config('custom-text', {extends: TextNode}};\n *   }\n * }\n * ```\n */\n\n/**\n * This is the type of LexicalNode.$config() that can be\n * overridden by subclasses.\n */\n\n/**\n * Used to extract the node and type from a StaticNodeConfigRecord\n */\n\n/**\n * Any StaticNodeConfigValue (for generics and collections)\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @internal\n *\n * This is the more specific type than BaseStaticNodeConfig that a subclass\n * should return from $config()\n */\n\n/**\n * Extract the type from a node based on its $config\n *\n * @example\n * ```ts\n * type TextNodeType = GetStaticNodeType<TextNode>;\n *      // ? 'text'\n * ```\n */\n\n/**\n * The most precise type we can infer for the JSON that will\n * be produced by T.exportJSON().\n *\n * Do not use this for the return type of T.exportJSON()! It must be\n * a more generic type to be compatible with subclassing.\n */\n\n/**\n * Omit the children, type, and version properties from the given SerializedLexicalNode definition.\n */\n\n/** @internal */\n\nfunction $removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n  if (parent === null) {\n    return;\n  }\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    $removeNode(parent, restoreSelection);\n  }\n  if (restoreSelection && selection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\n/**\n * An identity function that will infer the type of DOM nodes\n * based on tag names to make it easier to construct a\n * DOMConversionMap.\n */\nfunction buildImportMap(importMap) {\n  return importMap;\n}\nclass LexicalNode {\n  // Allow us to look up the type including static props\n\n  /** @internal */\n\n  /** @internal */\n  //@ts-ignore We set the key in the constructor.\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    const {\n      ownNodeType\n    } = getStaticNodeConfig(this);\n    if (!(ownNodeType !== undefined)) {\n      formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n    return ownNodeType;\n  }\n\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n  static clone(_data) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  /**\n   * Override this to implement the new static node configuration protocol,\n   * this method is called directly on the prototype and must not depend\n   * on anything initialized in the constructor. Generally it should be\n   * a trivial implementation.\n   *\n   * @example\n   * ```ts\n   * class MyNode extends TextNode {\n   *   $config() {\n   *     return this.config('my-node', {extends: TextNode});\n   *   }\n   * }\n   * ```\n   */\n  $config() {\n    return {};\n  }\n\n  /**\n   * This is a convenience method for $config that\n   * aids in type inference. See {@link LexicalNode.$config}\n   * for example usage.\n   */\n  config(type, config) {\n    const parentKlass = config.extends || Object.getPrototypeOf(this.constructor);\n    Object.assign(config, {\n      extends: parentKlass,\n      type\n    });\n    return {\n      [type]: config\n    };\n  }\n\n  /**\n   * Perform any state updates on the clone of prevNode that are not already\n   * handled by the constructor call in the static clone method. If you have\n   * state to update in your clone that is not handled directly by the\n   * constructor, it is advisable to override this method but it is required\n   * to include a call to `super.afterCloneFrom(prevNode)` in your\n   * implementation. This is only intended to be called by\n   * {@link $cloneWithProperties} function or via a super call.\n   *\n   * @example\n   * ```ts\n   * class ClassesTextNode extends TextNode {\n   *   // Not shown: static getType, static importJSON, exportJSON, createDOM, updateDOM\n   *   __classes = new Set<string>();\n   *   static clone(node: ClassesTextNode): ClassesTextNode {\n   *     // The inherited TextNode constructor is used here, so\n   *     // classes is not set by this method.\n   *     return new ClassesTextNode(node.__text, node.__key);\n   *   }\n   *   afterCloneFrom(node: this): void {\n   *     // This calls TextNode.afterCloneFrom and LexicalNode.afterCloneFrom\n   *     // for necessary state updates\n   *     super.afterCloneFrom(node);\n   *     this.__addClasses(node.__classes);\n   *   }\n   *   // This method is a private implementation detail, it is not\n   *   // suitable for the public API because it does not call getWritable\n   *   __addClasses(classNames: Iterable<string>): this {\n   *     for (const className of classNames) {\n   *       this.__classes.add(className);\n   *     }\n   *     return this;\n   *   }\n   *   addClass(...classNames: string[]): this {\n   *     return this.getWritable().__addClasses(classNames);\n   *   }\n   *   removeClass(...classNames: string[]): this {\n   *     const node = this.getWritable();\n   *     for (const className of classNames) {\n   *       this.__classes.delete(className);\n   *     }\n   *     return this;\n   *   }\n   *   getClasses(): Set<string> {\n   *     return this.getLatest().__classes;\n   *   }\n   * }\n   * ```\n   *\n   */\n  afterCloneFrom(prevNode) {\n    if (this.__key === prevNode.__key) {\n      this.__parent = prevNode.__parent;\n      this.__next = prevNode.__next;\n      this.__prev = prevNode.__prev;\n      this.__state = prevNode.__state;\n    } else if (prevNode.__state) {\n      this.__state = prevNode.__state.getWritable(this);\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  constructor(key) {\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    Object.defineProperty(this, '__state', {\n      configurable: true,\n      enumerable: false,\n      value: undefined,\n      writable: true\n    });\n    $setNodeKey(this, key);\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, this.constructor);\n      }\n    }\n  }\n  // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n  getType() {\n    return this.__type;\n  }\n  isInline() {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${this.constructor.name} does not implement .isInline().`);\n    }\n  }\n\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimately be cleaned up by the Lexical GC.\n   */\n  isAttached() {\n    let nodeKey = this.__key;\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n      const node = $getNodeByKey(nodeKey);\n      if (node === null) {\n        break;\n      }\n      nodeKey = node.__parent;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n    if (targetSelection == null) {\n      return false;\n    }\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n    if ($isTextNode(this)) {\n      return isSelected;\n    }\n    // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n    const isElementRangeSelection = $isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element';\n    if (isElementRangeSelection) {\n      if (targetSelection.isCollapsed()) {\n        return false;\n      }\n      const parentNode = this.getParent();\n      if ($isDecoratorNode(this) && this.isInline() && parentNode) {\n        const firstPoint = targetSelection.isBackward() ? targetSelection.focus : targetSelection.anchor;\n        if (parentNode.is(firstPoint.getNode()) && firstPoint.offset === parentNode.getChildrenSize() && this.is(parentNode.getLastChild())) {\n          return false;\n        }\n      }\n    }\n    return isSelected;\n  }\n\n  /**\n   * Returns this nodes key.\n   */\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n  getIndexWithinParent() {\n    const parent = this.getParent();\n    if (parent === null) {\n      return -1;\n    }\n    let node = parent.getFirstChild();\n    let index = 0;\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n      index++;\n      node = node.getNextSibling();\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n  getParent() {\n    const parent = this.getLatest().__parent;\n    if (parent === null) {\n      return null;\n    }\n    return $getNodeByKey(parent);\n  }\n\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n  getParentOrThrow() {\n    const parent = this.getParent();\n    if (parent === null) {\n      {\n        formatDevErrorMessage(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElement() {\n    let node = this;\n    while (node !== null) {\n      const parent = node.getParent();\n      if ($isRootOrShadowRoot(parent)) {\n        if (!($isElementNode(node) || node === this && $isDecoratorNode(node))) {\n          formatDevErrorMessage(`Children of root nodes must be elements or decorators`);\n        }\n        return node;\n      }\n      node = parent;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n    if (parent === null) {\n      {\n        formatDevErrorMessage(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n    return parent;\n  }\n\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n    return parents;\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n    if (parent === null) {\n      return siblings;\n    }\n    let node = parent.getFirstChild();\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n    return siblings;\n  }\n\n  /**\n   * @deprecated use {@link $getCommonAncestor}\n   *\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n  getCommonAncestor(node) {\n    const a = $isElementNode(this) ? this : this.getParent();\n    const b = $isElementNode(node) ? node : node.getParent();\n    const result = a && b ? $getCommonAncestor(a, b) : null;\n    return result ? result.commonAncestor /* TODO this type cast is a lie, but fixing it would break backwards compatibility */ : null;\n  }\n\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n    return this.__key === object.__key;\n  }\n\n  /**\n   * Returns true if this node logically precedes the target node in the\n   * editor state, false otherwise (including if there is no common ancestor).\n   *\n   * Note that this notion of isBefore is based on post-order; a descendant\n   * node is always before its ancestors. See also\n   * {@link $getCommonAncestor} and {@link $comparePointCaretNext} for\n   * more flexible ways to determine the relative positions of nodes.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n  isBefore(targetNode) {\n    const compare = $getCommonAncestor(this, targetNode);\n    if (compare === null) {\n      return false;\n    }\n    if (compare.type === 'descendant') {\n      return true;\n    }\n    if (compare.type === 'branch') {\n      return $getCommonAncestorResultBranchOrder(compare) === -1;\n    }\n    if (!(compare.type === 'same' || compare.type === 'ancestor')) {\n      formatDevErrorMessage(`LexicalNode.isBefore: exhaustiveness check`);\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this node is an ancestor of and distinct from the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n  isParentOf(targetNode) {\n    const result = $getCommonAncestor(this, targetNode);\n    return result !== null && result.type === 'ancestor';\n  }\n\n  // TO-DO: this function can be simplified a lot\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n    while (true) {\n      if (node === null) {\n        break;\n      }\n      const key = node.__key;\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n      if (node === targetNode) {\n        break;\n      }\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n      const parent = node.getParentOrThrow();\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n      if (parent === targetNode) {\n        break;\n      }\n      let parentSibling = null;\n      let ancestor = parent;\n      do {\n        if (ancestor === null) {\n          {\n            formatDevErrorMessage(`getNodesBetween: ancestor is null`);\n          }\n        }\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        } else {\n          break;\n        }\n      } while (parentSibling === null);\n      node = parentSibling;\n    }\n    if (!isBefore) {\n      nodes.reverse();\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n    if (latest === null) {\n      {\n        formatDevErrorMessage(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n    return latest;\n  }\n\n  /**\n   * Returns a mutable version of the node using {@link $cloneWithProperties}\n   * if necessary. Will throw an error if called outside of a Lexical Editor\n   * {@link LexicalEditor.update} callback.\n   *\n   */\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key;\n    // Ensure we get the latest node from pending state\n    const latestNode = this.getLatest();\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n    if (selection !== null) {\n      selection.setCachedNodes(null);\n    }\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n    const mutableNode = $cloneWithProperties(latestNode);\n    cloneNotNeeded.add(key);\n    internalMarkNodeAsDirty(mutableNode);\n    // Update reference in node map\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n  getTextContent() {\n    return '';\n  }\n\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n  getTextContentSize() {\n    return this.getTextContent().length;\n  }\n\n  // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecycle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n  createDOM(_config, _editor) {\n    {\n      formatDevErrorMessage(`createDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      formatDevErrorMessage(`updateDOM: base method not extended`);\n    }\n  }\n\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  exportJSON() {\n    // eslint-disable-next-line dot-notation\n    const state = this.__state ? this.__state.toJSON() : undefined;\n    return {\n      type: this.__type,\n      version: 1,\n      ...state\n    };\n  }\n\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n  static importJSON(_serializedNode) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n\n  /**\n   * Update this LexicalNode instance from serialized JSON. It's recommended\n   * to implement as much logic as possible in this method instead of the\n   * static importJSON method, so that the functionality can be inherited in subclasses.\n   *\n   * The LexicalUpdateJSON utility type should be used to ignore any type, version,\n   * or children properties in the JSON so that the extended JSON from subclasses\n   * are acceptable parameters for the super call.\n   *\n   * If overridden, this method must call super.\n   *\n   * @example\n   * ```ts\n   * class MyTextNode extends TextNode {\n   *   // ...\n   *   static importJSON(serializedNode: SerializedMyTextNode): MyTextNode {\n   *     return $createMyTextNode()\n   *       .updateFromJSON(serializedNode);\n   *   }\n   *   updateFromJSON(\n   *     serializedNode: LexicalUpdateJSON<SerializedMyTextNode>,\n   *   ): this {\n   *     return super.updateFromJSON(serializedNode)\n   *       .setMyProperty(serializedNode.myProperty);\n   *   }\n   * }\n   * ```\n   **/\n  updateFromJSON(serializedNode) {\n    return $updateStateFromJSON(this, serializedNode);\n  }\n\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n  static transform() {\n    return null;\n  }\n\n  // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n  remove(preserveEmptyParent) {\n    $removeNode(this, true, preserveEmptyParent);\n  }\n\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) {\n      selection = selection.clone();\n    }\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    $removeNode(self, false, true);\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n    writableReplaceWith.__prev = prevKey;\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n    if (includeChildren) {\n      if (!($isElementNode(this) && $isElementNode(writableReplaceWith))) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n    return writableReplaceWith;\n  }\n\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert before this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev;\n    // TODO: this is O(n), can we improve?\n    const index = this.getIndexWithinParent();\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n    return nodeToInsert;\n  }\n\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n  isParentRequired() {\n    return false;\n  }\n\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  selectStart() {\n    return this.selectPrevious();\n  }\n  selectEnd() {\n    return this.selectNext(0, 0);\n  }\n\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n    if (nextSibling === null) {\n      return parent.select();\n    }\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n  markDirty() {\n    this.getWritable();\n  }\n\n  /**\n   * @internal\n   *\n   * When the reconciler detects that a node was mutated, this method\n   * may be called to restore the node to a known good state.\n   */\n  reconcileObservedMutation(dom, editor) {\n    this.markDirty();\n  }\n}\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getRegisteredNode(getActiveEditor(), type);\n  // Common error - split in its own invariant\n  if (registeredNode === undefined) {\n    {\n      formatDevErrorMessage(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n  const editorKlass = registeredNode.klass;\n  if (editorKlass !== klass) {\n    {\n      formatDevErrorMessage(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Insert a series of nodes after this LexicalNode (as next siblings)\n *\n * @param firstToInsert - The first node to insert after this one.\n * @param lastToInsert - The last node to insert after this one. Must be a\n * later sibling of FirstNode. If not provided, it will be its last sibling.\n */\nfunction insertRangeAfter(node, firstToInsert, lastToInsert) {\n  const lastToInsert2 = firstToInsert.getParentOrThrow().getLastChild();\n  let current = firstToInsert;\n  const nodesToInsert = [firstToInsert];\n  while (current !== lastToInsert2) {\n    if (!current.getNextSibling()) {\n      {\n        formatDevErrorMessage(`insertRangeAfter: lastToInsert must be a later sibling of firstToInsert`);\n      }\n    }\n    current = current.getNextSibling();\n    nodesToInsert.push(current);\n  }\n  let currentNode = node;\n  for (const nodeToInsert of nodesToInsert) {\n    currentNode = currentNode.insertAfter(nodeToInsert);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n  constructor(key) {\n    super(key);\n  }\n  getTextContent() {\n    return '\\n';\n  }\n  createDOM() {\n    return document.createElement('br');\n  }\n  updateDOM() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  static importDOM() {\n    return {\n      br: node => {\n        if (isOnlyChildInBlockNode(node) || isLastChildInBlockNode(node)) {\n          return null;\n        }\n        return {\n          conversion: $convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode().updateFromJSON(serializedLineBreakNode);\n  }\n}\nfunction $convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\nfunction isOnlyChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      const lastChild = parentElement.lastChild;\n      if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isLastChildInBlockNode(node) {\n  const parentElement = node.parentElement;\n  if (parentElement !== null && isBlockDomNode(parentElement)) {\n    // check if node is first child, because only child dont count\n    const firstChild = parentElement.firstChild;\n    if (firstChild === node || firstChild.nextSibling === node && isWhitespaceDomTextNode(firstChild)) {\n      return false;\n    }\n\n    // check if its last child\n    const lastChild = parentElement.lastChild;\n    if (lastChild === node || lastChild.previousSibling === node && isWhitespaceDomTextNode(lastChild)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isWhitespaceDomTextNode(node) {\n  return isDOMTextNode(node) && /^( |\\t|\\r?\\n)+$/.test(node.textContent || '');\n}\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n  return null;\n}\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n  return 'span';\n}\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList;\n  // Firstly we handle the base theme.\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  }\n  // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n          continue;\n        }\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing();\n  // Always add a suffix if we're composing a node\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        }\n        // @ts-expect-error\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme;\n  // Apply theme class names\n  const textClassNames = theme.text;\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'text';\n  }\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__text = prevNode.__text;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__mode = prevNode.__mode;\n    this.__detail = prevNode.__detail;\n  }\n  constructor(text = '', key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not individually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n\n  /**\n   * Returns whether or not the node is in \"segmented\" mode. TextNodes in segmented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n\n  /**\n   *\n   * @returns true if the text node supports font styling, false otherwise.\n   */\n  canHaveFormat() {\n    return true;\n  }\n\n  /**\n   * @returns true if the text node is inline, false otherwise.\n   */\n  isInline() {\n    return true;\n  }\n\n  // View\n\n  createDOM(config, editor) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n    if (prevTag !== nextTag) {\n      return true;\n    }\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n      if (prevInnerDOM == null) {\n        {\n          formatDevErrorMessage(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n    let innerDOM = dom;\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n        if (innerDOM == null) {\n          {\n            formatDevErrorMessage(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme;\n    // Apply theme class names\n    const textClassNames = theme.text;\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n    return false;\n  }\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: $convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      mark: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTextNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setTextContent(serializedNode.text).setFormat(serializedNode.format).setDetail(serializedNode.detail).setMode(serializedNode.mode).setStyle(serializedNode.style);\n  }\n\n  // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n    if (!isHTMLElement(element)) {\n      formatDevErrorMessage(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n    element.style.whiteSpace = 'pre-wrap';\n\n    // Add text-transform styles for capitalization formats\n    if (this.hasFormat('lowercase')) {\n      element.style.textTransform = 'lowercase';\n    } else if (this.hasFormat('uppercase')) {\n      element.style.textTransform = 'uppercase';\n    } else if (this.hasFormat('capitalize')) {\n      element.style.textTransform = 'capitalize';\n    }\n\n    // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n  }\n\n  // Mutators\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.toggleUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it's present.\n   * The subscript and superscript formats are mutually exclusive.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n  toggleFormat(type) {\n    const format = this.getFormat();\n    const newFormat = toggleTextFormatType(format, type, null);\n    return this.setFormat(newFormat);\n  }\n\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n    if (this.__mode === mode) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n    return selection;\n  }\n  selectStart() {\n    return this.select(0, 0);\n  }\n  selectEnd() {\n    const size = this.getTextContentSize();\n    return this.select(size, size);\n  }\n\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n    if (index < 0) {\n      index = handledTextLength + index;\n      if (index < 0) {\n        index = 0;\n      }\n    }\n    const selection = $getSelection();\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n  canInsertTextBefore() {\n    return true;\n  }\n\n  /**\n   * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n  canInsertTextAfter() {\n    return true;\n  }\n\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    if (textContent === '') {\n      return [];\n    }\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const textLength = textContent.length;\n    splitOffsets.sort((a, b) => a - b);\n    splitOffsets.push(textLength);\n    const parts = [];\n    const splitOffsetsLength = splitOffsets.length;\n    for (let start = 0, offsetIndex = 0; start < textLength && offsetIndex <= splitOffsetsLength; offsetIndex++) {\n      const end = splitOffsets[offsetIndex];\n      if (end > start) {\n        parts.push(textContent.slice(start, end));\n        start = end;\n      }\n    }\n    const partsLength = parts.length;\n    if (partsLength === 1) {\n      return [self];\n    }\n    const firstPart = parts[0];\n    const parent = self.getParent();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n\n    // Prepare to handle selection\n    let startTextPoint = null;\n    let endTextPoint = null;\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const [startPoint, endPoint] = selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];\n      if (startPoint.type === 'text' && startPoint.key === key) {\n        startTextPoint = startPoint;\n      }\n      if (endPoint.type === 'text' && endPoint.key === key) {\n        endTextPoint = endPoint;\n      }\n    }\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      writableNode.__state = $cloneNodeState(self, writableNode);\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.setTextContent(firstPart);\n    }\n\n    // Then handle all other parts\n    const splitNodes = [writableNode];\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const sibling = $createTextNode(part);\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      sibling.__state = $cloneNodeState(self, sibling);\n      const siblingKey = sibling.__key;\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n      splitNodes.push(sibling);\n    }\n\n    // Move the selection to the best location in the split string.\n    // The end point is always left-biased, and the start point is\n    // generally left biased unless the end point would land on a\n    // later node in the split in which case it will prefer the start\n    // of that node so they will tend to be on the same node.\n    const originalStartOffset = startTextPoint ? startTextPoint.offset : null;\n    const originalEndOffset = endTextPoint ? endTextPoint.offset : null;\n    let startOffset = 0;\n    for (const node of splitNodes) {\n      if (!(startTextPoint || endTextPoint)) {\n        break;\n      }\n      const endOffset = startOffset + node.getTextContentSize();\n      if (startTextPoint !== null && originalStartOffset !== null && originalStartOffset <= endOffset && originalStartOffset >= startOffset) {\n        // Set the start point to the first valid node\n        startTextPoint.set(node.getKey(), originalStartOffset - startOffset, 'text');\n        if (originalStartOffset < endOffset) {\n          // The start isn't on a border so we can stop checking\n          startTextPoint = null;\n        }\n      }\n      if (endTextPoint !== null && originalEndOffset !== null && originalEndOffset <= endOffset && originalEndOffset >= startOffset) {\n        endTextPoint.set(node.getKey(), originalEndOffset - startOffset, 'text');\n        break;\n      }\n      startOffset = endOffset;\n    }\n\n    // Insert the nodes into the parent's children\n    if (parent !== null) {\n      internalMarkSiblingsAsDirty(this);\n      const writableParent = parent.getWritable();\n      const insertionIndex = this.getIndexWithinParent();\n      if (hasReplacedSelf) {\n        writableParent.splice(insertionIndex, 0, splitNodes);\n        this.remove();\n      } else {\n        writableParent.splice(insertionIndex, 1, splitNodes);\n      }\n      if ($isRangeSelection(selection)) {\n        $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n      }\n    }\n    return splitNodes;\n  }\n\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        formatDevErrorMessage(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n      }\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n      }\n    }\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n\n  /**\n   * This method is meant to be overridden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n  isTextEntity() {\n    return false;\n  }\n}\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode;\n  const style = span.style;\n  return {\n    forChild: applyTextFormatFromStyle(style),\n    node: null\n  };\n}\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode;\n  // Google Docs wraps all copied HTML in a <b> with font-weight normal\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: applyTextFormatFromStyle(b.style, hasNormalFontWeight ? undefined : 'bold'),\n    node: null\n  };\n}\nconst preParentCache = new WeakMap();\nfunction isNodePre(node) {\n  if (!isHTMLElement(node)) {\n    return false;\n  } else if (node.nodeName === 'PRE') {\n    return true;\n  }\n  const whiteSpace = node.style.whiteSpace;\n  return typeof whiteSpace === 'string' && whiteSpace.startsWith('pre');\n}\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n  const resultNode = cached === undefined ? parent : cached;\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n  return resultNode;\n}\nfunction $convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n  if (!(parentDom !== null)) {\n    formatDevErrorMessage(`Expected parentElement of Text not to be null`);\n  }\n  let textContent = domNode_.textContent || '';\n  // No collapse and preserve segment break for pre, pre-wrap and pre-line\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n    return {\n      node: nodes\n    };\n  }\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> potential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n        isStartOfLine = false;\n        break;\n      }\n    }\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n  return {\n    node: $createTextNode(textContent)\n  };\n}\nfunction findTextInLine(text, forward) {\n  let node = text;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    let sibling;\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n      if (parentElement === null) {\n        return null;\n      }\n      node = parentElement;\n    }\n    node = sibling;\n    if (isHTMLElement(node)) {\n      const display = node.style.display;\n      if (display === '' && !isInlineDomNode(node) || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n    let descendant = node;\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n    if (isDOMTextNode(node)) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  mark: 'highlight',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n  return {\n    forChild: applyTextFormatFromStyle(domNode.style, format),\n    node: null\n  };\n}\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\nfunction applyTextFormatFromStyle(style, shouldApply) {\n  const fontWeight = style.fontWeight;\n  const textDecoration = style.textDecoration.split(' ');\n  // Google Docs uses span tags + font-weight for bold text\n  const hasBoldFontWeight = fontWeight === '700' || fontWeight === 'bold';\n  // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  // Google Docs uses span tags + font-style for italic text\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  // Google Docs uses span tags + text-decoration: underline for underline text\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  // Google Docs uses span tags + vertical-align to specify subscript and superscript\n  const verticalAlign = style.verticalAlign;\n  return lexicalNode => {\n    if (!$isTextNode(lexicalNode)) {\n      return lexicalNode;\n    }\n    if (hasBoldFontWeight && !lexicalNode.hasFormat('bold')) {\n      lexicalNode.toggleFormat('bold');\n    }\n    if (hasLinethroughTextDecoration && !lexicalNode.hasFormat('strikethrough')) {\n      lexicalNode.toggleFormat('strikethrough');\n    }\n    if (hasItalicFontStyle && !lexicalNode.hasFormat('italic')) {\n      lexicalNode.toggleFormat('italic');\n    }\n    if (hasUnderlineTextDecoration && !lexicalNode.hasFormat('underline')) {\n      lexicalNode.toggleFormat('underline');\n    }\n    if (verticalAlign === 'sub' && !lexicalNode.hasFormat('subscript')) {\n      lexicalNode.toggleFormat('subscript');\n    }\n    if (verticalAlign === 'super' && !lexicalNode.hasFormat('superscript')) {\n      lexicalNode.toggleFormat('superscript');\n    }\n    if (shouldApply && !lexicalNode.hasFormat(shouldApply)) {\n      lexicalNode.toggleFormat(shouldApply);\n    }\n    return lexicalNode;\n  };\n}\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n  static clone(node) {\n    return new TabNode(node.__key);\n  }\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n  static importDOM() {\n    return null;\n  }\n  createDOM(config) {\n    const dom = super.createDOM(config);\n    const classNames = getCachedClassNameArray(config.theme, 'tab');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  static importJSON(serializedTabNode) {\n    return $createTabNode().updateFromJSON(serializedTabNode);\n  }\n  setTextContent(text) {\n    if (!(text === '\\t' || text === '')) {\n      formatDevErrorMessage(`TabNode does not support setTextContent`);\n    }\n    return super.setTextContent('\\t');\n  }\n  spliceText(offset, delCount, newText, moveSelection) {\n    if (!(newText === '' && delCount === 0 || newText === '\\t' && delCount === 1)) {\n      formatDevErrorMessage(`TabNode does not support spliceText`);\n    }\n    return this;\n  }\n  setDetail(detail) {\n    if (!(detail === IS_UNMERGEABLE)) {\n      formatDevErrorMessage(`TabNode does not support setDetail`);\n    }\n    return this;\n  }\n  setMode(type) {\n    if (!(type === 'normal')) {\n      formatDevErrorMessage(`TabNode does not support setMode`);\n    }\n    return this;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\nclass Point {\n  constructor(key, offset, type) {\n    {\n      // This prevents a circular reference error when serialized as JSON,\n      // which happens on unit test failures\n      Object.defineProperty(this, '_selection', {\n        enumerable: false,\n        writable: true\n      });\n    }\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n  isBefore(b) {\n    if (this.key === b.key) {\n      return this.offset < b.offset;\n    }\n    const aCaret = $normalizeCaret($caretFromPoint(this, 'next'));\n    const bCaret = $normalizeCaret($caretFromPoint(b, 'next'));\n    return $comparePointCaretNext(aCaret, bCaret) < 0;\n  }\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n    if (node === null) {\n      {\n        formatDevErrorMessage(`Point.getNode: node not found`);\n      }\n    }\n    return node;\n  }\n  set(key, offset, type, onlyIfChanged) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    if (onlyIfChanged && this.key === key && this.offset === offset && this.type === type) {\n      return;\n    }\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n    {\n      const node = $getNodeByKey(key);\n      if (!(type === 'text' ? $isTextNode(node) : $isElementNode(node))) {\n        formatDevErrorMessage(`PointType.set: node with key ${key} is ${node ? node.__type : '[not found]'} and can not be used for a ${type} point`);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n      if (selection !== null) {\n        selection.setCachedNodes(null);\n        selection.dirty = true;\n      }\n    }\n  }\n}\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n  point.set(key, offset, type);\n}\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target);\n  }\n  // Transfer the element point to a text point.\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n  start.set(textNode.__key, 0, 'text');\n}\nclass NodeSelection {\n  constructor(objects) {\n    this._cachedNodes = null;\n    this._nodes = objects;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n  isCollapsed() {\n    return false;\n  }\n  isBackward() {\n    return false;\n  }\n  getStartEndPoints() {\n    return null;\n  }\n  add(key) {\n    this.dirty = true;\n    this._nodes.add(key);\n    this._cachedNodes = null;\n  }\n  delete(key) {\n    this.dirty = true;\n    this._nodes.delete(key);\n    this._cachedNodes = null;\n  }\n  clear() {\n    this.dirty = true;\n    this._nodes.clear();\n    this._cachedNodes = null;\n  }\n  has(key) {\n    return this._nodes.has(key);\n  }\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n  insertNodes(nodes) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd;\n    // Insert nodes\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n    selectionAtEnd.insertNodes(nodes);\n    // Remove selected nodes\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n  }\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const objects = this._nodes;\n    const nodes = [];\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n    return textContent;\n  }\n\n  /**\n   * Remove all nodes in the NodeSelection. If there were any nodes,\n   * replace the selection with a new RangeSelection at the previous\n   * location of the first node.\n   */\n  deleteNodes() {\n    const nodes = this.getNodes();\n    if (($getSelection() || $getPreviousSelection()) === this && nodes[0]) {\n      const firstCaret = $getSiblingCaret(nodes[0], 'next');\n      $setSelectionFromCaretRange($getCaretRange(firstCaret, firstCaret));\n    }\n    for (const node of nodes) {\n      node.remove();\n    }\n  }\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.format = format;\n    this.style = style;\n    this.dirty = false;\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * including anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * See also the {@link CaretRange} APIs (starting with\n   * {@link $caretRangeFromSelection}), which are likely to provide a better\n   * foundation for any operation where partial selection is relevant\n   * (e.g. the anchor or focus are inside an ElementNode and TextNode)\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const range = $getCaretRangeInDirection($caretRangeFromSelection(this), 'next');\n    const nodes = $getNodesFromCaretRangeCompat(range);\n    {\n      if (this.isCollapsed() && nodes.length > 1) {\n        {\n          formatDevErrorMessage(`RangeSelection.getNodes() returned ${String(nodes.length)} > 1 nodes in a collapsed selection`);\n        }\n      }\n    }\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    this.anchor.set(anchorNode.__key, anchorOffset, 'text');\n    this.focus.set(focusNode.__key, focusOffset, 'text');\n  }\n\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n  getTextContent() {\n    const nodes = this.getNodes();\n    if (nodes.length === 0) {\n      return '';\n    }\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n    return textContent;\n  }\n\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = $internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    this.anchor.set(anchorPoint.key, anchorPoint.offset, anchorPoint.type, true);\n    this.focus.set(focusPoint.key, focusPoint.offset, focusPoint.type, true);\n    // Firefox will use an element point rather than a text point in some cases,\n    // so we normalize for that\n    $normalizeSelection(this);\n  }\n\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the format property on the Selection\n   *\n   * @param format - the format to set at the value of the format property.\n   */\n  setFormat(format) {\n    this.format = format;\n    this.dirty = true;\n  }\n\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n    this.insertNodes(nodes);\n  }\n\n  /**\n   * Insert the provided text into the EditorState at the current Selection.\n   *\n   * @param text the text to insert into the Selection\n   */\n  insertText(text) {\n    // Now that \"removeText\" has been improved and does not depend on\n    // insertText, insertText can be greatly simplified. The next\n    // commented version is a WIP (about 5 tests fail).\n    //\n    // this.removeText();\n    // if (text === '') {\n    //   return;\n    // }\n    // const anchorNode = this.anchor.getNode();\n    // const textNode = $createTextNode(text);\n    // textNode.setFormat(this.format);\n    // textNode.setStyle(this.style);\n    // if ($isTextNode(anchorNode)) {\n    //   const parent = anchorNode.getParentOrThrow();\n    //   if (this.anchor.offset === 0) {\n    //     if (parent.isInline() && !anchorNode.__prev) {\n    //       parent.insertBefore(textNode);\n    //     } else {\n    //       anchorNode.insertBefore(textNode);\n    //     }\n    //   } else if (this.anchor.offset === anchorNode.getTextContentSize()) {\n    //     if (parent.isInline() && !anchorNode.__next) {\n    //       parent.insertAfter(textNode);\n    //     } else {\n    //       anchorNode.insertAfter(textNode);\n    //     }\n    //   } else {\n    //     const [before] = anchorNode.splitText(this.anchor.offset);\n    //     before.insertAfter(textNode);\n    //   }\n    // } else {\n    //   anchorNode.splice(this.anchor.offset, 0, [textNode]);\n    // }\n    // const nodeToSelect = textNode.isAttached() ? textNode : anchorNode;\n    // nodeToSelect.selectEnd();\n    // // When composing, we need to adjust the anchor offset so that\n    // // we correctly replace that right range.\n    // if (\n    //   textNode.isComposing() &&\n    //   this.anchor.type === 'text' &&\n    //   anchorNode.getTextContent() !== ''\n    // ) {\n    //   this.anchor.offset -= text.length;\n    // }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const format = this.format;\n    const style = this.style;\n    let firstPoint = anchor;\n    let endPoint = focus;\n    if (!this.isCollapsed() && focus.isBefore(anchor)) {\n      firstPoint = focus;\n      endPoint = anchor;\n    }\n    if (firstPoint.type === 'element') {\n      $transferStartingElementPointToTextPoint(firstPoint, endPoint, format, style);\n    }\n    if (endPoint.type === 'element') {\n      $setPointFromCaret(endPoint, $normalizeCaret($caretFromPoint(endPoint, 'next')));\n    }\n    const startOffset = firstPoint.offset;\n    let endOffset = endPoint.offset;\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    let firstNode = selectedNodes[0];\n    if (!$isTextNode(firstNode)) {\n      {\n        formatDevErrorMessage(`insertText: first node is not a text node`);\n      }\n    }\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n    if (selectedNodesLength === 1 && endPoint.type === 'element') {\n      endOffset = firstNodeTextLength;\n      endPoint.set(firstPoint.key, endOffset, 'text');\n    }\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && ($isTokenOrSegmented(firstNode) || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n        nextSibling.setStyle(style);\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && ($isTokenOrSegmented(firstNode) || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n      prevSibling.select();\n      firstNode = prevSibling;\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        $normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n    if (selectedNodesLength === 1) {\n      if ($isTokenOrTab(firstNode)) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          }\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n          return;\n        }\n      } else if ($isTabNode(firstNode)) {\n        // We don't need to check for delCount because there is only the entire selected node case\n        // that can hit here for content size 1 and with canInsertTextBeforeAfter false\n        const textNode = $createTextNode(text);\n        textNode.setFormat(format);\n        textNode.setStyle(style);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);\n\n      // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode;\n\n      // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      }\n\n      // Handle mutations to the last node.\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !$isTokenOrTab(lastNode) && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          }\n          // root node selections only select whole nodes, so no text splice is necessary\n          if (!$isRootNode(endPoint.getNode()) && endPoint.type === 'text') {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      }\n\n      // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement);\n\n      // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n          parent = parent.getParent();\n        }\n      }\n\n      // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n      if (!$isTokenOrTab(firstNode)) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      }\n\n      // Remove all selected nodes that haven't already been removed.\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n  removeText() {\n    const isCurrentSelection = $getSelection() === this;\n    const newRange = $removeTextFromCaretRange($caretRangeFromSelection(this));\n    $updateRangeSelectionFromCaretRange(this, newRange);\n    if (isCurrentSelection && $getSelection() !== this) {\n      $setSelection(this);\n    }\n  }\n\n  // TO-DO: Migrate this method to the new utility function $forEachSelectedTextNode (share similar logic)\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   * @param alignWithFormat a 32-bit integer representing formatting flags to align with.\n   */\n  formatText(formatType, alignWithFormat = null) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      return;\n    }\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n    const applyFormatToElements = alignWith => {\n      selectedNodes.forEach(node => {\n        if ($isElementNode(node)) {\n          const newFormat = node.getFormatFlags(formatType, alignWith);\n          node.setTextFormat(newFormat);\n        }\n      });\n    };\n    const selectedTextNodesLength = selectedTextNodes.length;\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType);\n      // When changing format, we should stop composition\n      $setCompositionKey(null);\n      applyFormatToElements(alignWithFormat);\n      return;\n    }\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset;\n\n    // In case selection started at the end of text node use next text node\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n    if (firstNode == null) {\n      return;\n    }\n    const firstNextFormat = firstNode.getFormatFlags(formatType, alignWithFormat);\n    applyFormatToElements(firstNextFormat);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize();\n\n    // Single node selected\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      }\n      // The entire node is selected or it is token, so just format it\n      if ($isTokenOrSegmented(firstNode) || startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat);\n\n        // Update selection only if starts/ends on text node\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n      this.format = firstNextFormat;\n      return;\n    }\n    // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n    if (startOffset !== 0 && !$isTokenOrSegmented(firstNode)) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);\n    // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize() && !$isTokenOrSegmented(lastNode)) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n      lastNode.setFormat(lastNextFormat);\n    }\n\n    // Process all text nodes in between\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n      const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n      textNode.setFormat(nextFormat);\n    }\n\n    // Update selection only if starts/ends on text node\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n    this.format = firstNextFormat | lastNextFormat;\n  }\n\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accommodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   */\n  insertNodes(nodes) {\n    if (nodes.length === 0) {\n      return;\n    }\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n    if (this.anchor.key === 'root') {\n      this.insertParagraph();\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection)) {\n        formatDevErrorMessage(`Expected RangeSelection after insertParagraph`);\n      }\n      return selection.insertNodes(nodes);\n    }\n    const firstPoint = this.isBackward() ? this.focus : this.anchor;\n    const firstNode = firstPoint.getNode();\n    const firstBlock = $getAncestor(firstNode, INTERNAL_$isBlock);\n    const last = nodes[nodes.length - 1];\n\n    // CASE 1: insert inside a code block\n    if ($isElementNode(firstBlock) && '__language' in firstBlock) {\n      if ('__language' in nodes[0]) {\n        this.insertText(nodes[0].getTextContent());\n      } else {\n        const index = $removeTextAndSplitBlock(this);\n        firstBlock.splice(index, 0, nodes);\n        last.selectEnd();\n      }\n      return;\n    }\n\n    // CASE 2: All elements of the array are inline\n    const notInline = node => ($isElementNode(node) || $isDecoratorNode(node)) && !node.isInline();\n    if (!nodes.some(notInline)) {\n      if (!$isElementNode(firstBlock)) {\n        formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      const index = $removeTextAndSplitBlock(this);\n      firstBlock.splice(index, 0, nodes);\n      last.selectEnd();\n      return;\n    }\n\n    // CASE 3: At least 1 element of the array is not inline\n    const blocksParent = $wrapInlineNodes(nodes);\n    const nodeToSelect = blocksParent.getLastDescendant();\n    const blocks = blocksParent.getChildren();\n    const isMergeable = node => $isElementNode(node) && INTERNAL_$isBlock(node) && !node.isEmpty() && $isElementNode(firstBlock) && (!firstBlock.isEmpty() || firstBlock.canMergeWhenEmpty());\n    const shouldInsert = !$isElementNode(firstBlock) || !firstBlock.isEmpty();\n    const insertedParagraph = shouldInsert ? this.insertParagraph() : null;\n    const lastToInsert = blocks[blocks.length - 1];\n    let firstToInsert = blocks[0];\n    if (isMergeable(firstToInsert)) {\n      if (!$isElementNode(firstBlock)) {\n        formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ElementNode ancestor`);\n      }\n      firstBlock.append(...firstToInsert.getChildren());\n      firstToInsert = blocks[1];\n    }\n    if (firstToInsert) {\n      if (!(firstBlock !== null)) {\n        formatDevErrorMessage(`Expected node ${firstNode.constructor.name} of type ${firstNode.getType()} to have a block ancestor`);\n      }\n      insertRangeAfter(firstBlock, firstToInsert);\n    }\n    const lastInsertedBlock = $getAncestor(nodeToSelect, INTERNAL_$isBlock);\n    if (insertedParagraph && $isElementNode(lastInsertedBlock) && (insertedParagraph.canMergeWhenEmpty() || INTERNAL_$isBlock(lastToInsert))) {\n      lastInsertedBlock.append(...insertedParagraph.getChildren());\n      insertedParagraph.remove();\n    }\n    if ($isElementNode(firstBlock) && firstBlock.isEmpty()) {\n      firstBlock.remove();\n    }\n    nodeToSelect.selectEnd();\n\n    // To understand this take a look at the test \"can wrap post-linebreak nodes into new element\"\n    const lastChild = $isElementNode(firstBlock) ? firstBlock.getLastChild() : null;\n    if ($isLineBreakNode(lastChild) && lastInsertedBlock !== firstBlock) {\n      lastChild.remove();\n    }\n  }\n\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   *\n   * @returns the newly inserted node.\n   */\n  insertParagraph() {\n    if (this.anchor.key === 'root') {\n      const paragraph = $createParagraphNode();\n      $getRoot().splice(this.anchor.offset, 0, [paragraph]);\n      paragraph.select();\n      return paragraph;\n    }\n    const index = $removeTextAndSplitBlock(this);\n    const block = $getAncestor(this.anchor.getNode(), INTERNAL_$isBlock);\n    if (!$isElementNode(block)) {\n      formatDevErrorMessage(`Expected ancestor to be a block ElementNode`);\n    }\n    const firstToAppend = block.getChildAtIndex(index);\n    const nodesToInsert = firstToAppend ? [firstToAppend, ...firstToAppend.getNextSiblings()] : [];\n    const newBlock = block.insertNewAfter(this, false);\n    if (newBlock) {\n      newBlock.append(...nodesToInsert);\n      newBlock.selectStart();\n      return newBlock;\n    }\n    // if newBlock is null, it means that block is of type CodeNode.\n    return null;\n  }\n\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   */\n  insertLineBreak(selectStart) {\n    const lineBreak = $createLineBreakNode();\n    this.insertNodes([lineBreak]);\n    // this is used in MacOS with the command 'ctrl-O' (openLineBreak)\n    if (selectStart) {\n      const parent = lineBreak.getParentOrThrow();\n      const index = lineBreak.getIndexWithinParent();\n      parent.select(index, index);\n    }\n  }\n\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = $getCharacterOffsets(this);\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n      return [firstNode];\n    }\n    const isBefore = anchor.isBefore(focus);\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n    return selectedNodes;\n  }\n\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n  modify(alter, isBackward, granularity) {\n    if ($modifySelectionAroundDecoratorsAndBlocks(this, alter, isBackward, granularity)) {\n      return;\n    }\n    const collapse = alter === 'move';\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(getWindow(editor));\n    if (!domSelection) {\n      return;\n    }\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement;\n    const focusNode = this.focus.getNode();\n    // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(focusNode) && !focusNode.isInline() && !focusNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    }\n    if (this.dirty) {\n      let nextAnchorDOM = getElementByKeyOrThrow(editor, this.anchor.key);\n      let nextFocusDOM = getElementByKeyOrThrow(editor, this.focus.key);\n      if (this.anchor.type === 'text') {\n        nextAnchorDOM = getDOMTextNode(nextAnchorDOM);\n      }\n      if (this.focus.type === 'text') {\n        nextFocusDOM = getDOMTextNode(nextFocusDOM);\n      }\n      if (nextAnchorDOM && nextFocusDOM) {\n        setDOMSelectionBaseAndExtent(domSelection, nextAnchorDOM, this.anchor.offset, nextFocusDOM, this.focus.offset);\n      }\n    }\n    // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity);\n    // Guard against no ranges\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0);\n      // Apply the DOM selection to our Lexical selection.\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        }\n\n        // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n    if (granularity === 'lineboundary') {\n      $modifySelectionAroundDecoratorsAndBlocks(this, alter, isBackward, granularity, 'decorators');\n    }\n  }\n  /**\n   * Helper for handling forward character and word deletion that prevents element nodes\n   * like a table, columns layout being destroyed\n   *\n   * @param anchor the anchor\n   * @param anchorNode the anchor node in the selection\n   * @param isBackward whether or not selection is backwards\n   */\n  forwardDeletion(anchor, anchorNode, isBackward) {\n    if (!isBackward && (\n    // Delete forward handle case\n    anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n      const parent = anchorNode.getParent();\n      const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n      if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      let anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      const direction = isBackward ? 'previous' : 'next';\n      const initialCaret = $caretFromPoint(anchor, direction);\n      const initialRange = $extendCaretToRange(initialCaret);\n      if (initialRange.getTextSlices().every(slice => slice === null || slice.distance === 0)) {\n        // There's no text in the direction of the deletion so we can explore our options\n        let state = {\n          type: 'initial'\n        };\n        for (const caret of initialRange.iterNodeCarets('shadowRoot')) {\n          if ($isChildCaret(caret)) {\n            if (caret.origin.isInline()) ; else if (caret.origin.isShadowRoot()) {\n              if (state.type === 'merge-block') {\n                break;\n              }\n              // Don't merge with a shadow root block\n              if ($isElementNode(initialRange.anchor.origin) && initialRange.anchor.origin.isEmpty()) {\n                // delete an empty paragraph like the DecoratorNode case\n                const normCaret = $normalizeCaret(caret);\n                $updateRangeSelectionFromCaretRange(this, $getCaretRange(normCaret, normCaret));\n                initialRange.anchor.origin.remove();\n              }\n              return;\n            } else if (state.type === 'merge-next-block' || state.type === 'merge-block') {\n              // Keep descending ChildCaret to find which block to merge with\n              state = {\n                block: state.block,\n                caret,\n                type: 'merge-block'\n              };\n            }\n          } else if (state.type === 'merge-block') {\n            break;\n          } else if ($isSiblingCaret(caret)) {\n            if ($isElementNode(caret.origin)) {\n              if (!caret.origin.isInline()) {\n                state = {\n                  block: caret.origin,\n                  type: 'merge-next-block'\n                };\n              } else if (!caret.origin.isParentOf(initialRange.anchor.origin)) {\n                break;\n              }\n              continue;\n            } else if ($isDecoratorNode(caret.origin)) {\n              if (caret.origin.isIsolated()) ; else if (state.type === 'merge-next-block' && (caret.origin.isKeyboardSelectable() || !caret.origin.isInline()) && $isElementNode(initialRange.anchor.origin) && initialRange.anchor.origin.isEmpty()) {\n                // If the anchor is an empty element that is adjacent to a\n                // decorator then we remove the paragraph and select the\n                // decorator\n                initialRange.anchor.origin.remove();\n                const nodeSelection = $createNodeSelection();\n                nodeSelection.add(caret.origin.getKey());\n                $setSelection(nodeSelection);\n              } else {\n                // When the anchor is not an empty element then the\n                // adjacent decorator is removed\n                caret.origin.remove();\n              }\n              // always stop when a decorator is encountered\n              return;\n            }\n            break;\n          }\n        }\n        if (state.type === 'merge-block') {\n          const {\n            caret,\n            block\n          } = state;\n          $updateRangeSelectionFromCaretRange(this, $getCaretRange(!caret.origin.isEmpty() && block.isEmpty() ? $rewindSiblingCaret($getSiblingCaret(block, caret.direction)) : initialRange.anchor, caret));\n          return this.removeText();\n        }\n      }\n\n      // Handle the deletion around decorators.\n      const focus = this.focus;\n      this.modify('extend', isBackward, 'character');\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        if ($collapseAtStart(this, anchor.getNode())) {\n          return;\n        }\n      }\n    }\n    this.removeText();\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getPreviousSibling() === null) {\n        $collapseAtStart(this, anchorNode);\n      }\n    }\n  }\n\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'lineboundary');\n    }\n    if (this.isCollapsed()) {\n      // If the selection was already collapsed at the lineboundary,\n      // use the deleteCharacter operation to handle all of the logic associated\n      // with navigating through the parent element\n      this.deleteCharacter(isBackward);\n    } else {\n      this.removeText();\n    }\n  }\n\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const anchorNode = anchor.getNode();\n      if (this.forwardDeletion(anchor, anchorNode, isBackward)) {\n        return;\n      }\n      this.modify('extend', isBackward, 'word');\n    }\n    this.removeText();\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n  if (point.type === 'text') {\n    return offset;\n  }\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\nfunction $getCharacterOffsets(selection) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (anchorAndFocus === null) {\n    return [0, 0];\n  }\n  const [anchor, focus] = anchorAndFocus;\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\nfunction $collapseAtStart(selection, startNode) {\n  for (let node = startNode; node; node = node.getParent()) {\n    if ($isElementNode(node)) {\n      if (node.collapseAtStart(selection)) {\n        return true;\n      }\n      if ($isRootOrShadowRoot(node)) {\n        break;\n      }\n    }\n    if (node.getPreviousSibling()) {\n      break;\n    }\n  }\n  return false;\n}\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  anchor.set(focus.key, focus.offset, focus.type, true);\n  focus.set(anchorKey, anchorOffset, anchorType, true);\n}\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\n\n/**\n * Called by `RangeSelection.deleteCharacter` to determine if\n * `this.modify('extend', isBackward, 'character')` extended the selection\n * further than a user would expect for that operation.\n *\n * A short(?) JavaScript string vs. Unicode primer:\n *\n * Strings in JavaScript use an UTF-16 encoding, and the offsets into a\n * string are based on those UTF-16 *code units*. This is basically a\n * historical mistake (though logical at that time, decades ago), but\n * can never really be fixed for compatibility reasons.\n *\n * In Unicode, a *code point* is the combination of one or more *code units*.\n * and the range of a *code point* can fit into 21 bits.\n *\n * Every valid *code point* can be represented with one or two\n * *UTF-16 code units*. One unit is used when the code point is in the\n * Basic Multilingual Plane (BMP) and is `< 0xFFFF`. Anything outside\n * of that plane is encoded with a *surrogate pair* of *code units* and\n * `/[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/` is a regex that you could use to\n * find any valid *surrogate pair*. As far as Unicode is concerned, these\n * pairs represent a single *code point*, but in JavaScript, these pairs\n * have a length of 2 (`pair.charCodeAt(n)` is really returning a\n * UTF-16 *code unit*, not a unicode *code point*). It is possible to request\n * a *code point* with `pair.codePointAt(0)` and enumerate code points\n * in a string with `[...string]` but the offsets we work with, and\n * the string length, are based in *code units* so that functionality\n * is unfortunately not very useful here.\n *\n * This only gets us as far as *code points*. We now know that we must\n * consider that each *code point* can have a length of 1 or 2 in JavaScript\n * string distance. It gets even trickier because the visual representation\n * of a character is a *grapheme* (approximately what the user thinks of\n * as a character). A *grapheme* is one or more *code points*, and can\n * essentially be arbitrarily long, as there are many ways to combine\n * them.\n *\n * The `this.modify()` call has already extended our selection by one\n * *grapheme* in the direction we want to delete. Sounds great, it's done\n * a lot of awfully tricky work for us because this functionality has only\n * recently become available in JavaScript via `Intl.Segmenter`. The\n * problem is that in many cases the expected behavior of backspace or\n * delete is *not always to delete a whole grapheme*. In some languages\n * it's always expected that backspace ought to delete one code point, not the\n * whole grapheme. In other situations such as emoji that use variation\n * selectors you *do* want to delete the whole *grapheme*.\n *\n * In a few situations the behavior is even application dependent, such as\n * with latin languages where you have multiple ways to represent the same\n * character visually (e.g. a letter with an accent in one code point, or a\n * letter followed by a combining mark in a second code point); some apps will\n * delete the whole grapheme and others will delete only the combining mark,\n * probably based on whether they perform some sort of *normalization* on their\n * input to ensure that only one form is used when two sequences of code points\n * can represent the same visual character. Lexical currently chooses not\n * to perform any normalization so this type of combining marks will be\n * deleted as a *code point* without deleting the whole *grapheme*.\n *\n * See also:\n * https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-2/#G25564\n * https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-3/#G30602\n * https://www.unicode.org/versions/Unicode16.0.0/core-spec/chapter-3/#G49537\n * https://mathiasbynens.be/notes/javascript-unicode\n */\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n      if (shouldDeleteExactlyOneCodeUnit(text)) {\n        if (isBackward) {\n          focus.set(focus.key, characterOffset, focus.type);\n        } else {\n          anchor.set(anchor.key, characterOffset, anchor.type);\n        }\n      }\n    }\n  }\n}\nfunction shouldDeleteExactlyOneCodeUnit(text) {\n  {\n    if (!(text.length > 1)) {\n      formatDevErrorMessage(`shouldDeleteExactlyOneCodeUnit: expecting to be called only with sequences of two or more code units`);\n    }\n  }\n  return !(doesContainSurrogatePair(text) || doesContainEmoji(text));\n}\n\n/**\n * Given the wall of text in $updateCaretSelectionForUnicodeCharacter, you'd\n * think that the solution might be complex, but the only currently known\n * cases given the above constraints where we want to delete a whole grapheme\n * are when emoji is involved. Since ES6 we can use unicode character classes\n * in regexp which makes this simple.\n *\n * It may make sense to add to this heuristic in the future if other\n * edge cases are discovered, which is why detailed notes remain.\n *\n * This is implemented with runtime feature detection and will always\n * return false on pre-2020 platforms that do not have unicode character\n * class support.\n */\nconst doesContainEmoji = (() => {\n  try {\n    const re = new RegExp('\\\\p{Emoji}', 'u');\n    const test = re.test.bind(re);\n    // Sanity check a few emoji to make sure the regexp was parsed\n    // and works correctly. Any one of these should be sufficient,\n    // but they're cheap and it only runs once.\n    if (\n    // Emoji in the BMP (heart) with variation selector\n    test('\\u2764\\ufe0f') &&\n    // Emoji in the BMP (#) with variation selector\n    test('#\\ufe0f\\u20e3') &&\n    // Emoji outside the BMP (thumbs up) that is encoded with a surrogate pair\n    test('\\ud83d\\udc4d')) {\n      return test;\n    }\n  } catch (e) {\n    // SyntaxError\n  }\n  // fallback, surrogate pair already checked\n  return () => false;\n})();\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n      break;\n    }\n  }\n  const nextTextContent = split.join('').trim();\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\nfunction $internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode;\n  // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (isHTMLElement(dom)) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false;\n    // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length;\n    const blockCursorElement = editor._blockCursorElement;\n    // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n    if (childDOM === blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (blockCursorElement !== null) {\n      const blockCursorElementParent = blockCursorElement.parentNode;\n      if (dom === blockCursorElementParent) {\n        const blockCursorOffset = Array.prototype.indexOf.call(blockCursorElementParent.children, blockCursorElement);\n        if (offset > blockCursorOffset) {\n          resolvedOffset--;\n        }\n      }\n    }\n    resolvedNode = $getNodeFromDOM(childDOM);\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = $getTextNodeOffset(resolvedNode, moveSelectionToEnd ? 'next' : 'previous');\n    } else {\n      let resolvedElement = $getNodeFromDOM(dom);\n      // Ensure resolvedElement is actually a element.\n      if (resolvedElement === null) {\n        return null;\n      }\n      if ($isElementNode(resolvedElement)) {\n        const elementDOM = editor.getElementByKey(resolvedElement.getKey());\n        if (!(elementDOM !== null)) {\n          formatDevErrorMessage(`$internalResolveSelectionPoint: node in DOM but not keyToDOMMap`);\n        }\n        const slot = resolvedElement.getDOMSlot(elementDOM);\n        [resolvedElement, resolvedOffset] = slot.resolveChildIndex(resolvedElement, elementDOM, dom, offset);\n        // This is just a typescript workaround, it is true but lost due to mutability\n        if (!$isElementNode(resolvedElement)) {\n          formatDevErrorMessage(`$internalResolveSelectionPoint: resolvedElement is not an ElementNode`);\n        }\n        if (moveSelectionToEnd && resolvedOffset >= resolvedElement.getChildrenSize()) {\n          resolvedOffset = Math.max(0, resolvedElement.getChildrenSize() - 1);\n        }\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n          if (descendant === null) {\n            resolvedElement = child;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n          resolvedOffset = 0;\n        }\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = $getTextNodeOffset(child, moveSelectionToEnd ? 'next' : 'previous');\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          if (!$isElementNode(resolvedElement)) {\n            formatDevErrorMessage(`invariant`);\n          }\n          resolvedOffset = Math.min(resolvedElement.getChildrenSize(), resolvedOffset + 1);\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent();\n        // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && $getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = $getNodeFromDOM(dom);\n  }\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n  return $createPoint(resolvedNode.__key, $getTextNodeOffset(resolvedNode, resolvedOffset, 'clamp'), 'text');\n}\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.set(prevSibling.__key, prevSibling.getChildrenSize(), 'element');\n      } else if ($isTextNode(prevSibling)) {\n        point.set(prevSibling.__key, prevSibling.getTextContent().length, 'text');\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n      if ($isTextNode(parentSibling)) {\n        point.set(parentSibling.__key, parentSibling.getTextContent().length, 'text');\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.set(nextSibling.__key, 0, 'element');\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n      if ($isTextNode(parentSibling)) {\n        point.set(parentSibling.__key, 0, 'text');\n      }\n    }\n  }\n}\nfunction $normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus);\n\n    // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n    if (isCollapsed) {\n      focus.set(anchor.key, anchor.offset, anchor.type);\n    }\n    const editor = getActiveEditor();\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      anchor.set(lastAnchor.key, lastAnchor.offset, lastAnchor.type, true);\n      focus.set(lastFocus.key, lastFocus.offset, lastFocus.type, true);\n    }\n  }\n}\nfunction $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n  const resolvedAnchorPoint = $internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n  const resolvedFocusPoint = $internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n  {\n    $validatePoint('anchor', resolvedAnchorPoint);\n    $validatePoint('focus', resolvedFocusPoint);\n  }\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = $getNodeFromDOM(anchorDOM);\n    const focusNode = $getNodeFromDOM(focusDOM);\n    // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  }\n\n  // Handle normalization of selection when it is at the boundaries.\n  $normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n}\n\n// This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction $internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction $internalCreateSelection(editor, event) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(getWindow(editor));\n  if ($isRangeSelection(lastSelection) || lastSelection == null) {\n    return $internalCreateRangeSelection(lastSelection, domSelection, editor, event);\n  }\n  return lastSelection.clone();\n}\nfunction $createRangeSelectionFromDom(domSelection, editor) {\n  return $internalCreateRangeSelection(null, domSelection, editor, null);\n}\nfunction $internalCreateRangeSelection(lastSelection, domSelection, editor, event) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    return null;\n  }\n  // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n  const windowEvent = event || windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcessingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  }\n  // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n  const resolvedSelectionPoints = $internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $validatePoint(name, point) {\n  const node = $getNodeByKey(point.key);\n  if (!(node !== undefined)) {\n    formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} not found in current editorState`);\n  }\n  if (point.type === 'text') {\n    if (!$isTextNode(node)) {\n      formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} is not a TextNode`);\n    }\n    const size = node.getTextContentSize();\n    if (!(point.offset <= size)) {\n      formatDevErrorMessage(`$validatePoint: ${name} point.offset > node.getTextContentSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  } else {\n    if (!$isElementNode(node)) {\n      formatDevErrorMessage(`$validatePoint: ${name} key ${point.key} is not an ElementNode`);\n    }\n    const size = node.getChildrenSize();\n    if (!(point.offset <= size)) {\n      formatDevErrorMessage(`$validatePoint: ${name} point.offset > node.getChildrenSize() (${String(point.offset)} > ${String(size)})`);\n    }\n  }\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n  const parentKey = parentNode.__key;\n  // Single node. We shift selection but never redimension it\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element');\n      // The new selection might point to text nodes, try to resolve them\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  }\n  // The new selection might point to text nodes, try to resolve them\n  $updateSelectionResolveTextNodes(selection);\n}\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n    return;\n  }\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.set(key, point.offset + (isBefore ? 0 : textLength), 'text');\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.set(point.key, point.offset - 1, 'element');\n  }\n}\nfunction setDOMSelectionBaseAndExtent(domSelection, nextAnchorDOM, nextAnchorOffset, nextFocusDOM, nextFocusOffset) {\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  try {\n    domSelection.setBaseAndExtent(nextAnchorDOM, nextAnchorOffset, nextFocusDOM, nextFocusOffset);\n  } catch (error) {\n    // If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n    {\n      console.warn(error);\n    }\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement;\n\n  // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n  if (tags.has(COLLABORATION_TAG) && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n    return;\n  }\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  }\n\n  // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  }\n\n  // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode &&\n  // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n    if (anchor.type !== 'element') {\n      return;\n    }\n  }\n\n  // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n  setDOMSelectionBaseAndExtent(domSelection, nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  if (!tags.has(SKIP_SCROLL_INTO_VIEW_TAG) && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = $isRangeSelection(nextSelection) && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n    if (selectionTarget !== null) {\n      let selectionRect;\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes) {\n  let selection = $getSelection() || $getPreviousSelection();\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n  selection.insertNodes(nodes);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n  if (selection === null) {\n    return '';\n  }\n  return selection.getTextContent();\n}\nfunction $removeTextAndSplitBlock(selection) {\n  let selection_ = selection;\n  if (!selection.isCollapsed()) {\n    selection_.removeText();\n  }\n  // A new selection can originate as a result of node replacement, in which case is registered via\n  // $setSelection\n  const newSelection = $getSelection();\n  if ($isRangeSelection(newSelection)) {\n    selection_ = newSelection;\n  }\n  if (!$isRangeSelection(selection_)) {\n    formatDevErrorMessage(`Unexpected dirty selection to be null`);\n  }\n  const anchor = selection_.anchor;\n  let node = anchor.getNode();\n  let offset = anchor.offset;\n  while (!INTERNAL_$isBlock(node)) {\n    const prevNode = node;\n    [node, offset] = $splitNodeAtPoint(node, offset);\n    if (prevNode.is(node)) {\n      break;\n    }\n  }\n  return offset;\n}\nfunction $splitNodeAtPoint(node, offset) {\n  const parent = node.getParent();\n  if (!parent) {\n    const paragraph = $createParagraphNode();\n    $getRoot().append(paragraph);\n    paragraph.select();\n    return [$getRoot(), 0];\n  }\n  if ($isTextNode(node)) {\n    const split = node.splitText(offset);\n    if (split.length === 0) {\n      return [parent, node.getIndexWithinParent()];\n    }\n    const x = offset === 0 ? 0 : 1;\n    const index = split[0].getIndexWithinParent() + x;\n    return [parent, index];\n  }\n  if (!$isElementNode(node) || offset === 0) {\n    return [parent, node.getIndexWithinParent()];\n  }\n  const firstToAppend = node.getChildAtIndex(offset);\n  if (firstToAppend) {\n    const insertPoint = new RangeSelection($createPoint(node.__key, offset, 'element'), $createPoint(node.__key, offset, 'element'), 0, '');\n    const newElement = node.insertNewAfter(insertPoint);\n    if (newElement) {\n      newElement.append(firstToAppend, ...firstToAppend.getNextSiblings());\n    }\n  }\n  return [parent, node.getIndexWithinParent() + 1];\n}\nfunction $wrapInlineNodes(nodes) {\n  // We temporarily insert the topLevelNodes into an arbitrary ElementNode,\n  // since insertAfter does not work on nodes that have no parent (TO-DO: fix that).\n  const virtualRoot = $createParagraphNode();\n  let currentBlock = null;\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = $isLineBreakNode(node);\n    if (isLineBreakNode || $isDecoratorNode(node) && node.isInline() || $isElementNode(node) && node.isInline() || $isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        virtualRoot.append(currentBlock);\n        // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      virtualRoot.append(node);\n      currentBlock = null;\n    }\n  }\n  return virtualRoot;\n}\n\n/**\n * Get all nodes in a CaretRange in a way that complies with all of the\n * quirks of the original RangeSelection.getNodes().\n *\n * @param range The CaretRange\n */\nfunction $getNodesFromCaretRangeCompat(\n// getNodes returned nodes in document order\nrange) {\n  const nodes = [];\n  const [beforeSlice, afterSlice] = range.getTextSlices();\n  if (beforeSlice) {\n    nodes.push(beforeSlice.caret.origin);\n  }\n  const seenAncestors = new Set();\n  const seenElements = new Set();\n  for (const caret of range) {\n    if ($isChildCaret(caret)) {\n      // Emulate the leading under-selection behavior of getNodes by\n      // ignoring the 'enter' of any ElementNode until we've seen a\n      // SiblingCaret\n      const {\n        origin\n      } = caret;\n      if (nodes.length === 0) {\n        seenAncestors.add(origin);\n      } else {\n        seenElements.add(origin);\n        nodes.push(origin);\n      }\n    } else {\n      const {\n        origin\n      } = caret;\n      if (!$isElementNode(origin) || !seenElements.has(origin)) {\n        nodes.push(origin);\n      }\n    }\n  }\n  if (afterSlice) {\n    nodes.push(afterSlice.caret.origin);\n  }\n  // Emulate the trailing underselection behavior when the last offset of\n  // an element is selected\n  if ($isSiblingCaret(range.focus) && $isElementNode(range.focus.origin) && range.focus.getNodeAtCaret() === null) {\n    for (let reverseCaret = $getChildCaret(range.focus.origin, 'previous'); $isChildCaret(reverseCaret) && seenAncestors.has(reverseCaret.origin) && !reverseCaret.origin.isEmpty() && reverseCaret.origin.is(nodes[nodes.length - 1]); reverseCaret = $getAdjacentChildCaret(reverseCaret)) {\n      seenAncestors.delete(reverseCaret.origin);\n      nodes.pop();\n    }\n  }\n  while (nodes.length > 1) {\n    const lastIncludedNode = nodes[nodes.length - 1];\n    if ($isElementNode(lastIncludedNode)) {\n      if (seenElements.has(lastIncludedNode) || lastIncludedNode.isEmpty() || seenAncestors.has(lastIncludedNode)) ; else {\n        nodes.pop();\n        continue;\n      }\n    }\n    break;\n  }\n  if (nodes.length === 0 && range.isCollapsed()) {\n    // Emulate the collapsed behavior of getNodes by returning the descendant\n    const normCaret = $normalizeCaret(range.anchor);\n    const flippedNormCaret = $normalizeCaret(range.anchor.getFlipped());\n    const $getCandidate = caret => $isTextPointCaret(caret) ? caret.origin : caret.getNodeAtCaret();\n    const node = $getCandidate(normCaret) || $getCandidate(flippedNormCaret) || (range.anchor.getNodeAtCaret() ? normCaret.origin : flippedNormCaret.origin);\n    nodes.push(node);\n  }\n  return nodes;\n}\n\n/**\n * @internal\n *\n * Modify the focus of the focus around possible decorators and blocks and return true\n * if the movement is done.\n */\nfunction $modifySelectionAroundDecoratorsAndBlocks(selection, alter, isBackward, granularity, mode = 'decorators-and-blocks') {\n  if (alter === 'move' && granularity === 'character' && !selection.isCollapsed()) {\n    // moving left or right when the selection isn't collapsed will\n    // just set the anchor to the focus or vice versa depending on\n    // direction\n    const [src, dst] = isBackward === selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];\n    dst.set(src.key, src.offset, src.type);\n    return true;\n  }\n  const initialFocus = $caretFromPoint(selection.focus, isBackward ? 'previous' : 'next');\n  const isLineBoundary = granularity === 'lineboundary';\n  const collapse = alter === 'move';\n  let focus = initialFocus;\n  let checkForBlock = mode === 'decorators-and-blocks';\n  if (!$isExtendableTextPointCaret(focus)) {\n    for (const siblingCaret of focus) {\n      checkForBlock = false;\n      const {\n        origin\n      } = siblingCaret;\n      if ($isDecoratorNode(origin) && !origin.isIsolated()) {\n        focus = siblingCaret;\n        if (isLineBoundary && origin.isInline()) {\n          continue;\n        }\n      }\n      break;\n    }\n    if (checkForBlock) {\n      for (const nextCaret of $extendCaretToRange(initialFocus).iterNodeCarets(alter === 'extend' ? 'shadowRoot' : 'root')) {\n        if ($isChildCaret(nextCaret)) {\n          if (!nextCaret.origin.isInline()) {\n            focus = nextCaret;\n          }\n        } else if ($isElementNode(nextCaret.origin)) {\n          continue;\n        } else if ($isDecoratorNode(nextCaret.origin) && !nextCaret.origin.isInline()) {\n          focus = nextCaret;\n        }\n        break;\n      }\n    }\n  }\n  if (focus === initialFocus) {\n    return false;\n  }\n  // After this point checkForBlock is true if and only if we moved to a\n  // different block, so we should stop regardless of the granularity\n  if (collapse && !isLineBoundary && $isDecoratorNode(focus.origin) && focus.origin.isKeyboardSelectable()) {\n    // Make it possible to move selection from range selection to\n    // node selection on the node.\n    const nodeSelection = $createNodeSelection();\n    nodeSelection.add(focus.origin.getKey());\n    $setSelection(nodeSelection);\n    return true;\n  }\n  focus = $normalizeCaret(focus);\n  if (collapse) {\n    $setPointFromCaret(selection.anchor, focus);\n  }\n  $setPointFromCaret(selection.focus, focus);\n  return checkForBlock || !isLineBoundary;\n}\n\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      formatDevErrorMessage(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      formatDevErrorMessage(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      formatDevErrorMessage(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update(), editor.read(), or editorState.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      formatDevErrorMessage(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update() or editor.read().${collectBuildInformation()}`);\n    }\n  }\n  return activeEditor;\n}\nfunction collectBuildInformation() {\n  let compatibleEditors = 0;\n  const incompatibleEditors = new Set();\n  const thisVersion = LexicalEditor.version;\n  if (typeof window !== 'undefined') {\n    for (const node of document.querySelectorAll('[contenteditable]')) {\n      const editor = getEditorPropertyFromDOMNode(node);\n      if (isLexicalEditor(editor)) {\n        compatibleEditors++;\n      } else if (editor) {\n        let version = String(editor.constructor.version || '<0.17.1');\n        if (version === thisVersion) {\n          version += ' (separately built, likely a bundler configuration issue)';\n        }\n        incompatibleEditors.add(version);\n      }\n    }\n  }\n  let output = ` Detected on the page: ${compatibleEditors} compatible editor(s) with version ${thisVersion}`;\n  if (incompatibleEditors.size) {\n    output += ` and incompatible editors with versions ${Array.from(incompatibleEditors).join(', ')}`;\n  }\n  return output;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction internalGetActiveEditorState() {\n  return activeEditorState;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n  const transformsArrLength = transformsArr.length;\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined &&\n  // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\nfunction addTags(editor, tags) {\n  if (!tags) {\n    return;\n  }\n  const updateTags = editor._updateTags;\n  let tags_ = tags;\n  if (!Array.isArray(tags)) {\n    tags_ = [tags];\n  }\n  for (const tag of tags_) {\n    updateTags.add(tag);\n  }\n}\n\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n        dirtyLeaves.add(nodeKey);\n      }\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n\n      // We want to prioritize node transforms over element transforms\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    }\n\n    // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n\n    // The root is always considered intentionally dirty if any attached node\n    // is dirty and by deleting and re-inserting we will apply its transforms\n    // last (e.g. its transform can be used as a sort of \"update finalizer\")\n    const rootDirty = untransformedDirtyElements.delete('root');\n    if (rootDirty) {\n      untransformedDirtyElements.set('root', true);\n    }\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n      if (!intentionallyMarkedAsDirty) {\n        continue;\n      }\n      const node = nodeMap.get(nodeKey);\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n    }\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n  if (registeredNode === undefined) {\n    {\n      formatDevErrorMessage(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n  const nodeClass = registeredNode.klass;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n  return node;\n}\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n  setPendingNodeToClone(null);\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n    if (updateFn) {\n      updateFn();\n    }\n\n    // Make the editorState immutable\n    editorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n  return editorState;\n}\n\n// This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editor, editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = editor;\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\nfunction $commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n  if (pendingEditorState === null) {\n    return;\n  }\n\n  // ======\n  // Reconciliation has started.\n  // ======\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false;\n    // We don't want updates to sync block the reconciliation.\n    editor._updating = true;\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = $reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      }\n\n      // Reset editor and restore incoming editor state to the DOM\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        $commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n      Object.freeze(pendingSelection);\n    }\n  }\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n  $garbageCollectDetachedDecorators(editor, pendingEditorState);\n\n  // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(getWindow(editor));\n\n  // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n  if (editor._editable &&\n  // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty) && rootElement !== null && !tags.has(SKIP_DOM_SELECTION_TAG)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n    } finally {\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n  const pendingDecorators = editor._pendingDecorators;\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  }\n\n  // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    mutatedNodes,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  $triggerEnqueuedUpdates(editor);\n}\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klassSet] = listeners[i];\n    for (const klass of klassSet) {\n      const mutatedNodesByType = mutatedNodes.get(klass);\n      if (mutatedNodesByType !== undefined) {\n        listener(mutatedNodesByType, {\n          dirtyLeaves,\n          prevEditorState,\n          updateTags\n        });\n      }\n    }\n  }\n}\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n    for (let i = 0; i < listeners.length; i++) {\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  const editors = getEditorsToPropagate(editor);\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n          let returnVal = false;\n          updateEditorSync(currentEditor, () => {\n            for (let j = 0; j < listenersLength; j++) {\n              if (listeners[j](payload, editor)) {\n                returnVal = true;\n                return;\n              }\n            }\n          });\n          if (returnVal) {\n            return returnVal;\n          }\n        }\n      }\n    }\n  }\n  return false;\n}\nfunction $triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      $beginUpdate(editor, updateFn, options);\n    }\n  }\n}\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\nfunction $processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false;\n\n  // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      const pendingEditorState = editor._pendingEditorState;\n      let onUpdate;\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n        if (options.discrete) {\n          if (!(pendingEditorState !== null)) {\n            formatDevErrorMessage(`Unexpected empty pending editor state on discrete nested update`);\n          }\n          pendingEditorState._flushSync = true;\n        }\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n        addTags(editor, options.tag);\n      }\n      if (pendingEditorState == null) {\n        $beginUpdate(editor, nextUpdateFn, options);\n      } else {\n        nextUpdateFn();\n      }\n    }\n  }\n  return skipTransforms;\n}\nfunction $beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let skipTransforms = false;\n  let discrete = false;\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    addTags(editor, options.tag);\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n  const headless = editor._headless || editor.getRootElement() === null;\n  setPendingNodeToClone(null);\n  try {\n    if (editorStateWasCloned) {\n      if (headless) {\n        if (currentEditorState._selection !== null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = $internalCreateSelection(editor, options && options.event || null);\n      }\n    }\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = $processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n      $processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n    const endingCompositionKey = editor._compositionKey;\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n    const pendingSelection = pendingEditorState._selection;\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          formatDevErrorMessage(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n\n    // Restore existing editor state to the DOM\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n    editor._cloneNotNeeded.clear();\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements.clear();\n    $commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editor._deferred.length > 0 || editorStateHasDirtySelection(pendingEditorState, editor);\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      $commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        $commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\n\n/**\n * A variant of updateEditor that will not defer if it is nested in an update\n * to the same editor, much like if it was an editor.dispatchCommand issued\n * within an update\n */\nfunction updateEditorSync(editor, updateFn, options) {\n  if (activeEditor === editor && options === undefined) {\n    updateFn();\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    $beginUpdate(editor, updateFn, options);\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\n\n/**\n * A utility class for managing the DOM children of an ElementNode\n */\nclass ElementDOMSlot {\n  constructor(/** The element returned by createDOM */\n  element, /** All managed children will be inserted before this node, if defined */\n  before, /** All managed children will be inserted after this node, if defined */\n  after) {\n    this.element = element;\n    this.before = before || null;\n    this.after = after || null;\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted before this node\n   */\n  withBefore(before) {\n    return new ElementDOMSlot(this.element, before, this.after);\n  }\n  /**\n   * Return a new ElementDOMSlot where all managed children will be inserted after this node\n   */\n  withAfter(after) {\n    return new ElementDOMSlot(this.element, this.before, after);\n  }\n  /**\n   * Return a new ElementDOMSlot with an updated root element\n   */\n  withElement(element) {\n    if (this.element === element) {\n      return this;\n    }\n    return new ElementDOMSlot(element, this.before, this.after);\n  }\n  /**\n   * Insert the given child before this.before and any reconciler managed line break node,\n   * or append it if this.before is not defined\n   */\n  insertChild(dom) {\n    const before = this.before || this.getManagedLineBreak();\n    if (!(before === null || before.parentElement === this.element)) {\n      formatDevErrorMessage(`ElementDOMSlot.insertChild: before is not in element`);\n    }\n    this.element.insertBefore(dom, before);\n    return this;\n  }\n  /**\n   * Remove the managed child from this container, will throw if it was not already there\n   */\n  removeChild(dom) {\n    if (!(dom.parentElement === this.element)) {\n      formatDevErrorMessage(`ElementDOMSlot.removeChild: dom is not in element`);\n    }\n    this.element.removeChild(dom);\n    return this;\n  }\n  /**\n   * Replace managed child prevDom with dom. Will throw if prevDom is not a child\n   *\n   * @param dom The new node to replace prevDom\n   * @param prevDom the node that will be replaced\n   */\n  replaceChild(dom, prevDom) {\n    if (!(prevDom.parentElement === this.element)) {\n      formatDevErrorMessage(`ElementDOMSlot.replaceChild: prevDom is not in element`);\n    }\n    this.element.replaceChild(dom, prevDom);\n    return this;\n  }\n  /**\n   * Returns the first managed child of this node,\n   * which will either be this.after.nextSibling or this.element.firstChild,\n   * and will never be this.before if it is defined.\n   */\n  getFirstChild() {\n    const firstChild = this.after ? this.after.nextSibling : this.element.firstChild;\n    return firstChild === this.before || firstChild === this.getManagedLineBreak() ? null : firstChild;\n  }\n  /**\n   * @internal\n   */\n  getManagedLineBreak() {\n    const element = this.element;\n    return element.__lexicalLineBreak || null;\n  }\n  /** @internal */\n  setManagedLineBreak(lineBreakType) {\n    if (lineBreakType === null) {\n      this.removeManagedLineBreak();\n    } else {\n      const webkitHack = lineBreakType === 'decorator' && (IS_IOS || IS_SAFARI);\n      this.insertManagedLineBreak(webkitHack);\n    }\n  }\n\n  /** @internal */\n  removeManagedLineBreak() {\n    const br = this.getManagedLineBreak();\n    if (br) {\n      const element = this.element;\n      const sibling = br.nodeName === 'IMG' ? br.nextSibling : null;\n      if (sibling) {\n        element.removeChild(sibling);\n      }\n      element.removeChild(br);\n      element.__lexicalLineBreak = undefined;\n    }\n  }\n  /** @internal */\n  insertManagedLineBreak(webkitHack) {\n    const prevBreak = this.getManagedLineBreak();\n    if (prevBreak) {\n      if (webkitHack === (prevBreak.nodeName === 'IMG')) {\n        return;\n      }\n      this.removeManagedLineBreak();\n    }\n    const element = this.element;\n    const before = this.before;\n    const br = document.createElement('br');\n    element.insertBefore(br, before);\n    if (webkitHack) {\n      const img = document.createElement('img');\n      img.setAttribute('data-lexical-linebreak', 'true');\n      img.style.cssText = 'display: inline !important; border: 0px !important; margin: 0px !important;';\n      img.alt = '';\n      element.insertBefore(img, br);\n      element.__lexicalLineBreak = img;\n    } else {\n      element.__lexicalLineBreak = br;\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Returns the offset of the first child\n   */\n  getFirstChildOffset() {\n    let i = 0;\n    for (let node = this.after; node !== null; node = node.previousSibling) {\n      i++;\n    }\n    return i;\n  }\n\n  /**\n   * @internal\n   */\n  resolveChildIndex(element, elementDOM, initialDOM, initialOffset) {\n    if (initialDOM === this.element) {\n      const firstChildOffset = this.getFirstChildOffset();\n      return [element, Math.min(firstChildOffset + element.getChildrenSize(), Math.max(firstChildOffset, initialOffset))];\n    }\n    // The resolved offset must be before or after the children\n    const initialPath = indexPath(elementDOM, initialDOM);\n    initialPath.push(initialOffset);\n    const elementPath = indexPath(elementDOM, this.element);\n    let offset = element.getIndexWithinParent();\n    for (let i = 0; i < elementPath.length; i++) {\n      const target = initialPath[i];\n      const source = elementPath[i];\n      if (target === undefined || target < source) {\n        break;\n      } else if (target > source) {\n        offset += 1;\n        break;\n      }\n    }\n    return [element.getParentOrThrow(), offset];\n  }\n}\nfunction indexPath(root, child) {\n  const path = [];\n  let node = child;\n  for (; node !== root && node !== null; node = node.parentNode) {\n    let i = 0;\n    for (let sibling = node.previousSibling; sibling !== null; sibling = sibling.previousSibling) {\n      i++;\n    }\n    path.push(i);\n  }\n  if (!(node === root)) {\n    formatDevErrorMessage(`indexPath: root is not a parent of child`);\n  }\n  return path.reverse();\n}\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__style = '';\n    this.__indent = 0;\n    this.__dir = null;\n    this.__textFormat = 0;\n    this.__textStyle = '';\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    if (this.__key === prevNode.__key) {\n      this.__first = prevNode.__first;\n      this.__last = prevNode.__last;\n      this.__size = prevNode.__size;\n    }\n    this.__indent = prevNode.__indent;\n    this.__format = prevNode.__format;\n    this.__style = prevNode.__style;\n    this.__dir = prevNode.__dir;\n    this.__textFormat = prevNode.__textFormat;\n    this.__textStyle = prevNode.__textStyle;\n  }\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n    return children;\n  }\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n      child = child.getNextSibling();\n    }\n    return textNodes;\n  }\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n    while ($isElementNode(node)) {\n      const child = node.getFirstChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getLastDescendant() {\n    let node = this.getLastChild();\n    while ($isElementNode(node)) {\n      const child = node.getLastChild();\n      if (child === null) {\n        break;\n      }\n      node = child;\n    }\n    return node;\n  }\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n    if (firstChild === null) {\n      {\n        formatDevErrorMessage(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n    return firstChild;\n  }\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n    if (lastChild === null) {\n      {\n        formatDevErrorMessage(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n    return lastChild;\n  }\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n        node = node.getNextSibling();\n        i++;\n      }\n      return null;\n    }\n    node = this.getLastChild();\n    i = size - 1;\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n      node = node.getPreviousSibling();\n      i--;\n    }\n    return null;\n  }\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n    return textContent;\n  }\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n    return textContentSize;\n  }\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n  getTextFormat() {\n    const self = this.getLatest();\n    return self.__textFormat;\n  }\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n    return false;\n  }\n  hasTextFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getTextFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__textFormat;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  }\n  getTextStyle() {\n    const self = this.getLatest();\n    return self.__textStyle;\n  }\n\n  // Mutators\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n    const key = this.__key;\n    if (!$isRangeSelection(selection)) {\n      return $internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n    return selection;\n  }\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n    return firstNode ? firstNode.selectStart() : this.select();\n  }\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n    return lastNode ? lastNode.selectEnd() : this.select();\n  }\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style || '';\n    return this;\n  }\n  setTextFormat(type) {\n    const self = this.getWritable();\n    self.__textFormat = type;\n    return self;\n  }\n  setTextStyle(style) {\n    const self = this.getWritable();\n    self.__textStyle = style;\n    return self;\n  }\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    if (!(start + deleteCount <= oldSize)) {\n      formatDevErrorMessage(`ElementNode.splice: start + deleteCount > oldSize (${String(start)} + ${String(deleteCount)} > ${String(oldSize)})`);\n    }\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            formatDevErrorMessage(`splice: sibling not found`);\n          }\n        }\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n    let prevNode = nodeBeforeRange;\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n      const writableNodeToInsert = nodeToInsert.getWritable();\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          formatDevErrorMessage(`append: attempting to append self`);\n        }\n      }\n      // Set child parent to self\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n    writableSelf.__size = newSize;\n\n    // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n        // Cleanup if node can't be empty\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n    return writableSelf;\n  }\n  /**\n   * @internal\n   *\n   * An experimental API that an ElementNode can override to control where its\n   * children are inserted into the DOM, this is useful to add a wrapping node\n   * or accessory nodes before or after the children. The root of the node returned\n   * by createDOM must still be exactly one HTMLElement.\n   */\n  getDOMSlot(element) {\n    return new ElementDOMSlot(element);\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      const indent = this.getIndent();\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML\n        // (see https://www.caniemail.com/features/css-padding-inline-start-end/),\n        // If you want to use HTML output for email, consider overriding the serialization\n        // to use `padding-right` in RTL languages, `padding-left` in `LTR` languages, or\n        // `text-indent` if you are ok with first-line indents.\n        // We recommend keeping multiples of 40px to maintain consistency with list-items\n        // (see https://github.com/facebook/lexical/pull/4025)\n        element.style.paddingInlineStart = `${indent * 40}px`;\n      }\n      const direction = this.getDirection();\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n    return {\n      element\n    };\n  }\n  // JSON serialization\n  exportJSON() {\n    const json = {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      // As an exception here we invoke super at the end for historical reasons.\n      // Namely, to preserve the order of the properties and not to break the tests\n      // that use the serialized string representation.\n      ...super.exportJSON()\n    };\n    const textFormat = this.getTextFormat();\n    const textStyle = this.getTextStyle();\n    if (textFormat !== 0) {\n      json.textFormat = textFormat;\n    }\n    if (textStyle !== '') {\n      json.textStyle = textStyle;\n    }\n    return json;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setFormat(serializedNode.format).setIndent(serializedNode.indent).setDirection(serializedNode.direction).setTextFormat(serializedNode.textFormat || 0).setTextStyle(serializedNode.textStyle || '');\n  }\n  // These are intended to be extends for specific element heuristics.\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0). You may use this to have the node replace\n   * itself, change its state, or do nothing. When you do make such\n   * a change, you should return true.\n   *\n   * When true is returned, the collapse phase will stop.\n   * When false is returned, and isInline() is true, and getPreviousSibling() is null,\n   * then this function will be called on its parent.\n   */\n  collapseAtStart(selection) {\n    return false;\n  }\n  excludeFromCopy(destination) {\n    return false;\n  }\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return true;\n  }\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return true;\n  }\n  canBeEmpty() {\n    return true;\n  }\n  canInsertTextBefore() {\n    return true;\n  }\n  canInsertTextAfter() {\n    return true;\n  }\n  isInline() {\n    return false;\n  }\n  // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hierarchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n  isShadowRoot() {\n    return false;\n  }\n  /** @deprecated @internal */\n  canMergeWith(node) {\n    return false;\n  }\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n  /**\n   * Determines whether this node, when empty, can merge with a first block\n   * of nodes being inserted.\n   *\n   * This method is specifically called in {@link RangeSelection.insertNodes}\n   * to determine merging behavior during nodes insertion.\n   *\n   * @example\n   * // In a ListItemNode or QuoteNode implementation:\n   * canMergeWhenEmpty(): true {\n   *  return true;\n   * }\n   */\n  canMergeWhenEmpty() {\n    return false;\n  }\n\n  /** @internal */\n  reconcileObservedMutation(dom, editor) {\n    const slot = this.getDOMSlot(dom);\n    let currentDOM = slot.getFirstChild();\n    for (let currentNode = this.getFirstChild(); currentNode; currentNode = currentNode.getNextSibling()) {\n      const correctDOM = editor.getElementByKey(currentNode.getKey());\n      if (correctDOM === null) {\n        continue;\n      }\n      if (currentDOM == null) {\n        slot.insertChild(correctDOM);\n        currentDOM = correctDOM;\n      } else if (currentDOM !== correctDOM) {\n        slot.replaceChild(correctDOM, currentDOM);\n      }\n      currentDOM = currentDOM.nextSibling;\n    }\n  }\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n  while (node) {\n    const nodeKey = node.__key;\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n    node = node.getParent();\n  }\n  return false;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/** @noInheritDoc */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass DecoratorNode extends LexicalNode {\n  /**\n   * The returned value is added to the LexicalEditor._decorators\n   */\n  decorate(editor, config) {\n    {\n      formatDevErrorMessage(`decorate: base method not extended`);\n    }\n  }\n  isIsolated() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  isKeyboardSelectable() {\n    return true;\n  }\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'root';\n  }\n  static clone() {\n    return new RootNode();\n  }\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n  getTopLevelElementOrThrow() {\n    {\n      formatDevErrorMessage(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n  getTextContent() {\n    const cachedText = this.__cachedText;\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n    return super.getTextContent();\n  }\n  remove() {\n    {\n      formatDevErrorMessage(`remove: cannot be called on root nodes`);\n    }\n  }\n  replace(node) {\n    {\n      formatDevErrorMessage(`replace: cannot be called on root nodes`);\n    }\n  }\n  insertBefore(nodeToInsert) {\n    {\n      formatDevErrorMessage(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n  insertAfter(nodeToInsert) {\n    {\n      formatDevErrorMessage(`insertAfter: cannot be called on root nodes`);\n    }\n  }\n\n  // View\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  // Mutate\n  splice(start, deleteCount, nodesToInsert) {\n    for (const node of nodesToInsert) {\n      if (!($isElementNode(node) || $isDecoratorNode(node))) {\n        formatDevErrorMessage(`rootNode.splice: Only element or decorator nodes can be inserted to the root node`);\n      }\n    }\n    return super.splice(start, deleteCount, nodesToInsert);\n  }\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    return $getRoot().updateFromJSON(serializedNode);\n  }\n  collapseAtStart() {\n    return true;\n  }\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n  const pendingSelection = editorState._selection;\n\n  // Check if we need to update because of changes in selection\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor;\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  }\n  if ($isElementNode(node)) {\n    const serializedChildren = serializedNode.children;\n    if (!Array.isArray(serializedChildren)) {\n      {\n        formatDevErrorMessage(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  }\n\n  // @ts-expect-error\n  return serializedNode;\n}\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n  read(callbackFn, options) {\n    return readEditorState(options && options.editor || null, this, callbackFn);\n  }\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n  toJSON() {\n    return readEditorState(null, this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Common update tags used in Lexical. These tags can be used with editor.update() or $addUpdateTag()\n * to indicate the type/purpose of an update. Multiple tags can be used in a single update.\n */\n\n/**\n * Indicates that the update is related to history operations (undo/redo)\n */\nconst HISTORIC_TAG = 'historic';\n\n/**\n * Indicates that a new history entry should be pushed to the history stack\n */\nconst HISTORY_PUSH_TAG = 'history-push';\n\n/**\n * Indicates that the current update should be merged with the previous history entry\n */\nconst HISTORY_MERGE_TAG = 'history-merge';\n\n/**\n * Indicates that the update is related to a paste operation\n */\nconst PASTE_TAG = 'paste';\n\n/**\n * Indicates that the update is related to collaborative editing\n */\nconst COLLABORATION_TAG = 'collaboration';\n\n/**\n * Indicates that the update should skip collaborative sync\n */\nconst SKIP_COLLAB_TAG = 'skip-collab';\n\n/**\n * Indicates that the update should skip scrolling the selection into view\n */\nconst SKIP_SCROLL_INTO_VIEW_TAG = 'skip-scroll-into-view';\n\n/**\n * Indicates that the update should skip updating the DOM selection\n * This is useful when you want to make updates without changing the selection or focus\n */\nconst SKIP_DOM_SELECTION_TAG = 'skip-dom-selection';\n\n/**\n * The update was triggered by editor.focus()\n */\nconst FOCUS_TAG = 'focus';\n\n/**\n * The set of known update tags to help with TypeScript suggestions.\n */\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n// TODO: Cleanup ArtificialNode__DO_NOT_USE #5966\nclass ArtificialNode__DO_NOT_USE extends ElementNode {\n  static getType() {\n    return 'artificial';\n  }\n  createDOM(config) {\n    // this isnt supposed to be used and is not used anywhere but defining it to appease the API\n    const dom = document.createElement('div');\n    return dom;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  }\n\n  // View\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: $convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n    if (isHTMLElement(element)) {\n      if (this.isEmpty()) {\n        element.append(document.createElement('br'));\n      }\n      const formatType = this.getFormatType();\n      if (formatType) {\n        element.style.textAlign = formatType;\n      }\n    }\n    return {\n      element\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createParagraphNode().updateFromJSON(serializedNode);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      // These are included explicitly for backwards compatibility\n      textFormat: this.getTextFormat(),\n      textStyle: this.getTextStyle()\n    };\n  }\n\n  // Mutation\n\n  insertNewAfter(rangeSelection, restoreSelection) {\n    const newElement = $createParagraphNode();\n    newElement.setTextFormat(rangeSelection.format);\n    newElement.setTextStyle(rangeSelection.style);\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    newElement.setFormat(this.getFormatType());\n    newElement.setStyle(this.getStyle());\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart() {\n    const children = this.getChildren();\n    // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n      const prevSibling = this.getPreviousSibling();\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n    return false;\n  }\n}\nfunction $convertParagraphElement(element) {\n  const node = $createParagraphNode();\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    setNodeIndentFromDOM(element, node);\n  }\n  return {\n    node\n  };\n}\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n// https://github.com/microsoft/TypeScript/issues/3841\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * A LexicalNode class or LexicalNodeReplacement configuration\n */\n\nconst DEFAULT_SKIP_INITIALIZATION = false;\n\n/**\n * The payload passed to an UpdateListener\n */\n\n/**\n * A listener that gets called after the editor is updated\n */\n\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4;\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n/**\n * Type helper for extracting the payload type from a command.\n *\n * @example\n * ```ts\n * const MY_COMMAND = createCommand<SomeType>();\n *\n * // ...\n *\n * editor.registerCommand(MY_COMMAND, payload => {\n *   // Type of `payload` is inferred here. But lets say we want to extract a function to delegate to\n *   $handleMyCommand(editor, payload);\n *   return true;\n * });\n *\n * function $handleMyCommand(editor: LexicalEditor, payload: CommandPayloadType<typeof MY_COMMAND>) {\n *   // `payload` is of type `SomeType`, extracted from the command.\n * }\n * ```\n */\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n  editor._cloneNotNeeded.clear();\n  editor._dirtyLeaves = new Set();\n  editor._dirtyElements.clear();\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  }\n\n  // Remove all the DOM nodes from the root element\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\nfunction initializeConversionCache(nodes, additionalConversions) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  const addConversionsToCache = map => {\n    Object.keys(map).forEach(key => {\n      let currentCache = conversionCache.get(key);\n      if (currentCache === undefined) {\n        currentCache = [];\n        conversionCache.set(key, currentCache);\n      }\n      currentCache.push(map[key]);\n    });\n  };\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM;\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n    handledConversions.add(importDOM);\n    const map = importDOM.call(node.klass);\n    if (map !== null) {\n      addConversionsToCache(map);\n    }\n  });\n  if (additionalConversions) {\n    addConversionsToCache(additionalConversions);\n  }\n  return conversionCache;\n}\n\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ArtificialNode__DO_NOT_USE, ...(config.nodes || [])];\n  const {\n    onError,\n    html\n  } = config;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replace = null;\n      let replaceWithKlass = null;\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replace = options.with;\n        replaceWithKlass = options.withKlass || null;\n      }\n      const {\n        ownNodeConfig\n      } = getStaticNodeConfig(klass);\n      // Ensure custom nodes implement required methods and replaceWithKlass is instance of base klass.\n      {\n        // ArtificialNode__DO_NOT_USE can get renamed, so we use the type\n        const name = klass.name;\n        const nodeType = hasOwnStaticMethod(klass, 'getType') && klass.getType();\n        if (replaceWithKlass) {\n          if (!(replaceWithKlass.prototype instanceof klass)) {\n            formatDevErrorMessage(`${replaceWithKlass.name} doesn't extend the ${name}`);\n          }\n        } else if (replace) {\n          console.warn(`Override for ${name} specifies 'replace' without 'withKlass'. 'withKlass' will be required in a future version.`);\n        }\n        if (name !== 'RootNode' && nodeType !== 'root' && nodeType !== 'artificial' &&\n        // This is mostly for the unit test suite which\n        // uses LexicalNode in an otherwise incorrect way\n        // by mocking its static getType\n        klass !== LexicalNode) {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            if (!hasOwnStaticMethod(klass, method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n          if (!hasOwnStaticMethod(klass, 'importDOM') && hasOwnExportDOM(klass)) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n          if ($isDecoratorNode(proto)) {\n            if (proto.decorate === DecoratorNode.prototype.decorate) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n          if (!hasOwnStaticMethod(klass, 'importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n      if (ownNodeConfig && ownNodeConfig.$transform) {\n        transforms.add(ownNodeConfig.$transform);\n      }\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n      registeredNodes.set(type, {\n        exportDOM: html && html.export ? html.export.get(klass) : undefined,\n        klass,\n        replace,\n        replaceWithKlass,\n        sharedNodeState: createSharedNodeState(nodes[i]),\n        transforms\n      });\n    }\n  }\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes, html ? html.import : undefined), isEditable, editorConfig);\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n  return editor;\n}\nclass LexicalEditor {\n  /** The version with build identifiers for this editor (since 0.17.1) */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable, createEditorArgs) {\n    this._createEditorArgs = createEditorArgs;\n    this._parentEditor = parentEditor;\n    // The root element associated with this editor\n    this._rootElement = null;\n    // The current editor state\n    this._editorState = editorState;\n    // Handling of drafts and updates\n    this._pendingEditorState = null;\n    // Used to help co-ordinate selection and events\n    this._compositionKey = null;\n    this._deferred = [];\n    // Used during reconciliation\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false;\n    // Listeners\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    };\n    // Commands\n    this._commands = new Map();\n    // Editor configuration for theme/context.\n    this._config = config;\n    // Mapping of types to their nodes\n    this._nodes = nodes;\n    // React node decorators for portals\n    this._decorators = {};\n    this._pendingDecorators = null;\n    // Used to optimize reconciliation\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set();\n    // Handling of DOM mutations\n    this._observer = null;\n    // Used for identifying owning editors\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched with {@link LexicalEditor.dispatch}, subject to priority.\n   * Listeners that run at a higher priority can \"intercept\" commands and\n   * prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners are always invoked in an {@link LexicalEditor.update} and can\n   * call dollar functions.\n   *\n   * Listeners registered at the same priority level will run\n   * deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   *   (or {@link COMMAND_PRIORITY_EDITOR} |\n   *     {@link COMMAND_PRIORITY_LOW} |\n   *     {@link COMMAND_PRIORITY_NORMAL} |\n   *     {@link COMMAND_PRIORITY_HIGH} |\n   *     {@link COMMAND_PRIORITY_CRITICAL})\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        formatDevErrorMessage(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n    const commandsMap = this._commands;\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n    const listenersInPriorityOrder = commandsMap.get(command);\n    if (listenersInPriorityOrder === undefined) {\n      {\n        formatDevErrorMessage(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * If any existing nodes are in the DOM, and skipInitialization is not true, the listener\n   * will be called immediately with an updateTag of 'registerMutationListener' where all\n   * nodes have the 'created' NodeMutation. This can be controlled with the skipInitialization option\n   * (whose default was previously true for backwards compatibility with &lt;=0.16.1 but has been changed to false as of 0.21.0).\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @param options - see {@link MutationListenerOptions}\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerMutationListener(klass, listener, options) {\n    const klassToMutate = this.resolveRegisteredNodeAfterReplacements(this.getRegisteredNode(klass)).klass;\n    const mutations = this._listeners.mutation;\n    let klassSet = mutations.get(listener);\n    if (klassSet === undefined) {\n      klassSet = new Set();\n      mutations.set(listener, klassSet);\n    }\n    klassSet.add(klassToMutate);\n    const skipInitialization = options && options.skipInitialization;\n    if (!(skipInitialization === undefined ? DEFAULT_SKIP_INITIALIZATION : skipInitialization)) {\n      this.initializeMutationListener(listener, klassToMutate);\n    }\n    return () => {\n      klassSet.delete(klassToMutate);\n      if (klassSet.size === 0) {\n        mutations.delete(listener);\n      }\n    };\n  }\n\n  /** @internal */\n  getRegisteredNode(klass) {\n    const registeredNode = this._nodes.get(klass.getType());\n    if (registeredNode === undefined) {\n      {\n        formatDevErrorMessage(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  resolveRegisteredNodeAfterReplacements(registeredNode) {\n    while (registeredNode.replaceWithKlass) {\n      registeredNode = this.getRegisteredNode(registeredNode.replaceWithKlass);\n    }\n    return registeredNode;\n  }\n\n  /** @internal */\n  initializeMutationListener(listener, klass) {\n    const prevEditorState = this._editorState;\n    const nodeMap = getCachedTypeToNodeMap(prevEditorState).get(klass.getType());\n    if (!nodeMap) {\n      return;\n    }\n    const nodeMutationMap = new Map();\n    for (const k of nodeMap.keys()) {\n      nodeMutationMap.set(k, 'created');\n    }\n    if (nodeMutationMap.size > 0) {\n      listener(nodeMutationMap, {\n        dirtyLeaves: new Set(),\n        prevEditorState,\n        updateTags: new Set(['registerMutationListener'])\n      });\n    }\n  }\n\n  /** @internal */\n  registerNodeTransformToKlass(klass, listener) {\n    const registeredNode = this.getRegisteredNode(klass);\n    registeredNode.transforms.add(listener);\n    return registeredNode;\n  }\n\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n    markNodesWithTypesAsDirty(this, registeredNodes.map(node => node.klass.getType()));\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload. The command listeners\n   * will be triggered in an implicit {@link LexicalEditor.update}, unless\n   * this was invoked from inside an update in which case that update context\n   * will be re-used (as if this was a dollar function itself).\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n  getDecorators() {\n    return this._decorators;\n  }\n\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n  getRootElement() {\n    return this._rootElement;\n  }\n\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n  getKey() {\n    return this._key;\n  }\n\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n        this._updateTags.add(HISTORY_MERGE_TAG);\n        $commitPendingUpdates(this);\n\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n        {\n          const nextRootElementParent = nextRootElement.parentElement;\n          if (nextRootElementParent != null && ['flex', 'inline-flex'].includes(getComputedStyle(nextRootElementParent).display)) {\n            console.warn(`When using \"display: flex\" or \"display: inline-flex\" on an element containing content editable, Chrome may have unwanted focusing behavior when clicking outside of it. Consider wrapping the content editable within a non-flex element.`);\n          }\n        }\n      } else {\n        // When the content editable is unmounted we will still trigger a\n        // reconciliation so that any pending updates are flushed,\n        // to match the previous state change when\n        // `_editorState = pendingEditorState` was used, but by\n        // using a commit we preserve the readOnly invariant\n        // for editor.getEditorState().\n        this._window = null;\n        this._updateTags.add(HISTORY_MERGE_TAG);\n        $commitPendingUpdates(this);\n      }\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n  getEditorState() {\n    return this._editorState;\n  }\n\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        formatDevErrorMessage(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    // Ensure that we have a writable EditorState so that transforms can run\n    // during a historic operation\n    let writableEditorState = editorState;\n    if (writableEditorState._readOnly) {\n      writableEditorState = cloneEditorState(editorState);\n      writableEditorState._selection = editorState._selection ? editorState._selection.clone() : null;\n    }\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n      $commitPendingUpdates(this);\n    }\n    this._pendingEditorState = writableEditorState;\n    this._dirtyType = FULL_RECONCILE;\n    this._dirtyElements.set('root', false);\n    this._compositionKey = null;\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    // Only commit pending updates if not already in an editor.update\n    // (e.g. dispatchCommand) otherwise this will cause a second commit\n    // with an already read-only state and selection\n    if (!this._updating) {\n      $commitPendingUpdates(this);\n    }\n  }\n\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserialization from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n\n  /**\n   * Executes a read of the editor's state, with the\n   * editor context available (useful for exporting and read-only DOM\n   * operations). Much like update, but prevents any mutation of the\n   * editor's state. Any pending updates will be flushed immediately before\n   * the read.\n   * @param callbackFn - A function that has access to read-only editor state.\n   */\n  read(callbackFn) {\n    $commitPendingUpdates(this);\n    return this.getEditorState().read(callbackFn, {\n      editor: this\n    });\n  }\n\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   */\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n\n  /**\n   * Focuses the editor by marking the existing selection as dirty, or by\n   * creating a new selection at `defaultSelection` if one does not already\n   * exist. If you want to force a specific selection, you should call\n   * `root.selectStart()` or `root.selectEnd()` in an update.\n   *\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   */\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditorSync(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          if (!selection.dirty) {\n            $setSelection(selection.clone());\n          }\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n        $addUpdateTag(FOCUS_TAG);\n        $onUpdate(() => {\n          rootElement.removeAttribute('autocapitalize');\n          if (callbackFn) {\n            callbackFn();\n          }\n        });\n      });\n      // In the case where onUpdate doesn't fire (due to the focus update not\n      // occurring).\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n\n  /**\n   * Removes focus from the editor.\n   */\n  blur() {\n    const rootElement = this._rootElement;\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n    const domSelection = getDOMSelection(this._window);\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n}\nLexicalEditor.version = \"0.34.0+dev.esm\";\n\nlet pendingNodeToClone = null;\nfunction setPendingNodeToClone(pendingNode) {\n  pendingNodeToClone = pendingNode;\n}\nfunction getPendingNodeToClone() {\n  const node = pendingNodeToClone;\n  pendingNodeToClone = null;\n  return node;\n}\nlet keyCounter = 1;\nfunction resetRandomKey() {\n  keyCounter = 1;\n}\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\n\n/**\n * @internal\n */\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = getRegisteredNode(editor, nodeType);\n  if (registeredNode === undefined) {\n    {\n      formatDevErrorMessage(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n  return registeredNode;\n}\n\n/**\n * @internal\n */\nfunction getRegisteredNode(editor, nodeType) {\n  return editor._nodes.get(nodeType);\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n  if (!isHTMLElement(activeElement)) {\n    return false;\n  }\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && getEditorPropertyFromDOMNode(activeElement) == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) &&\n    // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * @returns true if the given argument is a LexicalEditor instance from this build of Lexical\n */\nfunction isLexicalEditor(editor) {\n  // Check instanceof to prevent issues with multiple embedded Lexical installations\n  return editor instanceof LexicalEditor;\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const editor = getEditorPropertyFromDOMNode(currentNode);\n    if (isLexicalEditor(editor)) {\n      return editor;\n    }\n    currentNode = getParentElement(currentNode);\n  }\n  return null;\n}\n\n/** @internal */\nfunction getEditorPropertyFromDOMNode(node) {\n  // @ts-expect-error: internal field\n  return node ? node.__lexicalEditor : null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n  return null;\n}\n\n/**\n * Return true if the TextNode is a TabNode or is in token mode.\n */\nfunction $isTokenOrTab(node) {\n  return $isTabNode(node) || node.isToken();\n}\n\n/**\n * Return true if the TextNode is a TabNode, or is in token or segmented mode.\n */\nfunction $isTokenOrSegmented(node) {\n  return $isTokenOrTab(node) || node.isSegmented();\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Text node, false otherwise.\n */\nfunction isDOMTextNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_TEXT_TYPE;\n}\n\n/**\n * @param node - The element being tested\n * @returns Returns true if node is an DOM Document node, false otherwise.\n */\nfunction isDOMDocumentNode(node) {\n  return isDOMNode(node) && node.nodeType === DOM_DOCUMENT_TYPE;\n}\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (isDOMTextNode(node)) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  if (alignWithFormat !== null && (format & activeFormat) === (alignWithFormat & activeFormat)) {\n    return format;\n  }\n  let newFormat = format ^ activeFormat;\n  if (type === 'subscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.superscript;\n  } else if (type === 'superscript') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.subscript;\n  } else if (type === 'lowercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'uppercase') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.capitalize;\n  } else if (type === 'capitalize') {\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.lowercase;\n    newFormat &= ~TEXT_TYPE_TO_FORMAT.uppercase;\n  }\n  return newFormat;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  const pendingNode = getPendingNodeToClone();\n  existingKey = existingKey || pendingNode && pendingNode.__key;\n  if (existingKey != null) {\n    {\n      errorOnNodeKeyConstructorMismatch(node, existingKey, pendingNode);\n    }\n    node.__key = existingKey;\n    return;\n  }\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n  editorState._nodeMap.set(key, node);\n  // TODO Split this function into leaf/element\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n  editor._cloneNotNeeded.add(key);\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\nfunction errorOnNodeKeyConstructorMismatch(node, existingKey, pendingNode) {\n  const editorState = internalGetActiveEditorState();\n  if (!editorState) {\n    // tests expect to be able to do this kind of clone without an active editor state\n    return;\n  }\n  const existingNode = editorState._nodeMap.get(existingKey);\n  if (pendingNode) {\n    if (!(existingKey === pendingNode.__key)) {\n      formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} (type ${node.getType()}) has an incorrect clone implementation, got ${String(existingKey)} for nodeKey when expecting ${pendingNode.__key}`);\n    }\n  }\n  if (existingNode && existingNode.constructor !== node.constructor) {\n    // Lifted condition to if statement because the inverted logic is a bit confusing\n    if (node.constructor.name !== existingNode.constructor.name) {\n      {\n        formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with constructor ${existingNode.constructor.name}. Keys must not be re-used when the type is changed.`);\n      }\n    } else {\n      {\n        formatDevErrorMessage(`Lexical node with constructor ${node.constructor.name} attempted to re-use key from node in active editor state with different constructor with the same name (possibly due to invalid Hot Module Replacement). Keys must not be re-used when the type is changed.`);\n      }\n    }\n  }\n}\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n    const node = nodeMap.get(nextParentKey);\n    if (node === undefined) {\n      break;\n    }\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\n// TODO #6031 this function or their callers have to adjust selection (i.e. insertBefore)\n/**\n * Removes a node from its parent, updating all necessary pointers and links.\n * @internal\n *\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n */\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling();\n\n    // Store sibling keys\n    const nextSiblingKey = nextSibling !== null ? nextSibling.__key : null;\n    const prevSiblingKey = prevSibling !== null ? prevSibling.__key : null;\n\n    // Get writable siblings once\n    const writablePrevSibling = prevSibling !== null ? prevSibling.getWritable() : null;\n    const writableNextSibling = nextSibling !== null ? nextSibling.getWritable() : null;\n\n    // Update parent's first/last pointers\n    if (prevSibling === null) {\n      writableParent.__first = nextSiblingKey;\n    }\n    if (nextSibling === null) {\n      writableParent.__last = prevSiblingKey;\n    }\n\n    // Update sibling links\n    if (writablePrevSibling !== null) {\n      writablePrevSibling.__next = nextSiblingKey;\n    }\n    if (writableNextSibling !== null) {\n      writableNextSibling.__prev = prevSiblingKey;\n    }\n\n    // Clear node's links\n    writableNode.__prev = null;\n    writableNode.__next = null;\n    writableNode.__parent = null;\n\n    // Update parent size\n    writableParent.__size--;\n  }\n}\n\n// Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n  const node = editorState._nodeMap.get(key);\n  if (node === undefined) {\n    return null;\n  }\n  return node;\n}\nfunction $getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor();\n  const key = getNodeKeyFromDOMNode(dom, editor);\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n  return null;\n}\nfunction setNodeKeyOnDOMNode(dom, editor, key) {\n  const prop = `__lexicalKey_${editor._key}`;\n  dom[prop] = key;\n}\nfunction getNodeKeyFromDOMNode(dom, editor) {\n  const prop = `__lexicalKey_${editor._key}`;\n  return dom[prop];\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n  while (dom != null) {\n    const node = $getNodeFromDOMNode(dom, editorState);\n    if (node !== null) {\n      return node;\n    }\n    dom = getParentElement(dom);\n  }\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markNodesWithTypesAsDirty(editor, types) {\n  // We only need to mark nodes dirty if they were in the previous state.\n  // If they aren't, then they are by definition dirty already.\n  const cachedMap = getCachedTypeToNodeMap(editor.getEditorState());\n  const dirtyNodeMaps = [];\n  for (const type of types) {\n    const nodeMap = cachedMap.get(type);\n    if (nodeMap) {\n      // By construction these are non-empty\n      dirtyNodeMaps.push(nodeMap);\n    }\n  }\n  // Nothing to mark dirty, no update necessary\n  if (dirtyNodeMaps.length === 0) {\n    return;\n  }\n  editor.update(() => {\n    for (const nodeMap of dirtyNodeMaps) {\n      for (const nodeKey of nodeMap.keys()) {\n        // We are only concerned with nodes that are still in the latest NodeMap,\n        // if they no longer exist then markDirty would raise an exception\n        const latest = $getNodeByKey(nodeKey);\n        if (latest) {\n          latest.markDirty();\n        }\n      }\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: HISTORY_MERGE_TAG\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          formatDevErrorMessage(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n    selection.dirty = true;\n    selection.setCachedNodes(null);\n  }\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction $getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOMTree(dom, editor);\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n    return null;\n  }\n  return $getNodeByKey(nodeKey);\n}\nfunction getNodeKeyFromDOMTree(\n// Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n  while (node != null) {\n    const key = getNodeKeyFromDOMNode(node, editor);\n    if (key !== undefined) {\n      return key;\n    }\n    node = getParentElement(node);\n  }\n  return null;\n}\n\n/**\n * Return true if `str` contains any valid surrogate pair.\n *\n * See also $updateCaretSelectionForUnicodeCharacter for\n * a discussion on when and why this is useful.\n */\nfunction doesContainSurrogatePair(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substring(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  return isDOMTextNode(anchorNode) ? anchorNode.nodeValue : null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(getWindow(editor));\n  if (domSelection === null) {\n    return;\n  }\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n    const prevTextContent = node.getTextContent();\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n        return;\n      }\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing ||\n      // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() && !isComposing || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter() && !isComposing)) {\n        node.markDirty();\n        return;\n      }\n      const selection = $getSelection();\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        $setTextContentWithSelection(node, normalizedTextContent, selection);\n        return;\n      }\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n      $setTextContentWithSelection(node, normalizedTextContent, selection);\n    }\n  }\n}\nfunction $setTextContentWithSelection(node, textContent, selection) {\n  node.setTextContent(textContent);\n  if ($isRangeSelection(selection)) {\n    const key = node.getKey();\n    for (const k of ['anchor', 'focus']) {\n      const pt = selection[k];\n      if (pt.type === 'text' && pt.key === key) {\n        pt.offset = $getTextNodeOffset(node, pt.offset, 'clamp');\n      }\n    }\n  }\n}\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n}\n\n// This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = $isTokenOrTab(node);\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() && !node.isComposing() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() && !node.isComposing() || isToken;\n  } else {\n    return false;\n  }\n}\n\n/**\n * A KeyboardEvent or structurally similar object with a string `key` as well\n * as `altKey`, `ctrlKey`, `metaKey`, and `shiftKey` boolean properties.\n */\n\n/**\n * A record of keyboard modifiers that must be enabled.\n * If the value is `'any'` then the modifier key's state is ignored.\n * If the value is `true` then the modifier key must be pressed.\n * If the value is `false` or the property is omitted then the modifier key must\n * not be pressed.\n */\n\nfunction matchModifier(event, mask, prop) {\n  const expected = mask[prop] || false;\n  return expected === 'any' || expected === event[prop];\n}\n\n/**\n * Match a KeyboardEvent with its expected modifier state\n *\n * @param event A KeyboardEvent, or structurally similar object\n * @param mask An object specifying the expected state of the modifiers\n * @returns true if the event matches\n */\nfunction isModifierMatch(event, mask) {\n  return matchModifier(event, mask, 'altKey') && matchModifier(event, mask, 'ctrlKey') && matchModifier(event, mask, 'shiftKey') && matchModifier(event, mask, 'metaKey');\n}\n\n/**\n * Match a KeyboardEvent with its expected state\n *\n * @param event A KeyboardEvent, or structurally similar object\n * @param expectedKey The string to compare with event.key (case insensitive)\n * @param mask An object specifying the expected state of the modifiers\n * @returns true if the event matches\n */\nfunction isExactShortcutMatch(event, expectedKey, mask) {\n  return isModifierMatch(event, mask) && event.key.toLowerCase() === expectedKey.toLowerCase();\n}\nconst CONTROL_OR_META = {\n  ctrlKey: !IS_APPLE,\n  metaKey: IS_APPLE\n};\nconst CONTROL_OR_ALT = {\n  altKey: IS_APPLE,\n  ctrlKey: !IS_APPLE\n};\nfunction isTab(event) {\n  return isExactShortcutMatch(event, 'Tab', {\n    shiftKey: 'any'\n  });\n}\nfunction isBold(event) {\n  return isExactShortcutMatch(event, 'b', CONTROL_OR_META);\n}\nfunction isItalic(event) {\n  return isExactShortcutMatch(event, 'i', CONTROL_OR_META);\n}\nfunction isUnderline(event) {\n  return isExactShortcutMatch(event, 'u', CONTROL_OR_META);\n}\nfunction isParagraph(event) {\n  return isExactShortcutMatch(event, 'Enter', {\n    altKey: 'any',\n    ctrlKey: 'any',\n    metaKey: 'any'\n  });\n}\nfunction isLineBreak(event) {\n  return isExactShortcutMatch(event, 'Enter', {\n    altKey: 'any',\n    ctrlKey: 'any',\n    metaKey: 'any',\n    shiftKey: true\n  });\n}\n\n// Inserts a new line after the selection\n\nfunction isOpenLineBreak(event) {\n  // 79 = KeyO\n  return IS_APPLE && isExactShortcutMatch(event, 'o', {\n    ctrlKey: true\n  });\n}\nfunction isDeleteWordBackward(event) {\n  return isExactShortcutMatch(event, 'Backspace', CONTROL_OR_ALT);\n}\nfunction isDeleteWordForward(event) {\n  return isExactShortcutMatch(event, 'Delete', CONTROL_OR_ALT);\n}\nfunction isDeleteLineBackward(event) {\n  return IS_APPLE && isExactShortcutMatch(event, 'Backspace', {\n    metaKey: true\n  });\n}\nfunction isDeleteLineForward(event) {\n  return IS_APPLE && (isExactShortcutMatch(event, 'Delete', {\n    metaKey: true\n  }) || isExactShortcutMatch(event, 'k', {\n    ctrlKey: true\n  }));\n}\nfunction isDeleteBackward(event) {\n  return isExactShortcutMatch(event, 'Backspace', {\n    shiftKey: 'any'\n  }) || IS_APPLE && isExactShortcutMatch(event, 'h', {\n    ctrlKey: true\n  });\n}\nfunction isDeleteForward(event) {\n  return isExactShortcutMatch(event, 'Delete', {}) || IS_APPLE && isExactShortcutMatch(event, 'd', {\n    ctrlKey: true\n  });\n}\nfunction isUndo(event) {\n  return isExactShortcutMatch(event, 'z', CONTROL_OR_META);\n}\nfunction isRedo(event) {\n  if (IS_APPLE) {\n    return isExactShortcutMatch(event, 'z', {\n      metaKey: true,\n      shiftKey: true\n    });\n  }\n  return isExactShortcutMatch(event, 'y', {\n    ctrlKey: true\n  }) || isExactShortcutMatch(event, 'z', {\n    ctrlKey: true,\n    shiftKey: true\n  });\n}\nfunction isCopy(event) {\n  return isExactShortcutMatch(event, 'c', CONTROL_OR_META);\n}\nfunction isCut(event) {\n  return isExactShortcutMatch(event, 'x', CONTROL_OR_META);\n}\nfunction isMoveBackward(event) {\n  return isExactShortcutMatch(event, 'ArrowLeft', {\n    shiftKey: 'any'\n  });\n}\nfunction isMoveToStart(event) {\n  return isExactShortcutMatch(event, 'ArrowLeft', CONTROL_OR_META);\n}\nfunction isMoveForward(event) {\n  return isExactShortcutMatch(event, 'ArrowRight', {\n    shiftKey: 'any'\n  });\n}\nfunction isMoveToEnd(event) {\n  return isExactShortcutMatch(event, 'ArrowRight', CONTROL_OR_META);\n}\nfunction isMoveUp(event) {\n  return isExactShortcutMatch(event, 'ArrowUp', {\n    altKey: 'any',\n    shiftKey: 'any'\n  });\n}\nfunction isMoveDown(event) {\n  return isExactShortcutMatch(event, 'ArrowDown', {\n    altKey: 'any',\n    shiftKey: 'any'\n  });\n}\nfunction isModifier(event) {\n  return event.ctrlKey || event.shiftKey || event.altKey || event.metaKey;\n}\nfunction isSpace(event) {\n  return event.key === ' ';\n}\nfunction isBackspace(event) {\n  return event.key === 'Backspace';\n}\nfunction isEscape(event) {\n  return event.key === 'Escape';\n}\nfunction isDelete(event) {\n  return event.key === 'Delete';\n}\nfunction isSelectAll(event) {\n  return isExactShortcutMatch(event, 'a', CONTROL_OR_META);\n}\nfunction $selectAll(selection) {\n  const root = $getRoot();\n  if ($isRangeSelection(selection)) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const topParent = anchorNode.getTopLevelElementOrThrow();\n    const rootNode = topParent.getParentOrThrow();\n    anchor.set(rootNode.getKey(), 0, 'element');\n    focus.set(rootNode.getKey(), rootNode.getChildrenSize(), 'element');\n    $normalizeSelection(selection);\n    return selection;\n  } else {\n    // Create a new RangeSelection\n    const newSelection = root.select(0, root.getChildrenSize());\n    $setSelection($normalizeSelection(newSelection));\n    return newSelection;\n  }\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n  const classNames = classNamesTheme[classNameThemeType];\n  // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n  if (typeof classNames === 'string') {\n    const classNamesArr = normalizeClassNames(classNames);\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n  if (registeredNode === undefined) {\n    {\n      formatDevErrorMessage(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n  const prevMutation = mutatedNodesByType.get(nodeKey);\n  // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\n/**\n * @deprecated Use {@link LexicalEditor.registerMutationListener} with `skipInitialization: false` instead.\n */\nfunction $nodesOfType(klass) {\n  const klassType = klass.getType();\n  const editorState = getActiveEditorState();\n  if (editorState._readOnly) {\n    const nodes = getCachedTypeToNodeMap(editorState).get(klassType);\n    return nodes ? Array.from(nodes.values()) : [];\n  }\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && node.isAttached()) {\n      nodesOfType.push(node);\n    }\n  }\n  return nodesOfType;\n}\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n      return possibleNode;\n    }\n  }\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n  if (element === undefined) {\n    {\n      formatDevErrorMessage(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return isDocumentFragment(parentElement) ? parentElement.host : parentElement;\n}\nfunction getDOMOwnerDocument(target) {\n  return isDOMDocumentNode(target) ? target : isHTMLElement(target) ? target.ownerDocument : null;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = getDOMOwnerDocument(rootElement);\n  const defaultView = getDefaultView(doc);\n  if (doc === null || defaultView === null) {\n    return;\n  }\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n    let diff = 0;\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n    if (isBodyElement) {\n      break;\n    }\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._updateTags.add(tag);\n}\n\n/**\n * Add a function to run after the current update. This will run after any\n * `onUpdate` function already supplied to `editor.update()`, as well as any\n * functions added with previous calls to `$onUpdate`.\n *\n * @param updateFn The function to run after the current update.\n */\nfunction $onUpdate(updateFn) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  editor._deferred.push(updateFn);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n    parent = parent.getParent();\n  }\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = getDOMOwnerDocument(domElem);\n  return ownerDoc ? ownerDoc.defaultView : null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n  if (windowObj === null) {\n    {\n      formatDevErrorMessage(`window object not found`);\n    }\n  }\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n    parent = parent.getParentOrThrow();\n  }\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\n\n/**\n * Returns a shallow clone of node with a new key. All properties of the node\n * will be copied to the new node (by `clone` and then `afterCloneFrom`),\n * except those related to parent/sibling/child\n * relationships in the `EditorState`. This means that the copy must be\n * separately added to the document, and it will not have any children.\n *\n * @param node - The node to be copied.\n * @returns The copy of the node.\n */\nfunction $copyNode(node) {\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  copy.afterCloneFrom(node);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.getType();\n  const registeredNode = getRegisteredNode(editor, nodeType);\n  if (!(registeredNode !== undefined)) {\n    formatDevErrorMessage(`$applyNodeReplacement node ${node.constructor.name} with type ${nodeType} must be registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n  }\n  const {\n    replace,\n    replaceWithKlass\n  } = registeredNode;\n  if (replace !== null) {\n    const replacementNode = replace(node);\n    const replacementNodeKlass = replacementNode.constructor;\n    if (replaceWithKlass !== null) {\n      if (!(replacementNode instanceof replaceWithKlass)) {\n        formatDevErrorMessage(`$applyNodeReplacement failed. Expected replacement node to be an instance of ${replaceWithKlass.name} with type ${replaceWithKlass.getType()} but returned ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} from original node ${node.constructor.name} with type ${nodeType}`);\n      }\n    } else {\n      if (!(replacementNode instanceof node.constructor && replacementNodeKlass !== node.constructor)) {\n        formatDevErrorMessage(`$applyNodeReplacement failed. Ensure replacement node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()} is a subclass of the original node ${node.constructor.name} with type ${nodeType}.`);\n      }\n    }\n    if (!(replacementNode.__key !== node.__key)) {\n      formatDevErrorMessage(`$applyNodeReplacement failed. Ensure that the key argument is *not* used in your replace function (from node ${node.constructor.name} with type ${nodeType} to node ${replacementNodeKlass.name} with type ${replacementNodeKlass.getType()}), Node keys must never be re-used except by the static clone method.`);\n    }\n    return replacementNode;\n  }\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      formatDevErrorMessage(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\nfunction $getNodeByKeyOrThrow(key) {\n  const node = $getNodeByKey(key);\n  if (node === null) {\n    {\n      formatDevErrorMessage(`Expected node with key ${key} to exist but it's not in the nodeMap.`);\n    }\n  }\n  return node;\n}\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = normalizeClassNames(blockCursorTheme);\n      // @ts-expect-error: intentional\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n  return element;\n}\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n      if (child !== null && needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n      rootElement.style.caretColor = 'transparent';\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n      return;\n    }\n  }\n  // Remove cursor\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\n\n/**\n * Returns the selection for the given window, or the global window if null.\n * Will return null if {@link CAN_USE_DOM} is false.\n *\n * @param targetWindow The window to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\n\n/**\n * Returns the selection for the defaultView of the ownerDocument of given EventTarget.\n *\n * @param eventTarget The node to get the selection from\n * @returns a Selection or null\n */\nfunction getDOMSelectionFromTarget(eventTarget) {\n  const defaultView = getDefaultView(eventTarget);\n  return defaultView ? defaultView.getSelection() : null;\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n  if (startNode == null) {\n    startNode = node;\n  }\n  if (!!$isRootOrShadowRoot(node)) {\n    formatDevErrorMessage(`Can not call $splitNode() on root element`);\n  }\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent);\n    // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n    if (isParentRoot) {\n      if (!($isElementNode(currentNode) && $isElementNode(nodeToMove))) {\n        formatDevErrorMessage(`Children of a root must be ElementNode`);\n      }\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML element, false otherwise.\n */\nfunction isHTMLElement(x) {\n  return isDOMNode(x) && x.nodeType === DOM_ELEMENT_TYPE;\n}\n\n/**\n * @param x - The element being tested\n * @returns Returns true if x is a DOM Node, false otherwise.\n */\nfunction isDOMNode(x) {\n  return typeof x === 'object' && x !== null && 'nodeType' in x && typeof x.nodeType === 'number';\n}\n\n/**\n * @param x - The element being testing\n * @returns Returns true if x is a document fragment, false otherwise.\n */\nfunction isDocumentFragment(x) {\n  return isDOMNode(x) && x.nodeType === DOM_DOCUMENT_FRAGMENT_TYPE;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is an inline node\n */\nfunction isInlineDomNode(node) {\n  const inlineNodes = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|mark|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var|#text)$/, 'i');\n  return node.nodeName.match(inlineNodes) !== null;\n}\n\n/**\n *\n * @param node - the Dom Node to check\n * @returns if the Dom Node is a block node\n */\nfunction isBlockDomNode(node) {\n  const blockNodes = new RegExp(/^(address|article|aside|blockquote|canvas|dd|div|dl|dt|fieldset|figcaption|figure|footer|form|h1|h2|h3|h4|h5|h6|header|hr|li|main|nav|noscript|ol|p|pre|section|table|td|tfoot|ul|video)$/, 'i');\n  return node.nodeName.match(blockNodes) !== null;\n}\n\n/**\n * @internal\n *\n * This function is for internal use of the library.\n * Please do not use it as it may change in the future.\n *\n * This function returns true for a DecoratorNode that is not inline OR\n * an ElementNode that is:\n * - not a root or shadow root\n * - not inline\n * - can't be empty\n * - has no children or an inline first child\n */\nfunction INTERNAL_$isBlock(node) {\n  if ($isDecoratorNode(node) && !node.isInline()) {\n    return true;\n  }\n  if (!$isElementNode(node) || $isRootOrShadowRoot(node)) {\n    return false;\n  }\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || $isLineBreakNode(firstChild) || $isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Utility function for accessing current active editor instance.\n * @returns Current active editor\n */\nfunction $getEditor() {\n  return getActiveEditor();\n}\n\n/** @internal */\n\n/**\n * @internal\n * Compute a cached Map of node type to nodes for a frozen EditorState\n */\nconst cachedNodeMaps = new WeakMap();\nconst EMPTY_TYPE_TO_NODE_MAP = new Map();\nfunction getCachedTypeToNodeMap(editorState) {\n  // If this is a new Editor it may have a writable this._editorState\n  // with only a 'root' entry.\n  if (!editorState._readOnly && editorState.isEmpty()) {\n    return EMPTY_TYPE_TO_NODE_MAP;\n  }\n  if (!editorState._readOnly) {\n    formatDevErrorMessage(`getCachedTypeToNodeMap called with a writable EditorState`);\n  }\n  let typeToNodeMap = cachedNodeMaps.get(editorState);\n  if (!typeToNodeMap) {\n    typeToNodeMap = computeTypeToNodeMap(editorState);\n    cachedNodeMaps.set(editorState, typeToNodeMap);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * @internal\n * Compute a Map of node type to nodes for an EditorState\n */\nfunction computeTypeToNodeMap(editorState) {\n  const typeToNodeMap = new Map();\n  for (const [nodeKey, node] of editorState._nodeMap) {\n    const nodeType = node.__type;\n    let nodeMap = typeToNodeMap.get(nodeType);\n    if (!nodeMap) {\n      nodeMap = new Map();\n      typeToNodeMap.set(nodeType, nodeMap);\n    }\n    nodeMap.set(nodeKey, node);\n  }\n  return typeToNodeMap;\n}\n\n/**\n * Returns a clone of a node using `node.constructor.clone()` followed by\n * `clone.afterCloneFrom(node)`. The resulting clone must have the same key,\n * parent/next/prev pointers, and other properties that are not set by\n * `node.constructor.clone` (format, style, etc.). This is primarily used by\n * {@link LexicalNode.getWritable} to create a writable version of an\n * existing node. The clone is the same logical node as the original node,\n * do not try and use this function to duplicate or copy an existing node.\n *\n * Does not mutate the EditorState.\n * @param latestNode - The node to be cloned.\n * @returns The clone of the node.\n */\nfunction $cloneWithProperties(latestNode) {\n  const constructor = latestNode.constructor;\n  const mutableNode = constructor.clone(latestNode);\n  mutableNode.afterCloneFrom(latestNode);\n  {\n    if (!(mutableNode.__key === latestNode.__key)) {\n      formatDevErrorMessage(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') did not return a node with the same key, make sure to specify node.__key as the last argument to the constructor`);\n    }\n    if (!(mutableNode.__parent === latestNode.__parent && mutableNode.__next === latestNode.__next && mutableNode.__prev === latestNode.__prev)) {\n      formatDevErrorMessage(`$cloneWithProperties: ${constructor.name}.clone(node) (with type '${constructor.getType()}') overrode afterCloneFrom but did not call super.afterCloneFrom(prevNode)`);\n    }\n  }\n  return mutableNode;\n}\nfunction setNodeIndentFromDOM(elementDom, elementNode) {\n  const indentSize = parseInt(elementDom.style.paddingInlineStart, 10) || 0;\n  const indent = Math.round(indentSize / 40);\n  elementNode.setIndent(indent);\n}\n\n/**\n * @internal\n *\n * Mark this node as unmanaged by lexical's mutation observer like\n * decorator nodes\n */\nfunction setDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  el.__lexicalUnmanaged = true;\n}\n\n/**\n * @internal\n *\n * True if this DOM node was marked with {@link setDOMUnmanaged}\n */\nfunction isDOMUnmanaged(elementDom) {\n  const el = elementDom;\n  return el.__lexicalUnmanaged === true;\n}\n\n/**\n * @internal\n *\n * Object.hasOwn ponyfill\n */\nfunction hasOwn(o, k) {\n  return Object.prototype.hasOwnProperty.call(o, k);\n}\n\n/**\n * @internal\n */\nfunction hasOwnStaticMethod(klass, k) {\n  return hasOwn(klass, k) && klass[k] !== LexicalNode[k];\n}\n\n/**\n * @internal\n */\nfunction hasOwnExportDOM(klass) {\n  return hasOwn(klass.prototype, 'exportDOM');\n}\n\n/** @internal */\nfunction isAbstractNodeClass(klass) {\n  return klass === DecoratorNode || klass === ElementNode || klass === LexicalNode;\n}\n\n/** @internal */\nfunction getStaticNodeConfig(klass) {\n  const nodeConfigRecord = PROTOTYPE_CONFIG_METHOD in klass.prototype ? klass.prototype[PROTOTYPE_CONFIG_METHOD]() : undefined;\n  const isAbstract = isAbstractNodeClass(klass);\n  const nodeType = !isAbstract && hasOwnStaticMethod(klass, 'getType') ? klass.getType() : undefined;\n  let ownNodeConfig;\n  let ownNodeType = nodeType;\n  if (nodeConfigRecord) {\n    if (nodeType) {\n      ownNodeConfig = nodeConfigRecord[nodeType];\n    } else {\n      for (const [k, v] of Object.entries(nodeConfigRecord)) {\n        ownNodeType = k;\n        ownNodeConfig = v;\n      }\n    }\n  }\n  if (!isAbstract && ownNodeType) {\n    if (!hasOwnStaticMethod(klass, 'getType')) {\n      klass.getType = () => ownNodeType;\n    }\n    if (!hasOwnStaticMethod(klass, 'clone')) {\n      // TextNode.length > 0 will only be true if the compiler output\n      // is not ES6 compliant, in which case we can not provide this\n      // warning\n      if (TextNode.length === 0) {\n        if (!(klass.length === 0)) {\n          formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) must implement a static clone method since its constructor has ${String(klass.length)} required arguments (expecting 0). Use an explicit default in the first argument of your constructor(prop: T=X, nodeKey?: NodeKey).`);\n        }\n      }\n      klass.clone = prevNode => {\n        setPendingNodeToClone(prevNode);\n        return new klass();\n      };\n    }\n    if (!hasOwnStaticMethod(klass, 'importJSON')) {\n      if (TextNode.length === 0) {\n        if (!(klass.length === 0)) {\n          formatDevErrorMessage(`${klass.name} (type ${ownNodeType}) must implement a static importJSON method since its constructor has ${String(klass.length)} required arguments (expecting 0). Use an explicit default in the first argument of your constructor(prop: T=X, nodeKey?: NodeKey).`);\n        }\n      }\n      klass.importJSON = ownNodeConfig && ownNodeConfig.$importJSON || (serializedNode => new klass().updateFromJSON(serializedNode));\n    }\n    if (!hasOwnStaticMethod(klass, 'importDOM') && ownNodeConfig) {\n      const {\n        importDOM\n      } = ownNodeConfig;\n      if (importDOM) {\n        klass.importDOM = () => importDOM;\n      }\n    }\n  }\n  return {\n    ownNodeConfig,\n    ownNodeType\n  };\n}\n\n/**\n * Create an node from its class.\n *\n * Note that this will directly construct the final `withKlass` node type,\n * and will ignore the deprecated `with` functions. This allows `$create` to\n * skip any intermediate steps where the replaced node would be created and\n * then immediately discarded (once per configured replacement of that node).\n *\n * This does not support any arguments to the constructor.\n * Setters can be used to initialize your node, and they can\n * be chained. You can of course write your own mutliple-argument functions\n * to wrap that.\n *\n * @example\n * ```ts\n * function $createTokenText(text: string): TextNode {\n *   return $create(TextNode).setTextContent(text).setMode('token');\n * }\n * ```\n */\nfunction $create(klass) {\n  const editor = $getEditor();\n  errorOnReadOnly();\n  const registeredNode = editor.resolveRegisteredNodeAfterReplacements(editor.getRegisteredNode(klass));\n  return new registeredNode.klass();\n}\n\n/**\n * The direction of a caret, 'next' points towards the end of the document\n * and 'previous' points towards the beginning\n */\n\n/**\n * A type utility to flip next and previous\n */\n\n/**\n * A sibling caret type points from a LexicalNode origin to its next or previous sibling,\n * and a child caret type points from an ElementNode origin to its first or last child.\n */\n\n/**\n * The RootMode is specified in all caret traversals where the traversal can go up\n * towards the root. 'root' means that it will stop at the document root,\n * and 'shadowRoot' will stop at the document root or any shadow root\n * (per {@link $isRootOrShadowRoot}).\n */\n\nconst FLIP_DIRECTION = {\n  next: 'previous',\n  previous: 'next'\n};\n\n/** @noInheritDoc */\n\n/**\n * A RangeSelection expressed as a pair of Carets\n */\n\n/**\n * A NodeCaret is the combination of an origin node and a direction\n * that points towards where a connected node will be fetched, inserted,\n * or replaced. A SiblingCaret points from a node to its next or previous\n * sibling, and a ChildCaret points to its first or last child\n * (using next or previous as direction, for symmetry with SiblingCaret).\n *\n * The differences between NodeCaret and PointType are:\n * - NodeCaret can only be used to refer to an entire node (PointCaret is used when a full analog is needed). A PointType of text type can be used to refer to a specific location inside of a TextNode.\n * - NodeCaret stores an origin node, type (sibling or child), and direction (next or previous). A PointType stores a type (text or element), the key of a node, and a text or child offset within that node.\n * - NodeCaret is directional and always refers to a very specific node, eliminating all ambiguity. PointType can refer to the location before or at a node depending on context.\n * - NodeCaret is more robust to nearby mutations, as it relies only on a node's direct connections. An element Any change to the count of previous siblings in an element PointType will invalidate it.\n * - NodeCaret is designed to work more directly with the internal representation of the document tree, making it suitable for use in traversals without performing any redundant work.\n *\n * The caret does *not* update in response to any mutations, you should\n * not persist it across editor updates, and using a caret after its origin\n * node has been removed or replaced may result in runtime errors.\n */\n\n/**\n * A PointCaret is a NodeCaret that also includes a\n * TextPointCaret type which refers to a specific offset of a TextNode.\n * This type is separate because it is not relevant to general node traversal\n * so it doesn't make sense to have it show up except when defining\n * a CaretRange and in those cases there will be at most two of them only\n * at the boundaries.\n *\n * The addition of TextPointCaret allows this type to represent any location\n * that is representable by PointType, as the TextPointCaret refers to a\n * specific offset within a TextNode.\n */\n\n/**\n * A SiblingCaret points from an origin LexicalNode towards its next or previous sibling.\n */\n\n/**\n * A ChildCaret points from an origin ElementNode towards its first or last child.\n */\n\n/**\n * A TextPointCaret is a special case of a SiblingCaret that also carries\n * an offset used for representing partially selected TextNode at the edges\n * of a CaretRange.\n *\n * The direction determines which part of the text is adjacent to the caret,\n * if next it's all of the text after offset. If previous, it's all of the\n * text before offset.\n *\n * While this can be used in place of any SiblingCaret of a TextNode,\n * the offset into the text will be ignored except in contexts that\n * specifically use the TextPointCaret or PointCaret types.\n */\n\n/**\n * A TextPointCaretSlice is a wrapper for a TextPointCaret that carries a signed\n * distance representing the direction and amount of text selected from the given\n * caret. A negative distance means that text before offset is selected, a\n * positive distance means that text after offset is selected. The offset+distance\n * pair is not affected in any way by the direction of the caret.\n */\n\n/**\n * A utility type to specify that a CaretRange may have zero,\n * one, or two associated TextPointCaretSlice. If the anchor\n * and focus are on the same node, the anchorSlice will contain\n * the slice and focusSlie will be null.\n */\n\nclass AbstractCaret {\n  constructor(origin) {\n    this.origin = origin;\n  }\n  [Symbol.iterator]() {\n    return makeStepwiseIterator({\n      hasNext: $isSiblingCaret,\n      initial: this.getAdjacentCaret(),\n      map: caret => caret,\n      step: caret => caret.getAdjacentCaret()\n    });\n  }\n  getAdjacentCaret() {\n    return $getSiblingCaret(this.getNodeAtCaret(), this.direction);\n  }\n  getSiblingCaret() {\n    return $getSiblingCaret(this.origin, this.direction);\n  }\n  remove() {\n    const node = this.getNodeAtCaret();\n    if (node) {\n      node.remove();\n    }\n    return this;\n  }\n  replaceOrInsert(node, includeChildren) {\n    const target = this.getNodeAtCaret();\n    if (node.is(this.origin) || node.is(target)) ; else if (target === null) {\n      this.insert(node);\n    } else {\n      target.replace(node, includeChildren);\n    }\n    return this;\n  }\n  splice(deleteCount, nodes, nodesDirection = 'next') {\n    const nodeIter = nodesDirection === this.direction ? nodes : Array.from(nodes).reverse();\n    let caret = this;\n    const parent = this.getParentAtCaret();\n    const nodesToRemove = new Map();\n    // Find all of the nodes we expect to remove first, so\n    // we don't have to worry about the cases where there is\n    // overlap between the nodes to insert and the nodes to\n    // remove\n    for (let removeCaret = caret.getAdjacentCaret(); removeCaret !== null && nodesToRemove.size < deleteCount; removeCaret = removeCaret.getAdjacentCaret()) {\n      const writableNode = removeCaret.origin.getWritable();\n      nodesToRemove.set(writableNode.getKey(), writableNode);\n    }\n    // TODO: Optimize this to work directly with node internals\n    for (const node of nodeIter) {\n      if (nodesToRemove.size > 0) {\n        // For some reason `npm run tsc-extension` needs this annotation?\n        const target = caret.getNodeAtCaret();\n        if (target) {\n          nodesToRemove.delete(target.getKey());\n          nodesToRemove.delete(node.getKey());\n          if (target.is(node) || caret.origin.is(node)) ; else {\n            const nodeParent = node.getParent();\n            if (nodeParent && nodeParent.is(parent)) {\n              // It's a sibling somewhere else in this node, so unparent it first\n              node.remove();\n            }\n            target.replace(node);\n          }\n        } else {\n          if (!(target !== null)) {\n            formatDevErrorMessage(`NodeCaret.splice: Underflow of expected nodesToRemove during splice (keys: ${Array.from(nodesToRemove).join(' ')})`);\n          }\n        }\n      } else {\n        caret.insert(node);\n      }\n      caret = $getSiblingCaret(node, this.direction);\n    }\n    for (const node of nodesToRemove.values()) {\n      node.remove();\n    }\n    return this;\n  }\n}\nclass AbstractChildCaret extends AbstractCaret {\n  type = 'child';\n  getLatest() {\n    const origin = this.origin.getLatest();\n    return origin === this.origin ? this : $getChildCaret(origin, this.direction);\n  }\n  /**\n   * Get the SiblingCaret from this origin in the same direction.\n   *\n   * @param mode 'root' to return null at the root, 'shadowRoot' to return null at the root or any shadow root\n   * @returns A SiblingCaret with this origin, or null if origin is a root according to mode.\n   */\n  getParentCaret(mode = 'root') {\n    return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);\n  }\n  getFlipped() {\n    const dir = flipDirection(this.direction);\n    return $getSiblingCaret(this.getNodeAtCaret(), dir) || $getChildCaret(this.origin, dir);\n  }\n  getParentAtCaret() {\n    return this.origin;\n  }\n  getChildCaret() {\n    return this;\n  }\n  isSameNodeCaret(other) {\n    return other instanceof AbstractChildCaret && this.direction === other.direction && this.origin.is(other.origin);\n  }\n  isSamePointCaret(other) {\n    return this.isSameNodeCaret(other);\n  }\n}\nclass ChildCaretFirst extends AbstractChildCaret {\n  direction = 'next';\n  getNodeAtCaret() {\n    return this.origin.getFirstChild();\n  }\n  insert(node) {\n    this.origin.splice(0, 0, [node]);\n    return this;\n  }\n}\nclass ChildCaretLast extends AbstractChildCaret {\n  direction = 'previous';\n  getNodeAtCaret() {\n    return this.origin.getLastChild();\n  }\n  insert(node) {\n    this.origin.splice(this.origin.getChildrenSize(), 0, [node]);\n    return this;\n  }\n}\nconst MODE_PREDICATE = {\n  root: $isRootNode,\n  shadowRoot: $isRootOrShadowRoot\n};\n\n/**\n * Flip a direction ('next' -> 'previous'; 'previous' -> 'next').\n *\n * Note that TypeScript can't prove that FlipDirection is its own\n * inverse (but if you have a concrete 'next' or 'previous' it will\n * simplify accordingly).\n *\n * @param direction A direction\n * @returns The opposite direction\n */\nfunction flipDirection(direction) {\n  return FLIP_DIRECTION[direction];\n}\nfunction $filterByMode(node, mode = 'root') {\n  return MODE_PREDICATE[mode](node) ? null : node;\n}\nclass AbstractSiblingCaret extends AbstractCaret {\n  type = 'sibling';\n  getLatest() {\n    const origin = this.origin.getLatest();\n    return origin === this.origin ? this : $getSiblingCaret(origin, this.direction);\n  }\n  getSiblingCaret() {\n    return this;\n  }\n  getParentAtCaret() {\n    return this.origin.getParent();\n  }\n  getChildCaret() {\n    return $isElementNode(this.origin) ? $getChildCaret(this.origin, this.direction) : null;\n  }\n  getParentCaret(mode = 'root') {\n    return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);\n  }\n  getFlipped() {\n    const dir = flipDirection(this.direction);\n    return $getSiblingCaret(this.getNodeAtCaret(), dir) || $getChildCaret(this.origin.getParentOrThrow(), dir);\n  }\n  isSamePointCaret(other) {\n    return other instanceof AbstractSiblingCaret && this.direction === other.direction && this.origin.is(other.origin);\n  }\n  isSameNodeCaret(other) {\n    return (other instanceof AbstractSiblingCaret || other instanceof AbstractTextPointCaret) && this.direction === other.direction && this.origin.is(other.origin);\n  }\n}\nclass AbstractTextPointCaret extends AbstractCaret {\n  type = 'text';\n  constructor(origin, offset) {\n    super(origin);\n    this.offset = offset;\n  }\n  getLatest() {\n    const origin = this.origin.getLatest();\n    return origin === this.origin ? this : $getTextPointCaret(origin, this.direction, this.offset);\n  }\n  getParentAtCaret() {\n    return this.origin.getParent();\n  }\n  getChildCaret() {\n    return null;\n  }\n  getParentCaret(mode = 'root') {\n    return $getSiblingCaret($filterByMode(this.getParentAtCaret(), mode), this.direction);\n  }\n  getFlipped() {\n    return $getTextPointCaret(this.origin, flipDirection(this.direction), this.offset);\n  }\n  isSamePointCaret(other) {\n    return other instanceof AbstractTextPointCaret && this.direction === other.direction && this.origin.is(other.origin) && this.offset === other.offset;\n  }\n  isSameNodeCaret(other) {\n    return (other instanceof AbstractSiblingCaret || other instanceof AbstractTextPointCaret) && this.direction === other.direction && this.origin.is(other.origin);\n  }\n  getSiblingCaret() {\n    return $getSiblingCaret(this.origin, this.direction);\n  }\n}\n/**\n * Guard to check if the given caret is specifically a TextPointCaret\n *\n * @param caret Any caret\n * @returns true if it is a TextPointCaret\n */\nfunction $isTextPointCaret(caret) {\n  return caret instanceof AbstractTextPointCaret;\n}\n\n/**\n * Guard to check if the given argument is any type of caret\n *\n * @param caret\n * @returns true if caret is any type of caret\n */\nfunction $isNodeCaret(caret) {\n  return caret instanceof AbstractCaret;\n}\n\n/**\n * Guard to check if the given argument is specifically a SiblingCaret (or TextPointCaret)\n *\n * @param caret\n * @returns true if caret is a SiblingCaret\n */\nfunction $isSiblingCaret(caret) {\n  return caret instanceof AbstractSiblingCaret;\n}\n\n/**\n * Guard to check if the given argument is specifically a ChildCaret\n\n * @param caret \n * @returns true if caret is a ChildCaret\n */\nfunction $isChildCaret(caret) {\n  return caret instanceof AbstractChildCaret;\n}\nclass SiblingCaretNext extends AbstractSiblingCaret {\n  direction = 'next';\n  getNodeAtCaret() {\n    return this.origin.getNextSibling();\n  }\n  insert(node) {\n    this.origin.insertAfter(node);\n    return this;\n  }\n}\nclass SiblingCaretPrevious extends AbstractSiblingCaret {\n  direction = 'previous';\n  getNodeAtCaret() {\n    return this.origin.getPreviousSibling();\n  }\n  insert(node) {\n    this.origin.insertBefore(node);\n    return this;\n  }\n}\nclass TextPointCaretNext extends AbstractTextPointCaret {\n  direction = 'next';\n  getNodeAtCaret() {\n    return this.origin.getNextSibling();\n  }\n  insert(node) {\n    this.origin.insertAfter(node);\n    return this;\n  }\n}\nclass TextPointCaretPrevious extends AbstractTextPointCaret {\n  direction = 'previous';\n  getNodeAtCaret() {\n    return this.origin.getPreviousSibling();\n  }\n  insert(node) {\n    this.origin.insertBefore(node);\n    return this;\n  }\n}\nconst TEXT_CTOR = {\n  next: TextPointCaretNext,\n  previous: TextPointCaretPrevious\n};\nconst SIBLING_CTOR = {\n  next: SiblingCaretNext,\n  previous: SiblingCaretPrevious\n};\nconst CHILD_CTOR = {\n  next: ChildCaretFirst,\n  previous: ChildCaretLast\n};\n\n/**\n * Get a caret that points at the next or previous sibling of the given origin node.\n *\n * @param origin The origin node\n * @param direction 'next' or 'previous'\n * @returns null if origin is null, otherwise a SiblingCaret for this origin and direction\n */\n\nfunction $getSiblingCaret(origin, direction) {\n  return origin ? new SIBLING_CTOR[direction](origin) : null;\n}\n\n/**\n * Construct a TextPointCaret\n *\n * @param origin The TextNode\n * @param direction The direction (next points to the end of the text, previous points to the beginning)\n * @param offset The offset into the text in absolute positive string coordinates (0 is the start)\n * @returns a TextPointCaret\n */\n\nfunction $getTextPointCaret(origin, direction, offset) {\n  return origin ? new TEXT_CTOR[direction](origin, $getTextNodeOffset(origin, offset)) : null;\n}\n\n/**\n * Get a normalized offset into a TextNode given a numeric offset or a\n * direction for which end of the string to use. Throws in dev if the offset\n * is not in the bounds of the text content size.\n *\n * @param origin a TextNode\n * @param offset An absolute offset into the TextNode string, or a direction for which end to use as the offset\n * @param mode If 'error' (the default) out of bounds offsets will be an error in dev. Otherwise it will clamp to a valid offset.\n * @returns An absolute offset into the TextNode string\n */\nfunction $getTextNodeOffset(origin, offset, mode = 'error') {\n  const size = origin.getTextContentSize();\n  let numericOffset = offset === 'next' ? size : offset === 'previous' ? 0 : offset;\n  if (numericOffset < 0 || numericOffset > size) {\n    if (!(mode === 'clamp')) {\n      formatDevErrorMessage(`$getTextNodeOffset: invalid offset ${String(offset)} for size ${String(size)} at key ${origin.getKey()}`);\n    } // Clamp invalid offsets in prod\n    numericOffset = numericOffset < 0 ? 0 : size;\n  }\n  return numericOffset;\n}\n\n/**\n * Construct a TextPointCaretSlice given a TextPointCaret and a signed distance. The\n * distance should be negative to slice text before the caret's offset, and positive\n * to slice text after the offset. The direction of the caret itself is not\n * relevant to the string coordinates when working with a TextPointCaretSlice\n * but mutation operations will preserve the direction.\n *\n * @param caret\n * @param distance\n * @returns TextPointCaretSlice\n */\nfunction $getTextPointCaretSlice(caret, distance) {\n  return new TextPointCaretSliceImpl(caret, distance);\n}\n\n/**\n * Get a caret that points at the first or last child of the given origin node,\n * which must be an ElementNode.\n *\n * @param origin The origin ElementNode\n * @param direction 'next' for first child or 'previous' for last child\n * @returns null if origin is null or not an ElementNode, otherwise a ChildCaret for this origin and direction\n */\n\nfunction $getChildCaret(origin, direction) {\n  return $isElementNode(origin) ? new CHILD_CTOR[direction](origin) : null;\n}\n\n/**\n * Gets the ChildCaret if one is possible at this caret origin, otherwise return the caret\n */\nfunction $getChildCaretOrSelf(caret) {\n  return caret && caret.getChildCaret() || caret;\n}\n\n/**\n * Gets the adjacent caret, if not-null and if the origin of the adjacent caret is an ElementNode, then return\n * the ChildCaret. This can be used along with the getParentAdjacentCaret method to perform a full DFS\n * style traversal of the tree.\n *\n * @param caret The caret to start at\n */\nfunction $getAdjacentChildCaret(caret) {\n  return caret && $getChildCaretOrSelf(caret.getAdjacentCaret());\n}\nclass CaretRangeImpl {\n  type = 'node-caret-range';\n  constructor(anchor, focus, direction) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.direction = direction;\n  }\n  getLatest() {\n    const anchor = this.anchor.getLatest();\n    const focus = this.focus.getLatest();\n    return anchor === this.anchor && focus === this.focus ? this : new CaretRangeImpl(anchor, focus, this.direction);\n  }\n  isCollapsed() {\n    return this.anchor.isSamePointCaret(this.focus);\n  }\n  getTextSlices() {\n    const getSlice = k => {\n      const caret = this[k].getLatest();\n      return $isTextPointCaret(caret) ? $getSliceFromTextPointCaret(caret, k) : null;\n    };\n    const anchorSlice = getSlice('anchor');\n    const focusSlice = getSlice('focus');\n    if (anchorSlice && focusSlice) {\n      const {\n        caret: anchorCaret\n      } = anchorSlice;\n      const {\n        caret: focusCaret\n      } = focusSlice;\n      if (anchorCaret.isSameNodeCaret(focusCaret)) {\n        return [$getTextPointCaretSlice(anchorCaret, focusCaret.offset - anchorCaret.offset), null];\n      }\n    }\n    return [anchorSlice, focusSlice];\n  }\n  iterNodeCarets(rootMode = 'root') {\n    const anchor = $isTextPointCaret(this.anchor) ? this.anchor.getSiblingCaret() : this.anchor.getLatest();\n    const focus = this.focus.getLatest();\n    const isTextFocus = $isTextPointCaret(focus);\n    const step = state => state.isSameNodeCaret(focus) ? null : $getAdjacentChildCaret(state) || state.getParentCaret(rootMode);\n    return makeStepwiseIterator({\n      hasNext: state => state !== null && !(isTextFocus && focus.isSameNodeCaret(state)),\n      initial: anchor.isSameNodeCaret(focus) ? null : step(anchor),\n      map: state => state,\n      step\n    });\n  }\n  [Symbol.iterator]() {\n    return this.iterNodeCarets('root');\n  }\n}\nclass TextPointCaretSliceImpl {\n  type = 'slice';\n  constructor(caret, distance) {\n    this.caret = caret;\n    this.distance = distance;\n  }\n  getSliceIndices() {\n    const {\n      distance,\n      caret: {\n        offset\n      }\n    } = this;\n    const offsetB = offset + distance;\n    return offsetB < offset ? [offsetB, offset] : [offset, offsetB];\n  }\n  getTextContent() {\n    const [startIndex, endIndex] = this.getSliceIndices();\n    return this.caret.origin.getTextContent().slice(startIndex, endIndex);\n  }\n  getTextContentSize() {\n    return Math.abs(this.distance);\n  }\n  removeTextSlice() {\n    const {\n      caret: {\n        origin,\n        direction\n      }\n    } = this;\n    const [indexStart, indexEnd] = this.getSliceIndices();\n    const text = origin.getTextContent();\n    return $getTextPointCaret(origin.setTextContent(text.slice(0, indexStart) + text.slice(indexEnd)), direction, indexStart);\n  }\n}\nfunction $getSliceFromTextPointCaret(caret, anchorOrFocus) {\n  const {\n    direction,\n    origin\n  } = caret;\n  const offsetB = $getTextNodeOffset(origin, anchorOrFocus === 'focus' ? flipDirection(direction) : direction);\n  return $getTextPointCaretSlice(caret, offsetB - caret.offset);\n}\n\n/**\n * Guard to check for a TextPointCaretSlice\n *\n * @param caretOrSlice A caret or slice\n * @returns true if caretOrSlice is a TextPointCaretSlice\n */\nfunction $isTextPointCaretSlice(caretOrSlice) {\n  return caretOrSlice instanceof TextPointCaretSliceImpl;\n}\n\n/**\n * Construct a CaretRange that starts at anchor and goes to the end of the\n * document in the anchor caret's direction.\n */\nfunction $extendCaretToRange(anchor) {\n  return $getCaretRange(anchor, $getSiblingCaret($getRoot(), anchor.direction));\n}\n\n/**\n * Construct a collapsed CaretRange that starts and ends at anchor.\n */\nfunction $getCollapsedCaretRange(anchor) {\n  return $getCaretRange(anchor, anchor);\n}\n\n/**\n * Construct a CaretRange from anchor and focus carets pointing in the\n * same direction. In order to get the expected behavior,\n * the anchor must point towards the focus or be the same point.\n *\n * In the 'next' direction the anchor should be at or before the\n * focus in the document. In the 'previous' direction the anchor\n * should be at or after the focus in the document\n * (similar to a backwards RangeSelection).\n *\n * @param anchor\n * @param focus\n * @returns a CaretRange\n */\nfunction $getCaretRange(anchor, focus) {\n  if (!(anchor.direction === focus.direction)) {\n    formatDevErrorMessage(`$getCaretRange: anchor and focus must be in the same direction`);\n  }\n  return new CaretRangeImpl(anchor, focus, anchor.direction);\n}\n\n/**\n * A generalized utility for creating a stepwise iterator\n * based on:\n *\n * - an initial state\n * - a stop guard that returns true if the iteration is over, this\n *   is typically used to detect a sentinel value such as null or\n *   undefined from the state but may return true for other conditions\n *   as well\n * - a step function that advances the state (this will be called\n *   after map each time next() is called to prepare the next state)\n * - a map function that will be called that may transform the state\n *   before returning it. It will only be called once for each next()\n *   call when stop(state) === false\n *\n * @param config\n * @returns An IterableIterator\n */\nfunction makeStepwiseIterator(config) {\n  const {\n    initial,\n    hasNext,\n    step,\n    map\n  } = config;\n  let state = initial;\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      if (!hasNext(state)) {\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n      const rval = {\n        done: false,\n        value: map(state)\n      };\n      state = step(state);\n      return rval;\n    }\n  };\n}\nfunction compareNumber(a, b) {\n  return Math.sign(a - b);\n}\n\n/**\n * A total ordering for `PointCaret<'next'>`, based on\n * the same order that a {@link CaretRange} would iterate\n * them.\n *\n * For a given origin node:\n * - ChildCaret comes before SiblingCaret\n * - TextPointCaret comes before SiblingCaret\n *\n * An exception is thrown when a and b do not have any\n * common ancestor.\n *\n * This ordering is a sort of mix of pre-order and post-order\n * because each ElementNode will show up as a ChildCaret\n * on 'enter' (pre-order) and a SiblingCaret on 'leave' (post-order).\n *\n * @param a\n * @param b\n * @returns -1 if a comes before b, 0 if a and b are the same, or 1 if a comes after b\n */\nfunction $comparePointCaretNext(a, b) {\n  const compare = $getCommonAncestor(a.origin, b.origin);\n  if (!(compare !== null)) {\n    formatDevErrorMessage(`$comparePointCaretNext: a (key ${a.origin.getKey()}) and b (key ${b.origin.getKey()}) do not have a common ancestor`);\n  }\n  switch (compare.type) {\n    case 'same':\n      {\n        const aIsText = a.type === 'text';\n        const bIsText = b.type === 'text';\n        return aIsText && bIsText ? compareNumber(a.offset, b.offset) : a.type === b.type ? 0 : aIsText ? -1 : bIsText ? 1 : a.type === 'child' ? -1 : 1;\n      }\n    case 'ancestor':\n      {\n        return a.type === 'child' ? -1 : 1;\n      }\n    case 'descendant':\n      {\n        return b.type === 'child' ? 1 : -1;\n      }\n    case 'branch':\n      {\n        return $getCommonAncestorResultBranchOrder(compare);\n      }\n  }\n}\n\n/**\n * Return the ordering of siblings in a CommonAncestorResultBranch\n * @param branch Returns -1 if a precedes b, 1 otherwise\n */\nfunction $getCommonAncestorResultBranchOrder(compare) {\n  const {\n    a,\n    b\n  } = compare;\n  const aKey = a.__key;\n  const bKey = b.__key;\n  let na = a;\n  let nb = b;\n  for (; na && nb; na = na.getNextSibling(), nb = nb.getNextSibling()) {\n    if (na.__key === bKey) {\n      return -1;\n    } else if (nb.__key === aKey) {\n      return 1;\n    }\n  }\n  return na === null ? 1 : -1;\n}\n\n/**\n * The two compared nodes are the same\n */\n\n/**\n * Node a was a descendant of node b, and not the same node\n */\n\n/**\n * Node a is an ancestor of node b, and not the same node\n */\n\n/**\n * Node a and node b have a common ancestor but are on different branches,\n * the `a` and `b` properties of this result are the ancestors of a and b\n * that are children of the commonAncestor. Since they are siblings, their\n * positions are comparable to determine order in the document.\n */\n\n/**\n * The result of comparing two nodes that share some common ancestor\n */\n\nfunction $isSameNode(reference, other) {\n  return other.is(reference);\n}\nfunction $initialElementTuple(node) {\n  return $isElementNode(node) ? [node.getLatest(), null] : [node.getParent(), node.getLatest()];\n}\n\n/**\n * Find a common ancestor of a and b and return a detailed result object,\n * or null if there is no common ancestor between the two nodes.\n *\n * The result object will have a commonAncestor property, and the other\n * properties can be used to quickly compare these positions in the tree.\n *\n * @param a A LexicalNode\n * @param b A LexicalNode\n * @returns A comparison result between the two nodes or null if they have no common ancestor\n */\nfunction $getCommonAncestor(a, b) {\n  if (a.is(b)) {\n    return {\n      commonAncestor: a,\n      type: 'same'\n    };\n  }\n  // Map of parent -> child entries based on a and its ancestors\n  const aMap = new Map();\n  for (let [parent, child] = $initialElementTuple(a); parent; child = parent, parent = parent.getParent()) {\n    aMap.set(parent, child);\n  }\n  for (let [parent, child] = $initialElementTuple(b); parent; child = parent, parent = parent.getParent()) {\n    const aChild = aMap.get(parent);\n    if (aChild === undefined) ; else if (aChild === null) {\n      // a is the ancestor\n      if (!$isSameNode(a, parent)) {\n        formatDevErrorMessage(`$originComparison: ancestor logic error`);\n      }\n      return {\n        commonAncestor: parent,\n        type: 'ancestor'\n      };\n    } else if (child === null) {\n      // b is the ancestor\n      if (!$isSameNode(b, parent)) {\n        formatDevErrorMessage(`$originComparison: descendant logic error`);\n      }\n      return {\n        commonAncestor: parent,\n        type: 'descendant'\n      };\n    } else {\n      if (!(($isElementNode(aChild) || $isSameNode(a, aChild)) && ($isElementNode(child) || $isSameNode(b, child)) && parent.is(aChild.getParent()) && parent.is(child.getParent()))) {\n        formatDevErrorMessage(`$originComparison: branch logic error`);\n      }\n      return {\n        a: aChild,\n        b: child,\n        commonAncestor: parent,\n        type: 'branch'\n      };\n    }\n  }\n  return null;\n}\n\n/**\n * @param point\n * @returns a PointCaret for the point\n */\nfunction $caretFromPoint(point, direction) {\n  const {\n    type,\n    key,\n    offset\n  } = point;\n  const node = $getNodeByKeyOrThrow(point.key);\n  if (type === 'text') {\n    if (!$isTextNode(node)) {\n      formatDevErrorMessage(`$caretFromPoint: Node with type ${node.getType()} and key ${key} that does not inherit from TextNode encountered for text point`);\n    }\n    return $getTextPointCaret(node, direction, offset);\n  }\n  if (!$isElementNode(node)) {\n    formatDevErrorMessage(`$caretFromPoint: Node with type ${node.getType()} and key ${key} that does not inherit from ElementNode encountered for element point`);\n  }\n  return $getChildCaretAtIndex(node, point.offset, direction);\n}\n\n/**\n * Update the given point in-place from the PointCaret\n *\n * @param point the point to set\n * @param caret the caret to set the point from\n */\nfunction $setPointFromCaret(point, caret) {\n  const {\n    origin,\n    direction\n  } = caret;\n  const isNext = direction === 'next';\n  if ($isTextPointCaret(caret)) {\n    point.set(origin.getKey(), caret.offset, 'text');\n  } else if ($isSiblingCaret(caret)) {\n    if ($isTextNode(origin)) {\n      point.set(origin.getKey(), $getTextNodeOffset(origin, direction), 'text');\n    } else {\n      point.set(origin.getParentOrThrow().getKey(), origin.getIndexWithinParent() + (isNext ? 1 : 0), 'element');\n    }\n  } else {\n    if (!($isChildCaret(caret) && $isElementNode(origin))) {\n      formatDevErrorMessage(`$setPointFromCaret: exhaustiveness check`);\n    }\n    point.set(origin.getKey(), isNext ? 0 : origin.getChildrenSize(), 'element');\n  }\n}\n\n/**\n * Set a RangeSelection on the editor from the given CaretRange\n *\n * @returns The new RangeSelection\n */\nfunction $setSelectionFromCaretRange(caretRange) {\n  const currentSelection = $getSelection();\n  const selection = $isRangeSelection(currentSelection) ? currentSelection : $createRangeSelection();\n  $updateRangeSelectionFromCaretRange(selection, caretRange);\n  $setSelection(selection);\n  return selection;\n}\n\n/**\n * Update the points of a RangeSelection based on the given PointCaret.\n */\nfunction $updateRangeSelectionFromCaretRange(selection, caretRange) {\n  $setPointFromCaret(selection.anchor, caretRange.anchor);\n  $setPointFromCaret(selection.focus, caretRange.focus);\n}\n\n/**\n * Get a pair of carets for a RangeSelection.\n *\n * If the focus is before the anchor, then the direction will be\n * 'previous', otherwise the direction will be 'next'.\n */\nfunction $caretRangeFromSelection(selection) {\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorCaret = $caretFromPoint(anchor, 'next');\n  const focusCaret = $caretFromPoint(focus, 'next');\n  const direction = $comparePointCaretNext(anchorCaret, focusCaret) <= 0 ? 'next' : 'previous';\n  return $getCaretRange($getCaretInDirection(anchorCaret, direction), $getCaretInDirection(focusCaret, direction));\n}\n\n/**\n * Given a SiblingCaret we can always compute a caret that points to the\n * origin of that caret in the same direction. The adjacent caret of the\n * returned caret will be equivalent to the given caret.\n *\n * @example\n * ```ts\n * siblingCaret.is($rewindSiblingCaret(siblingCaret).getAdjacentCaret())\n * ```\n *\n * @param caret The caret to \"rewind\"\n * @returns A new caret (ChildCaret or SiblingCaret) with the same direction\n */\nfunction $rewindSiblingCaret(caret) {\n  const {\n    direction,\n    origin\n  } = caret;\n  // Rotate the direction around the origin and get the adjacent node\n  const rewindOrigin = $getSiblingCaret(origin, flipDirection(direction)).getNodeAtCaret();\n  return rewindOrigin ? $getSiblingCaret(rewindOrigin, direction) : $getChildCaret(origin.getParentOrThrow(), direction);\n}\nfunction $getAnchorCandidates(anchor, rootMode = 'root') {\n  // These candidates will be the anchor itself, the pointer to the anchor (if different), and then any parents of that\n  const carets = [anchor];\n  for (let parent = $isChildCaret(anchor) ? anchor.getParentCaret(rootMode) : anchor.getSiblingCaret(); parent !== null; parent = parent.getParentCaret(rootMode)) {\n    carets.push($rewindSiblingCaret(parent));\n  }\n  return carets;\n}\nfunction $isCaretAttached(caret) {\n  return !!caret && caret.origin.isAttached();\n}\n\n/**\n * Remove all text and nodes in the given range. If the range spans multiple\n * blocks then the remaining contents of the later block will be merged with\n * the earlier block.\n *\n * @param initialRange The range to remove text and nodes from\n * @param sliceMode If 'preserveEmptyTextPointCaret' it will leave an empty TextPointCaret at the anchor for insert if one exists, otherwise empty slices will be removed\n * @returns The new collapsed range (biased towards the earlier node)\n */\nfunction $removeTextFromCaretRange(initialRange, sliceMode = 'removeEmptySlices') {\n  if (initialRange.isCollapsed()) {\n    return initialRange;\n  }\n  // Always process removals in document order\n  const rootMode = 'root';\n  const nextDirection = 'next';\n  let sliceState = sliceMode;\n  const range = $getCaretRangeInDirection(initialRange, nextDirection);\n  const anchorCandidates = $getAnchorCandidates(range.anchor, rootMode);\n  const focusCandidates = $getAnchorCandidates(range.focus.getFlipped(), rootMode);\n\n  // Mark the start of each ElementNode\n  const seenStart = new Set();\n  // Queue removals since removing the only child can cascade to having\n  // a parent remove itself which will affect iteration\n  const removedNodes = [];\n  for (const caret of range.iterNodeCarets(rootMode)) {\n    if ($isChildCaret(caret)) {\n      seenStart.add(caret.origin.getKey());\n    } else if ($isSiblingCaret(caret)) {\n      const {\n        origin\n      } = caret;\n      if (!$isElementNode(origin) || seenStart.has(origin.getKey())) {\n        removedNodes.push(origin);\n      }\n    }\n  }\n  for (const node of removedNodes) {\n    node.remove();\n  }\n\n  // Splice text at the anchor and/or origin.\n  // If the text is entirely selected then it is removed (unless it is the first slice and sliceMode is preserveEmptyTextSliceCaret).\n  // If it's a token with a non-empty selection then it is removed.\n  // Segmented nodes will be copied to a plain text node with the same format\n  // and style and set to normal mode.\n  for (const slice of range.getTextSlices()) {\n    if (!slice) {\n      continue;\n    }\n    const {\n      origin\n    } = slice.caret;\n    const contentSize = origin.getTextContentSize();\n    const caretBefore = $rewindSiblingCaret($getSiblingCaret(origin, nextDirection));\n    const mode = origin.getMode();\n    if (Math.abs(slice.distance) === contentSize && sliceState === 'removeEmptySlices' || mode === 'token' && slice.distance !== 0) {\n      // anchorCandidates[1] should still be valid, it is caretBefore\n      caretBefore.remove();\n    } else if (slice.distance !== 0) {\n      sliceState = 'removeEmptySlices';\n      let nextCaret = slice.removeTextSlice();\n      const sliceOrigin = slice.caret.origin;\n      if (mode === 'segmented') {\n        const src = nextCaret.origin;\n        const plainTextNode = $createTextNode(src.getTextContent()).setStyle(src.getStyle()).setFormat(src.getFormat());\n        caretBefore.replaceOrInsert(plainTextNode);\n        nextCaret = $getTextPointCaret(plainTextNode, nextDirection, nextCaret.offset);\n      }\n      if (sliceOrigin.is(anchorCandidates[0].origin)) {\n        anchorCandidates[0] = nextCaret;\n      }\n      if (sliceOrigin.is(focusCandidates[0].origin)) {\n        focusCandidates[0] = nextCaret.getFlipped();\n      }\n    }\n  }\n\n  // Find the deepest anchor and focus candidates that are\n  // still attached\n  let anchorCandidate;\n  let focusCandidate;\n  for (const candidate of anchorCandidates) {\n    if ($isCaretAttached(candidate)) {\n      anchorCandidate = $normalizeCaret(candidate);\n      break;\n    }\n  }\n  for (const candidate of focusCandidates) {\n    if ($isCaretAttached(candidate)) {\n      focusCandidate = $normalizeCaret(candidate);\n      break;\n    }\n  }\n\n  // Merge blocks if necessary\n  const mergeTargets = $getBlockMergeTargets(anchorCandidate, focusCandidate, seenStart);\n  if (mergeTargets) {\n    const [anchorBlock, focusBlock] = mergeTargets;\n    // always merge blocks later in the document with\n    // blocks earlier in the document\n    $getChildCaret(anchorBlock, 'previous').splice(0, focusBlock.getChildren());\n    focusBlock.remove();\n  }\n\n  // note this caret can be in either direction\n  const bestCandidate = [anchorCandidate, focusCandidate, ...anchorCandidates, ...focusCandidates].find($isCaretAttached);\n  if (bestCandidate) {\n    const anchor = $getCaretInDirection($normalizeCaret(bestCandidate), initialRange.direction);\n    return $getCollapsedCaretRange(anchor);\n  }\n  {\n    formatDevErrorMessage(`$removeTextFromCaretRange: selection was lost, could not find a new anchor given candidates with keys: ${JSON.stringify(anchorCandidates.map(n => n.origin.__key))}`);\n  }\n}\n\n/**\n * Determine if the two caret origins are in distinct blocks that\n * should be merged.\n *\n * The returned block pair will be the closest blocks to their\n * common ancestor, and must be no shadow roots between\n * the blocks and their respective carets. If two distinct\n * blocks matching this criteria are not found, this will return\n * null.\n */\nfunction $getBlockMergeTargets(anchor, focus, seenStart) {\n  if (!anchor || !focus) {\n    return null;\n  }\n  const anchorParent = anchor.getParentAtCaret();\n  const focusParent = focus.getParentAtCaret();\n  if (!anchorParent || !focusParent) {\n    return null;\n  }\n  // TODO refactor when we have a better primitive for common ancestor\n  const anchorElements = anchorParent.getParents().reverse();\n  anchorElements.push(anchorParent);\n  const focusElements = focusParent.getParents().reverse();\n  focusElements.push(focusParent);\n  const maxLen = Math.min(anchorElements.length, focusElements.length);\n  let commonAncestorCount;\n  for (commonAncestorCount = 0; commonAncestorCount < maxLen && anchorElements[commonAncestorCount] === focusElements[commonAncestorCount]; commonAncestorCount++) {\n    // just traverse the ancestors\n  }\n  const $getBlock = (arr, predicate) => {\n    let block;\n    for (let i = commonAncestorCount; i < arr.length; i++) {\n      const ancestor = arr[i];\n      if ($isRootOrShadowRoot(ancestor)) {\n        return;\n      } else if (!block && predicate(ancestor)) {\n        block = ancestor;\n      }\n    }\n    return block;\n  };\n  const anchorBlock = $getBlock(anchorElements, INTERNAL_$isBlock);\n  const focusBlock = anchorBlock && $getBlock(focusElements, node => seenStart.has(node.getKey()) && INTERNAL_$isBlock(node));\n  return anchorBlock && focusBlock ? [anchorBlock, focusBlock] : null;\n}\n\n/**\n * Return the deepest ChildCaret that has initialCaret's origin\n * as an ancestor, or initialCaret if the origin is not an ElementNode\n * or is already the deepest ChildCaret.\n *\n * This is generally used when normalizing because there is\n * \"zero distance\" between these locations.\n *\n * @param initialCaret\n * @returns Either a deeper ChildCaret or the given initialCaret\n */\nfunction $getDeepestChildOrSelf(initialCaret) {\n  let caret = initialCaret;\n  while ($isChildCaret(caret)) {\n    const adjacent = $getAdjacentChildCaret(caret);\n    if (!$isChildCaret(adjacent)) {\n      break;\n    }\n    caret = adjacent;\n  }\n  return caret;\n}\n\n/**\n * Normalize a caret to the deepest equivalent PointCaret.\n * This will return a TextPointCaret with the offset set according\n * to the direction if given a caret with a TextNode origin\n * or a caret with an ElementNode origin with the deepest ChildCaret\n * having an adjacent TextNode.\n *\n * If given a TextPointCaret, it will be returned, as no normalization\n * is required when an offset is already present.\n *\n * @param initialCaret\n * @returns The normalized PointCaret\n */\nfunction $normalizeCaret(initialCaret) {\n  const caret = $getDeepestChildOrSelf(initialCaret.getLatest());\n  const {\n    direction\n  } = caret;\n  if ($isTextNode(caret.origin)) {\n    return $isTextPointCaret(caret) ? caret : $getTextPointCaret(caret.origin, direction, direction);\n  }\n  const adj = caret.getAdjacentCaret();\n  return $isSiblingCaret(adj) && $isTextNode(adj.origin) ? $getTextPointCaret(adj.origin, direction, flipDirection(direction)) : caret;\n}\n/**\n * Determine whether the TextPointCaret's offset can be extended further without leaving the TextNode.\n * Returns false if the given caret is not a TextPointCaret or the offset can not be moved further in\n * direction.\n *\n * @param caret A PointCaret\n * @returns true if caret is a TextPointCaret with an offset that is not at the end of the text given the direction.\n */\nfunction $isExtendableTextPointCaret(caret) {\n  return $isTextPointCaret(caret) && caret.offset !== $getTextNodeOffset(caret.origin, caret.direction);\n}\n\n/**\n * Return the caret if it's in the given direction, otherwise return\n * caret.getFlipped().\n *\n * @param caret Any PointCaret\n * @param direction The desired direction\n * @returns A PointCaret in direction\n */\nfunction $getCaretInDirection(caret, direction) {\n  return caret.direction === direction ? caret : caret.getFlipped();\n}\n\n/**\n * Return the range if it's in the given direction, otherwise\n * construct a new range using a flipped focus as the anchor\n * and a flipped anchor as the focus. This transformation\n * preserves the section of the document that it's working\n * with, but reverses the order of iteration.\n *\n * @param range Any CaretRange\n * @param direction The desired direction\n * @returns A CaretRange in direction\n */\nfunction $getCaretRangeInDirection(range, direction) {\n  if (range.direction === direction) {\n    return range;\n  }\n  return $getCaretRange(\n  // focus and anchor get flipped here\n  $getCaretInDirection(range.focus, direction), $getCaretInDirection(range.anchor, direction));\n}\n\n/**\n * Get a caret pointing at the child at the given index, or the last\n * caret in that node if out of bounds.\n *\n * @param parent An ElementNode\n * @param index The index of the origin for the caret\n * @returns A caret pointing towards the node at that index\n */\nfunction $getChildCaretAtIndex(parent, index, direction) {\n  let caret = $getChildCaret(parent, 'next');\n  for (let i = 0; i < index; i++) {\n    const nextCaret = caret.getAdjacentCaret();\n    if (nextCaret === null) {\n      break;\n    }\n    caret = nextCaret;\n  }\n  return $getCaretInDirection(caret, direction);\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param startCaret The initial caret\n * @param rootMode The root mode, 'root' ('default') or 'shadowRoot'\n * @returns An array (tuple) containing the found caret and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = 'root') {\n  let depthDiff = 0;\n  let caret = startCaret;\n  let nextCaret = $getAdjacentChildCaret(caret);\n  while (nextCaret === null) {\n    depthDiff--;\n    nextCaret = caret.getParentCaret(rootMode);\n    if (!nextCaret) {\n      return null;\n    }\n    caret = nextCaret;\n    nextCaret = $getAdjacentChildCaret(caret);\n  }\n  return nextCaret && [nextCaret, depthDiff];\n}\n\n/**\n * Get the adjacent nodes to initialCaret in the given direction.\n *\n * @example\n * ```ts\n * expect($getAdjacentNodes($getChildCaret(parent, 'next'))).toEqual(parent.getChildren());\n * expect($getAdjacentNodes($getChildCaret(parent, 'previous'))).toEqual(parent.getChildren().reverse());\n * expect($getAdjacentNodes($getSiblingCaret(node, 'next'))).toEqual(node.getNextSiblings());\n * expect($getAdjacentNodes($getSiblingCaret(node, 'previous'))).toEqual(node.getPreviousSiblings().reverse());\n * ```\n *\n * @param initialCaret The caret to start at (the origin will not be included)\n * @returns An array of siblings.\n */\nfunction $getAdjacentNodes(initialCaret) {\n  const siblings = [];\n  for (let caret = initialCaret.getAdjacentCaret(); caret; caret = caret.getAdjacentCaret()) {\n    siblings.push(caret.origin);\n  }\n  return siblings;\n}\nfunction $splitTextPointCaret(textPointCaret) {\n  const {\n    origin,\n    offset,\n    direction\n  } = textPointCaret;\n  if (offset === $getTextNodeOffset(origin, direction)) {\n    return textPointCaret.getSiblingCaret();\n  } else if (offset === $getTextNodeOffset(origin, flipDirection(direction))) {\n    return $rewindSiblingCaret(textPointCaret.getSiblingCaret());\n  }\n  const [textNode] = origin.splitText(offset);\n  if (!$isTextNode(textNode)) {\n    formatDevErrorMessage(`$splitTextPointCaret: splitText must return at least one TextNode`);\n  }\n  return $getCaretInDirection($getSiblingCaret(textNode, 'next'), direction);\n}\nfunction $alwaysSplit(_node, _edge) {\n  return true;\n}\n\n/**\n * Split a node at a PointCaret and return a NodeCaret at that point, or null if the\n * node can't be split. This is non-recursive and will only perform at most one split.\n *\n * @returns The NodeCaret pointing to the location of the split (or null if a split is not possible)\n */\nfunction $splitAtPointCaretNext(pointCaret, {\n  $copyElementNode = $copyNode,\n  $splitTextPointCaretNext = $splitTextPointCaret,\n  rootMode = 'shadowRoot',\n  $shouldSplit = $alwaysSplit\n} = {}) {\n  if ($isTextPointCaret(pointCaret)) {\n    return $splitTextPointCaretNext(pointCaret);\n  }\n  const parentCaret = pointCaret.getParentCaret(rootMode);\n  if (parentCaret) {\n    const {\n      origin\n    } = parentCaret;\n    if ($isChildCaret(pointCaret) && !(origin.canBeEmpty() && $shouldSplit(origin, 'first'))) {\n      // No split necessary, the left side would be empty\n      return $rewindSiblingCaret(parentCaret);\n    }\n    const siblings = $getAdjacentNodes(pointCaret);\n    if (siblings.length > 0 || origin.canBeEmpty() && $shouldSplit(origin, 'last')) {\n      // Split and insert the siblings into the new tree\n      parentCaret.insert($copyElementNode(origin).splice(0, 0, siblings));\n    }\n  }\n  return parentCaret;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGV4aWNhbC9MZXhpY2FsLmRldi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxpQkFBaUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELCtDQUErQztBQUN6RztBQUNBLDhDQUE4Qyw0Q0FBNEM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDLElBQUksaUJBQWlCLEtBQUssZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxtQkFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNCQUFzQixLQUFLLHdCQUF3QjtBQUN2RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGlCQUFpQjtBQUN4RSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGlDQUFpQyxjQUFjLHVCQUF1QixpQkFBaUIsZ0JBQWdCLFVBQVUsY0FBYztBQUMvTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsMERBQTBEO0FBQ2pKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGNBQWMsS0FBSyxxQkFBcUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLGdCQUFnQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQixHQUFHLGdCQUFnQjtBQUN0RSxJQUFJLGdCQUFnQix3Q0FBd0MsZ0JBQWdCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsUUFBUSxJQUFJLHFCQUFxQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHlCQUF5QixrQkFBa0IsVUFBVSxZQUFZLGNBQWMsT0FBTyx3QkFBd0IsT0FBTyxtQkFBbUIsY0FBYyxPQUFPLGdCQUFnQixTQUFTLG1CQUFtQjtBQUN6TTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsSUFBSTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsOEJBQThCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxpREFBaUQsV0FBVztBQUM1RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDRCQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVCQUF1QjtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEMsOEJBQThCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLE1BQU0sMEJBQTBCLEtBQUssOEJBQThCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSxNQUFNLDRCQUE0QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDJDQUEyQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQ0FBMkM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyRUFBMkUsd0JBQXdCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsWUFBWTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU0sVUFBVSxZQUFZLGlDQUFpQyxrQkFBa0I7QUFDaEk7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseURBQXlEO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELEtBQUssS0FBSyxvQ0FBb0MsNEJBQTRCLE1BQU07QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMsTUFBTSwrQkFBK0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHNCQUFzQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHlCQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0QkFBNEIsVUFBVSxxQkFBcUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNEJBQTRCLFVBQVUscUJBQXFCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw0QkFBNEIsVUFBVSxxQkFBcUI7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsTUFBTSxNQUFNLFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLE1BQU0sTUFBTSxXQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNLDRDQUE0QyxzQkFBc0IsSUFBSSxhQUFhO0FBQ3hJO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsK0NBQStDLE1BQU0sTUFBTSxXQUFXO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNLHlDQUF5QyxzQkFBc0IsSUFBSSxhQUFhO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsNEpBQTRKO0FBQ3hPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFIO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnTkFBZ04sMEJBQTBCO0FBQzFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUtBQW1LLDBCQUEwQjtBQUM3TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG1CQUFtQixvQ0FBb0MsWUFBWTtBQUM1RztBQUNBLHlEQUF5RCwyQ0FBMkM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsS0FBSztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdCQUFnQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCx3QkFBd0IsdUJBQXVCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdDQUFnQztBQUN6QztBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsZUFBZSxJQUFJLHFCQUFxQixJQUFJLGdCQUFnQjtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsYUFBYTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHVCQUF1QixxQkFBcUIsS0FBSztBQUN0RjtBQUNBLFVBQVU7QUFDVix1Q0FBdUMsTUFBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsTUFBTSx5QkFBeUIsT0FBTztBQUNwRTtBQUNBLFdBQVc7QUFDWDtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwyQkFBMkI7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDRCQUE0QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQkFBK0I7QUFDM0MsVUFBVSw0QkFBNEI7QUFDdEMsVUFBVSwrQkFBK0I7QUFDekMsVUFBVSw2QkFBNkI7QUFDdkMsVUFBVSxnQ0FBZ0M7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlCQUFpQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scUNBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtEQUFrRCxvQ0FBb0M7QUFDdEY7QUFDQSx1Q0FBdUMsMkJBQTJCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlDQUF5QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBEQUEwRCx5QkFBeUI7QUFDbkYsaUVBQWlFLG1DQUFtQztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsVUFBVTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsdUJBQXVCLFFBQVEsZUFBZSwrQ0FBK0MscUJBQXFCLDZCQUE2QixrQkFBa0I7QUFDOU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHVCQUF1Qiw0RUFBNEUsOEJBQThCO0FBQ2hNO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsK0RBQStELHVCQUF1QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQThDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RixJQUFJO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCLFlBQVksVUFBVTtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEdBQThHLHVCQUF1QixZQUFZLDRCQUE0QixlQUFlLDJCQUEyQixZQUFZLGdDQUFnQyxxQkFBcUIsdUJBQXVCLFlBQVksU0FBUztBQUNwVTtBQUNBLE1BQU07QUFDTjtBQUNBLHVGQUF1RiwyQkFBMkIsWUFBWSxnQ0FBZ0MscUNBQXFDLHVCQUF1QixZQUFZLFNBQVM7QUFDL087QUFDQTtBQUNBO0FBQ0EsNElBQTRJLHVCQUF1QixZQUFZLFVBQVUsVUFBVSwyQkFBMkIsWUFBWSwrQkFBK0I7QUFDelE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLCtCQUErQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxpQkFBaUIsMkJBQTJCLHNCQUFzQjtBQUN2SDtBQUNBO0FBQ0EscURBQXFELGlCQUFpQiwyQkFBMkIsc0JBQXNCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsWUFBWSxRQUFRLFlBQVksbUVBQW1FLHNCQUFzQjtBQUM1SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZLFFBQVEsWUFBWSx3RUFBd0Usc0JBQXNCO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQkFBMEI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsMERBQTBEO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxnSEFBZ0gsb0NBQW9DO0FBQ3BKO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0IsV0FBVyxjQUFjLFNBQVMsZ0JBQWdCO0FBQ3BJLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxrQkFBa0IsZUFBZSxrQkFBa0I7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxRQUFRO0FBQzlEO0FBQ0E7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxnQkFBZ0IsVUFBVSxLQUFLO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGdCQUFnQixVQUFVLEtBQUs7QUFDNUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csaUJBQWlCO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksMERBQTBEO0FBQzlMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0R0FBNEc7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNHpIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9sZXhpY2FsL0xleGljYWwuZGV2Lm1qcz8xZGI4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscy5cblxuZnVuY3Rpb24gZm9ybWF0RGV2RXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBJU19BUFBMRSA9IENBTl9VU0VfRE9NICYmIC9NYWN8aVBvZHxpUGhvbmV8aVBhZC8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pO1xuY29uc3QgSVNfRklSRUZPWCA9IENBTl9VU0VfRE9NICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUID0gQ0FOX1VTRV9ET00gJiYgJ0lucHV0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlID8gJ2dldFRhcmdldFJhbmdlcycgaW4gbmV3IHdpbmRvdy5JbnB1dEV2ZW50KCdpbnB1dCcpIDogZmFsc2U7XG5jb25zdCBJU19TQUZBUkkgPSBDQU5fVVNFX0RPTSAmJiAvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IElTX0lPUyA9IENBTl9VU0VfRE9NICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICF3aW5kb3cuTVNTdHJlYW07XG5jb25zdCBJU19BTkRST0lEID0gQ0FOX1VTRV9ET00gJiYgL0FuZHJvaWQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8vIEtlZXAgdGhlc2UgaW4gY2FzZSB3ZSBuZWVkIHRvIHVzZSB0aGVtIGluIHRoZSBmdXR1cmUuXG4vLyBleHBvcnQgY29uc3QgSVNfV0lORE9XUzogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmIC9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmNvbnN0IElTX0NIUk9NRSA9IENBTl9VU0VfRE9NICYmIC9eKD89LipDaHJvbWUpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuLy8gZXhwb3J0IGNvbnN0IGNhblVzZVRleHRJbnB1dEV2ZW50OiBib29sZWFuID0gQ0FOX1VTRV9ET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGU7XG5cbmNvbnN0IElTX0FORFJPSURfQ0hST01FID0gQ0FOX1VTRV9ET00gJiYgSVNfQU5EUk9JRCAmJiBJU19DSFJPTUU7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBDQU5fVVNFX0RPTSAmJiAvQXBwbGVXZWJLaXRcXC9bXFxkLl0rLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICFJU19DSFJPTUU7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IHJ2YWwgPSBbXTtcbiAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAoY29uc3QgW3NdIG9mIGNsYXNzTmFtZS5tYXRjaEFsbCgvXFxTKy9nKSkge1xuICAgICAgICBydmFsLnB1c2gocyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cblxuLy8gRE9NXG5jb25zdCBET01fRUxFTUVOVF9UWVBFID0gMTtcbmNvbnN0IERPTV9URVhUX1RZUEUgPSAzO1xuY29uc3QgRE9NX0RPQ1VNRU5UX1RZUEUgPSA5O1xuY29uc3QgRE9NX0RPQ1VNRU5UX0ZSQUdNRU5UX1RZUEUgPSAxMTtcblxuLy8gUmVjb25jaWxpbmdcbmNvbnN0IE5PX0RJUlRZX05PREVTID0gMDtcbmNvbnN0IEhBU19ESVJUWV9OT0RFUyA9IDE7XG5jb25zdCBGVUxMX1JFQ09OQ0lMRSA9IDI7XG5cbi8vIFRleHQgbm9kZSBtb2Rlc1xuY29uc3QgSVNfTk9STUFMID0gMDtcbmNvbnN0IElTX1RPS0VOID0gMTtcbmNvbnN0IElTX1NFR01FTlRFRCA9IDI7XG4vLyBJU19JTkVSVCA9IDNcblxuLy8gVGV4dCBub2RlIGZvcm1hdHRpbmdcbmNvbnN0IElTX0JPTEQgPSAxO1xuY29uc3QgSVNfSVRBTElDID0gMSA8PCAxO1xuY29uc3QgSVNfU1RSSUtFVEhST1VHSCA9IDEgPDwgMjtcbmNvbnN0IElTX1VOREVSTElORSA9IDEgPDwgMztcbmNvbnN0IElTX0NPREUgPSAxIDw8IDQ7XG5jb25zdCBJU19TVUJTQ1JJUFQgPSAxIDw8IDU7XG5jb25zdCBJU19TVVBFUlNDUklQVCA9IDEgPDwgNjtcbmNvbnN0IElTX0hJR0hMSUdIVCA9IDEgPDwgNztcbmNvbnN0IElTX0xPV0VSQ0FTRSA9IDEgPDwgODtcbmNvbnN0IElTX1VQUEVSQ0FTRSA9IDEgPDwgOTtcbmNvbnN0IElTX0NBUElUQUxJWkUgPSAxIDw8IDEwO1xuY29uc3QgSVNfQUxMX0ZPUk1BVFRJTkcgPSBJU19CT0xEIHwgSVNfSVRBTElDIHwgSVNfU1RSSUtFVEhST1VHSCB8IElTX1VOREVSTElORSB8IElTX0NPREUgfCBJU19TVUJTQ1JJUFQgfCBJU19TVVBFUlNDUklQVCB8IElTX0hJR0hMSUdIVCB8IElTX0xPV0VSQ0FTRSB8IElTX1VQUEVSQ0FTRSB8IElTX0NBUElUQUxJWkU7XG5cbi8vIFRleHQgbm9kZSBkZXRhaWxzXG5jb25zdCBJU19ESVJFQ1RJT05MRVNTID0gMTtcbmNvbnN0IElTX1VOTUVSR0VBQkxFID0gMSA8PCAxO1xuXG4vLyBFbGVtZW50IG5vZGUgZm9ybWF0dGluZ1xuY29uc3QgSVNfQUxJR05fTEVGVCA9IDE7XG5jb25zdCBJU19BTElHTl9DRU5URVIgPSAyO1xuY29uc3QgSVNfQUxJR05fUklHSFQgPSAzO1xuY29uc3QgSVNfQUxJR05fSlVTVElGWSA9IDQ7XG5jb25zdCBJU19BTElHTl9TVEFSVCA9IDU7XG5jb25zdCBJU19BTElHTl9FTkQgPSA2O1xuXG4vLyBSZWNvbmNpbGlhdGlvblxuY29uc3QgTk9OX0JSRUFLSU5HX1NQQUNFID0gJ1xcdTAwQTAnO1xuY29uc3QgWkVST19XSURUSF9TUEFDRSA9ICdcXHUyMDBiJztcblxuLy8gRm9yIGlPUy9TYWZhcmkgd2UgdXNlIGEgbm9uIGJyZWFraW5nIHNwYWNlLCBvdGhlcndpc2UgdGhlIGN1cnNvciBhcHBlYXJzXG4vLyBvdmVybGFwcGluZyB0aGUgY29tcG9zZWQgdGV4dC5cbmNvbnN0IENPTVBPU0lUSU9OX1NVRkZJWCA9IElTX1NBRkFSSSB8fCBJU19JT1MgfHwgSVNfQVBQTEVfV0VCS0lUID8gTk9OX0JSRUFLSU5HX1NQQUNFIDogWkVST19XSURUSF9TUEFDRTtcbmNvbnN0IERPVUJMRV9MSU5FX0JSRUFLID0gJ1xcblxcbic7XG5cbi8vIEZvciBGRiwgd2UgbmVlZCB0byB1c2UgYSBub24tYnJlYWtpbmcgc3BhY2UsIG9yIGl0IGdldHMgY29tcG9zaXRpb25cbi8vIGluIGEgc3R1Y2sgc3RhdGUuXG5jb25zdCBDT01QT1NJVElPTl9TVEFSVF9DSEFSID0gSVNfRklSRUZPWCA/IE5PTl9CUkVBS0lOR19TUEFDRSA6IENPTVBPU0lUSU9OX1NVRkZJWDtcbmNvbnN0IFJUTCA9ICdcXHUwNTkxLVxcdTA3RkZcXHVGQjFELVxcdUZERkRcXHVGRTcwLVxcdUZFRkMnO1xuY29uc3QgTFRSID0gJ0EtWmEtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNicgKyAnXFx1MDBGOC1cXHUwMkI4XFx1MDMwMC1cXHUwNTkwXFx1MDgwMC1cXHUxRkZGXFx1MjAwRVxcdTJDMDAtXFx1RkIxQycgKyAnXFx1RkUwMC1cXHVGRTZGXFx1RkVGRC1cXHVGRkZGJztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzXG5jb25zdCBSVExfUkVHRVggPSBuZXcgUmVnRXhwKCdeW14nICsgTFRSICsgJ10qWycgKyBSVEwgKyAnXScpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzXG5jb25zdCBMVFJfUkVHRVggPSBuZXcgUmVnRXhwKCdeW14nICsgUlRMICsgJ10qWycgKyBMVFIgKyAnXScpO1xuY29uc3QgVEVYVF9UWVBFX1RPX0ZPUk1BVCA9IHtcbiAgYm9sZDogSVNfQk9MRCxcbiAgY2FwaXRhbGl6ZTogSVNfQ0FQSVRBTElaRSxcbiAgY29kZTogSVNfQ09ERSxcbiAgaGlnaGxpZ2h0OiBJU19ISUdITElHSFQsXG4gIGl0YWxpYzogSVNfSVRBTElDLFxuICBsb3dlcmNhc2U6IElTX0xPV0VSQ0FTRSxcbiAgc3RyaWtldGhyb3VnaDogSVNfU1RSSUtFVEhST1VHSCxcbiAgc3Vic2NyaXB0OiBJU19TVUJTQ1JJUFQsXG4gIHN1cGVyc2NyaXB0OiBJU19TVVBFUlNDUklQVCxcbiAgdW5kZXJsaW5lOiBJU19VTkRFUkxJTkUsXG4gIHVwcGVyY2FzZTogSVNfVVBQRVJDQVNFXG59O1xuY29uc3QgREVUQUlMX1RZUEVfVE9fREVUQUlMID0ge1xuICBkaXJlY3Rpb25sZXNzOiBJU19ESVJFQ1RJT05MRVNTLFxuICB1bm1lcmdlYWJsZTogSVNfVU5NRVJHRUFCTEVcbn07XG5jb25zdCBFTEVNRU5UX1RZUEVfVE9fRk9STUFUID0ge1xuICBjZW50ZXI6IElTX0FMSUdOX0NFTlRFUixcbiAgZW5kOiBJU19BTElHTl9FTkQsXG4gIGp1c3RpZnk6IElTX0FMSUdOX0pVU1RJRlksXG4gIGxlZnQ6IElTX0FMSUdOX0xFRlQsXG4gIHJpZ2h0OiBJU19BTElHTl9SSUdIVCxcbiAgc3RhcnQ6IElTX0FMSUdOX1NUQVJUXG59O1xuY29uc3QgRUxFTUVOVF9GT1JNQVRfVE9fVFlQRSA9IHtcbiAgW0lTX0FMSUdOX0NFTlRFUl06ICdjZW50ZXInLFxuICBbSVNfQUxJR05fRU5EXTogJ2VuZCcsXG4gIFtJU19BTElHTl9KVVNUSUZZXTogJ2p1c3RpZnknLFxuICBbSVNfQUxJR05fTEVGVF06ICdsZWZ0JyxcbiAgW0lTX0FMSUdOX1JJR0hUXTogJ3JpZ2h0JyxcbiAgW0lTX0FMSUdOX1NUQVJUXTogJ3N0YXJ0J1xufTtcbmNvbnN0IFRFWFRfTU9ERV9UT19UWVBFID0ge1xuICBub3JtYWw6IElTX05PUk1BTCxcbiAgc2VnbWVudGVkOiBJU19TRUdNRU5URUQsXG4gIHRva2VuOiBJU19UT0tFTlxufTtcbmNvbnN0IFRFWFRfVFlQRV9UT19NT0RFID0ge1xuICBbSVNfTk9STUFMXTogJ25vcm1hbCcsXG4gIFtJU19TRUdNRU5URURdOiAnc2VnbWVudGVkJyxcbiAgW0lTX1RPS0VOXTogJ3Rva2VuJ1xufTtcbmNvbnN0IE5PREVfU1RBVEVfS0VZID0gJyQnO1xuY29uc3QgUFJPVE9UWVBFX0NPTkZJR19NRVRIT0QgPSAnJGNvbmZpZyc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWNvcmF0b3JzKGVkaXRvciwgcGVuZGluZ0VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gZWRpdG9yLl9kZWNvcmF0b3JzO1xuICBjb25zdCBwZW5kaW5nRGVjb3JhdG9ycyA9IGVkaXRvci5fcGVuZGluZ0RlY29yYXRvcnM7XG4gIGxldCBkZWNvcmF0b3JzID0gcGVuZGluZ0RlY29yYXRvcnMgfHwgY3VycmVudERlY29yYXRvcnM7XG4gIGNvbnN0IG5vZGVNYXAgPSBwZW5kaW5nRWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIGRlY29yYXRvcnMpIHtcbiAgICBpZiAoIW5vZGVNYXAuaGFzKGtleSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzID09PSBjdXJyZW50RGVjb3JhdG9ycykge1xuICAgICAgICBkZWNvcmF0b3JzID0gY2xvbmVEZWNvcmF0b3JzKGVkaXRvcik7XG4gICAgICB9XG4gICAgICBkZWxldGUgZGVjb3JhdG9yc1trZXldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWVwQ2hpbGROb2Rlcyhub2RlLCBwYXJlbnRLZXksIHByZXZOb2RlTWFwLCBub2RlTWFwLCBub2RlTWFwRGVsZXRlLCBkaXJ0eU5vZGVzKSB7XG4gIGxldCBjaGlsZCA9IG5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBjb25zdCBjaGlsZEtleSA9IGNoaWxkLl9fa2V5O1xuICAgIC8vIFRPRE8gUmV2aXNlIGNvbmRpdGlvbiBiZWxvdywgcmVkdW5kYW50PyBMZXhpY2FsTm9kZSBhbHJlYWR5IGNsZWFucyB1cCBjaGlsZHJlbiB3aGVuIG1vdmluZyBOb2Rlc1xuICAgIGlmIChjaGlsZC5fX3BhcmVudCA9PT0gcGFyZW50S2V5KSB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICRnYXJiYWdlQ29sbGVjdERldGFjaGVkRGVlcENoaWxkTm9kZXMoY2hpbGQsIGNoaWxkS2V5LCBwcmV2Tm9kZU1hcCwgbm9kZU1hcCwgbm9kZU1hcERlbGV0ZSwgZGlydHlOb2Rlcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgY3JlYXRlZCBhIG5vZGUgYW5kIGl0IHdhcyBkZXJlZmVyZW5jZWQsIHRoZW4gYWxzb1xuICAgICAgLy8gcmVtb3ZlIGl0IGZyb20gb3V0IGRpcnR5IG5vZGVzIFNldC5cbiAgICAgIGlmICghcHJldk5vZGVNYXAuaGFzKGNoaWxkS2V5KSkge1xuICAgICAgICBkaXJ0eU5vZGVzLmRlbGV0ZShjaGlsZEtleSk7XG4gICAgICB9XG4gICAgICBub2RlTWFwRGVsZXRlLnB1c2goY2hpbGRLZXkpO1xuICAgIH1cbiAgICBjaGlsZCA9IGNoaWxkLmdldE5leHRTaWJsaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRnYXJiYWdlQ29sbGVjdERldGFjaGVkTm9kZXMocHJldkVkaXRvclN0YXRlLCBlZGl0b3JTdGF0ZSwgZGlydHlMZWF2ZXMsIGRpcnR5RWxlbWVudHMpIHtcbiAgY29uc3QgcHJldk5vZGVNYXAgPSBwcmV2RWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IG5vZGVNYXAgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgLy8gU3RvcmUgZGlydHlFbGVtZW50cyBpbiBhIHF1ZXVlIGZvciBsYXRlciBkZWxldGlvbjsgZGVsZXRpbmcgZGlydHkgc3VidHJlZXMgdG9vIGVhcmx5IHdpbGxcbiAgLy8gaGluZGVyIGFjY2Vzc2luZyAuX19uZXh0IG9uIGNoaWxkIG5vZGVzXG4gIGNvbnN0IG5vZGVNYXBEZWxldGUgPSBbXTtcbiAgZm9yIChjb25zdCBbbm9kZUtleV0gb2YgZGlydHlFbGVtZW50cykge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBHYXJiYWdlIGNvbGxlY3Qgbm9kZSBhbmQgaXRzIGNoaWxkcmVuIGlmIHRoZXkgZXhpc3RcbiAgICAgIGlmICghbm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWVwQ2hpbGROb2Rlcyhub2RlLCBub2RlS2V5LCBwcmV2Tm9kZU1hcCwgbm9kZU1hcCwgbm9kZU1hcERlbGV0ZSwgZGlydHlFbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBjcmVhdGVkIGEgbm9kZSBhbmQgaXQgd2FzIGRlcmVmZXJlbmNlZCwgdGhlbiBhbHNvXG4gICAgICAgIC8vIHJlbW92ZSBpdCBmcm9tIG91dCBkaXJ0eSBub2RlcyBTZXQuXG4gICAgICAgIGlmICghcHJldk5vZGVNYXAuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgICAgZGlydHlFbGVtZW50cy5kZWxldGUobm9kZUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZU1hcERlbGV0ZS5wdXNoKG5vZGVLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IG5vZGVLZXkgb2Ygbm9kZU1hcERlbGV0ZSkge1xuICAgIG5vZGVNYXAuZGVsZXRlKG5vZGVLZXkpO1xuICB9XG4gIGZvciAoY29uc3Qgbm9kZUtleSBvZiBkaXJ0eUxlYXZlcykge1xuICAgIGNvbnN0IG5vZGUgPSBub2RlTWFwLmdldChub2RlS2V5KTtcbiAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmICFub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgaWYgKCFwcmV2Tm9kZU1hcC5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgZGlydHlMZWF2ZXMuZGVsZXRlKG5vZGVLZXkpO1xuICAgICAgfVxuICAgICAgbm9kZU1hcC5kZWxldGUobm9kZUtleSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLy8gVGhlIHRpbWUgYmV0d2VlbiBhIHRleHQgZW50cnkgZXZlbnQgYW5kIHRoZSBtdXRhdGlvbiBvYnNlcnZlciBmaXJpbmcuXG5jb25zdCBURVhUX01VVEFUSU9OX1ZBUklBTkNFID0gMTAwO1xubGV0IGlzUHJvY2Vzc2luZ011dGF0aW9ucyA9IGZhbHNlO1xubGV0IGxhc3RUZXh0RW50cnlUaW1lU3RhbXAgPSAwO1xuZnVuY3Rpb24gZ2V0SXNQcm9jZXNzaW5nTXV0YXRpb25zKCkge1xuICByZXR1cm4gaXNQcm9jZXNzaW5nTXV0YXRpb25zO1xufVxuZnVuY3Rpb24gdXBkYXRlVGltZVN0YW1wKGV2ZW50KSB7XG4gIGxhc3RUZXh0RW50cnlUaW1lU3RhbXAgPSBldmVudC50aW1lU3RhbXA7XG59XG5mdW5jdGlvbiBpbml0VGV4dEVudHJ5TGlzdGVuZXIoZWRpdG9yKSB7XG4gIGlmIChsYXN0VGV4dEVudHJ5VGltZVN0YW1wID09PSAwKSB7XG4gICAgZ2V0V2luZG93KGVkaXRvcikuYWRkRXZlbnRMaXN0ZW5lcigndGV4dElucHV0JywgdXBkYXRlVGltZVN0YW1wLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNNYW5hZ2VkTGluZUJyZWFrKGRvbSwgdGFyZ2V0LCBlZGl0b3IpIHtcbiAgY29uc3QgaXNCUiA9IGRvbS5ub2RlTmFtZSA9PT0gJ0JSJztcbiAgY29uc3QgbGV4aWNhbExpbmVCcmVhayA9IHRhcmdldC5fX2xleGljYWxMaW5lQnJlYWs7XG4gIHJldHVybiBsZXhpY2FsTGluZUJyZWFrICYmIChkb20gPT09IGxleGljYWxMaW5lQnJlYWsgfHwgaXNCUiAmJiBkb20ucHJldmlvdXNTaWJsaW5nID09PSBsZXhpY2FsTGluZUJyZWFrKSB8fCBpc0JSICYmIGdldE5vZGVLZXlGcm9tRE9NTm9kZShkb20sIGVkaXRvcikgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGdldExhc3RTZWxlY3Rpb24oZWRpdG9yKSB7XG4gIHJldHVybiBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbiAhPT0gbnVsbCA/IHNlbGVjdGlvbi5jbG9uZSgpIDogbnVsbDtcbiAgfSk7XG59XG5mdW5jdGlvbiAkaGFuZGxlVGV4dE11dGF0aW9uKHRhcmdldCwgbm9kZSwgZWRpdG9yKSB7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihnZXRXaW5kb3coZWRpdG9yKSk7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBudWxsO1xuICBsZXQgZm9jdXNPZmZzZXQgPSBudWxsO1xuICBpZiAoZG9tU2VsZWN0aW9uICE9PSBudWxsICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSB0YXJnZXQpIHtcbiAgICBhbmNob3JPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICAgIGZvY3VzT2Zmc2V0ID0gZG9tU2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuICB9XG4gIGNvbnN0IHRleHQgPSB0YXJnZXQubm9kZVZhbHVlO1xuICBpZiAodGV4dCAhPT0gbnVsbCkge1xuICAgICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KG5vZGUsIHRleHQsIGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQsIGZhbHNlKTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkVXBkYXRlVGV4dE5vZGVGcm9tTXV0YXRpb24oc2VsZWN0aW9uLCB0YXJnZXRET00sIHRhcmdldE5vZGUpIHtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgaWYgKGFuY2hvck5vZGUuaXModGFyZ2V0Tm9kZSkgJiYgc2VsZWN0aW9uLmZvcm1hdCAhPT0gYW5jaG9yTm9kZS5nZXRGb3JtYXQoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaXNET01UZXh0Tm9kZSh0YXJnZXRET00pICYmIHRhcmdldE5vZGUuaXNBdHRhY2hlZCgpO1xufVxuZnVuY3Rpb24gJGdldE5lYXJlc3RNYW5hZ2VkTm9kZVBhaXJGcm9tRE9NTm9kZShzdGFydGluZ0RPTSwgZWRpdG9yLCBlZGl0b3JTdGF0ZSwgcm9vdEVsZW1lbnQpIHtcbiAgZm9yIChsZXQgZG9tID0gc3RhcnRpbmdET007IGRvbSAmJiAhaXNET01Vbm1hbmFnZWQoZG9tKTsgZG9tID0gZ2V0UGFyZW50RWxlbWVudChkb20pKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0Tm9kZUtleUZyb21ET01Ob2RlKGRvbSwgZWRpdG9yKTtcbiAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGtleSwgZWRpdG9yU3RhdGUpO1xuICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgLy8gQWxsIGRlY29yYXRvciBub2RlcyBhcmUgdW5tYW5hZ2VkXG4gICAgICAgIHJldHVybiAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpIHx8ICFpc0hUTUxFbGVtZW50KGRvbSkgPyB1bmRlZmluZWQgOiBbZG9tLCBub2RlXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRvbSA9PT0gcm9vdEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBbcm9vdEVsZW1lbnQsIGludGVybmFsR2V0Um9vdChlZGl0b3JTdGF0ZSldO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hNdXRhdGlvbnMoZWRpdG9yLCBtdXRhdGlvbnMsIG9ic2VydmVyKSB7XG4gIGlzUHJvY2Vzc2luZ011dGF0aW9ucyA9IHRydWU7XG4gIGNvbnN0IHNob3VsZEZsdXNoVGV4dE11dGF0aW9ucyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gbGFzdFRleHRFbnRyeVRpbWVTdGFtcCA+IFRFWFRfTVVUQVRJT05fVkFSSUFOQ0U7XG4gIHRyeSB7XG4gICAgdXBkYXRlRWRpdG9yU3luYyhlZGl0b3IsICgpID0+IHtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSB8fCBnZXRMYXN0U2VsZWN0aW9uKGVkaXRvcik7XG4gICAgICBjb25zdCBiYWRET01UYXJnZXRzID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICAgIC8vIFdlIHVzZSB0aGUgY3VycmVudCBlZGl0b3Igc3RhdGUsIGFzIHRoYXQgcmVmbGVjdHMgd2hhdCBpc1xuICAgICAgLy8gYWN0dWFsbHkgXCJvbiBzY3JlZW5cIi5cbiAgICAgIGNvbnN0IGN1cnJlbnRFZGl0b3JTdGF0ZSA9IGVkaXRvci5fZWRpdG9yU3RhdGU7XG4gICAgICBjb25zdCBibG9ja0N1cnNvckVsZW1lbnQgPSBlZGl0b3IuX2Jsb2NrQ3Vyc29yRWxlbWVudDtcbiAgICAgIGxldCBzaG91bGRSZXZlcnRTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgIGxldCBwb3NzaWJsZVRleHRGb3JGaXJlZm94UGFzdGUgPSAnJztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uID0gbXV0YXRpb25zW2ldO1xuICAgICAgICBjb25zdCB0eXBlID0gbXV0YXRpb24udHlwZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0RE9NID0gbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBwYWlyID0gJGdldE5lYXJlc3RNYW5hZ2VkTm9kZVBhaXJGcm9tRE9NTm9kZSh0YXJnZXRET00sIGVkaXRvciwgY3VycmVudEVkaXRvclN0YXRlLCByb290RWxlbWVudCk7XG4gICAgICAgIGlmICghcGFpcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtub2RlRE9NLCB0YXJnZXROb2RlXSA9IHBhaXI7XG4gICAgICAgIGlmICh0eXBlID09PSAnY2hhcmFjdGVyRGF0YScpIHtcbiAgICAgICAgICAvLyBUZXh0IG11dGF0aW9ucyBhcmUgZGVmZXJyZWQgYW5kIHBhc3NlZCB0byBtdXRhdGlvbiBsaXN0ZW5lcnMgdG8gYmVcbiAgICAgICAgICAvLyBwcm9jZXNzZWQgb3V0c2lkZSBvZiB0aGUgTGV4aWNhbCBlbmdpbmUuXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIFRPRE8gdGhlcmUgaXMgYW4gZWRnZSBjYXNlIGhlcmUgaWYgYSBtdXRhdGlvbiBoYXBwZW5zIHRvbyBxdWlja2x5XG4gICAgICAgICAgLy8gICAgICBhZnRlciB0ZXh0IGlucHV0LCBpdCBtYXkgbmV2ZXIgYmUgaGFuZGxlZCBzaW5jZSB3ZSBkbyBub3RcbiAgICAgICAgICAvLyAgICAgIHRyYWNrIHRoZSBpZ25vcmVkIG11dGF0aW9ucyBpbiBhbnkgd2F5XG4gICAgICAgICAgc2hvdWxkRmx1c2hUZXh0TXV0YXRpb25zICYmICRpc1RleHROb2RlKHRhcmdldE5vZGUpICYmIGlzRE9NVGV4dE5vZGUodGFyZ2V0RE9NKSAmJiBzaG91bGRVcGRhdGVUZXh0Tm9kZUZyb21NdXRhdGlvbihzZWxlY3Rpb24sIHRhcmdldERPTSwgdGFyZ2V0Tm9kZSkpIHtcbiAgICAgICAgICAgICRoYW5kbGVUZXh0TXV0YXRpb24odGFyZ2V0RE9NLCB0YXJnZXROb2RlLCBlZGl0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgIHNob3VsZFJldmVydFNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgLy8gV2UgYXR0ZW1wdCB0byBcInVuZG9cIiBhbnkgY2hhbmdlcyB0aGF0IGhhdmUgb2NjdXJyZWQgb3V0c2lkZVxuICAgICAgICAgIC8vIG9mIExleGljYWwuIFdlIHdhbnQgTGV4aWNhbCdzIGVkaXRvciBzdGF0ZSB0byBiZSBzb3VyY2Ugb2YgdHJ1dGguXG4gICAgICAgICAgLy8gVG8gdGhlIHVzZXIsIHRoZXNlIHdpbGwgbG9vayBsaWtlIG5vLW9wcy5cbiAgICAgICAgICBjb25zdCBhZGRlZERPTXMgPSBtdXRhdGlvbi5hZGRlZE5vZGVzO1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYWRkZWRET01zLmxlbmd0aDsgcysrKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRlZERPTSA9IGFkZGVkRE9Nc1tzXTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUZyb21ET01Ob2RlKGFkZGVkRE9NKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudERPTSA9IGFkZGVkRE9NLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAocGFyZW50RE9NICE9IG51bGwgJiYgYWRkZWRET00gIT09IGJsb2NrQ3Vyc29yRWxlbWVudCAmJiBub2RlID09PSBudWxsICYmICFpc01hbmFnZWRMaW5lQnJlYWsoYWRkZWRET00sIHBhcmVudERPTSwgZWRpdG9yKSkge1xuICAgICAgICAgICAgICBpZiAoSVNfRklSRUZPWCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlVGV4dCA9IChpc0hUTUxFbGVtZW50KGFkZGVkRE9NKSA/IGFkZGVkRE9NLmlubmVyVGV4dCA6IG51bGwpIHx8IGFkZGVkRE9NLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocG9zc2libGVUZXh0KSB7XG4gICAgICAgICAgICAgICAgICBwb3NzaWJsZVRleHRGb3JGaXJlZm94UGFzdGUgKz0gcG9zc2libGVUZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXJlbnRET00ucmVtb3ZlQ2hpbGQoYWRkZWRET00pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCByZW1vdmVkRE9NcyA9IG11dGF0aW9uLnJlbW92ZWROb2RlcztcbiAgICAgICAgICBjb25zdCByZW1vdmVkRE9Nc0xlbmd0aCA9IHJlbW92ZWRET01zLmxlbmd0aDtcbiAgICAgICAgICBpZiAocmVtb3ZlZERPTXNMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgdW5yZW1vdmVkQlJzID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgcmVtb3ZlZERPTXNMZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgICBjb25zdCByZW1vdmVkRE9NID0gcmVtb3ZlZERPTXNbc107XG4gICAgICAgICAgICAgIGlmIChpc01hbmFnZWRMaW5lQnJlYWsocmVtb3ZlZERPTSwgdGFyZ2V0RE9NLCBlZGl0b3IpIHx8IGJsb2NrQ3Vyc29yRWxlbWVudCA9PT0gcmVtb3ZlZERPTSkge1xuICAgICAgICAgICAgICAgIHRhcmdldERPTS5hcHBlbmRDaGlsZChyZW1vdmVkRE9NKTtcbiAgICAgICAgICAgICAgICB1bnJlbW92ZWRCUnMrKztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbW92ZWRET01zTGVuZ3RoICE9PSB1bnJlbW92ZWRCUnMpIHtcbiAgICAgICAgICAgICAgYmFkRE9NVGFyZ2V0cy5zZXQobm9kZURPTSwgdGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyB3ZSBwcm9jZXNzIGVhY2ggb2YgdGhlIHVuaXF1ZSB0YXJnZXQgbm9kZXMsIGF0dGVtcHRpbmdcbiAgICAgIC8vIHRvIHJlc3RvcmUgdGhlaXIgY29udGVudHMgYmFjayB0byB0aGUgc291cmNlIG9mIHRydXRoLCB3aGljaFxuICAgICAgLy8gaXMgTGV4aWNhbCdzIFwiY3VycmVudFwiIGVkaXRvciBzdGF0ZS4gVGhpcyBpcyBiYXNpY2FsbHkgbGlrZVxuICAgICAgLy8gYW4gaW50ZXJuYWwgcmV2ZXJ0IG9uIHRoZSBET00uXG4gICAgICBpZiAoYmFkRE9NVGFyZ2V0cy5zaXplID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtub2RlRE9NLCB0YXJnZXROb2RlXSBvZiBiYWRET01UYXJnZXRzKSB7XG4gICAgICAgICAgdGFyZ2V0Tm9kZS5yZWNvbmNpbGVPYnNlcnZlZE11dGF0aW9uKG5vZGVET00sIGVkaXRvcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2FwdHVyZSBhbGwgdGhlIG11dGF0aW9ucyBtYWRlIGR1cmluZyB0aGlzIGZ1bmN0aW9uLiBUaGlzXG4gICAgICAvLyBhbHNvIHByZXZlbnRzIHVzIGhhdmluZyB0byBwcm9jZXNzIHRoZW0gb24gdGhlIG5leHQgY3ljbGVcbiAgICAgIC8vIG9mIG9uTXV0YXRpb24sIGFzIHRoZXNlIG11dGF0aW9ucyB3ZXJlIG1hZGUgYnkgdXMuXG4gICAgICBjb25zdCByZWNvcmRzID0gb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcblxuICAgICAgLy8gQ2hlY2sgZm9yIGFueSByYW5kb20gYXV0by1hZGRlZCA8YnI+IGVsZW1lbnRzLCBhbmQgcmVtb3ZlIHRoZW0uXG4gICAgICAvLyBUaGVzZSBnZXQgYWRkZWQgYnkgdGhlIGJyb3dzZXIgd2hlbiB3ZSB1bmRvIHRoZSBhYm92ZSBtdXRhdGlvbnNcbiAgICAgIC8vIGFuZCB0aGlzIGNhbiBsZWFkIHRvIGEgYnJva2VuIFVJLlxuICAgICAgaWYgKHJlY29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgIGNvbnN0IGFkZGVkTm9kZXMgPSByZWNvcmQuYWRkZWROb2RlcztcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSByZWNvcmQudGFyZ2V0O1xuICAgICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgYWRkZWROb2Rlcy5sZW5ndGg7IHMrKykge1xuICAgICAgICAgICAgY29uc3QgYWRkZWRET00gPSBhZGRlZE5vZGVzW3NdO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RE9NID0gYWRkZWRET00ucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRET00gIT0gbnVsbCAmJiBhZGRlZERPTS5ub2RlTmFtZSA9PT0gJ0JSJyAmJiAhaXNNYW5hZ2VkTGluZUJyZWFrKGFkZGVkRE9NLCB0YXJnZXQsIGVkaXRvcikpIHtcbiAgICAgICAgICAgICAgcGFyZW50RE9NLnJlbW92ZUNoaWxkKGFkZGVkRE9NKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhciBhbnkgb2YgdGhvc2UgcmVtb3ZhbCBtdXRhdGlvbnNcbiAgICAgICAgb2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFJldmVydFNlbGVjdGlvbikge1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSVNfRklSRUZPWCAmJiBpc0ZpcmVmb3hDbGlwYm9hcmRFdmVudHMoZWRpdG9yKSkge1xuICAgICAgICAgIHNlbGVjdGlvbi5pbnNlcnRSYXdUZXh0KHBvc3NpYmxlVGV4dEZvckZpcmVmb3hQYXN0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpc1Byb2Nlc3NpbmdNdXRhdGlvbnMgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hSb290TXV0YXRpb25zKGVkaXRvcikge1xuICBjb25zdCBvYnNlcnZlciA9IGVkaXRvci5fb2JzZXJ2ZXI7XG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG11dGF0aW9ucyA9IG9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgZmx1c2hNdXRhdGlvbnMoZWRpdG9yLCBtdXRhdGlvbnMsIG9ic2VydmVyKTtcbiAgfVxufVxuZnVuY3Rpb24gaW5pdE11dGF0aW9uT2JzZXJ2ZXIoZWRpdG9yKSB7XG4gIGluaXRUZXh0RW50cnlMaXN0ZW5lcihlZGl0b3IpO1xuICBlZGl0b3IuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucywgb2JzZXJ2ZXIpID0+IHtcbiAgICBmbHVzaE11dGF0aW9ucyhlZGl0b3IsIG11dGF0aW9ucywgb2JzZXJ2ZXIpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIHR5cGUgKFYpIGZyb20gYSBTdGF0ZUNvbmZpZ1xuICovXG5cbi8qKlxuICogR2V0IHRoZSBrZXkgdHlwZSAoSykgZnJvbSBhIFN0YXRlQ29uZmlnXG4gKi9cblxuLyoqXG4gKiBBIHZhbHVlIHR5cGUsIG9yIGFuIHVwZGF0ZXIgZm9yIHRoYXQgdmFsdWUgdHlwZS4gRm9yIHVzZSB3aXRoXG4gKiB7QGxpbmsgJHNldFN0YXRlfSBvciBhbnkgdXNlci1kZWZpbmVkIHdyYXBwZXJzIGFyb3VuZCBpdC5cbiAqL1xuXG4vKipcbiAqIEEgdHlwZSBhbGlhcyB0byBtYWtlIGl0IGVhc2llciB0byBkZWZpbmUgc2V0dGVyIG1ldGhvZHMgb24geW91ciBub2RlIGNsYXNzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBmb29TdGF0ZSA9IGNyZWF0ZVN0YXRlKFwiZm9vXCIsIHsgcGFyc2U6IC4uLiB9KTtcbiAqIGNsYXNzIE15Q2xhc3MgZXh0ZW5kcyBUZXh0Tm9kZSB7XG4gKiAgIC8vIC4uLlxuICogICBzZXRGb28odmFsdWVPclVwZGF0ZXI6IFN0YXRlVmFsdWVPclVwZGF0ZXI8dHlwZW9mIGZvb1N0YXRlPik6IHRoaXMge1xuICogICAgIHJldHVybiAkc2V0U3RhdGUodGhpcywgZm9vU3RhdGUsIHZhbHVlT3JVcGRhdGVyKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHlwZXNcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuXG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cblxuLyoqXG4gKiBUaGUgTm9kZVN0YXRlIEpTT04gcHJvZHVjZWQgYnkgdGhpcyBMZXhpY2FsTm9kZVxuICovXG5cbi8qKlxuICogQ29uZmlndXJlIGEgdmFsdWUgdG8gYmUgdXNlZCB3aXRoIFN0YXRlQ29uZmlnLlxuICpcbiAqIFRoZSB2YWx1ZSB0eXBlIHNob3VsZCBiZSBpbmZlcnJlZCBmcm9tIHRoZSBkZWZpbml0aW9uIG9mIHBhcnNlLlxuICpcbiAqIElmIHRoZSB2YWx1ZSB0eXBlIGlzIG5vdCBKU09OIHNlcmlhbGl6YWJsZSwgdGhlbiB1bnBhcnNlIG11c3QgYWxzbyBiZSBwcm92aWRlZC5cbiAqXG4gKiBWYWx1ZXMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgaW1tdXRhYmxlLCBtdWNoIGxpa2UgUmVhY3QudXNlU3RhdGUuIE11dGF0aW5nXG4gKiBzdG9yZWQgdmFsdWVzIGRpcmVjdGx5IHdpbGwgY2F1c2UgdW5wcmVkaWN0YWJsZSBiZWhhdmlvciwgaXMgbm90IHN1cHBvcnRlZCxcbiAqIGFuZCBtYXkgdHJpZ2dlciBlcnJvcnMgaW4gdGhlIGZ1dHVyZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IG51bWJlck9yTnVsbFN0YXRlID0gY3JlYXRlU3RhdGUoJ251bWJlck9yTnVsbCcsIHtwYXJzZTogKHYpID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/IHYgOiBudWxsfSk7XG4gKiAvLyAgICBePyBTdGF0ZTwnbnVtYmVyT3JOdWxsJywgU3RhdGVWYWx1ZUNvbmZpZzxudW1iZXIgfCBudWxsPj5cbiAqIGNvbnN0IG51bWJlclN0YXRlID0gY3JlYXRlU3RhdGUoJ251bWJlcicsIHtwYXJzZTogKHYpID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyA/IHYgOiAwfSk7XG4gKiAvLyAgICBePyBTdGF0ZTwnbnVtYmVyJywgU3RhdGVWYWx1ZUNvbmZpZzxudW1iZXI+PlxuICogYGBgXG4gKlxuICogT25seSB0aGUgcGFyc2Ugb3B0aW9uIGlzIHJlcXVpcmVkLCBpdCBpcyBnZW5lcmFsbHkgbm90IHVzZWZ1bCB0b1xuICogb3ZlcnJpZGUgYHVucGFyc2VgIG9yIGBpc0VxdWFsYC4gSG93ZXZlciwgaWYgeW91IGFyZSB1c2luZ1xuICogbm9uLXByaW1pdGl2ZSB0eXBlcyBzdWNoIGFzIEFycmF5LCBPYmplY3QsIERhdGUsIG9yIHNvbWV0aGluZ1xuICogbW9yZSBleG90aWMgdGhlbiB5b3Ugd291bGQgd2FudCB0byBvdmVycmlkZSB0aGlzLiBJbiB0aGVzZVxuICogY2FzZXMgeW91IG1pZ2h0IHdhbnQgdG8gcmVhY2ggZm9yIHRoaXJkIHBhcnR5IGxpYnJhcmllcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGlzb0RhdGVTdGF0ZSA9IGNyZWF0ZVN0YXRlKCdpc29EYXRlJywge1xuICogICBwYXJzZTogKHYpOiBudWxsIHwgRGF0ZSA9PiB7XG4gKiAgICAgY29uc3QgZGF0ZSA9IHR5cGVvZiB2ID09PSAnc3RyaW5nJyA/IG5ldyBEYXRlKHYpIDogbnVsbDtcbiAqICAgICByZXR1cm4gZGF0ZSAmJiAhaXNOYU4oZGF0ZS52YWx1ZU9mKCkpID8gZGF0ZSA6IG51bGw7XG4gKiAgIH1cbiAqICAgaXNFcXVhbDogKGEsIGIpID0+IGEgPT09IGIgfHwgKGEgJiYgYiAmJiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCkpLFxuICogICB1bnBhcnNlOiAodikgPT4gdiAmJiB2LnRvU3RyaW5nKClcbiAqIH0pO1xuICogYGBgXG4gKlxuICogWW91IG1heSBmaW5kIGl0IGVhc2llciB0byB3cml0ZSBhIHBhcnNlIGZ1bmN0aW9uIHVzaW5nIGxpYnJhcmllcyBsaWtlXG4gKiB6b2QsIHZhbGlib3QsIGFqdiwgRWZmZWN0LCBUeXBlQm94LCBldGMuIHBlcmhhcHMgd2l0aCBhIHdyYXBwZXIgZnVuY3Rpb24uXG4gKi9cblxuLyoqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHtAbGluayBjcmVhdGVTdGF0ZX0sIGZvciB1c2Ugd2l0aFxuICoge0BsaW5rICRnZXRTdGF0ZX0gYW5kIHtAbGluayAkc2V0U3RhdGV9LlxuICovXG5jbGFzcyBTdGF0ZUNvbmZpZyB7XG4gIC8qKiBUaGUgc3RyaW5nIGtleSB1c2VkIHdoZW4gc2VyaWFsaXppbmcgdGhpcyBzdGF0ZSB0byBKU09OICovXG5cbiAgLyoqIFRoZSBwYXJzZSBmdW5jdGlvbiBmcm9tIHRoZSBTdGF0ZVZhbHVlQ29uZmlnIHBhc3NlZCB0byBjcmVhdGVTdGF0ZSAqL1xuXG4gIC8qKlxuICAgKiBUaGUgdW5wYXJzZSBmdW5jdGlvbiBmcm9tIHRoZSBTdGF0ZVZhbHVlQ29uZmlnIHBhc3NlZCB0byBjcmVhdGVTdGF0ZSxcbiAgICogd2l0aCBhIGRlZmF1bHQgdGhhdCBpcyBzaW1wbHkgYSBwYXNzLXRocm91Z2ggdGhhdCBhc3N1bWVzIHRoZSB2YWx1ZSBpc1xuICAgKiBKU09OIHNlcmlhbGl6YWJsZS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFuIGVxdWFsaXR5IGZ1bmN0aW9uIGZyb20gdGhlIFN0YXRlVmFsdWVDb25maWcsIHdpdGggYSBkZWZhdWx0IG9mXG4gICAqIE9iamVjdC5pcy5cbiAgICovXG5cbiAgLyoqXG4gICAqIFRoZSByZXN1bHQgb2YgYHN0YXRlVmFsdWVDb25maWcucGFyc2UodW5kZWZpbmVkKWAsIHdoaWNoIGlzIGNvbXB1dGVkIG9ubHlcbiAgICogb25jZSBhbmQgdXNlZCBhcyB0aGUgZGVmYXVsdCB2YWx1ZS4gV2hlbiB0aGUgY3VycmVudCB2YWx1ZSBgaXNFcXVhbGAgdG9cbiAgICogdGhlIGBkZWZhdWx0VmFsdWVgLCBpdCB3aWxsIG5vdCBiZSBzZXJpYWxpemVkIHRvIEpTT04uXG4gICAqL1xuXG4gIGNvbnN0cnVjdG9yKGtleSwgc3RhdGVWYWx1ZUNvbmZpZykge1xuICAgIHRoaXMua2V5ID0ga2V5O1xuICAgIHRoaXMucGFyc2UgPSBzdGF0ZVZhbHVlQ29uZmlnLnBhcnNlLmJpbmQoc3RhdGVWYWx1ZUNvbmZpZyk7XG4gICAgdGhpcy51bnBhcnNlID0gKHN0YXRlVmFsdWVDb25maWcudW5wYXJzZSB8fCBjb2VyY2VUb0pTT04pLmJpbmQoc3RhdGVWYWx1ZUNvbmZpZyk7XG4gICAgdGhpcy5pc0VxdWFsID0gKHN0YXRlVmFsdWVDb25maWcuaXNFcXVhbCB8fCBPYmplY3QuaXMpLmJpbmQoc3RhdGVWYWx1ZUNvbmZpZyk7XG4gICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB0aGlzLnBhcnNlKHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYWR2YW5jZWQgdXNlIGNhc2VzLCB1c2luZyB0aGlzIHR5cGUgaXMgbm90IHJlY29tbWVuZGVkIHVubGVzc1xuICogaXQgaXMgcmVxdWlyZWQgKGR1ZSB0byBUeXBlU2NyaXB0J3MgbGFjayBvZiBmZWF0dXJlcyBsaWtlXG4gKiBoaWdoZXIta2luZGVkIHR5cGVzKS5cbiAqXG4gKiBBIHtAbGluayBTdGF0ZUNvbmZpZ30gdHlwZSB3aXRoIGFueSBrZXkgYW5kIGFueSB2YWx1ZSB0aGF0IGNhbiBiZVxuICogdXNlZCBpbiBzaXR1YXRpb25zIHdoZXJlIHRoZSBrZXkgYW5kIHZhbHVlIHR5cGUgY2FuIG5vdCBiZSBrbm93bixcbiAqIHN1Y2ggYXMgaW4gYSBnZW5lcmljIGNvbnN0cmFpbnQgd2hlbiB3b3JraW5nIHdpdGggYSBjb2xsZWN0aW9uIG9mXG4gKiBTdGF0ZUNvbmZpZy5cbiAqXG4gKiB7QGxpbmsgU3RhdGVDb25maWdLZXl9IGFuZCB7QGxpbmsgU3RhdGVDb25maWdWYWx1ZX0gd2lsbCBiZVxuICogdXNlZnVsIHdoZW4gdGhpcyBpcyB1c2VkIGFzIGEgZ2VuZXJpYyBjb25zdHJhaW50LlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIENyZWF0ZSBhIFN0YXRlQ29uZmlnIGZvciB0aGUgZ2l2ZW4gc3RyaW5nIGtleSBhbmQgU3RhdGVWYWx1ZUNvbmZpZy5cbiAqXG4gKiBUaGUga2V5IG11c3QgYmUgbG9jYWxseSB1bmlxdWUuIEluIGRldiB5b3Ugd2lsbCBnZXQgYSBrZXkgY29sbGlzaW9uIGVycm9yXG4gKiB3aGVuIHlvdSB1c2UgdHdvIHNlcGFyYXRlIFN0YXRlQ29uZmlnIG9uIHRoZSBzYW1lIG5vZGUgd2l0aCB0aGUgc2FtZSBrZXkuXG4gKlxuICogVGhlIHJldHVybmVkIFN0YXRlQ29uZmlnIHZhbHVlIHNob3VsZCBiZSB1c2VkIHdpdGgge0BsaW5rICRnZXRTdGF0ZX0gYW5kXG4gKiB7QGxpbmsgJHNldFN0YXRlfS5cbiAqXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgdG8gdXNlXG4gKiBAcGFyYW0gdmFsdWVDb25maWcgQ29uZmlndXJhdGlvbiBmb3IgdGhlIHZhbHVlIHR5cGVcbiAqIEByZXR1cm5zIGEgU3RhdGVDb25maWdcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3RhdGUoa2V5LCB2YWx1ZUNvbmZpZykge1xuICByZXR1cm4gbmV3IFN0YXRlQ29uZmlnKGtleSwgdmFsdWVDb25maWcpO1xufVxuXG4vKipcbiAqIFRoZSBhY2Nlc3NvciBmb3Igd29ya2luZyB3aXRoIG5vZGUgc3RhdGUuIFRoaXMgd2lsbCByZWFkIHRoZSB2YWx1ZSBmb3IgdGhlXG4gKiBzdGF0ZSBvbiB0aGUgZ2l2ZW4gbm9kZSwgYW5kIHdpbGwgcmV0dXJuIGBzdGF0ZUNvbmZpZy5kZWZhdWx0VmFsdWVgIGlmIHRoZVxuICogc3RhdGUgaGFzIG5ldmVyIGJlZW4gc2V0IG9uIHRoaXMgbm9kZS5cbiAqXG4gKiBUaGUgYHZlcnNpb25gIHBhcmFtZXRlciBpcyBvcHRpb25hbCBhbmQgc2hvdWxkIGdlbmVyYWxseSBiZSBgJ2xhdGVzdCdgLFxuICogY29uc2lzdGVudCB3aXRoIHRoZSBiZWhhdmlvciBvZiBvdGhlciBub2RlIG1ldGhvZHMgYW5kIGZ1bmN0aW9ucyxcbiAqIGJ1dCBmb3IgY2VydGFpbiB1c2UgY2FzZXMgc3VjaCBhcyBgdXBkYXRlRE9NYCB5b3UgbWF5IGhhdmUgYSBuZWVkIHRvXG4gKiB1c2UgYCdkaXJlY3QnYCB0byByZWFkIHRoZSBzdGF0ZSBmcm9tIGEgcHJldmlvdXMgdmVyc2lvbiBvZiB0aGUgbm9kZS5cbiAqXG4gKiBGb3IgdmVyeSBhZHZhbmNlZCB1c2UgY2FzZXMsIHlvdSBjYW4gZXhwZWN0IHRoYXQgJ2RpcmVjdCcgZG9lcyBub3RcbiAqIHJlcXVpcmUgYW4gZWRpdG9yIHN0YXRlLCBqdXN0IGxpa2UgZGlyZWN0bHkgYWNjZXNzaW5nIG90aGVyIHByb3BlcnRpZXNcbiAqIG9mIGEgbm9kZSB3aXRob3V0IGFuIGFjY2Vzc29yIChlLmcuIGB0ZXh0Tm9kZS5fX3RleHRgKS5cbiAqXG4gKiBAcGFyYW0gbm9kZSBBbnkgTGV4aWNhbE5vZGVcbiAqIEBwYXJhbSBzdGF0ZUNvbmZpZyBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgc3RhdGUgdG8gcmVhZFxuICogQHBhcmFtIHZlcnNpb24gVGhlIGRlZmF1bHQgdmFsdWUgJ2xhdGVzdCcgd2lsbCByZWFkIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiB0aGUgbm9kZSBzdGF0ZSwgJ2RpcmVjdCcgd2lsbCByZWFkIHRoZSB2ZXJzaW9uIHRoYXQgaXMgc3RvcmVkIG9uIHRoaXMgTGV4aWNhbE5vZGUgd2hpY2ggbm90IHJlZmxlY3QgdGhlIHZlcnNpb24gdXNlZCBpbiB0aGUgY3VycmVudCBlZGl0b3Igc3RhdGVcbiAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHZhbHVlIGZyb20gdGhlIHN0YXRlLCBvciB0aGUgZGVmYXVsdCB2YWx1ZSBwcm92aWRlZCBieSB0aGUgY29uZmlndXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gJGdldFN0YXRlKG5vZGUsIHN0YXRlQ29uZmlnLCB2ZXJzaW9uID0gJ2xhdGVzdCcpIHtcbiAgY29uc3QgbGF0ZXN0T3JEaXJlY3ROb2RlID0gdmVyc2lvbiA9PT0gJ2xhdGVzdCcgPyBub2RlLmdldExhdGVzdCgpIDogbm9kZTtcbiAgY29uc3Qgc3RhdGUgPSBsYXRlc3RPckRpcmVjdE5vZGUuX19zdGF0ZTtcbiAgaWYgKHN0YXRlKSB7XG4gICAgJGNoZWNrQ29sbGlzaW9uKG5vZGUsIHN0YXRlQ29uZmlnLCBzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlLmdldFZhbHVlKHN0YXRlQ29uZmlnKTtcbiAgfVxuICByZXR1cm4gc3RhdGVDb25maWcuZGVmYXVsdFZhbHVlO1xufVxuXG4vKipcbiAqIEdpdmVuIHR3byB2ZXJzaW9ucyBvZiBhIG5vZGUgYW5kIGEgc3RhdGVDb25maWcsIGNvbXBhcmUgdGhlaXIgc3RhdGUgdmFsdWVzXG4gKiB1c2luZyBgJGdldFN0YXRlKG5vZGVWZXJzaW9uLCBzdGF0ZUNvbmZpZywgJ2RpcmVjdCcpYC5cbiAqIElmIHRoZSB2YWx1ZXMgYXJlIGVxdWFsIGFjY29yZGluZyB0byBgc3RhdGVDb25maWcuaXNFcXVhbGAsIHJldHVybiBgbnVsbGAsXG4gKiBvdGhlcndpc2UgcmV0dXJuIGBbdmFsdWUsIHByZXZWYWx1ZV1gLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBpbXBsZW1lbnRpbmcgdXBkYXRlRE9NLiBOb3RlIHRoYXQgdGhlIGAnZGlyZWN0J2BcbiAqIHZlcnNpb24gYXJndW1lbnQgaXMgdXNlZCBmb3IgYm90aCBub2Rlcy5cbiAqXG4gKiBAcGFyYW0gbm9kZSBBbnkgTGV4aWNhbE5vZGVcbiAqIEBwYXJhbSBwcmV2Tm9kZSBBIHByZXZpb3VzIHZlcnNpb24gb2Ygbm9kZVxuICogQHBhcmFtIHN0YXRlQ29uZmlnIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBzdGF0ZSB0byByZWFkXG4gKiBAcmV0dXJucyBgW3ZhbHVlLCBwcmV2VmFsdWVdYCBpZiBjaGFuZ2VkLCBvdGhlcndpc2UgYG51bGxgXG4gKi9cbmZ1bmN0aW9uICRnZXRTdGF0ZUNoYW5nZShub2RlLCBwcmV2Tm9kZSwgc3RhdGVDb25maWcpIHtcbiAgY29uc3QgdmFsdWUgPSAkZ2V0U3RhdGUobm9kZSwgc3RhdGVDb25maWcsICdkaXJlY3QnKTtcbiAgY29uc3QgcHJldlZhbHVlID0gJGdldFN0YXRlKHByZXZOb2RlLCBzdGF0ZUNvbmZpZywgJ2RpcmVjdCcpO1xuICByZXR1cm4gc3RhdGVDb25maWcuaXNFcXVhbCh2YWx1ZSwgcHJldlZhbHVlKSA/IG51bGwgOiBbdmFsdWUsIHByZXZWYWx1ZV07XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdGF0ZSBkZWZpbmVkIGJ5IHN0YXRlQ29uZmlnIG9uIG5vZGUuIExpa2Ugd2l0aCBgUmVhY3QudXNlU3RhdGVgXG4gKiB5b3UgbWF5IGRpcmVjdGx5IHNwZWNpZnkgdGhlIHZhbHVlIG9yIHVzZSBhbiB1cGRhdGVyIGZ1bmN0aW9uIHRoYXQgd2lsbFxuICogYmUgY2FsbGVkIHdpdGggdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBzdGF0ZSBvbiB0aGF0IG5vZGUgKHdoaWNoIHdpbGxcbiAqIGJlIHRoZSBgc3RhdGVDb25maWcuZGVmYXVsdFZhbHVlYCBpZiBub3Qgc2V0KS5cbiAqXG4gKiBXaGVuIGFuIHVwZGF0ZXIgZnVuY3Rpb24gaXMgdXNlZCwgdGhlIG5vZGUgd2lsbCBvbmx5IGJlIG1hcmtlZCBkaXJ0eSBpZlxuICogYHN0YXRlQ29uZmlnLmlzRXF1YWwocHJldlZhbHVlLCB2YWx1ZSlgIGlzIGZhbHNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgdG9nZ2xlID0gY3JlYXRlU3RhdGUoJ3RvZ2dsZScsIHtwYXJzZTogQm9vbGVhbn0pO1xuICogLy8gc2V0IGl0IGRpcmVjdGlvblxuICogJHNldFN0YXRlKG5vZGUsIGNvdW50ZXJTdGF0ZSwgdHJ1ZSk7XG4gKiAvLyB1c2UgYW4gdXBkYXRlclxuICogJHNldFN0YXRlKG5vZGUsIGNvdW50ZXJTdGF0ZSwgKHByZXYpID0+ICFwcmV2KTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBub2RlIFRoZSBMZXhpY2FsTm9kZSB0byBzZXQgdGhlIHN0YXRlIG9uXG4gKiBAcGFyYW0gc3RhdGVDb25maWcgVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgc3RhdGVcbiAqIEBwYXJhbSB2YWx1ZU9yVXBkYXRlciBUaGUgdmFsdWUgb3IgdXBkYXRlciBmdW5jdGlvblxuICogQHJldHVybnMgbm9kZVxuICovXG5mdW5jdGlvbiAkc2V0U3RhdGUobm9kZSwgc3RhdGVDb25maWcsIHZhbHVlT3JVcGRhdGVyKSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBsZXQgdmFsdWU7XG4gIGlmICh0eXBlb2YgdmFsdWVPclVwZGF0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb25zdCBsYXRlc3QgPSBub2RlLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHByZXZWYWx1ZSA9ICRnZXRTdGF0ZShsYXRlc3QsIHN0YXRlQ29uZmlnKTtcbiAgICB2YWx1ZSA9IHZhbHVlT3JVcGRhdGVyKHByZXZWYWx1ZSk7XG4gICAgaWYgKHN0YXRlQ29uZmlnLmlzRXF1YWwocHJldlZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBsYXRlc3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gdmFsdWVPclVwZGF0ZXI7XG4gIH1cbiAgY29uc3Qgd3JpdGFibGUgPSBub2RlLmdldFdyaXRhYmxlKCk7XG4gIGNvbnN0IHN0YXRlID0gJGdldFdyaXRhYmxlTm9kZVN0YXRlKHdyaXRhYmxlKTtcbiAgJGNoZWNrQ29sbGlzaW9uKG5vZGUsIHN0YXRlQ29uZmlnLCBzdGF0ZSk7XG4gIHN0YXRlLnVwZGF0ZUZyb21Lbm93bihzdGF0ZUNvbmZpZywgdmFsdWUpO1xuICByZXR1cm4gd3JpdGFibGU7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogUmVnaXN0ZXIgdGhlIGNvbmZpZyB0byB0aGlzIG5vZGUncyBzaGFyZWRDb25maWdNYXAgYW5kIHRocm93IGFuIGV4Y2VwdGlvbiBpblxuICogYHRydWVgIHdoZW4gYSBjb2xsaXNpb24gaXMgZGV0ZWN0ZWQuXG4gKi9cbmZ1bmN0aW9uICRjaGVja0NvbGxpc2lvbihub2RlLCBzdGF0ZUNvbmZpZywgc3RhdGUpIHtcbiAge1xuICAgIGNvbnN0IGNvbGxpc2lvbiA9IHN0YXRlLnNoYXJlZE5vZGVTdGF0ZS5zaGFyZWRDb25maWdNYXAuZ2V0KHN0YXRlQ29uZmlnLmtleSk7XG4gICAgaWYgKGNvbGxpc2lvbiAhPT0gdW5kZWZpbmVkICYmIGNvbGxpc2lvbiAhPT0gc3RhdGVDb25maWcpIHtcbiAgICAgIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkc2V0U3RhdGU6IFN0YXRlIGtleSBjb2xsaXNpb24gJHtKU09OLnN0cmluZ2lmeShzdGF0ZUNvbmZpZy5rZXkpfSBkZXRlY3RlZCBpbiAke25vZGUuY29uc3RydWN0b3IubmFtZX0gbm9kZSB3aXRoIHR5cGUgJHtub2RlLmdldFR5cGUoKX0gYW5kIGtleSAke25vZGUuZ2V0S2V5KCl9LiBPbmx5IG9uZSBTdGF0ZUNvbmZpZyB3aXRoIGEgZ2l2ZW4ga2V5IHNob3VsZCBiZSB1c2VkIG9uIGEgbm9kZS5gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBPcGFxdWUgc3RhdGUgdG8gYmUgc3RvcmVkIG9uIHRoZSBlZGl0b3IncyBSZWdpc3Rlck5vZGUgZm9yIHVzZSBieSBOb2RlU3RhdGVcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIENyZWF0ZSB0aGUgc3RhdGUgdG8gc3RvcmUgb24gUmVnaXN0ZXJlZE5vZGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU2hhcmVkTm9kZVN0YXRlKG5vZGVDb25maWcpIHtcbiAgY29uc3Qgc2hhcmVkQ29uZmlnTWFwID0gbmV3IE1hcCgpO1xuICBjb25zdCBmbGF0S2V5cyA9IG5ldyBTZXQoKTtcbiAgZm9yIChsZXQga2xhc3MgPSB0eXBlb2Ygbm9kZUNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA/IG5vZGVDb25maWcgOiBub2RlQ29uZmlnLnJlcGxhY2U7IGtsYXNzLnByb3RvdHlwZSAmJiBrbGFzcy5wcm90b3R5cGUuZ2V0VHlwZSAhPT0gdW5kZWZpbmVkOyBrbGFzcyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihrbGFzcykpIHtcbiAgICBjb25zdCB7XG4gICAgICBvd25Ob2RlQ29uZmlnXG4gICAgfSA9IGdldFN0YXRpY05vZGVDb25maWcoa2xhc3MpO1xuICAgIGlmIChvd25Ob2RlQ29uZmlnICYmIG93bk5vZGVDb25maWcuc3RhdGVDb25maWdzKSB7XG4gICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkU3RhdGVDb25maWcgb2Ygb3duTm9kZUNvbmZpZy5zdGF0ZUNvbmZpZ3MpIHtcbiAgICAgICAgbGV0IHN0YXRlQ29uZmlnO1xuICAgICAgICBpZiAoJ3N0YXRlQ29uZmlnJyBpbiByZXF1aXJlZFN0YXRlQ29uZmlnKSB7XG4gICAgICAgICAgc3RhdGVDb25maWcgPSByZXF1aXJlZFN0YXRlQ29uZmlnLnN0YXRlQ29uZmlnO1xuICAgICAgICAgIGlmIChyZXF1aXJlZFN0YXRlQ29uZmlnLmZsYXQpIHtcbiAgICAgICAgICAgIGZsYXRLZXlzLmFkZChzdGF0ZUNvbmZpZy5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZUNvbmZpZyA9IHJlcXVpcmVkU3RhdGVDb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgc2hhcmVkQ29uZmlnTWFwLnNldChzdGF0ZUNvbmZpZy5rZXksIHN0YXRlQ29uZmlnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmbGF0S2V5cyxcbiAgICBzaGFyZWRDb25maWdNYXBcbiAgfTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBBIE1hcCBvZiBzdHJpbmcga2V5cyB0byBzdGF0ZSBjb25maWd1cmF0aW9ucyB0byBiZSBzaGFyZWQgYWNyb3NzIG5vZGVzXG4gKiBhbmQvb3Igbm9kZSB2ZXJzaW9ucy5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBOb2RlU3RhdGUge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFRyYWNrIHRoZSAodmVyc2lvbmVkKSBub2RlIHRoYXQgdGhpcyBOb2RlU3RhdGUgd2FzIGNyZWF0ZWQgZm9yLCB0b1xuICAgKiBmYWNpbGl0YXRlIGNvcHktb24td3JpdGUgZm9yIE5vZGVTdGF0ZS4gV2hlbiBhIExleGljYWxOb2RlIGlzIGNsb25lZCxcbiAgICogaXQgd2lsbCAqcmVmZXJlbmNlKiB0aGUgTm9kZVN0YXRlIGZyb20gaXRzIHByZXZOb2RlLiBGcm9tIHRoZSBuZXh0Tm9kZVxuICAgKiB5b3UgY2FuIGNvbnRpbnVlIHRvIHJlYWQgc3RhdGUgd2l0aG91dCBjb3B5aW5nLCBidXQgdGhlIGZpcnN0ICRzZXRTdGF0ZVxuICAgKiB3aWxsIHRyaWdnZXIgYSBjb3B5IG9mIHRoZSBwcmV2Tm9kZSdzIE5vZGVTdGF0ZSB3aXRoIHRoZSBub2RlIHByb3BlcnR5XG4gICAqIHVwZGF0ZWQuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogU3RhdGUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHBhcnNlZCBpbiBhIGdldCBzdGF0ZSwgc28gaXQgaXMgc2FmZS4gKGNhbiBiZSByZXR1cm5lZCB3aXRoXG4gICAqIGp1c3QgYSBjYXN0IHNpbmNlIHRoZSBwcm9vZiB3YXMgZ2l2ZW4gYmVmb3JlKS5cbiAgICpcbiAgICogTm90ZSB0aGF0IGl0IHVzZXMgU3RhdGVDb25maWcsIHNvIGluIGFkZGl0aW9uIHRvICgxKSB0aGUgQ1VSUkVOVCBWQUxVRSwgaXQgaGFzIGFjY2VzcyB0b1xuICAgKiAoMikgdGhlIFN0YXRlIGtleSAoMykgdGhlIERFRkFVTFQgVkFMVUUgYW5kICg0KSB0aGUgUEFSU0UgRlVOQ1RJT05cbiAgICovXG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBBIGNvcHkgb2Ygc2VyaWFsaXplZE5vZGVbTk9ERV9TVEFURV9LRVldIHRoYXQgaXMgbWFkZSB3aGVuIEpTT04gaXNcbiAgICogaW1wb3J0ZWQgYnV0IGhhcyBub3QgYmVlbiBwYXJzZWQgeWV0LlxuICAgKlxuICAgKiBJdCBzdGF5cyBoZXJlIHVudGlsIGEgZ2V0IHN0YXRlIHJlcXVpcmVzIHVzIHRvIHBhcnNlIGl0LCBhbmQgc2luY2Ugd2VcbiAgICogdGhlbiBrbm93IHRoZSB2YWx1ZSBpcyBzYWZlIHdlIG1vdmUgaXQgdG8ga25vd25TdGF0ZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHNpbmNlIG9ubHkgc3RyaW5nIGtleXMgYXJlIHVzZWQgaGVyZSwgd2UgY2FuIG9ubHkgYWxsb3cgdGhpc1xuICAgKiBzdGF0ZSB0byBwYXNzLXRocm91Z2ggb24gZXhwb3J0IG9yIG9uIHRoZSBuZXh0IHZlcnNpb24gc2luY2UgdGhlcmUgaXNcbiAgICogbm8ga25vd24gdmFsdWUgY29uZmlndXJhdGlvbi4gVGhpcyBwYXNzLXRocm91Z2ggaXMgdG8gc3VwcG9ydCBzY2VuYXJpb3NcbiAgICogd2hlcmUgbXVsdGlwbGUgdmVyc2lvbnMgb2YgdGhlIGVkaXRvciBjb2RlIGFyZSB3b3JraW5nIGluIHBhcmFsbGVsIHNvXG4gICAqIGFuIG9sZCB2ZXJzaW9uIG9mIHlvdXIgY29kZSBkb2VzbnQgZXJhc2UgbWV0YWRhdGEgdGhhdCB3YXNcbiAgICogc2V0IGJ5IGEgbmV3ZXIgdmVyc2lvbiBvZiB5b3VyIGNvZGUuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogVGhpcyBzaGFyZWROb2RlU3RhdGUgaXMgcHJlc2VydmVkIGFjcm9zcyBhbGwgaW5zdGFuY2VzIG9mIGEgZ2l2ZW5cbiAgICogbm9kZSB0eXBlIGluIGFuIGVkaXRvciBhbmQgcmVtYWlucyB3cml0YWJsZS4gSXQgaXMgaG93IGtleXMgYXJlIHJlc29sdmVkXG4gICAqIHRvIGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogVGhlIGNvdW50IG9mIGtub3duIG9yIHVua25vd24ga2V5cyBpbiB0aGlzIHN0YXRlLCBpZ25vcmluZyB0aGVcbiAgICogaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIHR3byBzZXRzLlxuICAgKi9cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihub2RlLCBzaGFyZWROb2RlU3RhdGUsIHVua25vd25TdGF0ZSA9IHVuZGVmaW5lZCwga25vd25TdGF0ZSA9IG5ldyBNYXAoKSwgc2l6ZSA9IHVuZGVmaW5lZCkge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5zaGFyZWROb2RlU3RhdGUgPSBzaGFyZWROb2RlU3RhdGU7XG4gICAgdGhpcy51bmtub3duU3RhdGUgPSB1bmtub3duU3RhdGU7XG4gICAgdGhpcy5rbm93blN0YXRlID0ga25vd25TdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBzaGFyZWRDb25maWdNYXBcbiAgICB9ID0gdGhpcy5zaGFyZWROb2RlU3RhdGU7XG4gICAgY29uc3QgY29tcHV0ZWRTaXplID0gc2l6ZSAhPT0gdW5kZWZpbmVkID8gc2l6ZSA6IGNvbXB1dGVTaXplKHNoYXJlZENvbmZpZ01hcCwgdW5rbm93blN0YXRlLCBrbm93blN0YXRlKTtcbiAgICB7XG4gICAgICBpZiAoIShzaXplID09PSB1bmRlZmluZWQgfHwgY29tcHV0ZWRTaXplID09PSBzaXplKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYE5vZGVTdGF0ZTogc2l6ZSAhPSBjb21wdXRlZFNpemUgKCR7U3RyaW5nKHNpemUpfSAhPSAke1N0cmluZyhjb21wdXRlZFNpemUpfSlgKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc3RhdGVDb25maWcgb2Yga25vd25TdGF0ZS5rZXlzKCkpIHtcbiAgICAgICAgaWYgKCFzaGFyZWRDb25maWdNYXAuaGFzKHN0YXRlQ29uZmlnLmtleSkpIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYE5vZGVTdGF0ZTogc2hhcmVkQ29uZmlnTWFwIG1pc3Npbmcga25vd25TdGF0ZSBrZXkgJHtzdGF0ZUNvbmZpZy5rZXl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zaXplID0gY29tcHV0ZWRTaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBHZXQgdGhlIHZhbHVlIGZyb20ga25vd25TdGF0ZSwgb3IgcGFyc2UgaXQgZnJvbSB1bmtub3duU3RhdGVcbiAgICogaWYgaXQgY29udGFpbnMgdGhlIGdpdmVuIGtleS5cbiAgICpcbiAgICogVXBkYXRlcyB0aGUgc2hhcmVkQ29uZmlnTWFwIHdoZW4gbm8ga25vd24gc3RhdGUgaXMgZm91bmQuXG4gICAqIFVwZGF0ZXMgdW5rbm93blN0YXRlIGFuZCBrbm93blN0YXRlIHdoZW4gYW4gdW5rbm93blN0YXRlIGlzIHBhcnNlZC5cbiAgICovXG4gIGdldFZhbHVlKHN0YXRlQ29uZmlnKSB7XG4gICAgY29uc3Qga25vd24gPSB0aGlzLmtub3duU3RhdGUuZ2V0KHN0YXRlQ29uZmlnKTtcbiAgICBpZiAoa25vd24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGtub3duO1xuICAgIH1cbiAgICB0aGlzLnNoYXJlZE5vZGVTdGF0ZS5zaGFyZWRDb25maWdNYXAuc2V0KHN0YXRlQ29uZmlnLmtleSwgc3RhdGVDb25maWcpO1xuICAgIGxldCBwYXJzZWQgPSBzdGF0ZUNvbmZpZy5kZWZhdWx0VmFsdWU7XG4gICAgaWYgKHRoaXMudW5rbm93blN0YXRlICYmIHN0YXRlQ29uZmlnLmtleSBpbiB0aGlzLnVua25vd25TdGF0ZSkge1xuICAgICAgY29uc3QganNvblZhbHVlID0gdGhpcy51bmtub3duU3RhdGVbc3RhdGVDb25maWcua2V5XTtcbiAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXJzZWQgPSBzdGF0ZUNvbmZpZy5wYXJzZShqc29uVmFsdWUpO1xuICAgICAgfVxuICAgICAgLy8gT25seSB1cGRhdGUgaWYgdGhlIGtleSB3YXMgdW5rbm93blxuICAgICAgdGhpcy51cGRhdGVGcm9tS25vd24oc3RhdGVDb25maWcsIHBhcnNlZCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFVzZWQgb25seSBmb3IgYWR2YW5jZWQgdXNlIGNhc2VzLCBzdWNoIGFzIGNvbGxhYi4gVGhlIGludGVudCBoZXJlIGlzIHRvXG4gICAqIGFsbG93IHlvdSB0byBkaWZmIHN0YXRlcyB3aXRoIGEgbW9yZSBzdGFibGUgaW50ZXJmYWNlIHRoYW4gdGhlIHByb3BlcnRpZXNcbiAgICogb2YgdGhpcyBjbGFzcy5cbiAgICovXG4gIGdldEludGVybmFsU3RhdGUoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnVua25vd25TdGF0ZSwgdGhpcy5rbm93blN0YXRlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNvZGUgdGhpcyBOb2RlU3RhdGUgdG8gSlNPTiBpbiB0aGUgZm9ybWF0IHRoYXQgaXRzIG5vZGUgZXhwZWN0cy5cbiAgICogVGhpcyByZXR1cm5zIGB7W05PREVfU1RBVEVfS0VZXT86IFVua25vd25TdGF0ZVJlY29yZH1gIHJhdGhlciB0aGFuXG4gICAqIGBVbmtub3duU3RhdGVSZWNvcmQgfCB1bmRlZmluZWRgIHNvIHRoYXQgd2UgY2FuIHN1cHBvcnQgZmxhdHRlbmluZ1xuICAgKiBzcGVjaWZpYyBlbnRyaWVzIGluIHRoZSBmdXR1cmUgd2hlbiBub2RlcyBjYW4gZGVjbGFyZSB3aGF0XG4gICAqIHRoZWlyIHJlcXVpcmVkIFN0YXRlQ29uZmlncyBhcmUuXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAuLi50aGlzLnVua25vd25TdGF0ZVxuICAgIH07XG4gICAgY29uc3QgZmxhdFN0YXRlID0ge307XG4gICAgZm9yIChjb25zdCBbc3RhdGVDb25maWcsIHZdIG9mIHRoaXMua25vd25TdGF0ZSkge1xuICAgICAgaWYgKHN0YXRlQ29uZmlnLmlzRXF1YWwodiwgc3RhdGVDb25maWcuZGVmYXVsdFZhbHVlKSkge1xuICAgICAgICBkZWxldGUgc3RhdGVbc3RhdGVDb25maWcua2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlW3N0YXRlQ29uZmlnLmtleV0gPSBzdGF0ZUNvbmZpZy51bnBhcnNlKHYpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLnNoYXJlZE5vZGVTdGF0ZS5mbGF0S2V5cykge1xuICAgICAgaWYgKGtleSBpbiBzdGF0ZSkge1xuICAgICAgICBmbGF0U3RhdGVba2V5XSA9IHN0YXRlW2tleV07XG4gICAgICAgIGRlbGV0ZSBzdGF0ZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodW5kZWZpbmVkSWZFbXB0eShzdGF0ZSkpIHtcbiAgICAgIGZsYXRTdGF0ZVtOT0RFX1NUQVRFX0tFWV0gPSBzdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZsYXRTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogQSBOb2RlU3RhdGUgaXMgd3JpdGFibGUgd2hlbiB0aGUgbm9kZSB0byB1cGRhdGUgbWF0Y2hlc1xuICAgKiB0aGUgbm9kZSBhc3NvY2lhdGVkIHdpdGggdGhlIE5vZGVTdGF0ZS4gVGhpcyBiYXNpY2FsbHlcbiAgICogbWlycm9ycyBob3cgdGhlIEVkaXRvclN0YXRlIE5vZGVNYXAgd29ya3MsIGJ1dCBpbiBhXG4gICAqIGJvdHRvbS11cCBvcmdhbml6YXRpb24gcmF0aGVyIHRoYW4gYSB0b3AtZG93biBvcmdhbml6YXRpb24uXG4gICAqXG4gICAqIFRoaXMgYWxsb3dzIHVzIHRvIGltcGxlbWVudCB0aGUgc2FtZSBcImNvcHkgb24gd3JpdGVcIlxuICAgKiBwYXR0ZXJuIGZvciBzdGF0ZSwgd2l0aG91dCBoYXZpbmcgdGhlIHN0YXRlIHZlcnNpb25cbiAgICogdXBkYXRlIGV2ZXJ5IHRpbWUgdGhlIG5vZGUgdmVyc2lvbiBjaGFuZ2VzIChlLmcuIHdoZW5cbiAgICogaXRzIHBhcmVudCBvciBzaWJsaW5ncyBjaGFuZ2UpLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgc3RhdGVcbiAgICogQHJldHVybnMgVGhlIG5leHQgd3JpdGFibGUgc3RhdGVcbiAgICovXG4gIGdldFdyaXRhYmxlKG5vZGUpIHtcbiAgICBpZiAodGhpcy5ub2RlID09PSBub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgc2hhcmVkTm9kZVN0YXRlLFxuICAgICAgdW5rbm93blN0YXRlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV4dEtub3duU3RhdGUgPSBuZXcgTWFwKHRoaXMua25vd25TdGF0ZSk7XG4gICAgcmV0dXJuIG5ldyBOb2RlU3RhdGUobm9kZSwgc2hhcmVkTm9kZVN0YXRlLCBwYXJzZUFuZFBydW5lTmV4dFVua25vd25TdGF0ZShzaGFyZWROb2RlU3RhdGUuc2hhcmVkQ29uZmlnTWFwLCBuZXh0S25vd25TdGF0ZSwgdW5rbm93blN0YXRlKSwgbmV4dEtub3duU3RhdGUsIHRoaXMuc2l6ZSk7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUZyb21Lbm93bihzdGF0ZUNvbmZpZywgdmFsdWUpIHtcbiAgICBjb25zdCBrZXkgPSBzdGF0ZUNvbmZpZy5rZXk7XG4gICAgdGhpcy5zaGFyZWROb2RlU3RhdGUuc2hhcmVkQ29uZmlnTWFwLnNldChrZXksIHN0YXRlQ29uZmlnKTtcbiAgICBjb25zdCB7XG4gICAgICBrbm93blN0YXRlLFxuICAgICAgdW5rbm93blN0YXRlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCEoa25vd25TdGF0ZS5oYXMoc3RhdGVDb25maWcpIHx8IHVua25vd25TdGF0ZSAmJiBrZXkgaW4gdW5rbm93blN0YXRlKSkge1xuICAgICAgaWYgKHVua25vd25TdGF0ZSkge1xuICAgICAgICBkZWxldGUgdW5rbm93blN0YXRlW2tleV07XG4gICAgICAgIHRoaXMudW5rbm93blN0YXRlID0gdW5kZWZpbmVkSWZFbXB0eSh1bmtub3duU3RhdGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaXplKys7XG4gICAgfVxuICAgIGtub3duU3RhdGUuc2V0KHN0YXRlQ29uZmlnLCB2YWx1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFRoaXMgaXMgaW50ZW5kZWQgZm9yIGFkdmFuY2VkIHVzZSBjYXNlcyBvbmx5LCBzdWNoXG4gICAqIGFzIGNvbGxhYiBvciBkZXYgdG9vbHMuXG4gICAqXG4gICAqIFVwZGF0ZSBhIHNpbmdsZSBrZXkgdmFsdWUgcGFpciBmcm9tIHVua25vd24gc3RhdGUsXG4gICAqIHBhcnNpbmcgaXQgaWYgdGhlIGtleSBpcyBrbm93biB0byB0aGlzIG5vZGUuIFRoaXMgaXNcbiAgICogYmFzaWNhbGx5IGxpa2UgdXBkYXRlRnJvbUpTT04sIGJ1dCB0aGUgZWZmZWN0IGlzXG4gICAqIGlzb2xhdGVkIHRvIGEgc2luZ2xlIGVudHJ5LlxuICAgKlxuICAgKiBAcGFyYW0gayBUaGUgc3RyaW5nIGtleSBmcm9tIGFuIFVua25vd25TdGF0ZVJlY29yZFxuICAgKiBAcGFyYW0gdiBUaGUgdW5rbm93biB2YWx1ZSBmcm9tIGFuIFVua25vd25TdGF0ZVJlY29yZFxuICAgKi9cbiAgdXBkYXRlRnJvbVVua25vd24oaywgdikge1xuICAgIGNvbnN0IHN0YXRlQ29uZmlnID0gdGhpcy5zaGFyZWROb2RlU3RhdGUuc2hhcmVkQ29uZmlnTWFwLmdldChrKTtcbiAgICBpZiAoc3RhdGVDb25maWcpIHtcbiAgICAgIHRoaXMudXBkYXRlRnJvbUtub3duKHN0YXRlQ29uZmlnLCBzdGF0ZUNvbmZpZy5wYXJzZSh2KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5rbm93blN0YXRlID0gdGhpcy51bmtub3duU3RhdGUgfHwge307XG4gICAgICBpZiAoIShrIGluIHRoaXMudW5rbm93blN0YXRlKSkge1xuICAgICAgICB0aGlzLnNpemUrKztcbiAgICAgIH1cbiAgICAgIHRoaXMudW5rbm93blN0YXRlW2tdID0gdjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIFJlc2V0IGFsbCBleGlzdGluZyBzdGF0ZSB0byBkZWZhdWx0IG9yIGVtcHR5IHZhbHVlcyxcbiAgICogYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZnJvbSB0aGUgZ2l2ZW4gdW5rbm93blN0YXRlLlxuICAgKlxuICAgKiBUaGlzIGlzIHVzZWQgd2hlbiBpbml0aWFsaXppbmcgYSBub2RlJ3Mgc3RhdGUgZnJvbSBKU09OLFxuICAgKiBvciB3aGVuIHJlc2V0dGluZyBhIG5vZGUncyBzdGF0ZSBmcm9tIEpTT04uXG4gICAqXG4gICAqIEBwYXJhbSB1bmtub3duU3RhdGUgVGhlIG5ldyBzdGF0ZSBpbiBzZXJpYWxpemVkIGZvcm1cbiAgICovXG4gIHVwZGF0ZUZyb21KU09OKHVua25vd25TdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGtub3duU3RhdGVcbiAgICB9ID0gdGhpcztcbiAgICAvLyBSZXNldCBhbGwga25vd24gc3RhdGUgdG8gZGVmYXVsdHNcbiAgICBmb3IgKGNvbnN0IHN0YXRlQ29uZmlnIG9mIGtub3duU3RhdGUua2V5cygpKSB7XG4gICAgICBrbm93blN0YXRlLnNldChzdGF0ZUNvbmZpZywgc3RhdGVDb25maWcuZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgLy8gU2luY2Ugd2UgYXJlIHJlc2V0dGluZyBhbGwgc3RhdGUgdG8gdGhpcyBuZXcgcmVjb3JkLFxuICAgIC8vIHRoZSBzaXplIHN0YXJ0cyBhdCB0aGUgbnVtYmVyIG9mIGtub3duIGtleXNcbiAgICAvLyBhbmQgd2lsbCBiZSB1cGRhdGVkIGFzIHdlIHRyYXZlcnNlIHRoZSBuZXcgc3RhdGVcbiAgICB0aGlzLnNpemUgPSBrbm93blN0YXRlLnNpemU7XG4gICAgdGhpcy51bmtub3duU3RhdGUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHVua25vd25TdGF0ZSkge1xuICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModW5rbm93blN0YXRlKSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUZyb21Vbmtub3duKGssIHYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIE9ubHkgZm9yIGRpcmVjdCB1c2UgaW4gdmVyeSBhZHZhbmNlZCBpbnRlZ3JhdGlvbnMsIHN1Y2ggYXMgbGV4aWNhbC15anMuXG4gKiBUeXBpY2FsbHkgeW91IHdvdWxkIG9ubHkgdXNlIHtAbGluayBjcmVhdGVTdGF0ZX0sIHtAbGluayAkZ2V0U3RhdGV9LCBhbmRcbiAqIHtAbGluayAkc2V0U3RhdGV9LiBUaGlzIGlzIGVmZmVjdGl2ZWx5IHRoZSBwcmVhbWJsZSBmb3Ige0BsaW5rICRzZXRTdGF0ZX0uXG4gKi9cbmZ1bmN0aW9uICRnZXRXcml0YWJsZU5vZGVTdGF0ZShub2RlKSB7XG4gIGNvbnN0IHdyaXRhYmxlID0gbm9kZS5nZXRXcml0YWJsZSgpO1xuICBjb25zdCBzdGF0ZSA9IHdyaXRhYmxlLl9fc3RhdGUgPyB3cml0YWJsZS5fX3N0YXRlLmdldFdyaXRhYmxlKHdyaXRhYmxlKSA6IG5ldyBOb2RlU3RhdGUod3JpdGFibGUsICRnZXRTaGFyZWROb2RlU3RhdGUod3JpdGFibGUpKTtcbiAgd3JpdGFibGUuX19zdGF0ZSA9IHN0YXRlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogR2V0IHRoZSBTaGFyZWROb2RlU3RhdGUgZm9yIGEgbm9kZSBvbiB0aGlzIGVkaXRvclxuICovXG5mdW5jdGlvbiAkZ2V0U2hhcmVkTm9kZVN0YXRlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX19zdGF0ZSA/IG5vZGUuX19zdGF0ZS5zaGFyZWROb2RlU3RhdGUgOiBnZXRSZWdpc3RlcmVkTm9kZU9yVGhyb3coJGdldEVkaXRvcigpLCBub2RlLmdldFR5cGUoKSkuc2hhcmVkTm9kZVN0YXRlO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIFRoaXMgaXMgdXNlZCB0byBpbXBsZW1lbnQgTGV4aWNhbE5vZGUudXBkYXRlRnJvbUpTT04gYW5kIGlzXG4gKiBub3QgaW50ZW5kZWQgdG8gYmUgZXhwb3J0ZWQgZnJvbSB0aGUgcGFja2FnZS5cbiAqXG4gKiBAcGFyYW0gbm9kZSBhbnkgTGV4aWNhbE5vZGVcbiAqIEBwYXJhbSB1bmtub3duU3RhdGUgdW5kZWZpbmVkIG9yIGEgc2VyaWFsaXplZCBTdGF0ZVxuICogQHJldHVybnMgQSB3cml0YWJsZSB2ZXJzaW9uIG9mIG5vZGUsIHdpdGggdGhlIHN0YXRlIHNldC5cbiAqL1xuZnVuY3Rpb24gJHVwZGF0ZVN0YXRlRnJvbUpTT04obm9kZSwgc2VyaWFsaXplZCkge1xuICBjb25zdCB3cml0YWJsZSA9IG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgY29uc3QgdW5rbm93blN0YXRlID0gc2VyaWFsaXplZFtOT0RFX1NUQVRFX0tFWV07XG4gIGxldCBwYXJzZVN0YXRlID0gdW5rbm93blN0YXRlO1xuICBmb3IgKGNvbnN0IGsgb2YgJGdldFNoYXJlZE5vZGVTdGF0ZSh3cml0YWJsZSkuZmxhdEtleXMpIHtcbiAgICBpZiAoayBpbiBzZXJpYWxpemVkKSB7XG4gICAgICBpZiAocGFyc2VTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhcnNlU3RhdGUgPT09IHVua25vd25TdGF0ZSkge1xuICAgICAgICBwYXJzZVN0YXRlID0ge1xuICAgICAgICAgIC4uLnVua25vd25TdGF0ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcGFyc2VTdGF0ZVtrXSA9IHNlcmlhbGl6ZWRba107XG4gICAgfVxuICB9XG4gIGlmICh3cml0YWJsZS5fX3N0YXRlIHx8IHBhcnNlU3RhdGUpIHtcbiAgICAkZ2V0V3JpdGFibGVOb2RlU3RhdGUobm9kZSkudXBkYXRlRnJvbUpTT04ocGFyc2VTdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHdyaXRhYmxlO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB0d28gbm9kZXMgaGF2ZSBlcXVpdmFsZW50IE5vZGVTdGF0ZSwgdG8gYmUgdXNlZFxuICogdG8gZGV0ZXJtaW5lIHdoZW4gVGV4dE5vZGUgYXJlIGJlaW5nIG1lcmdlZCwgbm90IGEgbG90IG9mIHVzZSBjYXNlc1xuICogb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBub2RlU3RhdGVzQXJlRXF1aXZhbGVudChhLCBiKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGEgJiYgYiAmJiBhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICByZXR1cm4gIShhICYmIGhhc1VuZXF1YWxNYXBFbnRyeShrZXlzLCBhLCBiKSB8fCBiICYmIGhhc1VuZXF1YWxNYXBFbnRyeShrZXlzLCBiLCBhKSB8fCBhICYmIGhhc1VuZXF1YWxSZWNvcmRFbnRyeShrZXlzLCBhLCBiKSB8fCBiICYmIGhhc1VuZXF1YWxSZWNvcmRFbnRyeShrZXlzLCBiLCBhKSk7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGRpc3RpbmN0IGtleXMgdGhhdCB3aWxsIGJlIGluIGEgTm9kZVN0YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTaXplKHNoYXJlZENvbmZpZ01hcCwgdW5rbm93blN0YXRlLCBrbm93blN0YXRlKSB7XG4gIGxldCBzaXplID0ga25vd25TdGF0ZS5zaXplO1xuICBpZiAodW5rbm93blN0YXRlKSB7XG4gICAgZm9yIChjb25zdCBrIGluIHVua25vd25TdGF0ZSkge1xuICAgICAgY29uc3Qgc2hhcmVkQ29uZmlnID0gc2hhcmVkQ29uZmlnTWFwLmdldChrKTtcbiAgICAgIGlmICghc2hhcmVkQ29uZmlnIHx8ICFrbm93blN0YXRlLmhhcyhzaGFyZWRDb25maWcpKSB7XG4gICAgICAgIHNpemUrKztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogUmV0dXJuIG9iaiBpZiBpdCBpcyBhbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCBvbmUgcHJvcGVydHksIG90aGVyd2lzZVxuICogcmV0dXJuIHVuZGVmaW5lZC5cbiAqL1xuZnVuY3Rpb24gdW5kZWZpbmVkSWZFbXB0eShvYmopIHtcbiAgaWYgKG9iaikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBDYXN0IHRoZSBnaXZlbiB2IHRvIHVua25vd25cbiAqL1xuZnVuY3Rpb24gY29lcmNlVG9KU09OKHYpIHtcbiAgcmV0dXJuIHY7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogUGFyc2UgYWxsIGtub3dhYmxlIHZhbHVlcyBpbiBhbiBVbmtub3duU3RhdGVSZWNvcmQgaW50byBuZXh0S25vd25TdGF0ZVxuICogYW5kIHJldHVybiB0aGUgdW5wYXJzZWQgdmFsdWVzIGluIGEgbmV3IFVua25vd25TdGF0ZVJlY29yZC4gUmV0dXJuc1xuICogdW5kZWZpbmVkIGlmIG5vIHVua25vd24gdmFsdWVzIHJlbWFpbi5cbiAqL1xuZnVuY3Rpb24gcGFyc2VBbmRQcnVuZU5leHRVbmtub3duU3RhdGUoc2hhcmVkQ29uZmlnTWFwLCBuZXh0S25vd25TdGF0ZSwgdW5rbm93blN0YXRlKSB7XG4gIGxldCBuZXh0VW5rbm93blN0YXRlID0gdW5kZWZpbmVkO1xuICBpZiAodW5rbm93blN0YXRlKSB7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModW5rbm93blN0YXRlKSkge1xuICAgICAgY29uc3Qgc3RhdGVDb25maWcgPSBzaGFyZWRDb25maWdNYXAuZ2V0KGspO1xuICAgICAgaWYgKHN0YXRlQ29uZmlnKSB7XG4gICAgICAgIGlmICghbmV4dEtub3duU3RhdGUuaGFzKHN0YXRlQ29uZmlnKSkge1xuICAgICAgICAgIG5leHRLbm93blN0YXRlLnNldChzdGF0ZUNvbmZpZywgc3RhdGVDb25maWcucGFyc2UodikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0VW5rbm93blN0YXRlID0gbmV4dFVua25vd25TdGF0ZSB8fCB7fTtcbiAgICAgICAgbmV4dFVua25vd25TdGF0ZVtrXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXh0VW5rbm93blN0YXRlO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIENvbXBhcmUgZWFjaCBlbnRyeSBvZiBzb3VyY2VTdGF0ZS5rbm93blN0YXRlIHRoYXQgaXMgbm90IGluIGtleXMgdG9cbiAqIG90aGVyU3RhdGUgKG9yIHRoZSBkZWZhdWx0IHZhbHVlIGlmIG90aGVyU3RhdGUgaXMgdW5kZWZpbmVkLlxuICogTm90ZSB0aGF0IG90aGVyU3RhdGUgd2lsbCByZXR1cm4gdGhlIGRlZmF1bHRWYWx1ZSBhcyB3ZWxsIGlmIGl0XG4gKiBoYXMgbmV2ZXIgYmVlbiBzZXQuIEFueSBjaGVja2VkIGVudHJ5J3Mga2V5IHdpbGwgYmUgYWRkZWQgdG8ga2V5cy5cbiAqXG4gKiBAcmV0dXJucyB0cnVlIGlmIGFueSBkaWZmZXJlbmNlIGlzIGZvdW5kLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaGFzVW5lcXVhbE1hcEVudHJ5KGtleXMsIHNvdXJjZVN0YXRlLCBvdGhlclN0YXRlKSB7XG4gIGZvciAoY29uc3QgW3N0YXRlQ29uZmlnLCB2YWx1ZV0gb2Ygc291cmNlU3RhdGUua25vd25TdGF0ZSkge1xuICAgIGlmIChrZXlzLmhhcyhzdGF0ZUNvbmZpZy5rZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAga2V5cy5hZGQoc3RhdGVDb25maWcua2V5KTtcbiAgICBjb25zdCBvdGhlclZhbHVlID0gb3RoZXJTdGF0ZSA/IG90aGVyU3RhdGUuZ2V0VmFsdWUoc3RhdGVDb25maWcpIDogc3RhdGVDb25maWcuZGVmYXVsdFZhbHVlO1xuICAgIGlmIChvdGhlclZhbHVlICE9PSB2YWx1ZSAmJiAhc3RhdGVDb25maWcuaXNFcXVhbChvdGhlclZhbHVlLCB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogQ29tcGFyZSBlYWNoIGVudHJ5IG9mIHNvdXJjZVN0YXRlLnVua25vd25TdGF0ZSB0aGF0IGlzIG5vdCBpbiBrZXlzIHRvXG4gKiBvdGhlclN0YXRlLnVua25vd25TdGF0ZSAob3IgdW5kZWZpbmVkIGlmIG90aGVyU3RhdGUgaXMgdW5kZWZpbmVkKS5cbiAqIEFueSBjaGVja2VkIGVudHJ5J3Mga2V5IHdpbGwgYmUgYWRkZWQgdG8ga2V5cy5cbiAqXG4gKiBOb3RhYmx5IHNpbmNlIHdlIGhhdmUgYWxyZWFkeSBjaGVja2VkIGhhc1VuZXF1YWxNYXBFbnRyeSBvbiBib3RoIHNpZGVzLFxuICogd2UgZG8gbm90IGRvIGFueSBwYXJzaW5nIG9yIGNoZWNraW5nIG9mIGtub3duU3RhdGUuXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiBhbnkgZGlmZmVyZW5jZSBpcyBmb3VuZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGhhc1VuZXF1YWxSZWNvcmRFbnRyeShrZXlzLCBzb3VyY2VTdGF0ZSwgb3RoZXJTdGF0ZSkge1xuICBjb25zdCB7XG4gICAgdW5rbm93blN0YXRlXG4gIH0gPSBzb3VyY2VTdGF0ZTtcbiAgY29uc3Qgb3RoZXJVbmtub3duU3RhdGUgPSBvdGhlclN0YXRlID8gb3RoZXJTdGF0ZS51bmtub3duU3RhdGUgOiB1bmRlZmluZWQ7XG4gIGlmICh1bmtub3duU3RhdGUpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh1bmtub3duU3RhdGUpKSB7XG4gICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICBjb25zdCBvdGhlclZhbHVlID0gb3RoZXJVbmtub3duU3RhdGUgPyBvdGhlclVua25vd25TdGF0ZVtrZXldIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKHZhbHVlICE9PSBvdGhlclZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogQ2xvbmVzIHRoZSBOb2RlU3RhdGUgZm9yIGEgZ2l2ZW4gbm9kZS4gSGFuZGxlcyBhbGlhc2luZyBpZiB0aGUgc3RhdGUgcmVmZXJlbmNlcyB0aGUgZnJvbSBub2RlLlxuICovXG5mdW5jdGlvbiAkY2xvbmVOb2RlU3RhdGUoZnJvbSwgdG8pIHtcbiAgY29uc3Qgc3RhdGUgPSBmcm9tLl9fc3RhdGU7XG4gIHJldHVybiBzdGF0ZSAmJiBzdGF0ZS5ub2RlID09PSBmcm9tID8gc3RhdGUuZ2V0V3JpdGFibGUodG8pIDogc3RhdGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gJGNhblNpbXBsZVRleHROb2Rlc0JlTWVyZ2VkKG5vZGUxLCBub2RlMikge1xuICBjb25zdCBub2RlMU1vZGUgPSBub2RlMS5fX21vZGU7XG4gIGNvbnN0IG5vZGUxRm9ybWF0ID0gbm9kZTEuX19mb3JtYXQ7XG4gIGNvbnN0IG5vZGUxU3R5bGUgPSBub2RlMS5fX3N0eWxlO1xuICBjb25zdCBub2RlMk1vZGUgPSBub2RlMi5fX21vZGU7XG4gIGNvbnN0IG5vZGUyRm9ybWF0ID0gbm9kZTIuX19mb3JtYXQ7XG4gIGNvbnN0IG5vZGUyU3R5bGUgPSBub2RlMi5fX3N0eWxlO1xuICBjb25zdCBub2RlMVN0YXRlID0gbm9kZTEuX19zdGF0ZTtcbiAgY29uc3Qgbm9kZTJTdGF0ZSA9IG5vZGUyLl9fc3RhdGU7XG4gIHJldHVybiAobm9kZTFNb2RlID09PSBudWxsIHx8IG5vZGUxTW9kZSA9PT0gbm9kZTJNb2RlKSAmJiAobm9kZTFGb3JtYXQgPT09IG51bGwgfHwgbm9kZTFGb3JtYXQgPT09IG5vZGUyRm9ybWF0KSAmJiAobm9kZTFTdHlsZSA9PT0gbnVsbCB8fCBub2RlMVN0eWxlID09PSBub2RlMlN0eWxlKSAmJiAobm9kZTEuX19zdGF0ZSA9PT0gbnVsbCB8fCBub2RlMVN0YXRlID09PSBub2RlMlN0YXRlIHx8IG5vZGVTdGF0ZXNBcmVFcXVpdmFsZW50KG5vZGUxU3RhdGUsIG5vZGUyU3RhdGUpKTtcbn1cbmZ1bmN0aW9uICRtZXJnZVRleHROb2Rlcyhub2RlMSwgbm9kZTIpIHtcbiAgY29uc3Qgd3JpdGFibGVOb2RlMSA9IG5vZGUxLm1lcmdlV2l0aFNpYmxpbmcobm9kZTIpO1xuICBjb25zdCBub3JtYWxpemVkTm9kZXMgPSBnZXRBY3RpdmVFZGl0b3IoKS5fbm9ybWFsaXplZE5vZGVzO1xuICBub3JtYWxpemVkTm9kZXMuYWRkKG5vZGUxLl9fa2V5KTtcbiAgbm9ybWFsaXplZE5vZGVzLmFkZChub2RlMi5fX2tleSk7XG4gIHJldHVybiB3cml0YWJsZU5vZGUxO1xufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZVRleHROb2RlKHRleHROb2RlKSB7XG4gIGxldCBub2RlID0gdGV4dE5vZGU7XG4gIGlmIChub2RlLl9fdGV4dCA9PT0gJycgJiYgbm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhbm9kZS5pc1VubWVyZ2VhYmxlKCkpIHtcbiAgICBub2RlLnJlbW92ZSgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEJhY2t3YXJkXG4gIGxldCBwcmV2aW91c05vZGU7XG4gIHdoaWxlICgocHJldmlvdXNOb2RlID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSkgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUocHJldmlvdXNOb2RlKSAmJiBwcmV2aW91c05vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIXByZXZpb3VzTm9kZS5pc1VubWVyZ2VhYmxlKCkpIHtcbiAgICBpZiAocHJldmlvdXNOb2RlLl9fdGV4dCA9PT0gJycpIHtcbiAgICAgIHByZXZpb3VzTm9kZS5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKCRjYW5TaW1wbGVUZXh0Tm9kZXNCZU1lcmdlZChwcmV2aW91c05vZGUsIG5vZGUpKSB7XG4gICAgICBub2RlID0gJG1lcmdlVGV4dE5vZGVzKHByZXZpb3VzTm9kZSwgbm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gRm9yd2FyZFxuICBsZXQgbmV4dE5vZGU7XG4gIHdoaWxlICgobmV4dE5vZGUgPSBub2RlLmdldE5leHRTaWJsaW5nKCkpICE9PSBudWxsICYmICRpc1RleHROb2RlKG5leHROb2RlKSAmJiBuZXh0Tm9kZS5pc1NpbXBsZVRleHQoKSAmJiAhbmV4dE5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgaWYgKG5leHROb2RlLl9fdGV4dCA9PT0gJycpIHtcbiAgICAgIG5leHROb2RlLnJlbW92ZSgpO1xuICAgIH0gZWxzZSBpZiAoJGNhblNpbXBsZVRleHROb2Rlc0JlTWVyZ2VkKG5vZGUsIG5leHROb2RlKSkge1xuICAgICAgbm9kZSA9ICRtZXJnZVRleHROb2Rlcyhub2RlLCBuZXh0Tm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkbm9ybWFsaXplU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAkbm9ybWFsaXplUG9pbnQoc2VsZWN0aW9uLmFuY2hvcik7XG4gICRub3JtYWxpemVQb2ludChzZWxlY3Rpb24uZm9jdXMpO1xuICByZXR1cm4gc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZVBvaW50KHBvaW50KSB7XG4gIHdoaWxlIChwb2ludC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICBjb25zdCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgICBsZXQgbmV4dE5vZGU7XG4gICAgbGV0IG5leHRPZmZzZXRBdEVuZDtcbiAgICBpZiAob2Zmc2V0ID09PSBub2RlLmdldENoaWxkcmVuU2l6ZSgpKSB7XG4gICAgICBuZXh0Tm9kZSA9IG5vZGUuZ2V0Q2hpbGRBdEluZGV4KG9mZnNldCAtIDEpO1xuICAgICAgbmV4dE9mZnNldEF0RW5kID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dE5vZGUgPSBub2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQpO1xuICAgICAgbmV4dE9mZnNldEF0RW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgIHBvaW50LnNldChuZXh0Tm9kZS5fX2tleSwgbmV4dE9mZnNldEF0RW5kID8gbmV4dE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkgOiAwLCAndGV4dCcsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmICghJGlzRWxlbWVudE5vZGUobmV4dE5vZGUpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcG9pbnQuc2V0KG5leHROb2RlLl9fa2V5LCBuZXh0T2Zmc2V0QXRFbmQgPyBuZXh0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA6IDAsICdlbGVtZW50JywgdHJ1ZSk7XG4gIH1cbn1cblxubGV0IHN1YlRyZWVUZXh0Q29udGVudCA9ICcnO1xubGV0IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gJyc7XG5sZXQgc3ViVHJlZVRleHRGb3JtYXQgPSBudWxsO1xubGV0IHN1YlRyZWVUZXh0U3R5bGUgPSAnJztcbmxldCBlZGl0b3JUZXh0Q29udGVudCA9ICcnO1xubGV0IGFjdGl2ZUVkaXRvckNvbmZpZztcbmxldCBhY3RpdmVFZGl0b3IkMTtcbmxldCBhY3RpdmVFZGl0b3JOb2RlcztcbmxldCB0cmVhdEFsbE5vZGVzQXNEaXJ0eSA9IGZhbHNlO1xubGV0IGFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkgPSBmYWxzZTtcbmxldCBhY3RpdmVNdXRhdGlvbkxpc3RlbmVycztcbmxldCBhY3RpdmVUZXh0RGlyZWN0aW9uID0gbnVsbDtcbmxldCBhY3RpdmVEaXJ0eUVsZW1lbnRzO1xubGV0IGFjdGl2ZURpcnR5TGVhdmVzO1xubGV0IGFjdGl2ZVByZXZOb2RlTWFwO1xubGV0IGFjdGl2ZU5leHROb2RlTWFwO1xubGV0IGFjdGl2ZVByZXZLZXlUb0RPTU1hcDtcbmxldCBtdXRhdGVkTm9kZXM7XG5mdW5jdGlvbiBkZXN0cm95Tm9kZShrZXksIHBhcmVudERPTSkge1xuICBjb25zdCBub2RlID0gYWN0aXZlUHJldk5vZGVNYXAuZ2V0KGtleSk7XG4gIGlmIChwYXJlbnRET00gIT09IG51bGwpIHtcbiAgICBjb25zdCBkb20gPSBnZXRQcmV2RWxlbWVudEJ5S2V5T3JUaHJvdyhrZXkpO1xuICAgIGlmIChkb20ucGFyZW50Tm9kZSA9PT0gcGFyZW50RE9NKSB7XG4gICAgICBwYXJlbnRET00ucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIGxvZ2ljIGlzIHJlYWxseSBpbXBvcnRhbnQsIG90aGVyd2lzZSB3ZSB3aWxsIGxlYWsgRE9NIG5vZGVzXG4gIC8vIHdoZW4gdGhlaXIgY29ycmVzcG9uZGluZyBMZXhpY2FsTm9kZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgZWRpdG9yIHN0YXRlLlxuICBpZiAoIWFjdGl2ZU5leHROb2RlTWFwLmhhcyhrZXkpKSB7XG4gICAgYWN0aXZlRWRpdG9yJDEuX2tleVRvRE9NTWFwLmRlbGV0ZShrZXkpO1xuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW5BcnJheShub2RlLCBhY3RpdmVQcmV2Tm9kZU1hcCk7XG4gICAgZGVzdHJveUNoaWxkcmVuKGNoaWxkcmVuLCAwLCBjaGlsZHJlbi5sZW5ndGggLSAxLCBudWxsKTtcbiAgfVxuICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0TXV0YXRlZE5vZGUobXV0YXRlZE5vZGVzLCBhY3RpdmVFZGl0b3JOb2RlcywgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnMsIG5vZGUsICdkZXN0cm95ZWQnKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzdHJveUNoaWxkcmVuKGNoaWxkcmVuLCBfc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRvbSkge1xuICBsZXQgc3RhcnRJbmRleCA9IF9zdGFydEluZGV4O1xuICBmb3IgKDsgc3RhcnRJbmRleCA8PSBlbmRJbmRleDsgKytzdGFydEluZGV4KSB7XG4gICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltzdGFydEluZGV4XTtcbiAgICBpZiAoY2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdHJveU5vZGUoY2hpbGQsIGRvbSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsIHZhbHVlKSB7XG4gIGRvbVN0eWxlLnNldFByb3BlcnR5KCd0ZXh0LWFsaWduJywgdmFsdWUpO1xufVxuY29uc3QgREVGQVVMVF9JTkRFTlRfVkFMVUUgPSAnNDBweCc7XG5mdW5jdGlvbiBzZXRFbGVtZW50SW5kZW50KGRvbSwgaW5kZW50KSB7XG4gIGNvbnN0IGluZGVudENsYXNzTmFtZSA9IGFjdGl2ZUVkaXRvckNvbmZpZy50aGVtZS5pbmRlbnQ7XG4gIGlmICh0eXBlb2YgaW5kZW50Q2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGVsZW1lbnRIYXNDbGFzc05hbWUgPSBkb20uY2xhc3NMaXN0LmNvbnRhaW5zKGluZGVudENsYXNzTmFtZSk7XG4gICAgaWYgKGluZGVudCA+IDAgJiYgIWVsZW1lbnRIYXNDbGFzc05hbWUpIHtcbiAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGluZGVudENsYXNzTmFtZSk7XG4gICAgfSBlbHNlIGlmIChpbmRlbnQgPCAxICYmIGVsZW1lbnRIYXNDbGFzc05hbWUpIHtcbiAgICAgIGRvbS5jbGFzc0xpc3QucmVtb3ZlKGluZGVudENsYXNzTmFtZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGluZGVudGF0aW9uQmFzZVZhbHVlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb20pLmdldFByb3BlcnR5VmFsdWUoJy0tbGV4aWNhbC1pbmRlbnQtYmFzZS12YWx1ZScpIHx8IERFRkFVTFRfSU5ERU5UX1ZBTFVFO1xuICBkb20uc3R5bGUuc2V0UHJvcGVydHkoJ3BhZGRpbmctaW5saW5lLXN0YXJ0JywgaW5kZW50ID09PSAwID8gJycgOiBgY2FsYygke2luZGVudH0gKiAke2luZGVudGF0aW9uQmFzZVZhbHVlfSlgKTtcbn1cbmZ1bmN0aW9uIHNldEVsZW1lbnRGb3JtYXQoZG9tLCBmb3JtYXQpIHtcbiAgY29uc3QgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG4gIGlmIChmb3JtYXQgPT09IDApIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICcnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0xFRlQpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdsZWZ0Jyk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSBJU19BTElHTl9DRU5URVIpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdjZW50ZXInKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX1JJR0hUKSB7XG4gICAgc2V0VGV4dEFsaWduKGRvbVN0eWxlLCAncmlnaHQnKTtcbiAgfSBlbHNlIGlmIChmb3JtYXQgPT09IElTX0FMSUdOX0pVU1RJRlkpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdqdXN0aWZ5Jyk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSBJU19BTElHTl9TVEFSVCkge1xuICAgIHNldFRleHRBbGlnbihkb21TdHlsZSwgJ3N0YXJ0Jyk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ID09PSBJU19BTElHTl9FTkQpIHtcbiAgICBzZXRUZXh0QWxpZ24oZG9tU3R5bGUsICdlbmQnKTtcbiAgfVxufVxuZnVuY3Rpb24gJGNyZWF0ZU5vZGUoa2V5LCBzbG90KSB7XG4gIGNvbnN0IG5vZGUgPSBhY3RpdmVOZXh0Tm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgY3JlYXRlTm9kZTogbm9kZSBkb2VzIG5vdCBleGlzdCBpbiBub2RlTWFwYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRvbSA9IG5vZGUuY3JlYXRlRE9NKGFjdGl2ZUVkaXRvckNvbmZpZywgYWN0aXZlRWRpdG9yJDEpO1xuICBzdG9yZURPTVdpdGhLZXkoa2V5LCBkb20sIGFjdGl2ZUVkaXRvciQxKTtcblxuICAvLyBUaGlzIGhlbHBzIHByZXNlcnZlIHRoZSB0ZXh0LCBhbmQgc3RvcHMgc3BlbGwgY2hlY2sgdG9vbHMgZnJvbVxuICAvLyBtZXJnaW5nIG9yIGJyZWFrIHRoZSBzcGFucyAod2hpY2ggaGFwcGVucyBpZiB0aGV5IGFyZSBtaXNzaW5nXG4gIC8vIHRoaXMgYXR0cmlidXRlKS5cbiAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLXRleHQnLCAndHJ1ZScpO1xuICB9IGVsc2UgaWYgKCRpc0RlY29yYXRvck5vZGUobm9kZSkpIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtZGVjb3JhdG9yJywgJ3RydWUnKTtcbiAgfVxuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBpbmRlbnQgPSBub2RlLl9faW5kZW50O1xuICAgIGNvbnN0IGNoaWxkcmVuU2l6ZSA9IG5vZGUuX19zaXplO1xuICAgIGlmIChpbmRlbnQgIT09IDApIHtcbiAgICAgIHNldEVsZW1lbnRJbmRlbnQoZG9tLCBpbmRlbnQpO1xuICAgIH1cbiAgICBpZiAoY2hpbGRyZW5TaXplICE9PSAwKSB7XG4gICAgICBjb25zdCBlbmRJbmRleCA9IGNoaWxkcmVuU2l6ZSAtIDE7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IGNyZWF0ZUNoaWxkcmVuQXJyYXkobm9kZSwgYWN0aXZlTmV4dE5vZGVNYXApO1xuICAgICAgJGNyZWF0ZUNoaWxkcmVuV2l0aERpcmVjdGlvbihjaGlsZHJlbiwgZW5kSW5kZXgsIG5vZGUsIGRvbSk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdCA9IG5vZGUuX19mb3JtYXQ7XG4gICAgaWYgKGZvcm1hdCAhPT0gMCkge1xuICAgICAgc2V0RWxlbWVudEZvcm1hdChkb20sIGZvcm1hdCk7XG4gICAgfVxuICAgIGlmICghbm9kZS5pc0lubGluZSgpKSB7XG4gICAgICByZWNvbmNpbGVFbGVtZW50VGVybWluYXRpbmdMaW5lQnJlYWsobnVsbCwgbm9kZSwgZG9tKTtcbiAgICB9XG4gICAgaWYgKCR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQobm9kZSkpIHtcbiAgICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBET1VCTEVfTElORV9CUkVBSztcbiAgICAgIGVkaXRvclRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBkZWNvcmF0b3IgPSBub2RlLmRlY29yYXRlKGFjdGl2ZUVkaXRvciQxLCBhY3RpdmVFZGl0b3JDb25maWcpO1xuICAgICAgaWYgKGRlY29yYXRvciAhPT0gbnVsbCkge1xuICAgICAgICByZWNvbmNpbGVEZWNvcmF0b3Ioa2V5LCBkZWNvcmF0b3IpO1xuICAgICAgfVxuICAgICAgLy8gRGVjb3JhdG9ycyBhcmUgYWx3YXlzIG5vbiBlZGl0YWJsZVxuICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9ICdmYWxzZSc7XG4gICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgaWYgKCFub2RlLmlzRGlyZWN0aW9ubGVzcygpKSB7XG4gICAgICAgIHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSB0ZXh0O1xuICAgIGVkaXRvclRleHRDb250ZW50ICs9IHRleHQ7XG4gIH1cbiAgaWYgKHNsb3QgIT09IG51bGwpIHtcbiAgICBzbG90Lmluc2VydENoaWxkKGRvbSk7XG4gIH1cbiAge1xuICAgIC8vIEZyZWV6ZSB0aGUgbm9kZSBpbiBERVYgdG8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uc1xuICAgIE9iamVjdC5mcmVlemUobm9kZSk7XG4gIH1cbiAgc2V0TXV0YXRlZE5vZGUobXV0YXRlZE5vZGVzLCBhY3RpdmVFZGl0b3JOb2RlcywgYWN0aXZlTXV0YXRpb25MaXN0ZW5lcnMsIG5vZGUsICdjcmVhdGVkJyk7XG4gIHJldHVybiBkb207XG59XG5mdW5jdGlvbiAkY3JlYXRlQ2hpbGRyZW5XaXRoRGlyZWN0aW9uKGNoaWxkcmVuLCBlbmRJbmRleCwgZWxlbWVudCwgZG9tKSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJztcbiAgJGNyZWF0ZUNoaWxkcmVuKGNoaWxkcmVuLCBlbGVtZW50LCAwLCBlbmRJbmRleCwgZWxlbWVudC5nZXRET01TbG90KGRvbSkpO1xuICByZWNvbmNpbGVCbG9ja0RpcmVjdGlvbihlbGVtZW50LCBkb20pO1xuICBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudCA9IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQ7XG59XG5mdW5jdGlvbiAkY3JlYXRlQ2hpbGRyZW4oY2hpbGRyZW4sIGVsZW1lbnQsIF9zdGFydEluZGV4LCBlbmRJbmRleCwgc2xvdCkge1xuICBjb25zdCBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudCA9IHN1YlRyZWVUZXh0Q29udGVudDtcbiAgc3ViVHJlZVRleHRDb250ZW50ID0gJyc7XG4gIGxldCBzdGFydEluZGV4ID0gX3N0YXJ0SW5kZXg7XG4gIGZvciAoOyBzdGFydEluZGV4IDw9IGVuZEluZGV4OyArK3N0YXJ0SW5kZXgpIHtcbiAgICAkY3JlYXRlTm9kZShjaGlsZHJlbltzdGFydEluZGV4XSwgc2xvdCk7XG4gICAgY29uc3Qgbm9kZSA9IGFjdGl2ZU5leHROb2RlTWFwLmdldChjaGlsZHJlbltzdGFydEluZGV4XSk7XG4gICAgaWYgKG5vZGUgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGlmIChzdWJUcmVlVGV4dEZvcm1hdCA9PT0gbnVsbCkge1xuICAgICAgICBzdWJUcmVlVGV4dEZvcm1hdCA9IG5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICB9XG4gICAgICBpZiAoc3ViVHJlZVRleHRTdHlsZSA9PT0gJycpIHtcbiAgICAgICAgc3ViVHJlZVRleHRTdHlsZSA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQoZWxlbWVudCkpIHtcbiAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gRE9VQkxFX0xJTkVfQlJFQUs7XG4gIH1cbiAgY29uc3QgZG9tID0gc2xvdC5lbGVtZW50O1xuICBkb20uX19sZXhpY2FsVGV4dENvbnRlbnQgPSBzdWJUcmVlVGV4dENvbnRlbnQ7XG4gIHN1YlRyZWVUZXh0Q29udGVudCA9IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ICsgc3ViVHJlZVRleHRDb250ZW50O1xufVxuZnVuY3Rpb24gaXNMYXN0Q2hpbGRMaW5lQnJlYWtPckRlY29yYXRvcihlbGVtZW50LCBub2RlTWFwKSB7XG4gIGlmIChlbGVtZW50KSB7XG4gICAgY29uc3QgbGFzdEtleSA9IGVsZW1lbnQuX19sYXN0O1xuICAgIGlmIChsYXN0S2V5KSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobGFzdEtleSk7XG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICByZXR1cm4gJGlzTGluZUJyZWFrTm9kZShub2RlKSA/ICdsaW5lLWJyZWFrJyA6ICRpc0RlY29yYXRvck5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpID8gJ2RlY29yYXRvcicgOiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gJ2VtcHR5JztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSWYgd2UgZW5kIGFuIGVsZW1lbnQgd2l0aCBhIExpbmVCcmVha05vZGUsIHRoZW4gd2UgbmVlZCB0byBhZGQgYW4gYWRkaXRpb25hbCA8YnI+XG5mdW5jdGlvbiByZWNvbmNpbGVFbGVtZW50VGVybWluYXRpbmdMaW5lQnJlYWsocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBkb20pIHtcbiAgY29uc3QgcHJldkxpbmVCcmVhayA9IGlzTGFzdENoaWxkTGluZUJyZWFrT3JEZWNvcmF0b3IocHJldkVsZW1lbnQsIGFjdGl2ZVByZXZOb2RlTWFwKTtcbiAgY29uc3QgbmV4dExpbmVCcmVhayA9IGlzTGFzdENoaWxkTGluZUJyZWFrT3JEZWNvcmF0b3IobmV4dEVsZW1lbnQsIGFjdGl2ZU5leHROb2RlTWFwKTtcbiAgaWYgKHByZXZMaW5lQnJlYWsgIT09IG5leHRMaW5lQnJlYWspIHtcbiAgICBuZXh0RWxlbWVudC5nZXRET01TbG90KGRvbSkuc2V0TWFuYWdlZExpbmVCcmVhayhuZXh0TGluZUJyZWFrKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVjb25jaWxlVGV4dEZvcm1hdChlbGVtZW50KSB7XG4gIGlmIChzdWJUcmVlVGV4dEZvcm1hdCAhPSBudWxsICYmIHN1YlRyZWVUZXh0Rm9ybWF0ICE9PSBlbGVtZW50Ll9fdGV4dEZvcm1hdCAmJiAhYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSkge1xuICAgIGVsZW1lbnQuc2V0VGV4dEZvcm1hdChzdWJUcmVlVGV4dEZvcm1hdCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29uY2lsZVRleHRTdHlsZShlbGVtZW50KSB7XG4gIGlmIChzdWJUcmVlVGV4dFN0eWxlICE9PSAnJyAmJiBzdWJUcmVlVGV4dFN0eWxlICE9PSBlbGVtZW50Ll9fdGV4dFN0eWxlICYmICFhY3RpdmVFZGl0b3JTdGF0ZVJlYWRPbmx5KSB7XG4gICAgZWxlbWVudC5zZXRUZXh0U3R5bGUoc3ViVHJlZVRleHRTdHlsZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlY29uY2lsZUJsb2NrRGlyZWN0aW9uKGVsZW1lbnQsIGRvbSkge1xuICBjb25zdCBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudCA9IGRvbS5fX2xleGljYWxEaXJUZXh0Q29udGVudCB8fCAnJztcbiAgY29uc3QgcHJldmlvdXNEaXJlY3Rpb24gPSBkb20uX19sZXhpY2FsRGlyIHx8ICcnO1xuICBpZiAocHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQgIT09IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50IHx8IHByZXZpb3VzRGlyZWN0aW9uICE9PSBhY3RpdmVUZXh0RGlyZWN0aW9uKSB7XG4gICAgY29uc3QgaGFzRW1wdHlEaXJlY3Rpb25lZFRleHRDb250ZW50ID0gc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPT09ICcnO1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGhhc0VtcHR5RGlyZWN0aW9uZWRUZXh0Q29udGVudCA/IGFjdGl2ZVRleHREaXJlY3Rpb24gOiBnZXRUZXh0RGlyZWN0aW9uKHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50KTtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSBwcmV2aW91c0RpcmVjdGlvbikge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZG9tLmNsYXNzTGlzdDtcbiAgICAgIGNvbnN0IHRoZW1lID0gYWN0aXZlRWRpdG9yQ29uZmlnLnRoZW1lO1xuICAgICAgbGV0IHByZXZpb3VzRGlyZWN0aW9uVGhlbWUgPSBwcmV2aW91c0RpcmVjdGlvbiAhPT0gbnVsbCA/IHRoZW1lW3ByZXZpb3VzRGlyZWN0aW9uXSA6IHVuZGVmaW5lZDtcbiAgICAgIGxldCBuZXh0RGlyZWN0aW9uVGhlbWUgPSBkaXJlY3Rpb24gIT09IG51bGwgPyB0aGVtZVtkaXJlY3Rpb25dIDogdW5kZWZpbmVkO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIG9sZCB0aGVtZSBjbGFzc2VzIGlmIHRoZXkgZXhpc3RcbiAgICAgIGlmIChwcmV2aW91c0RpcmVjdGlvblRoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmV2aW91c0RpcmVjdGlvblRoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZXNBcnIgPSBub3JtYWxpemVDbGFzc05hbWVzKHByZXZpb3VzRGlyZWN0aW9uVGhlbWUpO1xuICAgICAgICAgIHByZXZpb3VzRGlyZWN0aW9uVGhlbWUgPSB0aGVtZVtwcmV2aW91c0RpcmVjdGlvbl0gPSBjbGFzc05hbWVzQXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQHRzLWlnbm9yZTogaW50ZW50aW9uYWxcbiAgICAgICAgY2xhc3NMaXN0LnJlbW92ZSguLi5wcmV2aW91c0RpcmVjdGlvblRoZW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IG51bGwgfHwgaGFzRW1wdHlEaXJlY3Rpb25lZFRleHRDb250ZW50ICYmIGRpcmVjdGlvbiA9PT0gJ2x0cicpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGRpcmVjdGlvblxuICAgICAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdkaXInKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFwcGx5IHRoZSBuZXcgdGhlbWUgY2xhc3NlcyBpZiB0aGV5IGV4aXN0XG4gICAgICAgIGlmIChuZXh0RGlyZWN0aW9uVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dERpcmVjdGlvblRoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMobmV4dERpcmVjdGlvblRoZW1lKTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVudGlvbmFsXG4gICAgICAgICAgICBuZXh0RGlyZWN0aW9uVGhlbWUgPSB0aGVtZVtkaXJlY3Rpb25dID0gY2xhc3NOYW1lc0FycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5leHREaXJlY3Rpb25UaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbGFzc0xpc3QuYWRkKC4uLm5leHREaXJlY3Rpb25UaGVtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIGRpcmVjdGlvblxuICAgICAgICBkb20uZGlyID0gZGlyZWN0aW9uO1xuICAgICAgfVxuICAgICAgaWYgKCFhY3RpdmVFZGl0b3JTdGF0ZVJlYWRPbmx5KSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlTm9kZSA9IGVsZW1lbnQuZ2V0V3JpdGFibGUoKTtcbiAgICAgICAgd3JpdGFibGVOb2RlLl9fZGlyID0gZGlyZWN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBhY3RpdmVUZXh0RGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIGRvbS5fX2xleGljYWxEaXJUZXh0Q29udGVudCA9IHN1YlRyZWVEaXJlY3Rpb25lZFRleHRDb250ZW50O1xuICAgIGRvbS5fX2xleGljYWxEaXIgPSBkaXJlY3Rpb247XG4gIH1cbn1cbmZ1bmN0aW9uICRyZWNvbmNpbGVDaGlsZHJlbldpdGhEaXJlY3Rpb24ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBkb20pIHtcbiAgY29uc3QgcHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQgPSBzdWJUcmVlRGlyZWN0aW9uZWRUZXh0Q29udGVudDtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJztcbiAgc3ViVHJlZVRleHRGb3JtYXQgPSBudWxsO1xuICBzdWJUcmVlVGV4dFN0eWxlID0gJyc7XG4gICRyZWNvbmNpbGVDaGlsZHJlbihwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIG5leHRFbGVtZW50LmdldERPTVNsb3QoZG9tKSk7XG4gIHJlY29uY2lsZUJsb2NrRGlyZWN0aW9uKG5leHRFbGVtZW50LCBkb20pO1xuICByZWNvbmNpbGVUZXh0Rm9ybWF0KG5leHRFbGVtZW50KTtcbiAgcmVjb25jaWxlVGV4dFN0eWxlKG5leHRFbGVtZW50KTtcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSBwcmV2aW91c1N1YlRyZWVEaXJlY3Rpb25UZXh0Q29udGVudDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuQXJyYXkoZWxlbWVudCwgbm9kZU1hcCkge1xuICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICBsZXQgbm9kZUtleSA9IGVsZW1lbnQuX19maXJzdDtcbiAgd2hpbGUgKG5vZGVLZXkgIT09IG51bGwpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobm9kZUtleSk7XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGNyZWF0ZUNoaWxkcmVuQXJyYXk6IG5vZGUgZG9lcyBub3QgZXhpc3QgaW4gbm9kZU1hcGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjaGlsZHJlbi5wdXNoKG5vZGVLZXkpO1xuICAgIG5vZGVLZXkgPSBub2RlLl9fbmV4dDtcbiAgfVxuICByZXR1cm4gY2hpbGRyZW47XG59XG5mdW5jdGlvbiAkcmVjb25jaWxlQ2hpbGRyZW4ocHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBzbG90KSB7XG4gIGNvbnN0IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ID0gc3ViVHJlZVRleHRDb250ZW50O1xuICBjb25zdCBwcmV2Q2hpbGRyZW5TaXplID0gcHJldkVsZW1lbnQuX19zaXplO1xuICBjb25zdCBuZXh0Q2hpbGRyZW5TaXplID0gbmV4dEVsZW1lbnQuX19zaXplO1xuICBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcbiAgY29uc3QgZG9tID0gc2xvdC5lbGVtZW50O1xuICBpZiAocHJldkNoaWxkcmVuU2l6ZSA9PT0gMSAmJiBuZXh0Q2hpbGRyZW5TaXplID09PSAxKSB7XG4gICAgY29uc3QgcHJldkZpcnN0Q2hpbGRLZXkgPSBwcmV2RWxlbWVudC5fX2ZpcnN0O1xuICAgIGNvbnN0IG5leHRGaXJzdENoaWxkS2V5ID0gbmV4dEVsZW1lbnQuX19maXJzdDtcbiAgICBpZiAocHJldkZpcnN0Q2hpbGRLZXkgPT09IG5leHRGaXJzdENoaWxkS2V5KSB7XG4gICAgICAkcmVjb25jaWxlTm9kZShwcmV2Rmlyc3RDaGlsZEtleSwgZG9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGFzdERPTSA9IGdldFByZXZFbGVtZW50QnlLZXlPclRocm93KHByZXZGaXJzdENoaWxkS2V5KTtcbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50RE9NID0gJGNyZWF0ZU5vZGUobmV4dEZpcnN0Q2hpbGRLZXksIG51bGwpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9tLnJlcGxhY2VDaGlsZChyZXBsYWNlbWVudERPTSwgbGFzdERPTSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvciAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgbXNnID0gYCR7ZXJyb3IudG9TdHJpbmcoKX0gUGFyZW50OiAke2RvbS50YWdOYW1lfSwgbmV3IGNoaWxkOiB7dGFnOiAke3JlcGxhY2VtZW50RE9NLnRhZ05hbWV9IGtleTogJHtuZXh0Rmlyc3RDaGlsZEtleX19LCBvbGQgY2hpbGQ6IHt0YWc6ICR7bGFzdERPTS50YWdOYW1lfSwga2V5OiAke3ByZXZGaXJzdENoaWxkS2V5fX0uYDtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVzdHJveU5vZGUocHJldkZpcnN0Q2hpbGRLZXksIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBuZXh0Q2hpbGROb2RlID0gYWN0aXZlTmV4dE5vZGVNYXAuZ2V0KG5leHRGaXJzdENoaWxkS2V5KTtcbiAgICBpZiAoJGlzVGV4dE5vZGUobmV4dENoaWxkTm9kZSkpIHtcbiAgICAgIGlmIChzdWJUcmVlVGV4dEZvcm1hdCA9PT0gbnVsbCkge1xuICAgICAgICBzdWJUcmVlVGV4dEZvcm1hdCA9IG5leHRDaGlsZE5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICB9XG4gICAgICBpZiAoc3ViVHJlZVRleHRTdHlsZSA9PT0gJycpIHtcbiAgICAgICAgc3ViVHJlZVRleHRTdHlsZSA9IG5leHRDaGlsZE5vZGUuZ2V0U3R5bGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldkNoaWxkcmVuID0gY3JlYXRlQ2hpbGRyZW5BcnJheShwcmV2RWxlbWVudCwgYWN0aXZlUHJldk5vZGVNYXApO1xuICAgIGNvbnN0IG5leHRDaGlsZHJlbiA9IGNyZWF0ZUNoaWxkcmVuQXJyYXkobmV4dEVsZW1lbnQsIGFjdGl2ZU5leHROb2RlTWFwKTtcbiAgICBpZiAoIShwcmV2Q2hpbGRyZW4ubGVuZ3RoID09PSBwcmV2Q2hpbGRyZW5TaXplKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkcmVjb25jaWxlQ2hpbGRyZW46IHByZXZDaGlsZHJlbi5sZW5ndGggIT09IHByZXZDaGlsZHJlblNpemVgKTtcbiAgICB9XG4gICAgaWYgKCEobmV4dENoaWxkcmVuLmxlbmd0aCA9PT0gbmV4dENoaWxkcmVuU2l6ZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJHJlY29uY2lsZUNoaWxkcmVuOiBuZXh0Q2hpbGRyZW4ubGVuZ3RoICE9PSBuZXh0Q2hpbGRyZW5TaXplYCk7XG4gICAgfVxuICAgIGlmIChwcmV2Q2hpbGRyZW5TaXplID09PSAwKSB7XG4gICAgICBpZiAobmV4dENoaWxkcmVuU2l6ZSAhPT0gMCkge1xuICAgICAgICAkY3JlYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCBuZXh0RWxlbWVudCwgMCwgbmV4dENoaWxkcmVuU2l6ZSAtIDEsIHNsb3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuU2l6ZSA9PT0gMCkge1xuICAgICAgaWYgKHByZXZDaGlsZHJlblNpemUgIT09IDApIHtcbiAgICAgICAgY29uc3QgY2FuVXNlRmFzdFBhdGggPSBzbG90LmFmdGVyID09IG51bGwgJiYgc2xvdC5iZWZvcmUgPT0gbnVsbCAmJiBzbG90LmVsZW1lbnQuX19sZXhpY2FsTGluZUJyZWFrID09IG51bGw7XG4gICAgICAgIGRlc3Ryb3lDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIDAsIHByZXZDaGlsZHJlblNpemUgLSAxLCBjYW5Vc2VGYXN0UGF0aCA/IG51bGwgOiBkb20pO1xuICAgICAgICBpZiAoY2FuVXNlRmFzdFBhdGgpIHtcbiAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIHJlbW92aW5nIERPTSBub2Rlc1xuICAgICAgICAgIGRvbS50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRyZWNvbmNpbGVOb2RlQ2hpbGRyZW4obmV4dEVsZW1lbnQsIHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCBwcmV2Q2hpbGRyZW5TaXplLCBuZXh0Q2hpbGRyZW5TaXplLCBzbG90KTtcbiAgICB9XG4gIH1cbiAgaWYgKCR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQobmV4dEVsZW1lbnQpKSB7XG4gICAgc3ViVHJlZVRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICB9XG4gIGRvbS5fX2xleGljYWxUZXh0Q29udGVudCA9IHN1YlRyZWVUZXh0Q29udGVudDtcbiAgc3ViVHJlZVRleHRDb250ZW50ID0gcHJldmlvdXNTdWJUcmVlVGV4dENvbnRlbnQgKyBzdWJUcmVlVGV4dENvbnRlbnQ7XG59XG5mdW5jdGlvbiAkcmVjb25jaWxlTm9kZShrZXksIHBhcmVudERPTSkge1xuICBjb25zdCBwcmV2Tm9kZSA9IGFjdGl2ZVByZXZOb2RlTWFwLmdldChrZXkpO1xuICBsZXQgbmV4dE5vZGUgPSBhY3RpdmVOZXh0Tm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKHByZXZOb2RlID09PSB1bmRlZmluZWQgfHwgbmV4dE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgcmVjb25jaWxlTm9kZTogcHJldk5vZGUgb3IgbmV4dE5vZGUgZG9lcyBub3QgZXhpc3QgaW4gbm9kZU1hcGApO1xuICAgIH1cbiAgfVxuICBjb25zdCBpc0RpcnR5ID0gdHJlYXRBbGxOb2Rlc0FzRGlydHkgfHwgYWN0aXZlRGlydHlMZWF2ZXMuaGFzKGtleSkgfHwgYWN0aXZlRGlydHlFbGVtZW50cy5oYXMoa2V5KTtcbiAgY29uc3QgZG9tID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhhY3RpdmVFZGl0b3IkMSwga2V5KTtcblxuICAvLyBJZiB0aGUgbm9kZSBrZXkgcG9pbnRzIHRvIHRoZSBzYW1lIGluc3RhbmNlIGluIGJvdGggc3RhdGVzXG4gIC8vIGFuZCBpc24ndCBkaXJ0eSwgd2UganVzdCB1cGRhdGUgdGhlIHRleHQgY29udGVudCBjYWNoZVxuICAvLyBhbmQgcmV0dXJuIHRoZSBleGlzdGluZyBET00gTm9kZS5cbiAgaWYgKHByZXZOb2RlID09PSBuZXh0Tm9kZSAmJiAhaXNEaXJ0eSkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2Tm9kZSkpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ID0gZG9tLl9fbGV4aWNhbFRleHRDb250ZW50O1xuICAgICAgaWYgKHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHByZXZpb3VzU3ViVHJlZVRleHRDb250ZW50O1xuICAgICAgICBlZGl0b3JUZXh0Q29udGVudCArPSBwcmV2aW91c1N1YlRyZWVUZXh0Q29udGVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ID0gZG9tLl9fbGV4aWNhbERpclRleHRDb250ZW50O1xuICAgICAgaWYgKHByZXZpb3VzU3ViVHJlZURpcmVjdGlvblRleHRDb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gcHJldmlvdXNTdWJUcmVlRGlyZWN0aW9uVGV4dENvbnRlbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRleHQgPSBwcmV2Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgaWYgKCRpc1RleHROb2RlKHByZXZOb2RlKSAmJiAhcHJldk5vZGUuaXNEaXJlY3Rpb25sZXNzKCkpIHtcbiAgICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICAgIH1cbiAgICAgIGVkaXRvclRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgICBzdWJUcmVlVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuICAvLyBJZiB0aGUgbm9kZSBrZXkgZG9lc24ndCBwb2ludCB0byB0aGUgc2FtZSBpbnN0YW5jZSBpbiBib3RoIG1hcHMsXG4gIC8vIGl0IHdhcyBjbG9uZWQuIElmIGl0J3MgYWxzbyBkaXJ0eSwgd2UgbWFyayBpdCBhcyBtdXRhdGVkLlxuICBpZiAocHJldk5vZGUgIT09IG5leHROb2RlICYmIGlzRGlydHkpIHtcbiAgICBzZXRNdXRhdGVkTm9kZShtdXRhdGVkTm9kZXMsIGFjdGl2ZUVkaXRvck5vZGVzLCBhY3RpdmVNdXRhdGlvbkxpc3RlbmVycywgbmV4dE5vZGUsICd1cGRhdGVkJyk7XG4gIH1cblxuICAvLyBVcGRhdGUgbm9kZS4gSWYgaXQgcmV0dXJucyB0cnVlLCB3ZSBuZWVkIHRvIHVubW91bnQgYW5kIHJlLWNyZWF0ZSB0aGUgbm9kZVxuICBpZiAobmV4dE5vZGUudXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGFjdGl2ZUVkaXRvckNvbmZpZykpIHtcbiAgICBjb25zdCByZXBsYWNlbWVudERPTSA9ICRjcmVhdGVOb2RlKGtleSwgbnVsbCk7XG4gICAgaWYgKHBhcmVudERPTSA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYHJlY29uY2lsZU5vZGU6IHBhcmVudERPTSBpcyBudWxsYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHBhcmVudERPTS5yZXBsYWNlQ2hpbGQocmVwbGFjZW1lbnRET00sIGRvbSk7XG4gICAgZGVzdHJveU5vZGUoa2V5LCBudWxsKTtcbiAgICByZXR1cm4gcmVwbGFjZW1lbnRET007XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZOb2RlKSAmJiAkaXNFbGVtZW50Tm9kZShuZXh0Tm9kZSkpIHtcbiAgICAvLyBSZWNvbmNpbGUgZWxlbWVudCBjaGlsZHJlblxuICAgIGNvbnN0IG5leHRJbmRlbnQgPSBuZXh0Tm9kZS5fX2luZGVudDtcbiAgICBpZiAobmV4dEluZGVudCAhPT0gcHJldk5vZGUuX19pbmRlbnQpIHtcbiAgICAgIHNldEVsZW1lbnRJbmRlbnQoZG9tLCBuZXh0SW5kZW50KTtcbiAgICB9XG4gICAgY29uc3QgbmV4dEZvcm1hdCA9IG5leHROb2RlLl9fZm9ybWF0O1xuICAgIGlmIChuZXh0Rm9ybWF0ICE9PSBwcmV2Tm9kZS5fX2Zvcm1hdCkge1xuICAgICAgc2V0RWxlbWVudEZvcm1hdChkb20sIG5leHRGb3JtYXQpO1xuICAgIH1cbiAgICBpZiAoaXNEaXJ0eSkge1xuICAgICAgJHJlY29uY2lsZUNoaWxkcmVuV2l0aERpcmVjdGlvbihwcmV2Tm9kZSwgbmV4dE5vZGUsIGRvbSk7XG4gICAgICBpZiAoISRpc1Jvb3ROb2RlKG5leHROb2RlKSAmJiAhbmV4dE5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgICByZWNvbmNpbGVFbGVtZW50VGVybWluYXRpbmdMaW5lQnJlYWsocHJldk5vZGUsIG5leHROb2RlLCBkb20pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJHRleHRDb250ZW50UmVxdWlyZXNEb3VibGVMaW5lYnJlYWtBdEVuZChuZXh0Tm9kZSkpIHtcbiAgICAgIHN1YlRyZWVUZXh0Q29udGVudCArPSBET1VCTEVfTElORV9CUkVBSztcbiAgICAgIGVkaXRvclRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0ZXh0ID0gbmV4dE5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShuZXh0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGRlY29yYXRvciA9IG5leHROb2RlLmRlY29yYXRlKGFjdGl2ZUVkaXRvciQxLCBhY3RpdmVFZGl0b3JDb25maWcpO1xuICAgICAgaWYgKGRlY29yYXRvciAhPT0gbnVsbCkge1xuICAgICAgICByZWNvbmNpbGVEZWNvcmF0b3Ioa2V5LCBkZWNvcmF0b3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJGlzVGV4dE5vZGUobmV4dE5vZGUpICYmICFuZXh0Tm9kZS5pc0RpcmVjdGlvbmxlc3MoKSkge1xuICAgICAgLy8gSGFuZGxlIHRleHQgY29udGVudCwgZm9yIExUUiwgTFRSIGNhc2VzLlxuICAgICAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgICB9XG4gICAgc3ViVHJlZVRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgZWRpdG9yVGV4dENvbnRlbnQgKz0gdGV4dDtcbiAgfVxuICBpZiAoIWFjdGl2ZUVkaXRvclN0YXRlUmVhZE9ubHkgJiYgJGlzUm9vdE5vZGUobmV4dE5vZGUpICYmIG5leHROb2RlLl9fY2FjaGVkVGV4dCAhPT0gZWRpdG9yVGV4dENvbnRlbnQpIHtcbiAgICAvLyBDYWNoZSB0aGUgbGF0ZXN0IHRleHQgY29udGVudC5cbiAgICBjb25zdCBuZXh0Um9vdE5vZGUgPSBuZXh0Tm9kZS5nZXRXcml0YWJsZSgpO1xuICAgIG5leHRSb290Tm9kZS5fX2NhY2hlZFRleHQgPSBlZGl0b3JUZXh0Q29udGVudDtcbiAgICBuZXh0Tm9kZSA9IG5leHRSb290Tm9kZTtcbiAgfVxuICB7XG4gICAgLy8gRnJlZXplIHRoZSBub2RlIGluIERFViB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb25zXG4gICAgT2JqZWN0LmZyZWV6ZShuZXh0Tm9kZSk7XG4gIH1cbiAgcmV0dXJuIGRvbTtcbn1cbmZ1bmN0aW9uIHJlY29uY2lsZURlY29yYXRvcihrZXksIGRlY29yYXRvcikge1xuICBsZXQgcGVuZGluZ0RlY29yYXRvcnMgPSBhY3RpdmVFZGl0b3IkMS5fcGVuZGluZ0RlY29yYXRvcnM7XG4gIGNvbnN0IGN1cnJlbnREZWNvcmF0b3JzID0gYWN0aXZlRWRpdG9yJDEuX2RlY29yYXRvcnM7XG4gIGlmIChwZW5kaW5nRGVjb3JhdG9ycyA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50RGVjb3JhdG9yc1trZXldID09PSBkZWNvcmF0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ0RlY29yYXRvcnMgPSBjbG9uZURlY29yYXRvcnMoYWN0aXZlRWRpdG9yJDEpO1xuICB9XG4gIHBlbmRpbmdEZWNvcmF0b3JzW2tleV0gPSBkZWNvcmF0b3I7XG59XG5mdW5jdGlvbiBnZXROZXh0U2libGluZyhlbGVtZW50KSB7XG4gIGxldCBuZXh0U2libGluZyA9IGVsZW1lbnQubmV4dFNpYmxpbmc7XG4gIGlmIChuZXh0U2libGluZyAhPT0gbnVsbCAmJiBuZXh0U2libGluZyA9PT0gYWN0aXZlRWRpdG9yJDEuX2Jsb2NrQ3Vyc29yRWxlbWVudCkge1xuICAgIG5leHRTaWJsaW5nID0gbmV4dFNpYmxpbmcubmV4dFNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIG5leHRTaWJsaW5nO1xufVxuZnVuY3Rpb24gJHJlY29uY2lsZU5vZGVDaGlsZHJlbihuZXh0RWxlbWVudCwgcHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHByZXZDaGlsZHJlbkxlbmd0aCwgbmV4dENoaWxkcmVuTGVuZ3RoLCBzbG90KSB7XG4gIGNvbnN0IHByZXZFbmRJbmRleCA9IHByZXZDaGlsZHJlbkxlbmd0aCAtIDE7XG4gIGNvbnN0IG5leHRFbmRJbmRleCA9IG5leHRDaGlsZHJlbkxlbmd0aCAtIDE7XG4gIGxldCBwcmV2Q2hpbGRyZW5TZXQ7XG4gIGxldCBuZXh0Q2hpbGRyZW5TZXQ7XG4gIGxldCBzaWJsaW5nRE9NID0gc2xvdC5nZXRGaXJzdENoaWxkKCk7XG4gIGxldCBwcmV2SW5kZXggPSAwO1xuICBsZXQgbmV4dEluZGV4ID0gMDtcbiAgd2hpbGUgKHByZXZJbmRleCA8PSBwcmV2RW5kSW5kZXggJiYgbmV4dEluZGV4IDw9IG5leHRFbmRJbmRleCkge1xuICAgIGNvbnN0IHByZXZLZXkgPSBwcmV2Q2hpbGRyZW5bcHJldkluZGV4XTtcbiAgICBjb25zdCBuZXh0S2V5ID0gbmV4dENoaWxkcmVuW25leHRJbmRleF07XG4gICAgaWYgKHByZXZLZXkgPT09IG5leHRLZXkpIHtcbiAgICAgIHNpYmxpbmdET00gPSBnZXROZXh0U2libGluZygkcmVjb25jaWxlTm9kZShuZXh0S2V5LCBzbG90LmVsZW1lbnQpKTtcbiAgICAgIHByZXZJbmRleCsrO1xuICAgICAgbmV4dEluZGV4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcmV2Q2hpbGRyZW5TZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcmV2Q2hpbGRyZW5TZXQgPSBuZXcgU2V0KHByZXZDaGlsZHJlbik7XG4gICAgICB9XG4gICAgICBpZiAobmV4dENoaWxkcmVuU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuU2V0ID0gbmV3IFNldChuZXh0Q2hpbGRyZW4pO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dEhhc1ByZXZLZXkgPSBuZXh0Q2hpbGRyZW5TZXQuaGFzKHByZXZLZXkpO1xuICAgICAgY29uc3QgcHJldkhhc05leHRLZXkgPSBwcmV2Q2hpbGRyZW5TZXQuaGFzKG5leHRLZXkpO1xuICAgICAgaWYgKCFuZXh0SGFzUHJldktleSkge1xuICAgICAgICAvLyBSZW1vdmUgcHJldlxuICAgICAgICBzaWJsaW5nRE9NID0gZ2V0TmV4dFNpYmxpbmcoZ2V0UHJldkVsZW1lbnRCeUtleU9yVGhyb3cocHJldktleSkpO1xuICAgICAgICBkZXN0cm95Tm9kZShwcmV2S2V5LCBzbG90LmVsZW1lbnQpO1xuICAgICAgICBwcmV2SW5kZXgrKztcbiAgICAgIH0gZWxzZSBpZiAoIXByZXZIYXNOZXh0S2V5KSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXh0XG4gICAgICAgICRjcmVhdGVOb2RlKG5leHRLZXksIHNsb3Qud2l0aEJlZm9yZShzaWJsaW5nRE9NKSk7XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTW92ZSBuZXh0XG4gICAgICAgIGNvbnN0IGNoaWxkRE9NID0gZ2V0RWxlbWVudEJ5S2V5T3JUaHJvdyhhY3RpdmVFZGl0b3IkMSwgbmV4dEtleSk7XG4gICAgICAgIGlmIChjaGlsZERPTSA9PT0gc2libGluZ0RPTSkge1xuICAgICAgICAgIHNpYmxpbmdET00gPSBnZXROZXh0U2libGluZygkcmVjb25jaWxlTm9kZShuZXh0S2V5LCBzbG90LmVsZW1lbnQpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzbG90LndpdGhCZWZvcmUoc2libGluZ0RPTSkuaW5zZXJ0Q2hpbGQoY2hpbGRET00pO1xuICAgICAgICAgICRyZWNvbmNpbGVOb2RlKG5leHRLZXksIHNsb3QuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkluZGV4Kys7XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub2RlID0gYWN0aXZlTmV4dE5vZGVNYXAuZ2V0KG5leHRLZXkpO1xuICAgIGlmIChub2RlICE9PSBudWxsICYmICRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBpZiAoc3ViVHJlZVRleHRGb3JtYXQgPT09IG51bGwpIHtcbiAgICAgICAgc3ViVHJlZVRleHRGb3JtYXQgPSBub2RlLmdldEZvcm1hdCgpO1xuICAgICAgfVxuICAgICAgaWYgKHN1YlRyZWVUZXh0U3R5bGUgPT09ICcnKSB7XG4gICAgICAgIHN1YlRyZWVUZXh0U3R5bGUgPSBub2RlLmdldFN0eWxlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGFwcGVuZE5ld0NoaWxkcmVuID0gcHJldkluZGV4ID4gcHJldkVuZEluZGV4O1xuICBjb25zdCByZW1vdmVPbGRDaGlsZHJlbiA9IG5leHRJbmRleCA+IG5leHRFbmRJbmRleDtcbiAgaWYgKGFwcGVuZE5ld0NoaWxkcmVuICYmICFyZW1vdmVPbGRDaGlsZHJlbikge1xuICAgIGNvbnN0IHByZXZpb3VzTm9kZSA9IG5leHRDaGlsZHJlbltuZXh0RW5kSW5kZXggKyAxXTtcbiAgICBjb25zdCBpbnNlcnRET00gPSBwcmV2aW91c05vZGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhY3RpdmVFZGl0b3IkMS5nZXRFbGVtZW50QnlLZXkocHJldmlvdXNOb2RlKTtcbiAgICAkY3JlYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCBuZXh0RWxlbWVudCwgbmV4dEluZGV4LCBuZXh0RW5kSW5kZXgsIHNsb3Qud2l0aEJlZm9yZShpbnNlcnRET00pKTtcbiAgfSBlbHNlIGlmIChyZW1vdmVPbGRDaGlsZHJlbiAmJiAhYXBwZW5kTmV3Q2hpbGRyZW4pIHtcbiAgICBkZXN0cm95Q2hpbGRyZW4ocHJldkNoaWxkcmVuLCBwcmV2SW5kZXgsIHByZXZFbmRJbmRleCwgc2xvdC5lbGVtZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gJHJlY29uY2lsZVJvb3QocHJldkVkaXRvclN0YXRlLCBuZXh0RWRpdG9yU3RhdGUsIGVkaXRvciwgZGlydHlUeXBlLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcykge1xuICAvLyBXZSBjYWNoZSB0ZXh0IGNvbnRlbnQgdG8gbWFrZSByZXRyaWV2YWwgbW9yZSBlZmZpY2llbnQuXG4gIC8vIFRoZSBjYWNoZSBtdXN0IGJlIHJlYnVpbHQgZHVyaW5nIHJlY29uY2lsaWF0aW9uIHRvIGFjY291bnQgZm9yIGFueSBjaGFuZ2VzLlxuICBzdWJUcmVlVGV4dENvbnRlbnQgPSAnJztcbiAgZWRpdG9yVGV4dENvbnRlbnQgPSAnJztcbiAgc3ViVHJlZURpcmVjdGlvbmVkVGV4dENvbnRlbnQgPSAnJztcbiAgLy8gUmF0aGVyIHRoYW4gcGFzcyBhcm91bmQgYSBsb2FkIG9mIGFyZ3VtZW50cyB0aHJvdWdoIHRoZSBzdGFjayByZWN1cnNpdmVseVxuICAvLyB3ZSBpbnN0ZWFkIHNldCB0aGVtIGFzIGJpbmRpbmdzIHdpdGhpbiB0aGUgc2NvcGUgb2YgdGhlIG1vZHVsZS5cbiAgdHJlYXRBbGxOb2Rlc0FzRGlydHkgPSBkaXJ0eVR5cGUgPT09IEZVTExfUkVDT05DSUxFO1xuICBhY3RpdmVUZXh0RGlyZWN0aW9uID0gbnVsbDtcbiAgYWN0aXZlRWRpdG9yJDEgPSBlZGl0b3I7XG4gIGFjdGl2ZUVkaXRvckNvbmZpZyA9IGVkaXRvci5fY29uZmlnO1xuICBhY3RpdmVFZGl0b3JOb2RlcyA9IGVkaXRvci5fbm9kZXM7XG4gIGFjdGl2ZU11dGF0aW9uTGlzdGVuZXJzID0gYWN0aXZlRWRpdG9yJDEuX2xpc3RlbmVycy5tdXRhdGlvbjtcbiAgYWN0aXZlRGlydHlFbGVtZW50cyA9IGRpcnR5RWxlbWVudHM7XG4gIGFjdGl2ZURpcnR5TGVhdmVzID0gZGlydHlMZWF2ZXM7XG4gIGFjdGl2ZVByZXZOb2RlTWFwID0gcHJldkVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBhY3RpdmVOZXh0Tm9kZU1hcCA9IG5leHRFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgYWN0aXZlRWRpdG9yU3RhdGVSZWFkT25seSA9IG5leHRFZGl0b3JTdGF0ZS5fcmVhZE9ubHk7XG4gIGFjdGl2ZVByZXZLZXlUb0RPTU1hcCA9IG5ldyBNYXAoZWRpdG9yLl9rZXlUb0RPTU1hcCk7XG4gIC8vIFdlIGtlZXAgdHJhY2sgb2YgbXV0YXRlZCBub2RlcyBzbyB3ZSBjYW4gdHJpZ2dlciBtdXRhdGlvblxuICAvLyBsaXN0ZW5lcnMgbGF0ZXIgaW4gdGhlIHVwZGF0ZSBjeWNsZS5cbiAgY29uc3QgY3VycmVudE11dGF0ZWROb2RlcyA9IG5ldyBNYXAoKTtcbiAgbXV0YXRlZE5vZGVzID0gY3VycmVudE11dGF0ZWROb2RlcztcbiAgJHJlY29uY2lsZU5vZGUoJ3Jvb3QnLCBudWxsKTtcbiAgLy8gV2UgZG9uJ3Qgd2FudCBhIGJ1bmNoIG9mIHZvaWQgY2hlY2tzIHRocm91Z2hvdXQgdGhlIHNjb3BlXG4gIC8vIHNvIGluc3RlYWQgd2UgbWFrZSBpdCBzZWVtIHRoYXQgdGhlc2UgdmFsdWVzIGFyZSBhbHdheXMgc2V0LlxuICAvLyBXZSBhbHNvIHdhbnQgdG8gbWFrZSBzdXJlIHdlIGNsZWFyIHRoZW0gZG93biwgb3RoZXJ3aXNlIHdlXG4gIC8vIGNhbiBsZWFrIG1lbW9yeS5cbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVFZGl0b3IkMSA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVFZGl0b3JOb2RlcyA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVEaXJ0eUVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAvLyBAdHMtaWdub3JlXG4gIGFjdGl2ZURpcnR5TGVhdmVzID0gdW5kZWZpbmVkO1xuICAvLyBAdHMtaWdub3JlXG4gIGFjdGl2ZVByZXZOb2RlTWFwID0gdW5kZWZpbmVkO1xuICAvLyBAdHMtaWdub3JlXG4gIGFjdGl2ZU5leHROb2RlTWFwID0gdW5kZWZpbmVkO1xuICAvLyBAdHMtaWdub3JlXG4gIGFjdGl2ZUVkaXRvckNvbmZpZyA9IHVuZGVmaW5lZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBhY3RpdmVQcmV2S2V5VG9ET01NYXAgPSB1bmRlZmluZWQ7XG4gIC8vIEB0cy1pZ25vcmVcbiAgbXV0YXRlZE5vZGVzID0gdW5kZWZpbmVkO1xuICByZXR1cm4gY3VycmVudE11dGF0ZWROb2Rlcztcbn1cbmZ1bmN0aW9uIHN0b3JlRE9NV2l0aEtleShrZXksIGRvbSwgZWRpdG9yKSB7XG4gIGNvbnN0IGtleVRvRE9NTWFwID0gZWRpdG9yLl9rZXlUb0RPTU1hcDtcbiAgc2V0Tm9kZUtleU9uRE9NTm9kZShkb20sIGVkaXRvciwga2V5KTtcbiAga2V5VG9ET01NYXAuc2V0KGtleSwgZG9tKTtcbn1cbmZ1bmN0aW9uIGdldFByZXZFbGVtZW50QnlLZXlPclRocm93KGtleSkge1xuICBjb25zdCBlbGVtZW50ID0gYWN0aXZlUHJldktleVRvRE9NTWFwLmdldChrZXkpO1xuICBpZiAoZWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBSZWNvbmNpbGlhdGlvbjogY291bGQgbm90IGZpbmQgRE9NIGVsZW1lbnQgZm9yIG5vZGUga2V5ICR7a2V5fWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKkBfX0lOTElORV9fKi9cbmZ1bmN0aW9uIHdhcm5Pbmx5T25jZShtZXNzYWdlKSB7XG4gIHtcbiAgICBsZXQgcnVuID0gZmFsc2U7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmICghcnVuKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHJ1biA9IHRydWU7XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1hbmQodHlwZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGVcbiAgfTtcbn1cbmNvbnN0IFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1NFTEVDVElPTl9DSEFOR0VfQ09NTUFORCcpO1xuY29uc3QgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1NFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQnKTtcbmNvbnN0IENMSUNLX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDTElDS19DT01NQU5EJyk7XG4vKipcbiAqIERpc3BhdGNoZWQgdG8gZGVsZXRlIGEgY2hhcmFjdGVyLCB0aGUgcGF5bG9hZCB3aWxsIGJlIGB0cnVlYCBpZiB0aGUgZGVsZXRpb25cbiAqIGlzIGJhY2t3YXJkcyAoYmFja3NwYWNlIG9yIGRlbGV0ZSBvbiBtYWNPUykgYW5kIGBmYWxzZWAgaWYgZm9yd2FyZHNcbiAqIChkZWxldGUgb3IgRm4rRGVsZXRlIG9uIG1hY09TKS5cbiAqL1xuY29uc3QgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5EJyk7XG4vKipcbiAqIERpc3BhdGNoZWQgdG8gaW5zZXJ0IGEgbGluZSBicmVhay4gV2l0aCBhIGZhbHNlIHBheWxvYWQgdGhlXG4gKiBjdXJzb3IgbW92ZXMgdG8gdGhlIG5ldyBsaW5lIChTaGlmdCtFbnRlciksIHdpdGggYSB0cnVlIHBheWxvYWQgdGhlIGN1cnNvclxuICogZG9lcyBub3QgbW92ZSAoQ3RybCtPIG9uIG1hY09TKS5cbiAqL1xuY29uc3QgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCcpO1xuY29uc3QgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5EJyk7XG5jb25zdCBQQVNURV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnUEFTVEVfQ09NTUFORCcpO1xuY29uc3QgUkVNT1ZFX1RFWFRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1JFTU9WRV9URVhUX0NPTU1BTkQnKTtcbi8qKlxuICogRGlzcGF0Y2hlZCB0byBkZWxldGUgYSB3b3JkLCB0aGUgcGF5bG9hZCB3aWxsIGJlIGB0cnVlYCBpZiB0aGUgZGVsZXRpb24gaXNcbiAqIGJhY2t3YXJkcyAoQ3RybCtCYWNrc3BhY2Ugb3IgT3B0K0RlbGV0ZSBvbiBtYWNPUyksIGFuZCBgZmFsc2VgIGlmXG4gKiBmb3J3YXJkcyAoQ3RybCtEZWxldGUgb3IgRm4rT3B0K0RlbGV0ZSBvbiBtYWNPUykuXG4gKi9cbmNvbnN0IERFTEVURV9XT1JEX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdERUxFVEVfV09SRF9DT01NQU5EJyk7XG4vKipcbiAqIERpc3BhdGNoZWQgdG8gZGVsZXRlIGEgbGluZSwgdGhlIHBheWxvYWQgd2lsbCBiZSBgdHJ1ZWAgaWYgdGhlIGRlbGV0aW9uIGlzXG4gKiBiYWNrd2FyZHMgKENtZCtEZWxldGUgb24gbWFjT1MpLCBhbmQgYGZhbHNlYCBpZiBmb3J3YXJkc1xuICogKEZuK0NtZCtEZWxldGUgb24gbWFjT1MpLlxuICovXG5jb25zdCBERUxFVEVfTElORV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnREVMRVRFX0xJTkVfQ09NTUFORCcpO1xuLyoqXG4gKiBEaXNwYXRjaGVkIHRvIGZvcm1hdCB0aGUgc2VsZWN0ZWQgdGV4dC5cbiAqL1xuY29uc3QgRk9STUFUX1RFWFRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0ZPUk1BVF9URVhUX0NPTU1BTkQnKTtcbi8qKlxuICogRGlzcGF0Y2hlZCBvbiB1bmRvIChDbWQrWiBvbiBtYWNPUywgQ3RybCtaIGVsc2V3aGVyZSkuXG4gKi9cbmNvbnN0IFVORE9fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1VORE9fQ09NTUFORCcpO1xuLyoqXG4gKiBEaXNwYXRjaGVkIG9uIHJlZG8gKFNoaWZ0K0NtZCtaIG9uIG1hY09TLCBTaGlmdCtDdHJsK1ogb3IgQ3RybCtZIGVsc2V3aGVyZSkuXG4gKi9cbmNvbnN0IFJFRE9fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1JFRE9fQ09NTUFORCcpO1xuLyoqXG4gKiBEaXNwYXRjaGVkIHdoZW4gYW55IGtleSBpcyBwcmVzc2VkLlxuICovXG5jb25zdCBLRVlfRE9XTl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZRE9XTl9DT01NQU5EJyk7XG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiB0aGUgYCdBcnJvd1JpZ2h0J2Aga2V5IGlzIHByZXNzZWQuXG4gKiBUaGUgc2hpZnQgbW9kaWZpZXIga2V5IG1heSBhbHNvIGJlIGRvd24uXG4gKi9cbmNvbnN0IEtFWV9BUlJPV19SSUdIVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQnKTtcbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3ZlIHRvIGVuZCBrZXlib2FyZCBzaG9ydGN1dCBpcyBwcmVzc2VkLFxuICogKENtZCtSaWdodCBvbiBtYWNPUzsgQ3RybCtSaWdodCBlbHNld2hlcmUpLlxuICovXG5jb25zdCBNT1ZFX1RPX0VORCA9IGNyZWF0ZUNvbW1hbmQoJ01PVkVfVE9fRU5EJyk7XG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiB0aGUgYCdBcnJvd0xlZnQnYCBrZXkgaXMgcHJlc3NlZC5cbiAqIFRoZSBzaGlmdCBtb2RpZmllciBrZXkgbWF5IGFsc28gYmUgZG93bi5cbiAqL1xuY29uc3QgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9BUlJPV19MRUZUX0NPTU1BTkQnKTtcbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBtb3ZlIHRvIHN0YXJ0IGtleWJvYXJkIHNob3J0Y3V0IGlzIHByZXNzZWQsXG4gKiAoQ21kK0xlZnQgb24gbWFjT1M7IEN0cmwrTGVmdCBlbHNld2hlcmUpLlxuICovXG5jb25zdCBNT1ZFX1RPX1NUQVJUID0gY3JlYXRlQ29tbWFuZCgnTU9WRV9UT19TVEFSVCcpO1xuLyoqXG4gKiBEaXNwYXRjaGVkIHdoZW4gdGhlIGAnQXJyb3dVcCdgIGtleSBpcyBwcmVzc2VkLlxuICogVGhlIHNoaWZ0IGFuZC9vciBhbHQgKG9wdGlvbikgbW9kaWZpZXIga2V5cyBtYXkgYWxzbyBiZSBkb3duLlxuICovXG5jb25zdCBLRVlfQVJST1dfVVBfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9BUlJPV19VUF9DT01NQU5EJyk7XG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbiB0aGUgYCdBcnJvd0Rvd24nYCBrZXkgaXMgcHJlc3NlZC5cbiAqIFRoZSBzaGlmdCBhbmQvb3IgYWx0IChvcHRpb24pIG1vZGlmaWVyIGtleXMgbWF5IGFsc28gYmUgZG93bi5cbiAqL1xuY29uc3QgS0VZX0FSUk9XX0RPV05fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9BUlJPV19ET1dOX0NPTU1BTkQnKTtcbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuIHRoZSBlbnRlciBrZXkgaXMgcHJlc3NlZCwgbWF5IGFsc28gYmUgY2FsbGVkIHdpdGggYSBudWxsXG4gKiBwYXlsb2FkIHdoZW4gdGhlIGludGVudCBpcyB0byBpbnNlcnQgYSBuZXdsaW5lLiBUaGUgc2hpZnQgbW9kaWZpZXIga2V5XG4gKiBtdXN0IGJlIGRvd24sIGFueSBvdGhlciBtb2RpZmllciBrZXlzIG1heSBhbHNvIGJlIGRvd24uXG4gKi9cbmNvbnN0IEtFWV9FTlRFUl9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0VOVEVSX0NPTU1BTkQnKTtcbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuZXZlciB0aGUgc3BhY2UgKGAnICdgKSBrZXkgaXMgcHJlc3NlZCwgYW55IG1vZGlmaWVyXG4gKiBrZXlzIG1heSBiZSBkb3duLlxuICovXG5jb25zdCBLRVlfU1BBQ0VfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0tFWV9TUEFDRV9DT01NQU5EJyk7XG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbmV2ZXIgdGhlIGAnQmFja3NwYWNlJ2Aga2V5IGlzIHByZXNzZWQsIHRoZSBzaGlmdFxuICogbW9kaWZpZXIga2V5IG1heSBiZSBkb3duLlxuICovXG5jb25zdCBLRVlfQkFDS1NQQUNFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfQkFDS1NQQUNFX0NPTU1BTkQnKTtcbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuZXZlciB0aGUgYCdFc2NhcGUnYCBrZXkgaXMgcHJlc3NlZCwgYW55IG1vZGlmaWVyXG4gKiBrZXlzIG1heSBiZSBkb3duLlxuICovXG5jb25zdCBLRVlfRVNDQVBFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfRVNDQVBFX0NPTU1BTkQnKTtcbi8qKlxuICogRGlzcGF0Y2hlZCB3aGVuZXZlciB0aGUgYCdEZWxldGUnYCBrZXkgaXMgcHJlc3NlZCAoRm4rRGVsZXRlIG9uIG1hY09TKS5cbiAqL1xuY29uc3QgS0VZX0RFTEVURV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnS0VZX0RFTEVURV9DT01NQU5EJyk7XG4vKipcbiAqIERpc3BhdGNoZWQgd2hlbmV2ZXIgdGhlIGAnVGFiJ2Aga2V5IGlzIHByZXNzZWQuIFRoZSBzaGlmdCBtb2RpZmllciBrZXlcbiAqIG1heSBiZSBkb3duLlxuICovXG5jb25zdCBLRVlfVEFCX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfVEFCX0NPTU1BTkQnKTtcbmNvbnN0IElOU0VSVF9UQUJfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9UQUJfQ09NTUFORCcpO1xuY29uc3QgSU5ERU5UX0NPTlRFTlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOREVOVF9DT05URU5UX0NPTU1BTkQnKTtcbmNvbnN0IE9VVERFTlRfQ09OVEVOVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnT1VUREVOVF9DT05URU5UX0NPTU1BTkQnKTtcbmNvbnN0IERST1BfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0RST1BfQ09NTUFORCcpO1xuY29uc3QgRk9STUFUX0VMRU1FTlRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0ZPUk1BVF9FTEVNRU5UX0NPTU1BTkQnKTtcbmNvbnN0IERSQUdTVEFSVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnRFJBR1NUQVJUX0NPTU1BTkQnKTtcbmNvbnN0IERSQUdPVkVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdEUkFHT1ZFUl9DT01NQU5EJyk7XG5jb25zdCBEUkFHRU5EX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdEUkFHRU5EX0NPTU1BTkQnKTtcbi8qKlxuICogRGlzcGF0Y2hlZCBvbiBhIGNvcHkgZXZlbnQsIGVpdGhlciB2aWEgdGhlIGNsaXBib2FyZCBvciBhIEtleWJvYXJkRXZlbnRcbiAqIChDbWQrQyBvbiBtYWNPUywgQ3RybCtDIGVsc2V3aGVyZSkuXG4gKi9cbmNvbnN0IENPUFlfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NPUFlfQ09NTUFORCcpO1xuLyoqXG4gKiBEaXNwYXRjaGVkIG9uIGEgY3V0IGV2ZW50LCBlaXRoZXIgdmlhIHRoZSBjbGlwYm9hcmQgb3IgYSBLZXlib2FyZEV2ZW50XG4gKiAoQ21kK1ggb24gbWFjT1MsIEN0cmwrWCBlbHNld2hlcmUpLlxuICovXG5jb25zdCBDVVRfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NVVF9DT01NQU5EJyk7XG4vKipcbiAqIERpc3BhdGNoZWQgb24gdGhlIHNlbGVjdCBhbGwga2V5Ym9hcmQgc2hvcnRjdXRcbiAqIChDbWQrQSBvbiBtYWNPUywgQ3RybCtBIGVsc2Vod2VyZSkuXG4gKi9cbmNvbnN0IFNFTEVDVF9BTExfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ1NFTEVDVF9BTExfQ09NTUFORCcpO1xuY29uc3QgQ0xFQVJfRURJVE9SX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdDTEVBUl9FRElUT1JfQ09NTUFORCcpO1xuY29uc3QgQ0xFQVJfSElTVE9SWV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0xFQVJfSElTVE9SWV9DT01NQU5EJyk7XG5jb25zdCBDQU5fUkVET19DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnQ0FOX1JFRE9fQ09NTUFORCcpO1xuY29uc3QgQ0FOX1VORE9fQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0NBTl9VTkRPX0NPTU1BTkQnKTtcbmNvbnN0IEZPQ1VTX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdGT0NVU19DT01NQU5EJyk7XG5jb25zdCBCTFVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdCTFVSX0NPTU1BTkQnKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgaW4gdjAuMzEuMCwgdXNlIEtFWV9ET1dOX0NPTU1BTkQgYW5kIGNoZWNrIGZvciBtb2RpZmllcnNcbiAqIGRpcmVjdGx5LlxuICpcbiAqIERpc3BhdGNoZWQgYWZ0ZXIgYW55IEtleWJvYXJkRXZlbnQgd2hlbiBtb2RpZmllcnMgYXJlIHByZXNzZWRcbiAqL1xuY29uc3QgS0VZX01PRElGSUVSX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdLRVlfTU9ESUZJRVJfQ09NTUFORCcpO1xuXG5jb25zdCBQQVNTX1RIUk9VR0hfQ09NTUFORCA9IE9iamVjdC5mcmVlemUoe30pO1xuY29uc3QgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZID0gMzA7XG5jb25zdCByb290RWxlbWVudEV2ZW50cyA9IFtbJ2tleWRvd24nLCBvbktleURvd25dLCBbJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93bl0sIFsnY29tcG9zaXRpb25zdGFydCcsIG9uQ29tcG9zaXRpb25TdGFydF0sIFsnY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kXSwgWydpbnB1dCcsIG9uSW5wdXRdLCBbJ2NsaWNrJywgb25DbGlja10sIFsnY3V0JywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2NvcHknLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnZHJhZ3N0YXJ0JywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2RyYWdvdmVyJywgUEFTU19USFJPVUdIX0NPTU1BTkRdLCBbJ2RyYWdlbmQnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsncGFzdGUnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnZm9jdXMnLCBQQVNTX1RIUk9VR0hfQ09NTUFORF0sIFsnYmx1cicsIFBBU1NfVEhST1VHSF9DT01NQU5EXSwgWydkcm9wJywgUEFTU19USFJPVUdIX0NPTU1BTkRdXTtcbmlmIChDQU5fVVNFX0JFRk9SRV9JTlBVVCkge1xuICByb290RWxlbWVudEV2ZW50cy5wdXNoKFsnYmVmb3JlaW5wdXQnLCAoZXZlbnQsIGVkaXRvcikgPT4gb25CZWZvcmVJbnB1dChldmVudCwgZWRpdG9yKV0pO1xufVxubGV0IGxhc3RLZXlEb3duVGltZVN0YW1wID0gMDtcbmxldCBsYXN0S2V5Q29kZSA9IG51bGw7XG5sZXQgbGFzdEJlZm9yZUlucHV0SW5zZXJ0VGV4dFRpbWVTdGFtcCA9IDA7XG5sZXQgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgPSBudWxsO1xuY29uc3Qgcm9vdEVsZW1lbnRzUmVnaXN0ZXJlZCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlID0gZmFsc2U7XG5sZXQgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duID0gZmFsc2U7XG5sZXQgaXNJbnNlcnRMaW5lQnJlYWsgPSBmYWxzZTtcbmxldCBpc0ZpcmVmb3hFbmRpbmdDb21wb3NpdGlvbiA9IGZhbHNlO1xubGV0IGlzU2FmYXJpRW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbmxldCBzYWZhcmlFbmRDb21wb3NpdGlvbkV2ZW50RGF0YSA9ICcnO1xubGV0IHBvc3REZWxldGVTZWxlY3Rpb25Ub1Jlc3RvcmUgPSBudWxsO1xubGV0IGNvbGxhcHNlZFNlbGVjdGlvbkZvcm1hdCA9IFswLCAnJywgMCwgJ3Jvb3QnLCAwXTtcblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGRldGVybWluZSBpZiBMZXhpY2FsIHNob3VsZCBhdHRlbXB0IHRvIG92ZXJyaWRlXG4vLyB0aGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIGZvciBpbnNlcnRpb24gb2YgdGV4dCBhbmQgdXNlIGl0cyBvd24gaW50ZXJuYWxcbi8vIGhldXJpc3RpY3MuIFRoaXMgaXMgYW4gZXh0cmVtZWx5IGltcG9ydGFudCBmdW5jdGlvbiwgYW5kIG1ha2VzIG11Y2ggb2YgTGV4aWNhbFxuLy8gd29yayBhcyBpbnRlbmRlZCBiZXR3ZWVuIGRpZmZlcmVudCBicm93c2VycyBhbmQgYWNyb3NzIHdvcmQsIGxpbmUgYW5kIGNoYXJhY3RlclxuLy8gYm91bmRhcnkvZm9ybWF0cy4gSXQgYWxzbyBpcyBpbXBvcnRhbnQgZm9yIHRleHQgcmVwbGFjZW1lbnQsIG5vZGUgc2NoZW1hcyBhbmRcbi8vIGNvbXBvc2l0aW9uIG1lY2hhbmljcy5cbmZ1bmN0aW9uICRzaG91bGRQcmV2ZW50RGVmYXVsdEFuZEluc2VydFRleHQoc2VsZWN0aW9uLCBkb21UYXJnZXRSYW5nZSwgdGV4dCwgdGltZVN0YW1wLCBpc0JlZm9yZUlucHV0KSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihnZXRXaW5kb3coZWRpdG9yKSk7XG4gIGNvbnN0IGRvbUFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24gIT09IG51bGwgPyBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSA6IG51bGw7XG4gIGNvbnN0IGFuY2hvcktleSA9IGFuY2hvci5rZXk7XG4gIGNvbnN0IGJhY2tpbmdBbmNob3JFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JLZXkpO1xuICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gIHJldHVybiBhbmNob3JLZXkgIT09IGZvY3VzLmtleSB8fFxuICAvLyBJZiB3ZSdyZSB3b3JraW5nIHdpdGggYSBub24tdGV4dCBub2RlLlxuICAhJGlzVGV4dE5vZGUoYW5jaG9yTm9kZSkgfHxcbiAgLy8gSWYgd2UgYXJlIHJlcGxhY2luZyBhIHJhbmdlIHdpdGggYSBzaW5nbGUgY2hhcmFjdGVyIG9yIGdyYXBoZW1lLCBhbmQgbm90IGNvbXBvc2luZy5cbiAgKCFpc0JlZm9yZUlucHV0ICYmICghQ0FOX1VTRV9CRUZPUkVfSU5QVVQgfHxcbiAgLy8gV2UgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGhhcyBiZWVuXG4gIC8vIGEgcmVjZW50IGJlZm9yZWlucHV0IGV2ZW50IGZvciBcInRleHRJbnB1dFwiLiBJZiB0aGVyZSBoYXMgYmVlbiBvbmUgaW4gdGhlIGxhc3RcbiAgLy8gNTBtcyB0aGVuIHdlIHByb2NlZWQgYXMgbm9ybWFsLiBIb3dldmVyLCBpZiB0aGVyZSBpcyBub3QsIHRoZW4gdGhpcyBpcyBsaWtlbHlcbiAgLy8gYSBkYW5nbGluZyBgaW5wdXRgIGV2ZW50IGNhdXNlZCBieSBleGVjQ29tbWFuZCgnaW5zZXJ0VGV4dCcpLlxuICBsYXN0QmVmb3JlSW5wdXRJbnNlcnRUZXh0VGltZVN0YW1wIDwgdGltZVN0YW1wICsgNTApIHx8IGFuY2hvck5vZGUuaXNEaXJ0eSgpICYmIHRleHRMZW5ndGggPCAyIHx8XG4gIC8vIFRPRE8gY29uc2lkZXIgaWYgdGhlcmUgYXJlIG90aGVyIHNjZW5hcmlvcyB3aGVuIG11bHRpcGxlIGNvZGUgdW5pdHNcbiAgLy8gICAgICBzaG91bGQgYmUgYWRkcmVzc2VkIGhlcmVcbiAgZG9lc0NvbnRhaW5TdXJyb2dhdGVQYWlyKHRleHQpKSAmJiBhbmNob3Iub2Zmc2V0ICE9PSBmb2N1cy5vZmZzZXQgJiYgIWFuY2hvck5vZGUuaXNDb21wb3NpbmcoKSB8fFxuICAvLyBBbnkgbm9uIHN0YW5kYXJkIHRleHQgbm9kZS5cbiAgJGlzVG9rZW5PclNlZ21lbnRlZChhbmNob3JOb2RlKSB8fFxuICAvLyBJZiB0aGUgdGV4dCBsZW5ndGggaXMgbW9yZSB0aGFuIGEgc2luZ2xlIGNoYXJhY3RlciBhbmQgd2UncmUgZWl0aGVyXG4gIC8vIGRlYWxpbmcgd2l0aCB0aGlzIGluIFwiYmVmb3JlaW5wdXRcIiBvciB3aGVyZSB0aGUgbm9kZSBoYXMgYWxyZWFkeSByZWNlbnRseVxuICAvLyBiZWVuIGNoYW5nZWQgKHRodXMgaXMgZGlydHkpLlxuICBhbmNob3JOb2RlLmlzRGlydHkoKSAmJiB0ZXh0TGVuZ3RoID4gMSB8fFxuICAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBlbGVtZW50IGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgYmFja2luZyBub2RlIGR1cmluZyBiZWZvcmVpbnB1dC5cbiAgKGlzQmVmb3JlSW5wdXQgfHwgIUNBTl9VU0VfQkVGT1JFX0lOUFVUKSAmJiBiYWNraW5nQW5jaG9yRWxlbWVudCAhPT0gbnVsbCAmJiAhYW5jaG9yTm9kZS5pc0NvbXBvc2luZygpICYmIGRvbUFuY2hvck5vZGUgIT09IGdldERPTVRleHROb2RlKGJhY2tpbmdBbmNob3JFbGVtZW50KSB8fFxuICAvLyBJZiBUYXJnZXRSYW5nZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIERPTSBzZWxlY3Rpb247IGJyb3dzZXIgdHJ5aW5nIHRvIGVkaXQgcmFuZG9tIHBhcnRzXG4gIC8vIG9mIHRoZSBlZGl0b3IuXG4gIGRvbVNlbGVjdGlvbiAhPT0gbnVsbCAmJiBkb21UYXJnZXRSYW5nZSAhPT0gbnVsbCAmJiAoIWRvbVRhcmdldFJhbmdlLmNvbGxhcHNlZCB8fCBkb21UYXJnZXRSYW5nZS5zdGFydENvbnRhaW5lciAhPT0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUgfHwgZG9tVGFyZ2V0UmFuZ2Uuc3RhcnRPZmZzZXQgIT09IGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQpIHx8XG4gIC8vIENoZWNrIGlmIHdlJ3JlIGNoYW5naW5nIGZyb20gYm9sZCB0byBpdGFsaWNzLCBvciBzb21lIG90aGVyIGZvcm1hdC5cbiAgYW5jaG9yTm9kZS5nZXRGb3JtYXQoKSAhPT0gc2VsZWN0aW9uLmZvcm1hdCB8fCBhbmNob3JOb2RlLmdldFN0eWxlKCkgIT09IHNlbGVjdGlvbi5zdHlsZSB8fFxuICAvLyBPbmUgbGFzdCBzZXQgb2YgaGV1cmlzdGljcyB0byBjaGVjayBhZ2FpbnN0LlxuICAkc2hvdWxkSW5zZXJ0VGV4dEFmdGVyT3JCZWZvcmVUZXh0Tm9kZShzZWxlY3Rpb24sIGFuY2hvck5vZGUpO1xufVxuZnVuY3Rpb24gc2hvdWxkU2tpcFNlbGVjdGlvbkNoYW5nZShkb21Ob2RlLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGlzRE9NVGV4dE5vZGUoZG9tTm9kZSkgJiYgZG9tTm9kZS5ub2RlVmFsdWUgIT09IG51bGwgJiYgb2Zmc2V0ICE9PSAwICYmIG9mZnNldCAhPT0gZG9tTm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xufVxuZnVuY3Rpb24gb25TZWxlY3Rpb25DaGFuZ2UoZG9tU2VsZWN0aW9uLCBlZGl0b3IsIGlzQWN0aXZlKSB7XG4gIGNvbnN0IHtcbiAgICBhbmNob3JOb2RlOiBhbmNob3JET00sXG4gICAgYW5jaG9yT2Zmc2V0LFxuICAgIGZvY3VzTm9kZTogZm9jdXNET00sXG4gICAgZm9jdXNPZmZzZXRcbiAgfSA9IGRvbVNlbGVjdGlvbjtcbiAgaWYgKGlzU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSkge1xuICAgIGlzU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgLy8gSWYgbmF0aXZlIERPTSBzZWxlY3Rpb24gaXMgb24gYSBET00gZWxlbWVudCwgdGhlblxuICAgIC8vIHdlIHNob3VsZCBjb250aW51ZSBhcyB1c3VhbCwgYXMgTGV4aWNhbCdzIHNlbGVjdGlvblxuICAgIC8vIG1heSBoYXZlIG5vcm1hbGl6ZWQgdG8gYSBiZXR0ZXIgY2hpbGQuIElmIHRoZSBET01cbiAgICAvLyBlbGVtZW50IGlzIGEgdGV4dCBub2RlLCB3ZSBjYW4gc2FmZWx5IGFwcGx5IHRoaXNcbiAgICAvLyBvcHRpbWl6YXRpb24gYW5kIHNraXAgdGhlIHNlbGVjdGlvbiBjaGFuZ2UgZW50aXJlbHkuXG4gICAgLy8gV2UgYWxzbyBuZWVkIHRvIGNoZWNrIGlmIHRoZSBvZmZzZXQgaXMgYXQgdGhlIGJvdW5kYXJ5LFxuICAgIC8vIGJlY2F1c2UgaW4gdGhpcyBjYXNlLCB3ZSBtaWdodCBuZWVkIHRvIG5vcm1hbGl6ZSB0byBhXG4gICAgLy8gc2libGluZyBpbnN0ZWFkLlxuICAgIGlmIChzaG91bGRTa2lwU2VsZWN0aW9uQ2hhbmdlKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KSAmJiBzaG91bGRTa2lwU2VsZWN0aW9uQ2hhbmdlKGZvY3VzRE9NLCBmb2N1c09mZnNldCkgJiYgIXBvc3REZWxldGVTZWxlY3Rpb25Ub1Jlc3RvcmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRWRpdG9yU3luYyhlZGl0b3IsICgpID0+IHtcbiAgICAvLyBOb24tYWN0aXZlIGVkaXRvciBkb24ndCBuZWVkIGFueSBleHRyYSBsb2dpYyBmb3Igc2VsZWN0aW9uLCBpdCBvbmx5IG5lZWRzIHVwZGF0ZVxuICAgIC8vIHRvIHJlY29uY2lsZSBzZWxlY3Rpb24gKHNldCBpdCB0byBudWxsKSB0byBlbnN1cmUgdGhhdCBvbmx5IG9uZSBlZGl0b3IgaGFzIG5vbi1udWxsIHNlbGVjdGlvbi5cbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAkc2V0U2VsZWN0aW9uKG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzU2VsZWN0aW9uV2l0aGluRWRpdG9yKGVkaXRvciwgYW5jaG9yRE9NLCBmb2N1c0RPTSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcblxuICAgIC8vIFJlc3RvcmUgc2VsZWN0aW9uIGluIHRoZSBldmVudCBvZiBpbmNvcnJlY3QgcmlnaHR3YXJkIHNoaWZ0IGFmdGVyIGRlbGV0aW9uXG4gICAgaWYgKHBvc3REZWxldGVTZWxlY3Rpb25Ub1Jlc3RvcmUgJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3QgY3VyQW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IHByZXZBbmNob3IgPSBwb3N0RGVsZXRlU2VsZWN0aW9uVG9SZXN0b3JlLmFuY2hvcjtcbiAgICAgIGlmIChcbiAgICAgIC8vIFJpZ2h0d2FyZCBzaGlmdCBpbiBzYW1lIG5vZGVcbiAgICAgIGN1ckFuY2hvci5rZXkgPT09IHByZXZBbmNob3Iua2V5ICYmIGN1ckFuY2hvci5vZmZzZXQgPT09IHByZXZBbmNob3Iub2Zmc2V0ICsgMSB8fFxuICAgICAgLy8gT3IgcmlnaHR3YXJkIHNoaWZ0IGludG8gc2libGluZyBub2RlXG4gICAgICBjdXJBbmNob3Iub2Zmc2V0ID09PSAxICYmIHByZXZBbmNob3IuZ2V0Tm9kZSgpLmlzKGN1ckFuY2hvci5nZXROb2RlKCkuZ2V0UHJldmlvdXNTaWJsaW5nKCkpKSB7XG4gICAgICAgIC8vIFJlc3RvcmUgc2VsZWN0aW9uXG4gICAgICAgIHNlbGVjdGlvbiA9IHBvc3REZWxldGVTZWxlY3Rpb25Ub1Jlc3RvcmUuY2xvbmUoKTtcbiAgICAgICAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3N0RGVsZXRlU2VsZWN0aW9uVG9SZXN0b3JlID0gbnVsbDtcblxuICAgIC8vIFVwZGF0ZSB0aGUgc2VsZWN0aW9uIGZvcm1hdFxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgLy8gQmFkbHkgaW50ZXJwcmV0ZWQgcmFuZ2Ugc2VsZWN0aW9uIHdoZW4gY29sbGFwc2VkIC0gIzE0ODJcbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbi50eXBlID09PSAnUmFuZ2UnICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlKSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbWFya2VkIGEgY29sbGFwc2VkIHNlbGVjdGlvbiBmb3JtYXQsIGFuZCB3ZSdyZVxuICAgICAgICAvLyB3aXRoaW4gdGhlIGdpdmVuIHRpbWUgcmFuZ2Ug4oCTIHRoZW4gYXR0ZW1wdCB0byB1c2UgdGhhdCBmb3JtYXRcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBnZXR0aW5nIHRoZSBmb3JtYXQgZnJvbSB0aGUgYW5jaG9yIG5vZGUuXG4gICAgICAgIGNvbnN0IHdpbmRvd0V2ZW50ID0gZ2V0V2luZG93KGVkaXRvcikuZXZlbnQ7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lU3RhbXAgPSB3aW5kb3dFdmVudCA/IHdpbmRvd0V2ZW50LnRpbWVTdGFtcCA6IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBbbGFzdEZvcm1hdCwgbGFzdFN0eWxlLCBsYXN0T2Zmc2V0LCBsYXN0S2V5LCB0aW1lU3RhbXBdID0gY29sbGFwc2VkU2VsZWN0aW9uRm9ybWF0O1xuICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgY29uc3QgaXNSb290VGV4dENvbnRlbnRFbXB0eSA9IGVkaXRvci5pc0NvbXBvc2luZygpID09PSBmYWxzZSAmJiByb290LmdldFRleHRDb250ZW50KCkgPT09ICcnO1xuICAgICAgICBpZiAoY3VycmVudFRpbWVTdGFtcCA8IHRpbWVTdGFtcCArIDIwMCAmJiBhbmNob3Iub2Zmc2V0ID09PSBsYXN0T2Zmc2V0ICYmIGFuY2hvci5rZXkgPT09IGxhc3RLZXkpIHtcbiAgICAgICAgICAkdXBkYXRlU2VsZWN0aW9uRm9ybWF0U3R5bGUoc2VsZWN0aW9uLCBsYXN0Rm9ybWF0LCBsYXN0U3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICBpZiAoISRpc1RleHROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgUG9pbnQuZ2V0Tm9kZSgpIG11c3QgcmV0dXJuIFRleHROb2RlIHdoZW4gdHlwZSBpcyB0ZXh0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAkdXBkYXRlU2VsZWN0aW9uRm9ybWF0U3R5bGVGcm9tVGV4dE5vZGUoc2VsZWN0aW9uLCBhbmNob3JOb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgIWlzUm9vdFRleHRDb250ZW50RW1wdHkpIHtcbiAgICAgICAgICAgIGlmICghJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBQb2ludC5nZXROb2RlKCkgbXVzdCByZXR1cm4gRWxlbWVudE5vZGUgd2hlbiB0eXBlIGlzIGVsZW1lbnRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxhc3ROb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIFRoaXMgcHJldmlvdXNseSBhcHBsaWVkIHRvIGFsbCBQYXJhZ3JhcGhOb2RlXG4gICAgICAgICAgICBsYXN0Tm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgJHVwZGF0ZVNlbGVjdGlvbkZvcm1hdFN0eWxlRnJvbUVsZW1lbnROb2RlKHNlbGVjdGlvbiwgbGFzdE5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJHVwZGF0ZVNlbGVjdGlvbkZvcm1hdFN0eWxlKHNlbGVjdGlvbiwgMCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yLmtleTtcbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIGNvbnN0IGZvY3VzS2V5ID0gZm9jdXMua2V5O1xuICAgICAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgICAgICBjb25zdCBub2Rlc0xlbmd0aCA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCYWNrd2FyZCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBjb25zdCBlbmRPZmZzZXQgPSBpc0JhY2t3YXJkID8gYW5jaG9yT2Zmc2V0IDogZm9jdXNPZmZzZXQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0S2V5ID0gaXNCYWNrd2FyZCA/IGZvY3VzS2V5IDogYW5jaG9yS2V5O1xuICAgICAgICBjb25zdCBlbmRLZXkgPSBpc0JhY2t3YXJkID8gYW5jaG9yS2V5IDogZm9jdXNLZXk7XG4gICAgICAgIGxldCBjb21iaW5lZEZvcm1hdCA9IElTX0FMTF9GT1JNQVRUSU5HO1xuICAgICAgICBsZXQgaGFzVGV4dE5vZGVzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudFNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSAmJiB0ZXh0Q29udGVudFNpemUgIT09IDAgJiZcbiAgICAgICAgICAvLyBFeGNsdWRlIGVtcHR5IHRleHQgbm9kZXMgYXQgYm91bmRhcmllcyByZXN1bHRpbmcgZnJvbSB1c2VyJ3Mgc2VsZWN0aW9uXG4gICAgICAgICAgIShpID09PSAwICYmIG5vZGUuX19rZXkgPT09IHN0YXJ0S2V5ICYmIHN0YXJ0T2Zmc2V0ID09PSB0ZXh0Q29udGVudFNpemUgfHwgaSA9PT0gbm9kZXNMZW5ndGggLSAxICYmIG5vZGUuX19rZXkgPT09IGVuZEtleSAmJiBlbmRPZmZzZXQgPT09IDApKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHN0eWxlP1xuICAgICAgICAgICAgaGFzVGV4dE5vZGVzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbWJpbmVkRm9ybWF0ICY9IG5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICAgICAgICBpZiAoY29tYmluZWRGb3JtYXQgPT09IDApIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBoYXNUZXh0Tm9kZXMgPyBjb21iaW5lZEZvcm1hdCA6IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfSk7XG59XG5mdW5jdGlvbiAkdXBkYXRlU2VsZWN0aW9uRm9ybWF0U3R5bGUoc2VsZWN0aW9uLCBmb3JtYXQsIHN0eWxlKSB7XG4gIGlmIChzZWxlY3Rpb24uZm9ybWF0ICE9PSBmb3JtYXQgfHwgc2VsZWN0aW9uLnN0eWxlICE9PSBzdHlsZSkge1xuICAgIHNlbGVjdGlvbi5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgc2VsZWN0aW9uLnN0eWxlID0gc3R5bGU7XG4gICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gJHVwZGF0ZVNlbGVjdGlvbkZvcm1hdFN0eWxlRnJvbVRleHROb2RlKHNlbGVjdGlvbiwgbm9kZSkge1xuICBjb25zdCBmb3JtYXQgPSBub2RlLmdldEZvcm1hdCgpO1xuICBjb25zdCBzdHlsZSA9IG5vZGUuZ2V0U3R5bGUoKTtcbiAgJHVwZGF0ZVNlbGVjdGlvbkZvcm1hdFN0eWxlKHNlbGVjdGlvbiwgZm9ybWF0LCBzdHlsZSk7XG59XG5mdW5jdGlvbiAkdXBkYXRlU2VsZWN0aW9uRm9ybWF0U3R5bGVGcm9tRWxlbWVudE5vZGUoc2VsZWN0aW9uLCBub2RlKSB7XG4gIGNvbnN0IGZvcm1hdCA9IG5vZGUuZ2V0VGV4dEZvcm1hdCgpO1xuICBjb25zdCBzdHlsZSA9IG5vZGUuZ2V0VGV4dFN0eWxlKCk7XG4gICR1cGRhdGVTZWxlY3Rpb25Gb3JtYXRTdHlsZShzZWxlY3Rpb24sIGZvcm1hdCwgc3R5bGUpO1xufVxuXG4vLyBUaGlzIGlzIGEgd29yay1hcm91bmQgaXMgbWFpbmx5IENocm9tZSBzcGVjaWZpYyBidWcgd2hlcmUgaWYgeW91IHNlbGVjdFxuLy8gdGhlIGNvbnRlbnRzIG9mIGFuIGVtcHR5IGJsb2NrLCB5b3UgY2Fubm90IGVhc2lseSB1bnNlbGVjdCBhbnl0aGluZy5cbi8vIFRoaXMgcmVzdWx0cyBpbiBhIHRpbnkgc2VsZWN0aW9uIGJveCB0aGF0IGxvb2tzIGJ1Z2d5L2Jyb2tlbi4gVGhpcyBjYW5cbi8vIGFsc28gaGVscCBvdGhlciBicm93c2VycyB3aGVuIHNlbGVjdGlvbiBtaWdodCBcImFwcGVhclwiIGxvc3QsIHdoZW4gaXRcbi8vIHJlYWxseSBpc24ndC5cbmZ1bmN0aW9uIG9uQ2xpY2soZXZlbnQsIGVkaXRvcikge1xuICB1cGRhdGVFZGl0b3JTeW5jKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZ2V0V2luZG93KGVkaXRvcikpO1xuICAgIGNvbnN0IGxhc3RTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICBpZiAoZG9tU2VsZWN0aW9uKSB7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgaWYgKGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLm9mZnNldCA9PT0gMCAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiAhJGlzUm9vdE5vZGUoYW5jaG9yTm9kZSkgJiYgJGdldFJvb3QoKS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSAmJiBhbmNob3JOb2RlLmdldFRvcExldmVsRWxlbWVudE9yVGhyb3coKS5pc0VtcHR5KCkgJiYgbGFzdFNlbGVjdGlvbiAhPT0gbnVsbCAmJiBzZWxlY3Rpb24uaXMobGFzdFNlbGVjdGlvbikpIHtcbiAgICAgICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5kZXRhaWwgPT09IDMgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgLy8gVHJpcGxlIGNsaWNrIGNhdXNpbmcgc2VsZWN0aW9uIHRvIG92ZXJmbG93IGludG8gdGhlIG5lYXJlc3QgZWxlbWVudC4gSW4gdGhhdFxuICAgICAgICAgIC8vIGNhc2UgdmlzdWFsbHkgaXQgbG9va3MgbGlrZSBhIHNpbmdsZSBlbGVtZW50IGNvbnRlbnQgaXMgc2VsZWN0ZWQsIGZvY3VzIG5vZGVcbiAgICAgICAgICAvLyBpcyBhY3R1YWxseSBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGVsZW1lbnQgKGlmIHByZXNlbnQpIGFuZCBhbnkgbWFuaXB1bGF0aW9uc1xuICAgICAgICAgIC8vIHdpdGggc2VsZWN0aW9uIChmb3JtYXR0aW5nKSBhcmUgYWZmZWN0aW5nIHNlY29uZCBlbGVtZW50IGFzIHdlbGxcbiAgICAgICAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICAgICAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgICAgICAgaWYgKGFuY2hvck5vZGUgIT09IGZvY3VzTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yTm9kZSwgbm9kZSA9PiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKTtcbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShwYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICBwYXJlbnROb2RlLnNlbGVjdCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byB1cGRhdGUgdGhlIHNlbGVjdGlvbiBvbiB0b3VjaCBkZXZpY2VzIChpbmNsdWRpbmcgQXBwbGUgUGVuY2lsKSB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0ZXh0IGFmdGVyIGFcbiAgICAgICAgLy8gbm9kZSBzZWxlY3Rpb24uIFNlZSBpc1NlbGVjdGlvbkNoYW5nZUZyb21Nb3VzZURvd24gZm9yIHRoZSBpbnZlcnNlXG4gICAgICAgIGNvbnN0IGRvbUFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaXMgYXR0ZW1wdGluZyB0byBjbGljayBzZWxlY3Rpb24gYmFjayBvbnRvIHRleHQsIHRoZW5cbiAgICAgICAgLy8gd2Ugc2hvdWxkIGF0dGVtcHQgY3JlYXRlIGEgcmFuZ2Ugc2VsZWN0aW9uLlxuICAgICAgICAvLyBXaGVuIHdlIGNsaWNrIG9uIGFuIGVtcHR5IHBhcmFncmFwaCBub2RlIG9yIHRoZSBlbmQgb2YgYSBwYXJhZ3JhcGggdGhhdCBlbmRzXG4gICAgICAgIC8vIHdpdGggYW4gaW1hZ2UvcG9sbCwgdGhlIG5vZGVUeXBlIHdpbGwgYmUgRUxFTUVOVF9OT0RFXG4gICAgICAgIGlmIChpc0hUTUxFbGVtZW50KGRvbUFuY2hvck5vZGUpIHx8IGlzRE9NVGV4dE5vZGUoZG9tQW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSAkaW50ZXJuYWxDcmVhdGVSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uLCBkb21TZWxlY3Rpb24sIGVkaXRvciwgZXZlbnQpO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDTElDS19DT01NQU5ELCBldmVudCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgZWRpdG9yKSB7XG4gIC8vIFRPRE8gaW1wbGVtZW50IHRleHQgZHJhZyAmIGRyb3BcbiAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICBjb25zdCBwb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xuICBpZiAoaXNET01Ob2RlKHRhcmdldCkgJiYgcG9pbnRlclR5cGUgIT09ICd0b3VjaCcgJiYgcG9pbnRlclR5cGUgIT09ICdwZW4nICYmIGV2ZW50LmJ1dHRvbiA9PT0gMCkge1xuICAgIHVwZGF0ZUVkaXRvclN5bmMoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAvLyBEcmFnICYgZHJvcCBzaG91bGQgbm90IHJlY29tcHV0ZSBzZWxlY3Rpb24gdW50aWwgbW91c2UgdXA7IG90aGVyd2lzZSB0aGUgaW5pdGlhbGx5XG4gICAgICAvLyBzZWxlY3RlZCBjb250ZW50IGlzIGxvc3QuXG4gICAgICBpZiAoISRpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3IodGFyZ2V0KSkge1xuICAgICAgICBpc1NlbGVjdGlvbkNoYW5nZUZyb21Nb3VzZURvd24gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUYXJnZXRSYW5nZShldmVudCkge1xuICBpZiAoIWV2ZW50LmdldFRhcmdldFJhbmdlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHRhcmdldFJhbmdlcyA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpO1xuICBpZiAodGFyZ2V0UmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiB0YXJnZXRSYW5nZXNbMF07XG59XG5mdW5jdGlvbiAkY2FuUmVtb3ZlVGV4dChhbmNob3JOb2RlLCBmb2N1c05vZGUpIHtcbiAgcmV0dXJuIGFuY2hvck5vZGUgIT09IGZvY3VzTm9kZSB8fCAkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSB8fCAkaXNFbGVtZW50Tm9kZShmb2N1c05vZGUpIHx8ICEkaXNUb2tlbk9yVGFiKGFuY2hvck5vZGUpIHx8ICEkaXNUb2tlbk9yVGFiKGZvY3VzTm9kZSk7XG59XG5mdW5jdGlvbiBpc1Bvc3NpYmx5QW5kcm9pZEtleVByZXNzKHRpbWVTdGFtcCkge1xuICByZXR1cm4gbGFzdEtleUNvZGUgPT09ICdNZWRpYUxhc3QnICYmIHRpbWVTdGFtcCA8IGxhc3RLZXlEb3duVGltZVN0YW1wICsgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZO1xufVxuZnVuY3Rpb24gb25CZWZvcmVJbnB1dChldmVudCwgZWRpdG9yKSB7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGV2ZW50LmlucHV0VHlwZTtcbiAgY29uc3QgdGFyZ2V0UmFuZ2UgPSBnZXRUYXJnZXRSYW5nZShldmVudCk7XG5cbiAgLy8gV2UgbGV0IHRoZSBicm93c2VyIGRvIGl0cyBvd24gdGhpbmcgZm9yIGNvbXBvc2l0aW9uLlxuICBpZiAoaW5wdXRUeXBlID09PSAnZGVsZXRlQ29tcG9zaXRpb25UZXh0JyB8fFxuICAvLyBJZiB3ZSdyZSBwYXN0aW5nIGluIEZGLCB3ZSBzaG91bGRuJ3QgZ2V0IHRoaXMgZXZlbnRcbiAgLy8gYXMgdGhlIGBwYXN0ZWAgZXZlbnQgc2hvdWxkIGhhdmUgdHJpZ2dlcmVkLCB1bmxlc3MgdGhlXG4gIC8vIHVzZXIgaGFzIGRvbS5ldmVudC5jbGlwYm9hcmRldmVudHMuZW5hYmxlZCBkaXNhYmxlZCBpblxuICAvLyBhYm91dDpjb25maWcuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byBwcm9jZXNzIHRoZVxuICAvLyBwYXN0ZWQgY29udGVudCBpbiB0aGUgRE9NIG11dGF0aW9uIHBoYXNlLlxuICBJU19GSVJFRk9YICYmIGlzRmlyZWZveENsaXBib2FyZEV2ZW50cyhlZGl0b3IpKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlucHV0VHlwZSA9PT0gJ2luc2VydENvbXBvc2l0aW9uVGV4dCcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdXBkYXRlRWRpdG9yU3luYyhlZGl0b3IsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKGlucHV0VHlwZSA9PT0gJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcpIHtcbiAgICAgIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICAgICAgLy8gVXNlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgJHNldFNlbGVjdGlvbihwcmV2U2VsZWN0aW9uLmNsb25lKCkpO1xuICAgICAgfVxuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY29uc3QgaXNTZWxlY3Rpb25BbmNob3JTYW1lQXNGb2N1cyA9IHNlbGVjdGlvbi5hbmNob3Iua2V5ID09PSBzZWxlY3Rpb24uZm9jdXMua2V5O1xuICAgICAgICBpZiAoaXNQb3NzaWJseUFuZHJvaWRLZXlQcmVzcyhldmVudC50aW1lU3RhbXApICYmIGVkaXRvci5pc0NvbXBvc2luZygpICYmIGlzU2VsZWN0aW9uQW5jaG9yU2FtZUFzRm9jdXMpIHtcbiAgICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICAgICAgbGFzdEtleURvd25UaW1lU3RhbXAgPSAwO1xuICAgICAgICAgIC8vIEZpeGVzIGFuIEFuZHJvaWQgYnVnIHdoZXJlIHNlbGVjdGlvbiBmbGlja2VycyB3aGVuIGJhY2tzcGFjaW5nXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB1cGRhdGVFZGl0b3JTeW5jKGVkaXRvciwgKCkgPT4ge1xuICAgICAgICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCBBTkRST0lEX0NPTVBPU0lUSU9OX0xBVEVOQ1kpO1xuICAgICAgICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgICBhbmNob3JOb2RlLm1hcmtEaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKCEkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEFuY2hvciBub2RlIG11c3QgYmUgYSBUZXh0Tm9kZWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHVwZGF0ZVNlbGVjdGlvbkZvcm1hdFN0eWxlRnJvbVRleHROb2RlKHNlbGVjdGlvbiwgYW5jaG9yTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIC8vIENocm9taXVtIEFuZHJvaWQgYXQgdGhlIG1vbWVudCBzZWVtcyB0byBpZ25vcmUgdGhlIHByZXZlbnREZWZhdWx0XG4gICAgICAgICAgLy8gb24gJ2RlbGV0ZUNvbnRlbnRCYWNrd2FyZCcgYW5kIHN0aWxsIGRlbGV0ZXMgdGhlIGNvbnRlbnQuIFdoaWNoIGxlYWRzXG4gICAgICAgICAgLy8gdG8gbXVsdGlwbGUgZGVsZXRpb25zLiBTbyB3ZSBsZXQgdGhlIGJyb3dzZXIgaGFuZGxlIHRoZSBkZWxldGlvbiBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlVGV4dCA9IHNlbGVjdGVkTm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICAgIC8vIFdoZW4gdGhlIHRhcmdldCBub2RlIGhhcyBgY2FuSW5zZXJ0VGV4dEFmdGVyYCBzZXQgdG8gZmFsc2UsIHRoZSBmaXJzdCBkZWxldGlvblxuICAgICAgICAgIC8vIGRvZXNuJ3QgaGF2ZSBhbiBlZmZlY3QsIHNvIHdlIG5lZWQgdG8gaGFuZGxlIGl0IHdpdGggTGV4aWNhbC5cbiAgICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVDYW5JbnNlcnRUZXh0QWZ0ZXIgPSBzZWxlY3RlZE5vZGUuY2FuSW5zZXJ0VGV4dEFmdGVyKCk7XG4gICAgICAgICAgY29uc3QgaGFzU2VsZWN0ZWRBbGxUZXh0SW5Ob2RlID0gc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgPT09IDAgJiYgc2VsZWN0aW9uLmZvY3VzLm9mZnNldCA9PT0gc2VsZWN0ZWROb2RlVGV4dC5sZW5ndGg7XG4gICAgICAgICAgbGV0IHNob3VsZExldEJyb3dzZXJIYW5kbGVEZWxldGUgPSBJU19BTkRST0lEX0NIUk9NRSAmJiBpc1NlbGVjdGlvbkFuY2hvclNhbWVBc0ZvY3VzICYmICFoYXNTZWxlY3RlZEFsbFRleHRJbk5vZGUgJiYgc2VsZWN0ZWROb2RlQ2FuSW5zZXJ0VGV4dEFmdGVyO1xuICAgICAgICAgIC8vIENoZWNrIGlmIHNlbGVjdGlvbiBpcyBjb2xsYXBzZWQgYW5kIGlmIHRoZSBwcmV2aW91cyBub2RlIGlzIGEgZGVjb3JhdG9yIG5vZGVcbiAgICAgICAgICAvLyBJZiBzbywgdGhlIGJyb3dzZXIgd2lsbCBub3QgYmUgYWJsZSB0byBoYW5kbGUgdGhlIGRlbGV0aW9uXG4gICAgICAgICAgaWYgKHNob3VsZExldEJyb3dzZXJIYW5kbGVEZWxldGUgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICAgIHNob3VsZExldEJyb3dzZXJIYW5kbGVEZWxldGUgPSAhJGlzRGVjb3JhdG9yTm9kZSgkZ2V0QWRqYWNlbnROb2RlKHNlbGVjdGlvbi5hbmNob3IsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzaG91bGRMZXRCcm93c2VySGFuZGxlRGVsZXRlKSB7XG4gICAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIHRydWUpO1xuICAgICAgICAgICAgLy8gV2hlbiBkZWxldGluZyBhY3Jvc3MgcGFyYWdyYXBocywgQ2hyb21lIG9uIEFuZHJvaWQgaW5jb3JyZWN0bHkgc2hpZnRzIHRoZSBzZWxlY3Rpb24gcmlnaHR3YXJkc1xuICAgICAgICAgICAgLy8gV2Ugc2F2ZSB0aGUgY29ycmVjdCBzZWxlY3Rpb24gdG8gcmVzdG9yZSBsYXRlciBkdXJpbmcgaGFuZGxpbmcgb2Ygc2VsZWN0aW9uY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25BZnRlckRlbGV0ZSA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChJU19BTkRST0lEX0NIUk9NRSAmJiAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb25BZnRlckRlbGV0ZSkgJiYgc2VsZWN0aW9uQWZ0ZXJEZWxldGUuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgICAgICBwb3N0RGVsZXRlU2VsZWN0aW9uVG9SZXN0b3JlID0gc2VsZWN0aW9uQWZ0ZXJEZWxldGU7XG4gICAgICAgICAgICAgIC8vIENsZWFudXAgaW4gY2FzZSBzZWxlY3Rpb25jaGFuZ2UgZG9lcyBub3QgZmlyZVxuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHBvc3REZWxldGVTZWxlY3Rpb25Ub1Jlc3RvcmUgPSBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICAvLyBUaGlzIHJlcHJlc2VudHMgdGhlIGNhc2Ugd2hlbiB0d28gYmVmb3JlaW5wdXQgZXZlbnRzIGFyZSB0cmlnZ2VyZWQgYXQgdGhlIHNhbWUgdGltZSAod2l0aG91dCBhXG4gICAgLy8gZnVsbCBldmVudCBsb29wIGVuZGluZyBhdCBpbnB1dCkuIFRoaXMgaGFwcGVucyB3aXRoIE1hY09TIHdpdGggdGhlIGRlZmF1bHQga2V5Ym9hcmQgc2V0dGluZ3MsXG4gICAgLy8gYSBjb21iaW5hdGlvbiBvZiBhdXRvY29ycmVjdGlvbiArIGF1dG9jYXBpdGFsaXphdGlvbi5cbiAgICAvLyBIYXZpbmcgTGV4aWNhbCBydW4gZXZlcnl0aGluZyBpbiBjb250cm9sbGVkIG1vZGUgd291bGQgZml4IHRoZSBpc3N1ZSB3aXRob3V0IGFkZGl0aW9uYWwgY29kZVxuICAgIC8vIGJ1dCB0aGlzIHdvdWxkIGtpbGwgdGhlIG1hc3NpdmUgcGVyZm9ybWFuY2Ugd2luIGZyb20gdGhlIG1vc3QgY29tbW9uIHR5cGluZyBldmVudC5cbiAgICAvLyBBbHRlcm5hdGl2ZWx5LCB3aGVuIHRoaXMgaGFwcGVucyB3ZSBjYW4gcHJlbWF0dXJlbHkgdXBkYXRlIG91ciBFZGl0b3JTdGF0ZSBiYXNlZCBvbiB0aGUgRE9NXG4gICAgLy8gY29udGVudCwgYSBqb2IgdGhhdCB3b3VsZCB1c3VhbGx5IGJlIHRoZSBpbnB1dCBldmVudCdzIHJlc3BvbnNpYmlsaXR5LlxuICAgIGlmICh1bnByb2Nlc3NlZEJlZm9yZUlucHV0RGF0YSAhPT0gbnVsbCkge1xuICAgICAgJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00oZmFsc2UsIGVkaXRvciwgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEpO1xuICAgIH1cbiAgICBpZiAoKCFzZWxlY3Rpb24uZGlydHkgfHwgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgIT09IG51bGwpICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmICEkaXNSb290Tm9kZShzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSkgJiYgdGFyZ2V0UmFuZ2UgIT09IG51bGwpIHtcbiAgICAgIHNlbGVjdGlvbi5hcHBseURPTVJhbmdlKHRhcmdldFJhbmdlKTtcbiAgICB9XG4gICAgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgPSBudWxsO1xuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmIChpbnB1dFR5cGUgPT09ICdpbnNlcnRUZXh0JyB8fCBpbnB1dFR5cGUgPT09ICdpbnNlcnRUcmFuc3Bvc2UnKSB7XG4gICAgICBpZiAoZGF0YSA9PT0gJ1xcbicpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhID09PSBET1VCTEVfTElORV9CUkVBSykge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICB9IGVsc2UgaWYgKGRhdGEgPT0gbnVsbCAmJiBldmVudC5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgLy8gR2V0cyBhcm91bmQgYSBTYWZhcmkgdGV4dCByZXBsYWNlbWVudCBidWcuXG4gICAgICAgIGNvbnN0IHRleHQgPSBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZWxlY3Rpb24uaW5zZXJ0UmF3VGV4dCh0ZXh0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YSAhPSBudWxsICYmICRzaG91bGRQcmV2ZW50RGVmYXVsdEFuZEluc2VydFRleHQoc2VsZWN0aW9uLCB0YXJnZXRSYW5nZSwgZGF0YSwgZXZlbnQudGltZVN0YW1wLCB0cnVlKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIGRhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5wcm9jZXNzZWRCZWZvcmVJbnB1dERhdGEgPSBkYXRhO1xuICAgICAgfVxuICAgICAgbGFzdEJlZm9yZUlucHV0SW5zZXJ0VGV4dFRpbWVTdGFtcCA9IGV2ZW50LnRpbWVTdGFtcDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBQcmV2ZW50IHRoZSBicm93c2VyIGZyb20gY2Fycnlpbmcgb3V0XG4gICAgLy8gdGhlIGlucHV0IGV2ZW50LCBzbyB3ZSBjYW4gY29udHJvbCB0aGVcbiAgICAvLyBvdXRwdXQuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBzd2l0Y2ggKGlucHV0VHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVlhbmsnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbURyb3AnOlxuICAgICAgY2FzZSAnaW5zZXJ0UmVwbGFjZW1lbnRUZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uXG4gICAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVXNlZCBmb3IgQW5kcm9pZFxuICAgICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydFBhcmFncmFwaCc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBVc2VkIGZvciBBbmRyb2lkXG4gICAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuXG4gICAgICAgICAgLy8gU2FmYXJpIGRvZXMgbm90IHByb3ZpZGUgdGhlIHR5cGUgXCJpbnNlcnRMaW5lQnJlYWtcIi5cbiAgICAgICAgICAvLyBTbyBpbnN0ZWFkLCB3ZSBuZWVkIHRvIGluZmVyIGl0IGZyb20gdGhlIGtleWJvYXJkIGV2ZW50LlxuICAgICAgICAgIC8vIFdlIGRvIG5vdCBhcHBseSB0aGlzIGxvZ2ljIHRvIGlPUyB0byBhbGxvdyBuZXdsaW5lIGF1dG8tY2FwaXRhbGl6YXRpb25cbiAgICAgICAgICAvLyB3b3JrIHdpdGhvdXQgY3JlYXRpbmcgbGluZWJyZWFrcyB3aGVuIHByZXNzaW5nIEVudGVyXG4gICAgICAgICAgaWYgKGlzSW5zZXJ0TGluZUJyZWFrICYmICFJU19JT1MpIHtcbiAgICAgICAgICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gZmFsc2U7XG4gICAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBJTlNFUlRfTElORV9CUkVBS19DT01NQU5ELCBmYWxzZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2luc2VydEZyb21QYXN0ZSc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tUGFzdGVBc1F1b3RhdGlvbic6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBQQVNURV9DT01NQU5ELCBldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q29tcG9zaXRpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCRjYW5SZW1vdmVUZXh0KGFuY2hvck5vZGUsIGZvY3VzTm9kZSkpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFJFTU9WRV9URVhUX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5RHJhZyc6XG4gICAgICBjYXNlICdkZWxldGVCeUN1dCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBSRU1PVkVfVEVYVF9DT01NQU5ELCBldmVudCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfV09SRF9DT01NQU5ELCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZGVsZXRlV29yZEZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX1dPUkRfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0xJTkVfQ09NTUFORCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnRGb3J3YXJkJzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUhhcmRMaW5lRm9yd2FyZCc6XG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0xJTkVfQ09NTUFORCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdmb3JtYXRTdHJpa2VUaHJvdWdoJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdzdHJpa2V0aHJvdWdoJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgJ2Zvcm1hdEJvbGQnOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ2JvbGQnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZm9ybWF0SXRhbGljJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdpdGFsaWMnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnZm9ybWF0VW5kZXJsaW5lJzpcbiAgICAgICAge1xuICAgICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICd1bmRlcmxpbmUnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgY2FzZSAnaGlzdG9yeVVuZG8nOlxuICAgICAgICB7XG4gICAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgVU5ET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBjYXNlICdoaXN0b3J5UmVkbyc6XG4gICAgICAgIHtcbiAgICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBSRURPX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIE5PLU9QXG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9uSW5wdXQoZXZlbnQsIGVkaXRvcikge1xuICAvLyBOb3RlIHRoYXQgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgbWF5IG9yIG1heSBub3QgaGF2ZSBhbHJlYWR5IGZpcmVkLFxuICAvLyBidXQgdGhlIHRoZSBET00gYW5kIHNlbGVjdGlvbiBtYXkgaGF2ZSBhbHJlYWR5IGNoYW5nZWQuXG4gIC8vIFNlZSBhbHNvOlxuICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9sZXhpY2FsL2lzc3Vlcy83MDI4XG4gIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2xleGljYWwvcHVsbC83OTRcblxuICAvLyBXZSBkb24ndCB3YW50IHRoZSBvbklucHV0IHRvIGJ1YmJsZSwgaW4gdGhlIGNhc2Ugb2YgbmVzdGVkIGVkaXRvcnMuXG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB1cGRhdGVFZGl0b3JTeW5jKGVkaXRvciwgKCkgPT4ge1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGV2ZW50LnRhcmdldCkgJiYgJGlzU2VsZWN0aW9uQ2FwdHVyZWRJbkRlY29yYXRvcihldmVudC50YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcbiAgICBjb25zdCB0YXJnZXRSYW5nZSA9IGdldFRhcmdldFJhbmdlKGV2ZW50KTtcbiAgICBpZiAoZGF0YSAhPSBudWxsICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgJHNob3VsZFByZXZlbnREZWZhdWx0QW5kSW5zZXJ0VGV4dChzZWxlY3Rpb24sIHRhcmdldFJhbmdlLCBkYXRhLCBldmVudC50aW1lU3RhbXAsIGZhbHNlKSkge1xuICAgICAgLy8gR2l2ZW4gd2UncmUgb3Zlci1yaWRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3IsIHdlIHdpbGwgbmVlZFxuICAgICAgLy8gdG8gZW5zdXJlIHRvIGRpc2FibGUgY29tcG9zaXRpb24gYmVmb3JlIGRpc3BhdGNoaW5nIHRoZVxuICAgICAgLy8gaW5zZXJ0VGV4dCBjb21tYW5kIGZvciB3aGVuIGNoYW5naW5nIHRoZSBzZXF1ZW5jZSBmb3IgRkYuXG4gICAgICBpZiAoaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24pIHtcbiAgICAgICAgJG9uQ29tcG9zaXRpb25FbmRJbXBsKGVkaXRvciwgZGF0YSk7XG4gICAgICAgIGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZ2V0V2luZG93KGVkaXRvcikpO1xuICAgICAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gaXNCYWNrd2FyZCA/IHNlbGVjdGlvbi5hbmNob3Iub2Zmc2V0IDogc2VsZWN0aW9uLmZvY3VzLm9mZnNldDtcbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzQmFja3dhcmQgPyBzZWxlY3Rpb24uZm9jdXMub2Zmc2V0IDogc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQ7XG4gICAgICAvLyBJZiB0aGUgY29udGVudCBpcyB0aGUgc2FtZSBhcyBpbnNlcnRlZCwgdGhlbiBkb24ndCBkaXNwYXRjaCBhbiBpbnNlcnRpb24uXG4gICAgICAvLyBHaXZlbiBvbklucHV0IGRvZXNuJ3QgdGFrZSB0aGUgY3VycmVudCBzZWxlY3Rpb24gKGl0IHVzZXMgdGhlIHByZXZpb3VzKVxuICAgICAgLy8gd2UgY2FuIGNvbXBhcmUgdGhhdCBhZ2FpbnN0IHdoYXQgdGhlIERPTSBjdXJyZW50bHkgc2F5cy5cbiAgICAgIGlmICghQ0FOX1VTRV9CRUZPUkVfSU5QVVQgfHwgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgISRpc1RleHROb2RlKGFuY2hvck5vZGUpIHx8IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBudWxsIHx8IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKS5zbGljZSgwLCBzdGFydE9mZnNldCkgKyBkYXRhICsgYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpLnNsaWNlKHN0YXJ0T2Zmc2V0ICsgZW5kT2Zmc2V0KSAhPT0gZ2V0QW5jaG9yVGV4dEZyb21ET00oZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUpKSB7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgZGF0YSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0TGVuZ3RoID0gZGF0YS5sZW5ndGg7XG5cbiAgICAgIC8vIEFub3RoZXIgaGFjayBmb3IgRkYsIGFzIGl0J3MgcG9zc2libGUgdGhhdCB0aGUgSU1FIGlzIHN0aWxsXG4gICAgICAvLyBvcGVuLCBldmVuIHRob3VnaCBjb21wb3NpdGlvbmVuZCBoYXMgYWxyZWFkeSBmaXJlZCAoc2lnaCkuXG4gICAgICBpZiAoSVNfRklSRUZPWCAmJiB0ZXh0TGVuZ3RoID4gMSAmJiBldmVudC5pbnB1dFR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnICYmICFlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgICBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldCAtPSB0ZXh0TGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgY29uc2lzdGVuY3kgb24gQW5kcm9pZC5cbiAgICAgIGlmICghSVNfU0FGQVJJICYmICFJU19JT1MgJiYgIUlTX0FQUExFX1dFQktJVCAmJiBlZGl0b3IuaXNDb21wb3NpbmcoKSkge1xuICAgICAgICBsYXN0S2V5RG93blRpbWVTdGFtcCA9IDA7XG4gICAgICAgICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hhcmFjdGVyRGF0YSA9IGRhdGEgIT09IG51bGwgPyBkYXRhIDogdW5kZWZpbmVkO1xuICAgICAgJHVwZGF0ZVNlbGVjdGVkVGV4dEZyb21ET00oZmFsc2UsIGVkaXRvciwgY2hhcmFjdGVyRGF0YSk7XG5cbiAgICAgIC8vIG9uSW5wdXQgYWx3YXlzIGZpcmVzIGFmdGVyIG9uQ29tcG9zaXRpb25FbmQgZm9yIEZGLlxuICAgICAgaWYgKGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uKSB7XG4gICAgICAgICRvbkNvbXBvc2l0aW9uRW5kSW1wbChlZGl0b3IsIGRhdGEgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHNvIGZsdXNoIGFueSBvdGhlciBtdXRhdGlvbnMgdGhhdCBtaWdodCBoYXZlIG9jY3VycmVkXG4gICAgLy8gc2luY2UgdGhlIGNoYW5nZS5cbiAgICAkZmx1c2hNdXRhdGlvbnMoKTtcbiAgfSwge1xuICAgIGV2ZW50XG4gIH0pO1xuICB1bnByb2Nlc3NlZEJlZm9yZUlucHV0RGF0YSA9IG51bGw7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQoZXZlbnQsIGVkaXRvcikge1xuICB1cGRhdGVFZGl0b3JTeW5jKGVkaXRvciwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAhZWRpdG9yLmlzQ29tcG9zaW5nKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICBjb25zdCBub2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkoYW5jaG9yLmtleSk7XG4gICAgICBpZiAoXG4gICAgICAvLyBJZiBpdCBoYXMgYmVlbiAzMG1zIHNpbmNlIHRoZSBsYXN0IGtleWRvd24sIHRoZW4gd2Ugc2hvdWxkXG4gICAgICAvLyBhcHBseSB0aGUgZW1wdHkgc3BhY2UgaGV1cmlzdGljLiBXZSBjYW4ndCBkbyB0aGlzIGZvciBTYWZhcmksXG4gICAgICAvLyBhcyB0aGUga2V5ZG93biBmaXJlcyBhZnRlciBjb21wb3NpdGlvbiBzdGFydC5cbiAgICAgIGV2ZW50LnRpbWVTdGFtcCA8IGxhc3RLZXlEb3duVGltZVN0YW1wICsgQU5EUk9JRF9DT01QT1NJVElPTl9MQVRFTkNZIHx8XG4gICAgICAvLyBGRiBoYXMgaXNzdWVzIGFyb3VuZCBjb21wb3NpbmcgbXVsdGlieXRlIGNoYXJhY3RlcnMsIHNvIHdlIGFsc29cbiAgICAgIC8vIG5lZWQgdG8gaW52b2tlIHRoZSBlbXB0eSBzcGFjZSBoZXVyaXN0aWMgYmVsb3cuXG4gICAgICBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCBub2RlLmdldEZvcm1hdCgpICE9PSBzZWxlY3Rpb24uZm9ybWF0IHx8ICRpc1RleHROb2RlKG5vZGUpICYmIG5vZGUuZ2V0U3R5bGUoKSAhPT0gc2VsZWN0aW9uLnN0eWxlKSB7XG4gICAgICAgIC8vIFdlIGluc2VydCBhIHplcm8gd2lkdGggY2hhcmFjdGVyLCByZWFkeSBmb3IgdGhlIGNvbXBvc2l0aW9uXG4gICAgICAgIC8vIHRvIGdldCBpbnNlcnRlZCBpbnRvIHRoZSBuZXcgbm9kZSB3ZSBjcmVhdGUuIElmXG4gICAgICAgIC8vIHdlIGRvbid0IGRvIHRoaXMsIFNhZmFyaSB3aWxsIGZhaWwgb24gdXMgYmVjYXVzZVxuICAgICAgICAvLyB0aGVyZSBpcyBubyB0ZXh0IG5vZGUgbWF0Y2hpbmcgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09OVFJPTExFRF9URVhUX0lOU0VSVElPTl9DT01NQU5ELCBDT01QT1NJVElPTl9TVEFSVF9DSEFSKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gJG9uQ29tcG9zaXRpb25FbmRJbXBsKGVkaXRvciwgZGF0YSkge1xuICBjb25zdCBjb21wb3NpdGlvbktleSA9IGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG4gICRzZXRDb21wb3NpdGlvbktleShudWxsKTtcblxuICAvLyBIYW5kbGUgdGVybWluYXRpb24gb2YgY29tcG9zaXRpb24uXG4gIGlmIChjb21wb3NpdGlvbktleSAhPT0gbnVsbCAmJiBkYXRhICE9IG51bGwpIHtcbiAgICAvLyBDb21wb3NpdGlvbiBjYW4gc29tZXRpbWVzIG1vdmUgdG8gYW4gYWRqYWNlbnQgRE9NIG5vZGUgd2hlbiBiYWNrc3BhY2luZy5cbiAgICAvLyBTbyBjaGVjayBmb3IgdGhlIGVtcHR5IGNhc2UuXG4gICAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShjb21wb3NpdGlvbktleSk7XG4gICAgICBjb25zdCB0ZXh0Tm9kZSA9IGdldERPTVRleHROb2RlKGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY29tcG9zaXRpb25LZXkpKTtcbiAgICAgIGlmICh0ZXh0Tm9kZSAhPT0gbnVsbCAmJiB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IG51bGwgJiYgJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgICAgJHVwZGF0ZVRleHROb2RlRnJvbURPTUNvbnRlbnQobm9kZSwgdGV4dE5vZGUubm9kZVZhbHVlLCBudWxsLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb21wb3NpdGlvbiBjYW4gc29tZXRpbWVzIGJlIHRoYXQgb2YgYSBuZXcgbGluZS4gSW4gd2hpY2ggY2FzZSwgd2UgbmVlZCB0b1xuICAgIC8vIGhhbmRsZSB0aGF0IGFjY29yZGluZ2x5LlxuICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoIC0gMV0gPT09ICdcXG4nKSB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICAvLyBJZiB0aGUgbGFzdCBjaGFyYWN0ZXIgaXMgYSBsaW5lIGJyZWFrLCB3ZSBhbHNvIG5lZWQgdG8gaW5zZXJ0XG4gICAgICAgIC8vIGEgbGluZSBicmVhay5cbiAgICAgICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgICAgIHNlbGVjdGlvbi5hbmNob3Iuc2V0KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKTtcbiAgICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0VOVEVSX0NPTU1BTkQsIG51bGwpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG4gICR1cGRhdGVTZWxlY3RlZFRleHRGcm9tRE9NKHRydWUsIGVkaXRvciwgZGF0YSk7XG59XG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uRW5kKGV2ZW50LCBlZGl0b3IpIHtcbiAgLy8gRmlyZWZveCBmaXJlcyBvbkNvbXBvc2l0aW9uRW5kIGJlZm9yZSBvbklucHV0LCBidXQgQ2hyb21lL1dlYmtpdCxcbiAgLy8gZmlyZSBvbklucHV0IGJlZm9yZSBvbkNvbXBvc2l0aW9uRW5kLiBUbyBlbnN1cmUgdGhlIHNlcXVlbmNlIHdvcmtzXG4gIC8vIGxpa2UgQ2hyb21lL1dlYmtpdCB3ZSB1c2UgdGhlIGlzRmlyZWZveEVuZGluZ0NvbXBvc2l0aW9uIGZsYWcgdG9cbiAgLy8gZGVmZXIgaGFuZGxpbmcgb2Ygb25Db21wb3NpdGlvbkVuZCBpbiBGaXJlZm94IHRpbGwgd2UgaGF2ZSBwcm9jZXNzZWRcbiAgLy8gdGhlIGxvZ2ljIGluIG9uSW5wdXQuXG4gIGlmIChJU19GSVJFRk9YKSB7XG4gICAgaXNGaXJlZm94RW5kaW5nQ29tcG9zaXRpb24gPSB0cnVlO1xuICB9IGVsc2UgaWYgKCFJU19JT1MgJiYgKElTX1NBRkFSSSB8fCBJU19BUFBMRV9XRUJLSVQpKSB7XG4gICAgLy8gRml477yaaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2xleGljYWwvcHVsbC83MDYxXG4gICAgLy8gSW4gc2FmYXJpLCBvbkNvbXBvc2l0aW9uRW5kIHRyaWdnZXJzIGJlZm9yZSBrZXlkb3duXG4gICAgLy8gVGhpcyB3aWxsIGNhdXNlIGFuIGV4dHJhIGNoYXJhY3RlciB0byBiZSBkZWxldGVkIHdoZW4gZXhpdGluZyB0aGUgSU1FXG4gICAgLy8gVGhlcmVmb3JlLCBhIGZsYWcgaXMgdXNlZCB0byBtYXJrIHRoYXQgdGhlIGtleWRvd24gZXZlbnQgaXMgdHJpZ2dlcmVkIGFmdGVyIG9uQ29tcG9zaXRpb25FbmRcbiAgICAvLyBFbnN1cmUgdGhhdCBhbiBleHRyYSBjaGFyYWN0ZXIgaXMgbm90IGRlbGV0ZWQgZHVlIHRvIHRoZSBiYWNrc3BhY2UgZXZlbnQgYmVpbmcgdHJpZ2dlcmVkIGluIHRoZSBrZXlkb3duIGV2ZW50LlxuICAgIGlzU2FmYXJpRW5kaW5nQ29tcG9zaXRpb24gPSB0cnVlO1xuICAgIHNhZmFyaUVuZENvbXBvc2l0aW9uRXZlbnREYXRhID0gZXZlbnQuZGF0YTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVFZGl0b3JTeW5jKGVkaXRvciwgKCkgPT4ge1xuICAgICAgJG9uQ29tcG9zaXRpb25FbmRJbXBsKGVkaXRvciwgZXZlbnQuZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9uS2V5RG93bihldmVudCwgZWRpdG9yKSB7XG4gIGxhc3RLZXlEb3duVGltZVN0YW1wID0gZXZlbnQudGltZVN0YW1wO1xuICBsYXN0S2V5Q29kZSA9IGV2ZW50LmtleTtcbiAgaWYgKGVkaXRvci5pc0NvbXBvc2luZygpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfRE9XTl9DT01NQU5ELCBldmVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGV2ZW50LmtleSA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc1NhZmFyaUVuZGluZ0NvbXBvc2l0aW9uICYmIGlzQmFja3NwYWNlKGV2ZW50KSkge1xuICAgIHVwZGF0ZUVkaXRvclN5bmMoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAkb25Db21wb3NpdGlvbkVuZEltcGwoZWRpdG9yLCBzYWZhcmlFbmRDb21wb3NpdGlvbkV2ZW50RGF0YSk7XG4gICAgfSk7XG4gICAgaXNTYWZhcmlFbmRpbmdDb21wb3NpdGlvbiA9IGZhbHNlO1xuICAgIHNhZmFyaUVuZENvbXBvc2l0aW9uRXZlbnREYXRhID0gJyc7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpc01vdmVGb3J3YXJkKGV2ZW50KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNNb3ZlVG9FbmQoZXZlbnQpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgTU9WRV9UT19FTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVCYWNrd2FyZChldmVudCkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNNb3ZlVG9TdGFydChldmVudCkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBNT1ZFX1RPX1NUQVJULCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNNb3ZlVXAoZXZlbnQpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc01vdmVEb3duKGV2ZW50KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9BUlJPV19ET1dOX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc0xpbmVCcmVhayhldmVudCkpIHtcbiAgICBpc0luc2VydExpbmVCcmVhayA9IHRydWU7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0VOVEVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc1NwYWNlKGV2ZW50KSkge1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9TUEFDRV9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNPcGVuTGluZUJyZWFrKGV2ZW50KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaXNJbnNlcnRMaW5lQnJlYWsgPSB0cnVlO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIElOU0VSVF9MSU5FX0JSRUFLX0NPTU1BTkQsIHRydWUpO1xuICB9IGVsc2UgaWYgKGlzUGFyYWdyYXBoKGV2ZW50KSkge1xuICAgIGlzSW5zZXJ0TGluZUJyZWFrID0gZmFsc2U7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0VOVEVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUJhY2t3YXJkKGV2ZW50KSkge1xuICAgIGlmIChpc0JhY2tzcGFjZShldmVudCkpIHtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCB0cnVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFc2NhcGUoZXZlbnQpKSB7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgS0VZX0VTQ0FQRV9DT01NQU5ELCBldmVudCk7XG4gIH0gZWxzZSBpZiAoaXNEZWxldGVGb3J3YXJkKGV2ZW50KSkge1xuICAgIGlmIChpc0RlbGV0ZShldmVudCkpIHtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEtFWV9ERUxFVEVfQ09NTUFORCwgZXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX0NIQVJBQ1RFUl9DT01NQU5ELCBmYWxzZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRGVsZXRlV29yZEJhY2t3YXJkKGV2ZW50KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgREVMRVRFX1dPUkRfQ09NTUFORCwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAoaXNEZWxldGVXb3JkRm9yd2FyZChldmVudCkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9XT1JEX0NPTU1BTkQsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChpc0RlbGV0ZUxpbmVCYWNrd2FyZChldmVudCkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERFTEVURV9MSU5FX0NPTU1BTkQsIHRydWUpO1xuICB9IGVsc2UgaWYgKGlzRGVsZXRlTGluZUZvcndhcmQoZXZlbnQpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBERUxFVEVfTElORV9DT01NQU5ELCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoaXNCb2xkKGV2ZW50KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRk9STUFUX1RFWFRfQ09NTUFORCwgJ2JvbGQnKTtcbiAgfSBlbHNlIGlmIChpc1VuZGVybGluZShldmVudCkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICd1bmRlcmxpbmUnKTtcbiAgfSBlbHNlIGlmIChpc0l0YWxpYyhldmVudCkpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEZPUk1BVF9URVhUX0NPTU1BTkQsICdpdGFsaWMnKTtcbiAgfSBlbHNlIGlmIChpc1RhYihldmVudCkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfVEFCX0NPTU1BTkQsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChpc1VuZG8oZXZlbnQpKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBVTkRPX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH0gZWxzZSBpZiAoaXNSZWRvKGV2ZW50KSkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgUkVET19DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSBlZGl0b3IuX2VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgaWYgKHByZXZTZWxlY3Rpb24gIT09IG51bGwgJiYgISRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICAvLyBPbmx5IFJhbmdlU2VsZWN0aW9uIGNhbiB1c2UgdGhlIG5hdGl2ZSBjdXQvY29weS9zZWxlY3QgYWxsXG4gICAgICBpZiAoaXNDb3B5KGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDT1BZX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNDdXQoZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIENVVF9DT01NQU5ELCBldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzU2VsZWN0QWxsKGV2ZW50KSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBTRUxFQ1RfQUxMX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzU2VsZWN0QWxsKGV2ZW50KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIFNFTEVDVF9BTExfQ09NTUFORCwgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNNb2RpZmllcihldmVudCkpIHtcbiAgICBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBLRVlfTU9ESUZJRVJfQ09NTUFORCwgZXZlbnQpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSb290RWxlbWVudFJlbW92ZUhhbmRsZXMocm9vdEVsZW1lbnQpIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgbGV0IGV2ZW50SGFuZGxlcyA9IHJvb3RFbGVtZW50Ll9fbGV4aWNhbEV2ZW50SGFuZGxlcztcbiAgaWYgKGV2ZW50SGFuZGxlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRIYW5kbGVzID0gW107XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICByb290RWxlbWVudC5fX2xleGljYWxFdmVudEhhbmRsZXMgPSBldmVudEhhbmRsZXM7XG4gIH1cbiAgcmV0dXJuIGV2ZW50SGFuZGxlcztcbn1cblxuLy8gTWFwcGluZyByb290IGVkaXRvcnMgdG8gdGhlaXIgYWN0aXZlIG5lc3RlZCBlZGl0b3JzLCBjb250YWlucyBuZXN0ZWQgZWRpdG9yc1xuLy8gbWFwcGluZyBvbmx5LCBzbyBpZiByb290IGVkaXRvciBpcyBzZWxlY3RlZCBtYXAgd2lsbCBoYXZlIG5vIHJlZmVyZW5jZSB0byBmcmVlIHVwIG1lbW9yeVxuY29uc3QgYWN0aXZlTmVzdGVkRWRpdG9yc01hcCA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIG9uRG9jdW1lbnRTZWxlY3Rpb25DaGFuZ2UoZXZlbnQpIHtcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uRnJvbVRhcmdldChldmVudC50YXJnZXQpO1xuICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG5leHRBY3RpdmVFZGl0b3IgPSBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUoZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUpO1xuICBpZiAobmV4dEFjdGl2ZUVkaXRvciA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duKSB7XG4gICAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tTW91c2VEb3duID0gZmFsc2U7XG4gICAgdXBkYXRlRWRpdG9yU3luYyhuZXh0QWN0aXZlRWRpdG9yLCAoKSA9PiB7XG4gICAgICBjb25zdCBsYXN0U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgICBpZiAoaXNIVE1MRWxlbWVudChkb21BbmNob3JOb2RlKSB8fCBpc0RPTVRleHROb2RlKGRvbUFuY2hvck5vZGUpKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIGF0dGVtcHRpbmcgdG8gY2xpY2sgc2VsZWN0aW9uIGJhY2sgb250byB0ZXh0LCB0aGVuXG4gICAgICAgIC8vIHdlIHNob3VsZCBhdHRlbXB0IGNyZWF0ZSBhIHJhbmdlIHNlbGVjdGlvbi5cbiAgICAgICAgLy8gV2hlbiB3ZSBjbGljayBvbiBhbiBlbXB0eSBwYXJhZ3JhcGggbm9kZSBvciB0aGUgZW5kIG9mIGEgcGFyYWdyYXBoIHRoYXQgZW5kc1xuICAgICAgICAvLyB3aXRoIGFuIGltYWdlL3BvbGwsIHRoZSBub2RlVHlwZSB3aWxsIGJlIEVMRU1FTlRfTk9ERVxuICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSAkaW50ZXJuYWxDcmVhdGVSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uLCBkb21TZWxlY3Rpb24sIG5leHRBY3RpdmVFZGl0b3IsIGV2ZW50KTtcbiAgICAgICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gV2hlbiBlZGl0b3IgcmVjZWl2ZXMgc2VsZWN0aW9uIGNoYW5nZSBldmVudCwgd2UncmUgY2hlY2tpbmcgaWZcbiAgLy8gaXQgaGFzIGFueSBzaWJsaW5nIGVkaXRvcnMgKHdpdGhpbiBzYW1lIHBhcmVudCBlZGl0b3IpIHRoYXQgd2VyZSBhY3RpdmVcbiAgLy8gYmVmb3JlLCBhbmQgdHJpZ2dlciBzZWxlY3Rpb24gY2hhbmdlIG9uIGl0IHRvIG51bGxpZnkgc2VsZWN0aW9uLlxuICBjb25zdCBlZGl0b3JzID0gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKG5leHRBY3RpdmVFZGl0b3IpO1xuICBjb25zdCByb290RWRpdG9yID0gZWRpdG9yc1tlZGl0b3JzLmxlbmd0aCAtIDFdO1xuICBjb25zdCByb290RWRpdG9yS2V5ID0gcm9vdEVkaXRvci5fa2V5O1xuICBjb25zdCBhY3RpdmVOZXN0ZWRFZGl0b3IgPSBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmdldChyb290RWRpdG9yS2V5KTtcbiAgY29uc3QgcHJldkFjdGl2ZUVkaXRvciA9IGFjdGl2ZU5lc3RlZEVkaXRvciB8fCByb290RWRpdG9yO1xuICBpZiAocHJldkFjdGl2ZUVkaXRvciAhPT0gbmV4dEFjdGl2ZUVkaXRvcikge1xuICAgIG9uU2VsZWN0aW9uQ2hhbmdlKGRvbVNlbGVjdGlvbiwgcHJldkFjdGl2ZUVkaXRvciwgZmFsc2UpO1xuICB9XG4gIG9uU2VsZWN0aW9uQ2hhbmdlKGRvbVNlbGVjdGlvbiwgbmV4dEFjdGl2ZUVkaXRvciwgdHJ1ZSk7XG5cbiAgLy8gSWYgbmV3bHkgc2VsZWN0ZWQgZWRpdG9yIGlzIG5lc3RlZCwgdGhlbiBhZGQgaXQgdG8gdGhlIG1hcCwgY2xlYW4gbWFwIG90aGVyd2lzZVxuICBpZiAobmV4dEFjdGl2ZUVkaXRvciAhPT0gcm9vdEVkaXRvcikge1xuICAgIGFjdGl2ZU5lc3RlZEVkaXRvcnNNYXAuc2V0KHJvb3RFZGl0b3JLZXksIG5leHRBY3RpdmVFZGl0b3IpO1xuICB9IGVsc2UgaWYgKGFjdGl2ZU5lc3RlZEVkaXRvcikge1xuICAgIGFjdGl2ZU5lc3RlZEVkaXRvcnNNYXAuZGVsZXRlKHJvb3RFZGl0b3JLZXkpO1xuICB9XG59XG5mdW5jdGlvbiBzdG9wTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KSB7XG4gIC8vIFdlIGF0dGFjaCBhIHNwZWNpYWwgcHJvcGVydHkgdG8gZW5zdXJlIHRoZSBzYW1lIGV2ZW50IGRvZXNuJ3QgcmUtZmlyZVxuICAvLyBmb3IgcGFyZW50IGVkaXRvcnMuXG4gIC8vIEB0cy1pZ25vcmVcbiAgZXZlbnQuX2xleGljYWxIYW5kbGVkID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc1N0b3BwZWRMZXhpY2FsUHJvcGFnYXRpb24oZXZlbnQpIHtcbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdG9wcGVkID0gZXZlbnQuX2xleGljYWxIYW5kbGVkID09PSB0cnVlO1xuICByZXR1cm4gc3RvcHBlZDtcbn1cbmZ1bmN0aW9uIGFkZFJvb3RFbGVtZW50RXZlbnRzKHJvb3RFbGVtZW50LCBlZGl0b3IpIHtcbiAgLy8gV2Ugb25seSB3YW50IHRvIGhhdmUgYSBzaW5nbGUgZ2xvYmFsIHNlbGVjdGlvbmNoYW5nZSBldmVudCBoYW5kbGVyLCBzaGFyZWRcbiAgLy8gYmV0d2VlbiBhbGwgZWRpdG9yIGluc3RhbmNlcy5cbiAgY29uc3QgZG9jID0gcm9vdEVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgY29uc3QgZG9jdW1lbnRSb290RWxlbWVudHNDb3VudCA9IHJvb3RFbGVtZW50c1JlZ2lzdGVyZWQuZ2V0KGRvYyk7XG4gIGlmIChkb2N1bWVudFJvb3RFbGVtZW50c0NvdW50ID09PSB1bmRlZmluZWQgfHwgZG9jdW1lbnRSb290RWxlbWVudHNDb3VudCA8IDEpIHtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25Eb2N1bWVudFNlbGVjdGlvbkNoYW5nZSk7XG4gIH1cbiAgcm9vdEVsZW1lbnRzUmVnaXN0ZXJlZC5zZXQoZG9jLCAoZG9jdW1lbnRSb290RWxlbWVudHNDb3VudCB8fCAwKSArIDEpO1xuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gIHJvb3RFbGVtZW50Ll9fbGV4aWNhbEVkaXRvciA9IGVkaXRvcjtcbiAgY29uc3QgcmVtb3ZlSGFuZGxlcyA9IGdldFJvb3RFbGVtZW50UmVtb3ZlSGFuZGxlcyhyb290RWxlbWVudCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm9vdEVsZW1lbnRFdmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBbZXZlbnROYW1lLCBvbkV2ZW50XSA9IHJvb3RFbGVtZW50RXZlbnRzW2ldO1xuICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IHR5cGVvZiBvbkV2ZW50ID09PSAnZnVuY3Rpb24nID8gZXZlbnQgPT4ge1xuICAgICAgaWYgKGhhc1N0b3BwZWRMZXhpY2FsUHJvcGFnYXRpb24oZXZlbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN0b3BMZXhpY2FsUHJvcGFnYXRpb24oZXZlbnQpO1xuICAgICAgaWYgKGVkaXRvci5pc0VkaXRhYmxlKCkgfHwgZXZlbnROYW1lID09PSAnY2xpY2snKSB7XG4gICAgICAgIG9uRXZlbnQoZXZlbnQsIGVkaXRvcik7XG4gICAgICB9XG4gICAgfSA6IGV2ZW50ID0+IHtcbiAgICAgIGlmIChoYXNTdG9wcGVkTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdG9wTGV4aWNhbFByb3BhZ2F0aW9uKGV2ZW50KTtcbiAgICAgIGNvbnN0IGlzRWRpdGFibGUgPSBlZGl0b3IuaXNFZGl0YWJsZSgpO1xuICAgICAgc3dpdGNoIChldmVudE5hbWUpIHtcbiAgICAgICAgY2FzZSAnY3V0JzpcbiAgICAgICAgICByZXR1cm4gaXNFZGl0YWJsZSAmJiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBDVVRfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICBjYXNlICdjb3B5JzpcbiAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgQ09QWV9DT01NQU5ELCBldmVudCk7XG4gICAgICAgIGNhc2UgJ3Bhc3RlJzpcbiAgICAgICAgICByZXR1cm4gaXNFZGl0YWJsZSAmJiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBQQVNURV9DT01NQU5ELCBldmVudCk7XG4gICAgICAgIGNhc2UgJ2RyYWdzdGFydCc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRFJBR1NUQVJUX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgY2FzZSAnZHJhZ292ZXInOlxuICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIERSQUdPVkVSX0NPTU1BTkQsIGV2ZW50KTtcbiAgICAgICAgY2FzZSAnZHJhZ2VuZCc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRFJBR0VORF9DT01NQU5ELCBldmVudCk7XG4gICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICByZXR1cm4gaXNFZGl0YWJsZSAmJiBkaXNwYXRjaENvbW1hbmQoZWRpdG9yLCBGT0NVU19DT01NQU5ELCBldmVudCk7XG4gICAgICAgIGNhc2UgJ2JsdXInOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBpc0VkaXRhYmxlICYmIGRpc3BhdGNoQ29tbWFuZChlZGl0b3IsIEJMVVJfQ09NTUFORCwgZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnZHJvcCc6XG4gICAgICAgICAgcmV0dXJuIGlzRWRpdGFibGUgJiYgZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgRFJPUF9DT01NQU5ELCBldmVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByb290RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgICByZW1vdmVIYW5kbGVzLnB1c2goKCkgPT4ge1xuICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IHJvb3RFbGVtZW50Tm90UmVnaXN0ZXJlZFdhcm5pbmcgPSB3YXJuT25seU9uY2UoJ1Jvb3QgZWxlbWVudCBub3QgcmVnaXN0ZXJlZCcpO1xuZnVuY3Rpb24gcmVtb3ZlUm9vdEVsZW1lbnRFdmVudHMocm9vdEVsZW1lbnQpIHtcbiAgY29uc3QgZG9jID0gcm9vdEVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgY29uc3QgZG9jdW1lbnRSb290RWxlbWVudHNDb3VudCA9IHJvb3RFbGVtZW50c1JlZ2lzdGVyZWQuZ2V0KGRvYyk7XG4gIGlmIChkb2N1bWVudFJvb3RFbGVtZW50c0NvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgc2V0Um9vdEVsZW1lbnQoKSBmYWlsZWRcbiAgICByb290RWxlbWVudE5vdFJlZ2lzdGVyZWRXYXJuaW5nKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gV2Ugb25seSB3YW50IHRvIGhhdmUgYSBzaW5nbGUgZ2xvYmFsIHNlbGVjdGlvbmNoYW5nZSBldmVudCBoYW5kbGVyLCBzaGFyZWRcbiAgLy8gYmV0d2VlbiBhbGwgZWRpdG9yIGluc3RhbmNlcy5cbiAgY29uc3QgbmV3Q291bnQgPSBkb2N1bWVudFJvb3RFbGVtZW50c0NvdW50IC0gMTtcbiAgaWYgKCEobmV3Q291bnQgPj0gMCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFJvb3QgZWxlbWVudCBjb3VudCBsZXNzIHRoYW4gMGApO1xuICB9XG4gIHJvb3RFbGVtZW50c1JlZ2lzdGVyZWQuc2V0KGRvYywgbmV3Q291bnQpO1xuICBpZiAobmV3Q291bnQgPT09IDApIHtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25Eb2N1bWVudFNlbGVjdGlvbkNoYW5nZSk7XG4gIH1cbiAgY29uc3QgZWRpdG9yID0gZ2V0RWRpdG9yUHJvcGVydHlGcm9tRE9NTm9kZShyb290RWxlbWVudCk7XG4gIGlmIChpc0xleGljYWxFZGl0b3IoZWRpdG9yKSkge1xuICAgIGNsZWFuQWN0aXZlTmVzdGVkRWRpdG9yc01hcChlZGl0b3IpO1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgcm9vdEVsZW1lbnQuX19sZXhpY2FsRWRpdG9yID0gbnVsbDtcbiAgfSBlbHNlIGlmIChlZGl0b3IpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEF0dGVtcHRlZCB0byByZW1vdmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBhIG5vZGUgdGhhdCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBidWlsZCBvZiBMZXhpY2FsYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlbW92ZUhhbmRsZXMgPSBnZXRSb290RWxlbWVudFJlbW92ZUhhbmRsZXMocm9vdEVsZW1lbnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZUhhbmRsZXMubGVuZ3RoOyBpKyspIHtcbiAgICByZW1vdmVIYW5kbGVzW2ldKCk7XG4gIH1cblxuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICByb290RWxlbWVudC5fX2xleGljYWxFdmVudEhhbmRsZXMgPSBbXTtcbn1cbmZ1bmN0aW9uIGNsZWFuQWN0aXZlTmVzdGVkRWRpdG9yc01hcChlZGl0b3IpIHtcbiAgaWYgKGVkaXRvci5fcGFyZW50RWRpdG9yICE9PSBudWxsKSB7XG4gICAgLy8gRm9yIG5lc3RlZCBlZGl0b3IgY2xlYW51cCBtYXAgaWYgdGhpcyBlZGl0b3Igd2FzIG1hcmtlZCBhcyBhY3RpdmVcbiAgICBjb25zdCBlZGl0b3JzID0gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKGVkaXRvcik7XG4gICAgY29uc3Qgcm9vdEVkaXRvciA9IGVkaXRvcnNbZWRpdG9ycy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCByb290RWRpdG9yS2V5ID0gcm9vdEVkaXRvci5fa2V5O1xuICAgIGlmIChhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmdldChyb290RWRpdG9yS2V5KSA9PT0gZWRpdG9yKSB7XG4gICAgICBhY3RpdmVOZXN0ZWRFZGl0b3JzTWFwLmRlbGV0ZShyb290RWRpdG9yS2V5KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRm9yIHRvcC1sZXZlbCBlZGl0b3JzIGNsZWFudXAgbWFwXG4gICAgYWN0aXZlTmVzdGVkRWRpdG9yc01hcC5kZWxldGUoZWRpdG9yLl9rZXkpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSgpIHtcbiAgaXNTZWxlY3Rpb25DaGFuZ2VGcm9tRE9NVXBkYXRlID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIG1hcmtDb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQoZm9ybWF0LCBzdHlsZSwgb2Zmc2V0LCBrZXksIHRpbWVTdGFtcCkge1xuICBjb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQgPSBbZm9ybWF0LCBzdHlsZSwgb2Zmc2V0LCBrZXksIHRpbWVTdGFtcF07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgdHlwZSBmb3IgYWxsIHNlcmlhbGl6ZWQgbm9kZXNcbiAqL1xuXG4vKipcbiAqIEVYUEVSSU1FTlRBTFxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBub2RlIHJldHVybmVkIGJ5IExleGljYWxOb2RlLiRjb25maWcoKVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY2xhc3MgQ3VzdG9tVGV4dCBleHRlbmRzIFRleHROb2RlIHtcbiAqICAgJGNvbmZpZygpIHtcbiAqICAgICByZXR1cm4gdGhpcy5jb25maWcoJ2N1c3RvbS10ZXh0Jywge2V4dGVuZHM6IFRleHROb2RlfX07XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgdHlwZSBvZiBMZXhpY2FsTm9kZS4kY29uZmlnKCkgdGhhdCBjYW4gYmVcbiAqIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3Nlcy5cbiAqL1xuXG4vKipcbiAqIFVzZWQgdG8gZXh0cmFjdCB0aGUgbm9kZSBhbmQgdHlwZSBmcm9tIGEgU3RhdGljTm9kZUNvbmZpZ1JlY29yZFxuICovXG5cbi8qKlxuICogQW55IFN0YXRpY05vZGVDb25maWdWYWx1ZSAoZm9yIGdlbmVyaWNzIGFuZCBjb2xsZWN0aW9ucylcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBUaGlzIGlzIHRoZSBtb3JlIHNwZWNpZmljIHR5cGUgdGhhbiBCYXNlU3RhdGljTm9kZUNvbmZpZyB0aGF0IGEgc3ViY2xhc3NcbiAqIHNob3VsZCByZXR1cm4gZnJvbSAkY29uZmlnKClcbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgdGhlIHR5cGUgZnJvbSBhIG5vZGUgYmFzZWQgb24gaXRzICRjb25maWdcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIHR5cGUgVGV4dE5vZGVUeXBlID0gR2V0U3RhdGljTm9kZVR5cGU8VGV4dE5vZGU+O1xuICogICAgICAvLyA/ICd0ZXh0J1xuICogYGBgXG4gKi9cblxuLyoqXG4gKiBUaGUgbW9zdCBwcmVjaXNlIHR5cGUgd2UgY2FuIGluZmVyIGZvciB0aGUgSlNPTiB0aGF0IHdpbGxcbiAqIGJlIHByb2R1Y2VkIGJ5IFQuZXhwb3J0SlNPTigpLlxuICpcbiAqIERvIG5vdCB1c2UgdGhpcyBmb3IgdGhlIHJldHVybiB0eXBlIG9mIFQuZXhwb3J0SlNPTigpISBJdCBtdXN0IGJlXG4gKiBhIG1vcmUgZ2VuZXJpYyB0eXBlIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBzdWJjbGFzc2luZy5cbiAqL1xuXG4vKipcbiAqIE9taXQgdGhlIGNoaWxkcmVuLCB0eXBlLCBhbmQgdmVyc2lvbiBwcm9wZXJ0aWVzIGZyb20gdGhlIGdpdmVuIFNlcmlhbGl6ZWRMZXhpY2FsTm9kZSBkZWZpbml0aW9uLlxuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuZnVuY3Rpb24gJHJlbW92ZU5vZGUobm9kZVRvUmVtb3ZlLCByZXN0b3JlU2VsZWN0aW9uLCBwcmVzZXJ2ZUVtcHR5UGFyZW50KSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBrZXkgPSBub2RlVG9SZW1vdmUuX19rZXk7XG4gIGNvbnN0IHBhcmVudCA9IG5vZGVUb1JlbW92ZS5nZXRQYXJlbnQoKTtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb24gPSAkbWF5YmVNb3ZlQ2hpbGRyZW5TZWxlY3Rpb25Ub1BhcmVudChub2RlVG9SZW1vdmUpO1xuICBsZXQgc2VsZWN0aW9uTW92ZWQgPSBmYWxzZTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbikge1xuICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gICAgaWYgKGFuY2hvci5rZXkgPT09IGtleSkge1xuICAgICAgbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKGFuY2hvciwgbm9kZVRvUmVtb3ZlLCBwYXJlbnQsIG5vZGVUb1JlbW92ZS5nZXRQcmV2aW91c1NpYmxpbmcoKSwgbm9kZVRvUmVtb3ZlLmdldE5leHRTaWJsaW5nKCkpO1xuICAgICAgc2VsZWN0aW9uTW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZm9jdXMua2V5ID09PSBrZXkpIHtcbiAgICAgIG1vdmVTZWxlY3Rpb25Qb2ludFRvU2libGluZyhmb2N1cywgbm9kZVRvUmVtb3ZlLCBwYXJlbnQsIG5vZGVUb1JlbW92ZS5nZXRQcmV2aW91c1NpYmxpbmcoKSwgbm9kZVRvUmVtb3ZlLmdldE5leHRTaWJsaW5nKCkpO1xuICAgICAgc2VsZWN0aW9uTW92ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbiAmJiBub2RlVG9SZW1vdmUuaXNTZWxlY3RlZCgpKSB7XG4gICAgbm9kZVRvUmVtb3ZlLnNlbGVjdFByZXZpb3VzKCk7XG4gIH1cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgcmVzdG9yZVNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uTW92ZWQpIHtcbiAgICAvLyBEb2luZyB0aGlzIGlzIE8obikgc28gbGV0cyBhdm9pZCBpdCB1bmxlc3Mgd2UgbmVlZCB0byBkbyBpdFxuICAgIGNvbnN0IGluZGV4ID0gbm9kZVRvUmVtb3ZlLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgcmVtb3ZlRnJvbVBhcmVudChub2RlVG9SZW1vdmUpO1xuICAgICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgcGFyZW50LCBpbmRleCwgLTEpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUZyb21QYXJlbnQobm9kZVRvUmVtb3ZlKTtcbiAgfVxuICBpZiAoIXByZXNlcnZlRW1wdHlQYXJlbnQgJiYgISRpc1Jvb3RPclNoYWRvd1Jvb3QocGFyZW50KSAmJiAhcGFyZW50LmNhbkJlRW1wdHkoKSAmJiBwYXJlbnQuaXNFbXB0eSgpKSB7XG4gICAgJHJlbW92ZU5vZGUocGFyZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgfVxuICBpZiAocmVzdG9yZVNlbGVjdGlvbiAmJiBzZWxlY3Rpb24gJiYgJGlzUm9vdE5vZGUocGFyZW50KSAmJiBwYXJlbnQuaXNFbXB0eSgpKSB7XG4gICAgcGFyZW50LnNlbGVjdEVuZCgpO1xuICB9XG59XG4vKipcbiAqIEFuIGlkZW50aXR5IGZ1bmN0aW9uIHRoYXQgd2lsbCBpbmZlciB0aGUgdHlwZSBvZiBET00gbm9kZXNcbiAqIGJhc2VkIG9uIHRhZyBuYW1lcyB0byBtYWtlIGl0IGVhc2llciB0byBjb25zdHJ1Y3QgYVxuICogRE9NQ29udmVyc2lvbk1hcC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRJbXBvcnRNYXAoaW1wb3J0TWFwKSB7XG4gIHJldHVybiBpbXBvcnRNYXA7XG59XG5jbGFzcyBMZXhpY2FsTm9kZSB7XG4gIC8vIEFsbG93IHVzIHRvIGxvb2sgdXAgdGhlIHR5cGUgaW5jbHVkaW5nIHN0YXRpYyBwcm9wc1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gIC8vQHRzLWlnbm9yZSBXZSBzZXQgdGhlIGtleSBpbiB0aGUgY29uc3RydWN0b3IuXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IGFic3RyYWN0IGNsYXNzZXMgdW5mb3J0dW5hdGVseSwgc28gd2UgY2FuJ3QgX2ZvcmNlX1xuICAvLyBzdWJjbGFzc2VzIG9mIE5vZGUgdG8gaW1wbGVtZW50IHN0YXRpY3MuIEFsbCBzdWJjbGFzc2VzIG9mIE5vZGUgc2hvdWxkIGhhdmVcbiAgLy8gYSBzdGF0aWMgZ2V0VHlwZSBhbmQgY2xvbmUgbWV0aG9kIHRob3VnaC4gV2UgZGVmaW5lIGdldFR5cGUgYW5kIGNsb25lIGhlcmUgc28gd2UgY2FuIGNhbGwgaXRcbiAgLy8gb24gYW55ICBOb2RlLCBhbmQgd2UgdGhyb3cgdGhpcyBlcnJvciBieSBkZWZhdWx0IHNpbmNlIHRoZSBzdWJjbGFzcyBzaG91bGQgcHJvdmlkZVxuICAvLyB0aGVpciBvd24gaW1wbGVtZW50YXRpb24uXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJpbmcgdHlwZSBvZiB0aGlzIG5vZGUuIEV2ZXJ5IG5vZGUgbXVzdFxuICAgKiBpbXBsZW1lbnQgdGhpcyBhbmQgaXQgTVVTVCBCRSBVTklRVUUgYW1vbmdzdCBub2RlcyByZWdpc3RlcmVkXG4gICAqIG9uIHRoZSBlZGl0b3IuXG4gICAqXG4gICAqL1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBvd25Ob2RlVHlwZVxuICAgIH0gPSBnZXRTdGF0aWNOb2RlQ29uZmlnKHRoaXMpO1xuICAgIGlmICghKG93bk5vZGVUeXBlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYExleGljYWxOb2RlOiBOb2RlICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmdldFR5cGUoKS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG93bk5vZGVUeXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGlzIG5vZGUsIGNyZWF0aW5nIGEgbmV3IG5vZGUgd2l0aCBhIGRpZmZlcmVudCBrZXlcbiAgICogYW5kIGFkZGluZyBpdCB0byB0aGUgRWRpdG9yU3RhdGUgKGJ1dCBub3QgYXR0YWNoaW5nIGl0IGFueXdoZXJlISkuIEFsbCBub2RlcyBtdXN0XG4gICAqIGltcGxlbWVudCB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICovXG4gIHN0YXRpYyBjbG9uZShfZGF0YSkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTGV4aWNhbE5vZGU6IE5vZGUgJHt0aGlzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuY2xvbmUoKS5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhpcyB0byBpbXBsZW1lbnQgdGhlIG5ldyBzdGF0aWMgbm9kZSBjb25maWd1cmF0aW9uIHByb3RvY29sLFxuICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgZGlyZWN0bHkgb24gdGhlIHByb3RvdHlwZSBhbmQgbXVzdCBub3QgZGVwZW5kXG4gICAqIG9uIGFueXRoaW5nIGluaXRpYWxpemVkIGluIHRoZSBjb25zdHJ1Y3Rvci4gR2VuZXJhbGx5IGl0IHNob3VsZCBiZVxuICAgKiBhIHRyaXZpYWwgaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNsYXNzIE15Tm9kZSBleHRlbmRzIFRleHROb2RlIHtcbiAgICogICAkY29uZmlnKCkge1xuICAgKiAgICAgcmV0dXJuIHRoaXMuY29uZmlnKCdteS1ub2RlJywge2V4dGVuZHM6IFRleHROb2RlfSk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgJGNvbmZpZygpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgJGNvbmZpZyB0aGF0XG4gICAqIGFpZHMgaW4gdHlwZSBpbmZlcmVuY2UuIFNlZSB7QGxpbmsgTGV4aWNhbE5vZGUuJGNvbmZpZ31cbiAgICogZm9yIGV4YW1wbGUgdXNhZ2UuXG4gICAqL1xuICBjb25maWcodHlwZSwgY29uZmlnKSB7XG4gICAgY29uc3QgcGFyZW50S2xhc3MgPSBjb25maWcuZXh0ZW5kcyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIHtcbiAgICAgIGV4dGVuZHM6IHBhcmVudEtsYXNzLFxuICAgICAgdHlwZVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBbdHlwZV06IGNvbmZpZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybSBhbnkgc3RhdGUgdXBkYXRlcyBvbiB0aGUgY2xvbmUgb2YgcHJldk5vZGUgdGhhdCBhcmUgbm90IGFscmVhZHlcbiAgICogaGFuZGxlZCBieSB0aGUgY29uc3RydWN0b3IgY2FsbCBpbiB0aGUgc3RhdGljIGNsb25lIG1ldGhvZC4gSWYgeW91IGhhdmVcbiAgICogc3RhdGUgdG8gdXBkYXRlIGluIHlvdXIgY2xvbmUgdGhhdCBpcyBub3QgaGFuZGxlZCBkaXJlY3RseSBieSB0aGVcbiAgICogY29uc3RydWN0b3IsIGl0IGlzIGFkdmlzYWJsZSB0byBvdmVycmlkZSB0aGlzIG1ldGhvZCBidXQgaXQgaXMgcmVxdWlyZWRcbiAgICogdG8gaW5jbHVkZSBhIGNhbGwgdG8gYHN1cGVyLmFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKWAgaW4geW91clxuICAgKiBpbXBsZW1lbnRhdGlvbi4gVGhpcyBpcyBvbmx5IGludGVuZGVkIHRvIGJlIGNhbGxlZCBieVxuICAgKiB7QGxpbmsgJGNsb25lV2l0aFByb3BlcnRpZXN9IGZ1bmN0aW9uIG9yIHZpYSBhIHN1cGVyIGNhbGwuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYHRzXG4gICAqIGNsYXNzIENsYXNzZXNUZXh0Tm9kZSBleHRlbmRzIFRleHROb2RlIHtcbiAgICogICAvLyBOb3Qgc2hvd246IHN0YXRpYyBnZXRUeXBlLCBzdGF0aWMgaW1wb3J0SlNPTiwgZXhwb3J0SlNPTiwgY3JlYXRlRE9NLCB1cGRhdGVET01cbiAgICogICBfX2NsYXNzZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICogICBzdGF0aWMgY2xvbmUobm9kZTogQ2xhc3Nlc1RleHROb2RlKTogQ2xhc3Nlc1RleHROb2RlIHtcbiAgICogICAgIC8vIFRoZSBpbmhlcml0ZWQgVGV4dE5vZGUgY29uc3RydWN0b3IgaXMgdXNlZCBoZXJlLCBzb1xuICAgKiAgICAgLy8gY2xhc3NlcyBpcyBub3Qgc2V0IGJ5IHRoaXMgbWV0aG9kLlxuICAgKiAgICAgcmV0dXJuIG5ldyBDbGFzc2VzVGV4dE5vZGUobm9kZS5fX3RleHQsIG5vZGUuX19rZXkpO1xuICAgKiAgIH1cbiAgICogICBhZnRlckNsb25lRnJvbShub2RlOiB0aGlzKTogdm9pZCB7XG4gICAqICAgICAvLyBUaGlzIGNhbGxzIFRleHROb2RlLmFmdGVyQ2xvbmVGcm9tIGFuZCBMZXhpY2FsTm9kZS5hZnRlckNsb25lRnJvbVxuICAgKiAgICAgLy8gZm9yIG5lY2Vzc2FyeSBzdGF0ZSB1cGRhdGVzXG4gICAqICAgICBzdXBlci5hZnRlckNsb25lRnJvbShub2RlKTtcbiAgICogICAgIHRoaXMuX19hZGRDbGFzc2VzKG5vZGUuX19jbGFzc2VzKTtcbiAgICogICB9XG4gICAqICAgLy8gVGhpcyBtZXRob2QgaXMgYSBwcml2YXRlIGltcGxlbWVudGF0aW9uIGRldGFpbCwgaXQgaXMgbm90XG4gICAqICAgLy8gc3VpdGFibGUgZm9yIHRoZSBwdWJsaWMgQVBJIGJlY2F1c2UgaXQgZG9lcyBub3QgY2FsbCBnZXRXcml0YWJsZVxuICAgKiAgIF9fYWRkQ2xhc3NlcyhjbGFzc05hbWVzOiBJdGVyYWJsZTxzdHJpbmc+KTogdGhpcyB7XG4gICAqICAgICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAqICAgICAgIHRoaXMuX19jbGFzc2VzLmFkZChjbGFzc05hbWUpO1xuICAgKiAgICAgfVxuICAgKiAgICAgcmV0dXJuIHRoaXM7XG4gICAqICAgfVxuICAgKiAgIGFkZENsYXNzKC4uLmNsYXNzTmFtZXM6IHN0cmluZ1tdKTogdGhpcyB7XG4gICAqICAgICByZXR1cm4gdGhpcy5nZXRXcml0YWJsZSgpLl9fYWRkQ2xhc3NlcyhjbGFzc05hbWVzKTtcbiAgICogICB9XG4gICAqICAgcmVtb3ZlQ2xhc3MoLi4uY2xhc3NOYW1lczogc3RyaW5nW10pOiB0aGlzIHtcbiAgICogICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAqICAgICBmb3IgKGNvbnN0IGNsYXNzTmFtZSBvZiBjbGFzc05hbWVzKSB7XG4gICAqICAgICAgIHRoaXMuX19jbGFzc2VzLmRlbGV0ZShjbGFzc05hbWUpO1xuICAgKiAgICAgfVxuICAgKiAgICAgcmV0dXJuIHRoaXM7XG4gICAqICAgfVxuICAgKiAgIGdldENsYXNzZXMoKTogU2V0PHN0cmluZz4ge1xuICAgKiAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19jbGFzc2VzO1xuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICpcbiAgICovXG4gIGFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKSB7XG4gICAgaWYgKHRoaXMuX19rZXkgPT09IHByZXZOb2RlLl9fa2V5KSB7XG4gICAgICB0aGlzLl9fcGFyZW50ID0gcHJldk5vZGUuX19wYXJlbnQ7XG4gICAgICB0aGlzLl9fbmV4dCA9IHByZXZOb2RlLl9fbmV4dDtcbiAgICAgIHRoaXMuX19wcmV2ID0gcHJldk5vZGUuX19wcmV2O1xuICAgICAgdGhpcy5fX3N0YXRlID0gcHJldk5vZGUuX19zdGF0ZTtcbiAgICB9IGVsc2UgaWYgKHByZXZOb2RlLl9fc3RhdGUpIHtcbiAgICAgIHRoaXMuX19zdGF0ZSA9IHByZXZOb2RlLl9fc3RhdGUuZ2V0V3JpdGFibGUodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICB0aGlzLl9fdHlwZSA9IHRoaXMuY29uc3RydWN0b3IuZ2V0VHlwZSgpO1xuICAgIHRoaXMuX19wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuX19wcmV2ID0gbnVsbDtcbiAgICB0aGlzLl9fbmV4dCA9IG51bGw7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdfX3N0YXRlJywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICAkc2V0Tm9kZUtleSh0aGlzLCBrZXkpO1xuICAgIHtcbiAgICAgIGlmICh0aGlzLl9fdHlwZSAhPT0gJ3Jvb3QnKSB7XG4gICAgICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgICAgICBlcnJvck9uVHlwZUtsYXNzTWlzbWF0Y2godGhpcy5fX3R5cGUsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBHZXR0ZXJzIGFuZCBUcmF2ZXJzZXJzXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN0cmluZyB0eXBlIG9mIHRoaXMgbm9kZS5cbiAgICovXG4gIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190eXBlO1xuICB9XG4gIGlzSW5saW5lKCkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTGV4aWNhbE5vZGU6IE5vZGUgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuaXNJbmxpbmUoKS5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgcGF0aCBiZXR3ZWVuIHRoaXMgbm9kZSBhbmQgdGhlIFJvb3ROb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIFRoaXMgaXMgYSB3YXkgb2YgZGV0ZXJtaW5pbmcgaWYgdGhlIG5vZGUgaXMgXCJhdHRhY2hlZFwiIEVkaXRvclN0YXRlLiBVbmF0dGFjaGVkIG5vZGVzXG4gICAqIHdvbid0IGJlIHJlY29uY2lsZWQgYW5kIHdpbGwgdWx0aW1hdGVseSBiZSBjbGVhbmVkIHVwIGJ5IHRoZSBMZXhpY2FsIEdDLlxuICAgKi9cbiAgaXNBdHRhY2hlZCgpIHtcbiAgICBsZXQgbm9kZUtleSA9IHRoaXMuX19rZXk7XG4gICAgd2hpbGUgKG5vZGVLZXkgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlS2V5ID09PSAncm9vdCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbiAgICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZUtleSA9IG5vZGUuX19wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGlzIGNvbnRhaW5lZCB3aXRoaW4gdGhlIHByb3ZpZGVkIFNlbGVjdGlvbi4sIGZhbHNlIG90aGVyd2lzZS5cbiAgICogUmVsaWVzIG9uIHRoZSBhbGdvcml0aG1zIGltcGxlbWVudGVkIGluIHtAbGluayBCYXNlU2VsZWN0aW9uLmdldE5vZGVzfSB0byBkZXRlcm1pbmVcbiAgICogd2hhdCdzIGluY2x1ZGVkLlxuICAgKlxuICAgKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB0aGF0IHdlIHdhbnQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBub2RlIGlzIGluLlxuICAgKi9cbiAgaXNTZWxlY3RlZChzZWxlY3Rpb24pIHtcbiAgICBjb25zdCB0YXJnZXRTZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICh0YXJnZXRTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc1NlbGVjdGVkID0gdGFyZ2V0U2VsZWN0aW9uLmdldE5vZGVzKCkuc29tZShuID0+IG4uX19rZXkgPT09IHRoaXMuX19rZXkpO1xuICAgIGlmICgkaXNUZXh0Tm9kZSh0aGlzKSkge1xuICAgICAgcmV0dXJuIGlzU2VsZWN0ZWQ7XG4gICAgfVxuICAgIC8vIEZvciBpbmxpbmUgaW1hZ2VzIGluc2lkZSBvZiBlbGVtZW50IG5vZGVzLlxuICAgIC8vIFdpdGhvdXQgdGhpcyBjaGFuZ2UgdGhlIGltYWdlIHdpbGwgYmUgc2VsZWN0ZWQgaWYgdGhlIGN1cnNvciBpcyBiZWZvcmUgb3IgYWZ0ZXIgaXQuXG4gICAgY29uc3QgaXNFbGVtZW50UmFuZ2VTZWxlY3Rpb24gPSAkaXNSYW5nZVNlbGVjdGlvbih0YXJnZXRTZWxlY3Rpb24pICYmIHRhcmdldFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHRhcmdldFNlbGVjdGlvbi5mb2N1cy50eXBlID09PSAnZWxlbWVudCc7XG4gICAgaWYgKGlzRWxlbWVudFJhbmdlU2VsZWN0aW9uKSB7XG4gICAgICBpZiAodGFyZ2V0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZSh0aGlzKSAmJiB0aGlzLmlzSW5saW5lKCkgJiYgcGFyZW50Tm9kZSkge1xuICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gdGFyZ2V0U2VsZWN0aW9uLmlzQmFja3dhcmQoKSA/IHRhcmdldFNlbGVjdGlvbi5mb2N1cyA6IHRhcmdldFNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGlmIChwYXJlbnROb2RlLmlzKGZpcnN0UG9pbnQuZ2V0Tm9kZSgpKSAmJiBmaXJzdFBvaW50Lm9mZnNldCA9PT0gcGFyZW50Tm9kZS5nZXRDaGlsZHJlblNpemUoKSAmJiB0aGlzLmlzKHBhcmVudE5vZGUuZ2V0TGFzdENoaWxkKCkpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc1NlbGVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBub2RlcyBrZXkuXG4gICAqL1xuICBnZXRLZXkoKSB7XG4gICAgLy8gS2V5IGlzIHN0YWJsZSBiZXR3ZWVuIGNvcGllc1xuICAgIHJldHVybiB0aGlzLl9fa2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHplcm8tYmFzZWQgaW5kZXggb2YgdGhpcyBub2RlIHdpdGhpbiB0aGUgcGFyZW50LlxuICAgKi9cbiAgZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGxldCBub2RlID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5pcyhub2RlKSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICBpbmRleCsrO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGlzIG5vZGUsIG9yIG51bGwgaWYgbm9uZSBpcyBmb3VuZC5cbiAgICovXG4gIGdldFBhcmVudCgpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldExhdGVzdCgpLl9fcGFyZW50O1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gJGdldE5vZGVCeUtleShwYXJlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHBhcmVudCBvZiB0aGlzIG5vZGUsIG9yIHRocm93cyBpZiBub25lIGlzIGZvdW5kLlxuICAgKi9cbiAgZ2V0UGFyZW50T3JUaHJvdygpIHtcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBub2RlICR7dGhpcy5fX2tleX0gdG8gaGF2ZSBhIHBhcmVudC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoaWdoZXN0IChpbiB0aGUgRWRpdG9yU3RhdGUgdHJlZSlcbiAgICogbm9uLXJvb3QgYW5jZXN0b3Igb2YgdGhpcyBub2RlLCBvciBudWxsIGlmIG5vbmUgaXMgZm91bmQuIFNlZSB7QGxpbmsgbGV4aWNhbCEkaXNSb290T3JTaGFkb3dSb290fVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB3aGljaCBFbGVtZW50cyBjb21wcmlzZSBcInJvb3RzXCIuXG4gICAqL1xuICBnZXRUb3BMZXZlbEVsZW1lbnQoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QocGFyZW50KSkge1xuICAgICAgICBpZiAoISgkaXNFbGVtZW50Tm9kZShub2RlKSB8fCBub2RlID09PSB0aGlzICYmICRpc0RlY29yYXRvck5vZGUobm9kZSkpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBDaGlsZHJlbiBvZiByb290IG5vZGVzIG11c3QgYmUgZWxlbWVudHMgb3IgZGVjb3JhdG9yc2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGlnaGVzdCAoaW4gdGhlIEVkaXRvclN0YXRlIHRyZWUpXG4gICAqIG5vbi1yb290IGFuY2VzdG9yIG9mIHRoaXMgbm9kZSwgb3IgdGhyb3dzIGlmIG5vbmUgaXMgZm91bmQuIFNlZSB7QGxpbmsgbGV4aWNhbCEkaXNSb290T3JTaGFkb3dSb290fVxuICAgKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB3aGljaCBFbGVtZW50cyBjb21wcmlzZSBcInJvb3RzXCIuXG4gICAqL1xuICBnZXRUb3BMZXZlbEVsZW1lbnRPclRocm93KCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0VG9wTGV2ZWxFbGVtZW50KCk7XG4gICAgaWYgKHBhcmVudCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgJHt0aGlzLl9fa2V5fSB0byBoYXZlIGEgdG9wIHBhcmVudCBlbGVtZW50LmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBldmVyeSBhbmNlc3RvciBvZiB0aGlzIG5vZGUsXG4gICAqIGFsbCB0aGUgd2F5IHVwIHRvIHRoZSBSb290Tm9kZS5cbiAgICpcbiAgICovXG4gIGdldFBhcmVudHMoKSB7XG4gICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgIGxldCBub2RlID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHRoZSBrZXlzIG9mIGV2ZXJ5IGFuY2VzdG9yIG9mIHRoaXMgbm9kZSxcbiAgICogYWxsIHRoZSB3YXkgdXAgdG8gdGhlIFJvb3ROb2RlLlxuICAgKlxuICAgKi9cbiAgZ2V0UGFyZW50S2V5cygpIHtcbiAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBwYXJlbnRzLnB1c2gobm9kZS5fX2tleSk7XG4gICAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudHM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJwcmV2aW91c1wiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGUgdGhhdCBjb21lc1xuICAgKiBiZWZvcmUgdGhpcyBvbmUgaW4gdGhlIHNhbWUgcGFyZW50LlxuICAgKlxuICAgKi9cbiAgZ2V0UHJldmlvdXNTaWJsaW5nKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHByZXZLZXkgPSBzZWxmLl9fcHJldjtcbiAgICByZXR1cm4gcHJldktleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KHByZXZLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwicHJldmlvdXNcIiBzaWJsaW5ncyAtIHRoYXQgaXMsIHRoZSBub2RlcyB0aGF0IGNvbWUgYmV0d2VlblxuICAgKiB0aGlzIG9uZSBhbmQgdGhlIGZpcnN0IGNoaWxkIG9mIGl0J3MgcGFyZW50LCBpbmNsdXNpdmUuXG4gICAqXG4gICAqL1xuICBnZXRQcmV2aW91c1NpYmxpbmdzKCkge1xuICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gc2libGluZ3M7XG4gICAgfVxuICAgIGxldCBub2RlID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUuaXModGhpcykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzaWJsaW5ncy5wdXNoKG5vZGUpO1xuICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpYmxpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFwibmV4dFwiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGUgdGhhdCBjb21lc1xuICAgKiBhZnRlciB0aGlzIG9uZSBpbiB0aGUgc2FtZSBwYXJlbnRcbiAgICpcbiAgICovXG4gIGdldE5leHRTaWJsaW5nKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IG5leHRLZXkgPSBzZWxmLl9fbmV4dDtcbiAgICByZXR1cm4gbmV4dEtleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KG5leHRLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIFwibmV4dFwiIHNpYmxpbmdzIC0gdGhhdCBpcywgdGhlIG5vZGVzIHRoYXQgY29tZSBiZXR3ZWVuIHRoaXNcbiAgICogb25lIGFuZCB0aGUgbGFzdCBjaGlsZCBvZiBpdCdzIHBhcmVudCwgaW5jbHVzaXZlLlxuICAgKlxuICAgKi9cbiAgZ2V0TmV4dFNpYmxpbmdzKCkge1xuICAgIGNvbnN0IHNpYmxpbmdzID0gW107XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldE5leHRTaWJsaW5nKCk7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmdzLnB1c2gobm9kZSk7XG4gICAgICBub2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgICByZXR1cm4gc2libGluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayAkZ2V0Q29tbW9uQW5jZXN0b3J9XG4gICAqXG4gICAqIFJldHVybnMgdGhlIGNsb3Nlc3QgY29tbW9uIGFuY2VzdG9yIG9mIHRoaXMgbm9kZSBhbmQgdGhlIHByb3ZpZGVkIG9uZSBvciBudWxsXG4gICAqIGlmIG9uZSBjYW5ub3QgYmUgZm91bmQuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlIC0gdGhlIG90aGVyIG5vZGUgdG8gZmluZCB0aGUgY29tbW9uIGFuY2VzdG9yIG9mLlxuICAgKi9cbiAgZ2V0Q29tbW9uQW5jZXN0b3Iobm9kZSkge1xuICAgIGNvbnN0IGEgPSAkaXNFbGVtZW50Tm9kZSh0aGlzKSA/IHRoaXMgOiB0aGlzLmdldFBhcmVudCgpO1xuICAgIGNvbnN0IGIgPSAkaXNFbGVtZW50Tm9kZShub2RlKSA/IG5vZGUgOiBub2RlLmdldFBhcmVudCgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJiYgYiA/ICRnZXRDb21tb25BbmNlc3RvcihhLCBiKSA6IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdC5jb21tb25BbmNlc3RvciAvKiBUT0RPIHRoaXMgdHlwZSBjYXN0IGlzIGEgbGllLCBidXQgZml4aW5nIGl0IHdvdWxkIGJyZWFrIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5ICovIDogbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIG5vZGUgaXMgdGhlIGV4YWN0IHNhbWUgb25lIGFzIHRoaXMgbm9kZSwgZnJvbSBMZXhpY2FsJ3MgcGVyc3BlY3RpdmUuXG4gICAqIEFsd2F5cyB1c2UgdGhpcyBpbnN0ZWFkIG9mIHJlZmVyZW50aWFsIGVxdWFsaXR5LlxuICAgKlxuICAgKiBAcGFyYW0gb2JqZWN0IC0gdGhlIG5vZGUgdG8gcGVyZm9ybSB0aGUgZXF1YWxpdHkgY29tcGFyaXNvbiBvbi5cbiAgICovXG4gIGlzKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX2tleSA9PT0gb2JqZWN0Ll9fa2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG5vZGUgbG9naWNhbGx5IHByZWNlZGVzIHRoZSB0YXJnZXQgbm9kZSBpbiB0aGVcbiAgICogZWRpdG9yIHN0YXRlLCBmYWxzZSBvdGhlcndpc2UgKGluY2x1ZGluZyBpZiB0aGVyZSBpcyBubyBjb21tb24gYW5jZXN0b3IpLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBub3Rpb24gb2YgaXNCZWZvcmUgaXMgYmFzZWQgb24gcG9zdC1vcmRlcjsgYSBkZXNjZW5kYW50XG4gICAqIG5vZGUgaXMgYWx3YXlzIGJlZm9yZSBpdHMgYW5jZXN0b3JzLiBTZWUgYWxzb1xuICAgKiB7QGxpbmsgJGdldENvbW1vbkFuY2VzdG9yfSBhbmQge0BsaW5rICRjb21wYXJlUG9pbnRDYXJldE5leHR9IGZvclxuICAgKiBtb3JlIGZsZXhpYmxlIHdheXMgdG8gZGV0ZXJtaW5lIHRoZSByZWxhdGl2ZSBwb3NpdGlvbnMgb2Ygbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlIC0gdGhlIG5vZGUgd2UncmUgdGVzdGluZyB0byBzZWUgaWYgaXQncyBhZnRlciB0aGlzIG9uZS5cbiAgICovXG4gIGlzQmVmb3JlKHRhcmdldE5vZGUpIHtcbiAgICBjb25zdCBjb21wYXJlID0gJGdldENvbW1vbkFuY2VzdG9yKHRoaXMsIHRhcmdldE5vZGUpO1xuICAgIGlmIChjb21wYXJlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChjb21wYXJlLnR5cGUgPT09ICdkZXNjZW5kYW50Jykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjb21wYXJlLnR5cGUgPT09ICdicmFuY2gnKSB7XG4gICAgICByZXR1cm4gJGdldENvbW1vbkFuY2VzdG9yUmVzdWx0QnJhbmNoT3JkZXIoY29tcGFyZSkgPT09IC0xO1xuICAgIH1cbiAgICBpZiAoIShjb21wYXJlLnR5cGUgPT09ICdzYW1lJyB8fCBjb21wYXJlLnR5cGUgPT09ICdhbmNlc3RvcicpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYExleGljYWxOb2RlLmlzQmVmb3JlOiBleGhhdXN0aXZlbmVzcyBjaGVja2ApO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbm9kZSBpcyBhbiBhbmNlc3RvciBvZiBhbmQgZGlzdGluY3QgZnJvbSB0aGUgdGFyZ2V0IG5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICpcbiAgICogQHBhcmFtIHRhcmdldE5vZGUgLSB0aGUgd291bGQtYmUgY2hpbGQgbm9kZS5cbiAgICovXG4gIGlzUGFyZW50T2YodGFyZ2V0Tm9kZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9ICRnZXRDb21tb25BbmNlc3Rvcih0aGlzLCB0YXJnZXROb2RlKTtcbiAgICByZXR1cm4gcmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdC50eXBlID09PSAnYW5jZXN0b3InO1xuICB9XG5cbiAgLy8gVE8tRE86IHRoaXMgZnVuY3Rpb24gY2FuIGJlIHNpbXBsaWZpZWQgYSBsb3RcbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGJldHdlZW4gdGhpcyBub2RlIGFuZFxuICAgKiB0aGUgdGFyZ2V0IG5vZGUgaW4gdGhlIEVkaXRvclN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0gdGFyZ2V0Tm9kZSAtIHRoZSBub2RlIHRoYXQgbWFya3MgdGhlIG90aGVyIGVuZCBvZiB0aGUgcmFuZ2Ugb2Ygbm9kZXMgdG8gYmUgcmV0dXJuZWQuXG4gICAqL1xuICBnZXROb2Rlc0JldHdlZW4odGFyZ2V0Tm9kZSkge1xuICAgIGNvbnN0IGlzQmVmb3JlID0gdGhpcy5pc0JlZm9yZSh0YXJnZXROb2RlKTtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgbGV0IG5vZGUgPSB0aGlzO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IG5vZGUuX19rZXk7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGtleSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQoa2V5KTtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB0YXJnZXROb2RlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGQgPSAkaXNFbGVtZW50Tm9kZShub2RlKSA/IGlzQmVmb3JlID8gbm9kZS5nZXRGaXJzdENoaWxkKCkgOiBub2RlLmdldExhc3RDaGlsZCgpIDogbnVsbDtcbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBpc0JlZm9yZSA/IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA6IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAobmV4dFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhwYXJlbnQuX19rZXkpKSB7XG4gICAgICAgIG5vZGVzLnB1c2gocGFyZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgPT09IHRhcmdldE5vZGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgcGFyZW50U2libGluZyA9IG51bGw7XG4gICAgICBsZXQgYW5jZXN0b3IgPSBwYXJlbnQ7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChhbmNlc3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0Tm9kZXNCZXR3ZWVuOiBhbmNlc3RvciBpcyBudWxsYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBhcmVudFNpYmxpbmcgPSBpc0JlZm9yZSA/IGFuY2VzdG9yLmdldE5leHRTaWJsaW5nKCkgOiBhbmNlc3Rvci5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKGFuY2VzdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT09IG51bGwgJiYgIXZpc2l0ZWQuaGFzKGFuY2VzdG9yLl9fa2V5KSkge1xuICAgICAgICAgICAgbm9kZXMucHVzaChhbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChwYXJlbnRTaWJsaW5nID09PSBudWxsKTtcbiAgICAgIG5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgIH1cbiAgICBpZiAoIWlzQmVmb3JlKSB7XG4gICAgICBub2Rlcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBub2RlIGhhcyBiZWVuIG1hcmtlZCBkaXJ0eSBkdXJpbmcgdGhpcyB1cGRhdGUgY3ljbGUuXG4gICAqXG4gICAqL1xuICBpc0RpcnR5KCkge1xuICAgIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICAgIGNvbnN0IGRpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgICByZXR1cm4gZGlydHlMZWF2ZXMgIT09IG51bGwgJiYgZGlydHlMZWF2ZXMuaGFzKHRoaXMuX19rZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoZSBub2RlIGZyb20gdGhlIGFjdGl2ZSBFZGl0b3JTdGF0ZS5cbiAgICogVGhpcyBpcyB1c2VkIHRvIGF2b2lkIGdldHRpbmcgdmFsdWVzIGZyb20gc3RhbGUgbm9kZSByZWZlcmVuY2VzLlxuICAgKlxuICAgKi9cbiAgZ2V0TGF0ZXN0KCkge1xuICAgIGNvbnN0IGxhdGVzdCA9ICRnZXROb2RlQnlLZXkodGhpcy5fX2tleSk7XG4gICAgaWYgKGxhdGVzdCA9PT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYExleGljYWwgbm9kZSBkb2VzIG5vdCBleGlzdCBpbiBhY3RpdmUgZWRpdG9yIHN0YXRlLiBBdm9pZCB1c2luZyB0aGUgc2FtZSBub2RlIHJlZmVyZW5jZXMgYmV0d2VlbiBuZXN0ZWQgY2xvc3VyZXMgZnJvbSBlZGl0b3JTdGF0ZS5yZWFkL2VkaXRvci51cGRhdGUuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsYXRlc3Q7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG11dGFibGUgdmVyc2lvbiBvZiB0aGUgbm9kZSB1c2luZyB7QGxpbmsgJGNsb25lV2l0aFByb3BlcnRpZXN9XG4gICAqIGlmIG5lY2Vzc2FyeS4gV2lsbCB0aHJvdyBhbiBlcnJvciBpZiBjYWxsZWQgb3V0c2lkZSBvZiBhIExleGljYWwgRWRpdG9yXG4gICAqIHtAbGluayBMZXhpY2FsRWRpdG9yLnVwZGF0ZX0gY2FsbGJhY2suXG4gICAqXG4gICAqL1xuICBnZXRXcml0YWJsZSgpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7XG4gICAgLy8gRW5zdXJlIHdlIGdldCB0aGUgbGF0ZXN0IG5vZGUgZnJvbSBwZW5kaW5nIHN0YXRlXG4gICAgY29uc3QgbGF0ZXN0Tm9kZSA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgY2xvbmVOb3ROZWVkZWQgPSBlZGl0b3IuX2Nsb25lTm90TmVlZGVkO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBzZWxlY3Rpb24uc2V0Q2FjaGVkTm9kZXMobnVsbCk7XG4gICAgfVxuICAgIGlmIChjbG9uZU5vdE5lZWRlZC5oYXMoa2V5KSkge1xuICAgICAgLy8gVHJhbnNmb3JtcyBjbGVhciB0aGUgZGlydHkgbm9kZSBzZXQgb24gZWFjaCBpdGVyYXRpb24gdG8ga2VlcCB0cmFjayBvbiBuZXdseSBkaXJ0eSBub2Rlc1xuICAgICAgaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkobGF0ZXN0Tm9kZSk7XG4gICAgICByZXR1cm4gbGF0ZXN0Tm9kZTtcbiAgICB9XG4gICAgY29uc3QgbXV0YWJsZU5vZGUgPSAkY2xvbmVXaXRoUHJvcGVydGllcyhsYXRlc3ROb2RlKTtcbiAgICBjbG9uZU5vdE5lZWRlZC5hZGQoa2V5KTtcbiAgICBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShtdXRhYmxlTm9kZSk7XG4gICAgLy8gVXBkYXRlIHJlZmVyZW5jZSBpbiBub2RlIG1hcFxuICAgIG5vZGVNYXAuc2V0KGtleSwgbXV0YWJsZU5vZGUpO1xuICAgIHJldHVybiBtdXRhYmxlTm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuIE92ZXJyaWRlIHRoaXMgZm9yXG4gICAqIGN1c3RvbSBub2RlcyB0aGF0IHNob3VsZCBoYXZlIGEgcmVwcmVzZW50YXRpb24gaW4gcGxhaW4gdGV4dFxuICAgKiBmb3JtYXQgKGZvciBjb3B5ICsgcGFzdGUsIGZvciBleGFtcGxlKVxuICAgKlxuICAgKi9cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHByb2R1Y2VkIGJ5IGNhbGxpbmcgZ2V0VGV4dENvbnRlbnQgb24gdGhpcyBub2RlLlxuICAgKlxuICAgKi9cbiAgZ2V0VGV4dENvbnRlbnRTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmdldFRleHRDb250ZW50KCkubGVuZ3RoO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgZHVyaW5nIHRoZSByZWNvbmNpbGlhdGlvbiBwcm9jZXNzIHRvIGRldGVybWluZSB3aGljaCBub2Rlc1xuICAgKiB0byBpbnNlcnQgaW50byB0aGUgRE9NIGZvciB0aGlzIExleGljYWwgTm9kZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgbXVzdCByZXR1cm4gZXhhY3RseSBvbmUgSFRNTEVsZW1lbnQuIE5lc3RlZCBlbGVtZW50cyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICpcbiAgICogRG8gbm90IGF0dGVtcHQgdG8gdXBkYXRlIHRoZSBMZXhpY2FsIEVkaXRvclN0YXRlIGR1cmluZyB0aGlzIHBoYXNlIG9mIHRoZSB1cGRhdGUgbGlmZWN5Y2xlLlxuICAgKlxuICAgKiBAcGFyYW0gX2NvbmZpZyAtIGFsbG93cyBhY2Nlc3MgdG8gdGhpbmdzIGxpa2UgdGhlIEVkaXRvclRoZW1lICh0byBhcHBseSBjbGFzc2VzKSBkdXJpbmcgcmVjb25jaWxpYXRpb24uXG4gICAqIEBwYXJhbSBfZWRpdG9yIC0gYWxsb3dzIGFjY2VzcyB0byB0aGUgZWRpdG9yIGZvciBjb250ZXh0IGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAgICpcbiAgICogKi9cbiAgY3JlYXRlRE9NKF9jb25maWcsIF9lZGl0b3IpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGNyZWF0ZURPTTogYmFzZSBtZXRob2Qgbm90IGV4dGVuZGVkYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgbm9kZSBjaGFuZ2VzIGFuZCBzaG91bGQgdXBkYXRlIHRoZSBET01cbiAgICogaW4gd2hhdGV2ZXIgd2F5IGlzIG5lY2Vzc2FyeSB0byBtYWtlIGl0IGFsaWduIHdpdGggYW55IGNoYW5nZXMgdGhhdCBtaWdodFxuICAgKiBoYXZlIGhhcHBlbmVkIGR1cmluZyB0aGUgdXBkYXRlLlxuICAgKlxuICAgKiBSZXR1cm5pbmcgXCJ0cnVlXCIgaGVyZSB3aWxsIGNhdXNlIGxleGljYWwgdG8gdW5tb3VudCBhbmQgcmVjcmVhdGUgdGhlIERPTSBub2RlXG4gICAqIChieSBjYWxsaW5nIGNyZWF0ZURPTSkuIFlvdSB3b3VsZCBuZWVkIHRvIGRvIHRoaXMgaWYgdGhlIGVsZW1lbnQgdGFnIGNoYW5nZXMsXG4gICAqIGZvciBpbnN0YW5jZS5cbiAgICpcbiAgICogKi9cbiAgdXBkYXRlRE9NKF9wcmV2Tm9kZSwgX2RvbSwgX2NvbmZpZykge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgdXBkYXRlRE9NOiBiYXNlIG1ldGhvZCBub3QgZXh0ZW5kZWRgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgaG93IHRoZSB0aGlzIG5vZGUgaXMgc2VyaWFsaXplZCB0byBIVE1MLiBUaGlzIGlzIGltcG9ydGFudCBmb3JcbiAgICogY29weSBhbmQgcGFzdGUgYmV0d2VlbiBMZXhpY2FsIGFuZCBub24tTGV4aWNhbCBlZGl0b3JzLCBvciBMZXhpY2FsIGVkaXRvcnMgd2l0aCBkaWZmZXJlbnQgbmFtZXNwYWNlcyxcbiAgICogaW4gd2hpY2ggY2FzZSB0aGUgcHJpbWFyeSB0cmFuc2ZlciBmb3JtYXQgaXMgSFRNTC4gSXQncyBhbHNvIGltcG9ydGFudCBpZiB5b3UncmUgc2VyaWFsaXppbmdcbiAgICogdG8gSFRNTCBmb3IgYW55IG90aGVyIHJlYXNvbiB2aWEge0BsaW5rIEBsZXhpY2FsL2h0bWwhJGdlbmVyYXRlSHRtbEZyb21Ob2Rlc30uIFlvdSBjb3VsZFxuICAgKiBhbHNvIHVzZSB0aGlzIG1ldGhvZCB0byBidWlsZCB5b3VyIG93biBIVE1MIHJlbmRlcmVyLlxuICAgKlxuICAgKiAqL1xuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuY3JlYXRlRE9NKGVkaXRvci5fY29uZmlnLCBlZGl0b3IpO1xuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb250cm9scyBob3cgdGhlIHRoaXMgbm9kZSBpcyBzZXJpYWxpemVkIHRvIEpTT04uIFRoaXMgaXMgaW1wb3J0YW50IGZvclxuICAgKiBjb3B5IGFuZCBwYXN0ZSBiZXR3ZWVuIExleGljYWwgZWRpdG9ycyBzaGFyaW5nIHRoZSBzYW1lIG5hbWVzcGFjZS4gSXQncyBhbHNvIGltcG9ydGFudFxuICAgKiBpZiB5b3UncmUgc2VyaWFsaXppbmcgdG8gSlNPTiBmb3IgcGVyc2lzdGVudCBzdG9yYWdlIHNvbWV3aGVyZS5cbiAgICogU2VlIFtTZXJpYWxpemF0aW9uICYgRGVzZXJpYWxpemF0aW9uXShodHRwczovL2xleGljYWwuZGV2L2RvY3MvY29uY2VwdHMvc2VyaWFsaXphdGlvbiNsZXhpY2FsLS0taHRtbCkuXG4gICAqXG4gICAqICovXG4gIGV4cG9ydEpTT04oKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRvdC1ub3RhdGlvblxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fX3N0YXRlID8gdGhpcy5fX3N0YXRlLnRvSlNPTigpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiB0aGlzLl9fdHlwZSxcbiAgICAgIHZlcnNpb246IDEsXG4gICAgICAuLi5zdGF0ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udHJvbHMgaG93IHRoZSB0aGlzIG5vZGUgaXMgZGVzZXJpYWxpemVkIGZyb20gSlNPTi4gVGhpcyBpcyB1c3VhbGx5IGJvaWxlcnBsYXRlLFxuICAgKiBidXQgcHJvdmlkZXMgYW4gYWJzdHJhY3Rpb24gYmV0d2VlbiB0aGUgbm9kZSBpbXBsZW1lbnRhdGlvbiBhbmQgc2VyaWFsaXplZCBpbnRlcmZhY2UgdGhhdCBjYW5cbiAgICogYmUgaW1wb3J0YW50IGlmIHlvdSBldmVyIG1ha2UgYnJlYWtpbmcgY2hhbmdlcyB0byBhIG5vZGUgc2NoZW1hIChieSBhZGRpbmcgb3IgcmVtb3ZpbmcgcHJvcGVydGllcykuXG4gICAqIFNlZSBbU2VyaWFsaXphdGlvbiAmIERlc2VyaWFsaXphdGlvbl0oaHR0cHM6Ly9sZXhpY2FsLmRldi9kb2NzL2NvbmNlcHRzL3NlcmlhbGl6YXRpb24jbGV4aWNhbC0tLWh0bWwpLlxuICAgKlxuICAgKiAqL1xuICBzdGF0aWMgaW1wb3J0SlNPTihfc2VyaWFsaXplZE5vZGUpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYExleGljYWxOb2RlOiBOb2RlICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBpbXBsZW1lbnQgLmltcG9ydEpTT04oKS5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoaXMgTGV4aWNhbE5vZGUgaW5zdGFuY2UgZnJvbSBzZXJpYWxpemVkIEpTT04uIEl0J3MgcmVjb21tZW5kZWRcbiAgICogdG8gaW1wbGVtZW50IGFzIG11Y2ggbG9naWMgYXMgcG9zc2libGUgaW4gdGhpcyBtZXRob2QgaW5zdGVhZCBvZiB0aGVcbiAgICogc3RhdGljIGltcG9ydEpTT04gbWV0aG9kLCBzbyB0aGF0IHRoZSBmdW5jdGlvbmFsaXR5IGNhbiBiZSBpbmhlcml0ZWQgaW4gc3ViY2xhc3Nlcy5cbiAgICpcbiAgICogVGhlIExleGljYWxVcGRhdGVKU09OIHV0aWxpdHkgdHlwZSBzaG91bGQgYmUgdXNlZCB0byBpZ25vcmUgYW55IHR5cGUsIHZlcnNpb24sXG4gICAqIG9yIGNoaWxkcmVuIHByb3BlcnRpZXMgaW4gdGhlIEpTT04gc28gdGhhdCB0aGUgZXh0ZW5kZWQgSlNPTiBmcm9tIHN1YmNsYXNzZXNcbiAgICogYXJlIGFjY2VwdGFibGUgcGFyYW1ldGVycyBmb3IgdGhlIHN1cGVyIGNhbGwuXG4gICAqXG4gICAqIElmIG92ZXJyaWRkZW4sIHRoaXMgbWV0aG9kIG11c3QgY2FsbCBzdXBlci5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHNcbiAgICogY2xhc3MgTXlUZXh0Tm9kZSBleHRlbmRzIFRleHROb2RlIHtcbiAgICogICAvLyAuLi5cbiAgICogICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZTogU2VyaWFsaXplZE15VGV4dE5vZGUpOiBNeVRleHROb2RlIHtcbiAgICogICAgIHJldHVybiAkY3JlYXRlTXlUZXh0Tm9kZSgpXG4gICAqICAgICAgIC51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gICAqICAgfVxuICAgKiAgIHVwZGF0ZUZyb21KU09OKFxuICAgKiAgICAgc2VyaWFsaXplZE5vZGU6IExleGljYWxVcGRhdGVKU09OPFNlcmlhbGl6ZWRNeVRleHROb2RlPixcbiAgICogICApOiB0aGlzIHtcbiAgICogICAgIHJldHVybiBzdXBlci51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSlcbiAgICogICAgICAgLnNldE15UHJvcGVydHkoc2VyaWFsaXplZE5vZGUubXlQcm9wZXJ0eSk7XG4gICAqICAgfVxuICAgKiB9XG4gICAqIGBgYFxuICAgKiovXG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICR1cGRhdGVTdGF0ZUZyb21KU09OKHRoaXMsIHNlcmlhbGl6ZWROb2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqXG4gICAqIFJlZ2lzdGVycyB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gYXMgYSB0cmFuc2Zvcm0gb24gdGhlIG5vZGUgZHVyaW5nXG4gICAqIEVkaXRvciBpbml0aWFsaXphdGlvbi4gTW9zdCBzdWNoIHVzZSBjYXNlcyBzaG91bGQgYmUgYWRkcmVzc2VkIHZpYVxuICAgKiB0aGUge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtfSBBUEkuXG4gICAqXG4gICAqIEV4cGVyaW1lbnRhbCAtIHVzZSBhdCB5b3VyIG93biByaXNrLlxuICAgKi9cbiAgc3RhdGljIHRyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFNldHRlcnMgYW5kIG11dGF0b3JzXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhpcyBMZXhpY2FsTm9kZSBmcm9tIHRoZSBFZGl0b3JTdGF0ZS4gSWYgdGhlIG5vZGUgaXNuJ3QgcmUtaW5zZXJ0ZWRcbiAgICogc29tZXdoZXJlLCB0aGUgTGV4aWNhbCBnYXJiYWdlIGNvbGxlY3RvciB3aWxsIGV2ZW50dWFsbHkgY2xlYW4gaXQgdXAuXG4gICAqXG4gICAqIEBwYXJhbSBwcmVzZXJ2ZUVtcHR5UGFyZW50IC0gSWYgZmFsc3ksIHRoZSBub2RlJ3MgcGFyZW50IHdpbGwgYmUgcmVtb3ZlZCBpZlxuICAgKiBpdCdzIGVtcHR5IGFmdGVyIHRoZSByZW1vdmFsIG9wZXJhdGlvbi4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvciwgc3ViamVjdCB0b1xuICAgKiBvdGhlciBub2RlIGhldXJpc3RpY3Mgc3VjaCBhcyB7QGxpbmsgRWxlbWVudE5vZGUjY2FuQmVFbXB0eX1cbiAgICogKi9cbiAgcmVtb3ZlKHByZXNlcnZlRW1wdHlQYXJlbnQpIHtcbiAgICAkcmVtb3ZlTm9kZSh0aGlzLCB0cnVlLCBwcmVzZXJ2ZUVtcHR5UGFyZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGlzIExleGljYWxOb2RlIHdpdGggdGhlIHByb3ZpZGVkIG5vZGUsIG9wdGlvbmFsbHkgdHJhbnNmZXJyaW5nIHRoZSBjaGlsZHJlblxuICAgKiBvZiB0aGUgcmVwbGFjZWQgbm9kZSB0byB0aGUgcmVwbGFjaW5nIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSByZXBsYWNlV2l0aCAtIFRoZSBub2RlIHRvIHJlcGxhY2UgdGhpcyBvbmUgd2l0aC5cbiAgICogQHBhcmFtIGluY2x1ZGVDaGlsZHJlbiAtIFdoZXRoZXIgb3Igbm90IHRvIHRyYW5zZmVyIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUgdG8gdGhlIHJlcGxhY2luZyBub2RlLlxuICAgKiAqL1xuICByZXBsYWNlKHJlcGxhY2VXaXRoLCBpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBsZXQgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgIH1cbiAgICBlcnJvck9uSW5zZXJ0VGV4dE5vZGVPblJvb3QodGhpcywgcmVwbGFjZVdpdGgpO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHRvUmVwbGFjZUtleSA9IHRoaXMuX19rZXk7XG4gICAgY29uc3Qga2V5ID0gcmVwbGFjZVdpdGguX19rZXk7XG4gICAgY29uc3Qgd3JpdGFibGVSZXBsYWNlV2l0aCA9IHJlcGxhY2VXaXRoLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgd3JpdGFibGVQYXJlbnQgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKS5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHNpemUgPSB3cml0YWJsZVBhcmVudC5fX3NpemU7XG4gICAgcmVtb3ZlRnJvbVBhcmVudCh3cml0YWJsZVJlcGxhY2VXaXRoKTtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHNlbGYuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBzZWxmLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgcHJldktleSA9IHNlbGYuX19wcmV2O1xuICAgIGNvbnN0IG5leHRLZXkgPSBzZWxmLl9fbmV4dDtcbiAgICBjb25zdCBwYXJlbnRLZXkgPSBzZWxmLl9fcGFyZW50O1xuICAgICRyZW1vdmVOb2RlKHNlbGYsIGZhbHNlLCB0cnVlKTtcbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fZmlyc3QgPSBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBrZXk7XG4gICAgfVxuICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguX19wcmV2ID0gcHJldktleTtcbiAgICBpZiAobmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fbGFzdCA9IGtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IGtleTtcbiAgICB9XG4gICAgd3JpdGFibGVSZXBsYWNlV2l0aC5fX25leHQgPSBuZXh0S2V5O1xuICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguX19wYXJlbnQgPSBwYXJlbnRLZXk7XG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplID0gc2l6ZTtcbiAgICBpZiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgICBpZiAoISgkaXNFbGVtZW50Tm9kZSh0aGlzKSAmJiAkaXNFbGVtZW50Tm9kZSh3cml0YWJsZVJlcGxhY2VXaXRoKSkpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbmNsdWRlQ2hpbGRyZW4gc2hvdWxkIG9ubHkgYmUgdHJ1ZSBmb3IgRWxlbWVudE5vZGVzYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIHdyaXRhYmxlUmVwbGFjZVdpdGguYXBwZW5kKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgaWYgKGFuY2hvci5rZXkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgICAkbW92ZVNlbGVjdGlvblBvaW50VG9FbmQoYW5jaG9yLCB3cml0YWJsZVJlcGxhY2VXaXRoKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb2N1cy5rZXkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgICAkbW92ZVNlbGVjdGlvblBvaW50VG9FbmQoZm9jdXMsIHdyaXRhYmxlUmVwbGFjZVdpdGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGdldENvbXBvc2l0aW9uS2V5KCkgPT09IHRvUmVwbGFjZUtleSkge1xuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGtleSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0YWJsZVJlcGxhY2VXaXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBub2RlIGFmdGVyIHRoaXMgTGV4aWNhbE5vZGUgKGFzIHRoZSBuZXh0IHNpYmxpbmcpLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZVRvSW5zZXJ0IC0gVGhlIG5vZGUgdG8gaW5zZXJ0IGFmdGVyIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVzdG9yZVNlbGVjdGlvbiAtIFdoZXRoZXIgb3Igbm90IHRvIGF0dGVtcHQgdG8gcmVzb2x2ZSB0aGVcbiAgICogc2VsZWN0aW9uIHRvIHRoZSBhcHByb3ByaWF0ZSBwbGFjZSBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKiAqL1xuICBpbnNlcnRBZnRlcihub2RlVG9JbnNlcnQsIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgZXJyb3JPbkluc2VydFRleHROb2RlT25Sb290KHRoaXMsIG5vZGVUb0luc2VydCk7XG4gICAgY29uc3Qgd3JpdGFibGVTZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0LmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3Qgb2xkUGFyZW50ID0gd3JpdGFibGVOb2RlVG9JbnNlcnQuZ2V0UGFyZW50KCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGxldCBlbGVtZW50QW5jaG9yU2VsZWN0aW9uT25Ob2RlID0gZmFsc2U7XG4gICAgbGV0IGVsZW1lbnRGb2N1c1NlbGVjdGlvbk9uTm9kZSA9IGZhbHNlO1xuICAgIGlmIChvbGRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IHRoaXMgaXMgTyhuKSwgY2FuIHdlIGltcHJvdmU/XG4gICAgICBjb25zdCBvbGRJbmRleCA9IG5vZGVUb0luc2VydC5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgICAgcmVtb3ZlRnJvbVBhcmVudCh3cml0YWJsZU5vZGVUb0luc2VydCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBvbGRQYXJlbnRLZXkgPSBvbGRQYXJlbnQuX19rZXk7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBlbGVtZW50QW5jaG9yU2VsZWN0aW9uT25Ob2RlID0gYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBhbmNob3Iua2V5ID09PSBvbGRQYXJlbnRLZXkgJiYgYW5jaG9yLm9mZnNldCA9PT0gb2xkSW5kZXggKyAxO1xuICAgICAgICBlbGVtZW50Rm9jdXNTZWxlY3Rpb25Pbk5vZGUgPSBmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgZm9jdXMua2V5ID09PSBvbGRQYXJlbnRLZXkgJiYgZm9jdXMub2Zmc2V0ID09PSBvbGRJbmRleCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IHdyaXRhYmxlUGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCkuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBpbnNlcnRLZXkgPSB3cml0YWJsZU5vZGVUb0luc2VydC5fX2tleTtcbiAgICBjb25zdCBuZXh0S2V5ID0gd3JpdGFibGVTZWxmLl9fbmV4dDtcbiAgICBpZiAobmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fbGFzdCA9IGluc2VydEtleTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nLmdldFdyaXRhYmxlKCk7XG4gICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IGluc2VydEtleTtcbiAgICB9XG4gICAgd3JpdGFibGVQYXJlbnQuX19zaXplKys7XG4gICAgd3JpdGFibGVTZWxmLl9fbmV4dCA9IGluc2VydEtleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX25leHQgPSBuZXh0S2V5O1xuICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcHJldiA9IHdyaXRhYmxlU2VsZi5fX2tleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9IHdyaXRhYmxlU2VsZi5fX3BhcmVudDtcbiAgICBpZiAocmVzdG9yZVNlbGVjdGlvbiAmJiAkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgd3JpdGFibGVQYXJlbnQsIGluZGV4ICsgMSk7XG4gICAgICBjb25zdCB3cml0YWJsZVBhcmVudEtleSA9IHdyaXRhYmxlUGFyZW50Ll9fa2V5O1xuICAgICAgaWYgKGVsZW1lbnRBbmNob3JTZWxlY3Rpb25Pbk5vZGUpIHtcbiAgICAgICAgc2VsZWN0aW9uLmFuY2hvci5zZXQod3JpdGFibGVQYXJlbnRLZXksIGluZGV4ICsgMiwgJ2VsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50Rm9jdXNTZWxlY3Rpb25Pbk5vZGUpIHtcbiAgICAgICAgc2VsZWN0aW9uLmZvY3VzLnNldCh3cml0YWJsZVBhcmVudEtleSwgaW5kZXggKyAyLCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZVRvSW5zZXJ0O1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBub2RlIGJlZm9yZSB0aGlzIExleGljYWxOb2RlIChhcyB0aGUgcHJldmlvdXMgc2libGluZykuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlVG9JbnNlcnQgLSBUaGUgbm9kZSB0byBpbnNlcnQgYmVmb3JlIHRoaXMgb25lLlxuICAgKiBAcGFyYW0gcmVzdG9yZVNlbGVjdGlvbiAtIFdoZXRoZXIgb3Igbm90IHRvIGF0dGVtcHQgdG8gcmVzb2x2ZSB0aGVcbiAgICogc2VsZWN0aW9uIHRvIHRoZSBhcHByb3ByaWF0ZSBwbGFjZSBhZnRlciB0aGUgb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgKiAqL1xuICBpbnNlcnRCZWZvcmUobm9kZVRvSW5zZXJ0LCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGVycm9yT25JbnNlcnRUZXh0Tm9kZU9uUm9vdCh0aGlzLCBub2RlVG9JbnNlcnQpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZU5vZGVUb0luc2VydCA9IG5vZGVUb0luc2VydC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IGluc2VydEtleSA9IHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fa2V5O1xuICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9JbnNlcnQpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgcHJldktleSA9IHdyaXRhYmxlU2VsZi5fX3ByZXY7XG4gICAgLy8gVE9ETzogdGhpcyBpcyBPKG4pLCBjYW4gd2UgaW1wcm92ZT9cbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICBpZiAocHJldlNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fZmlyc3QgPSBpbnNlcnRLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlUHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5nZXRXcml0YWJsZSgpO1xuICAgICAgd3JpdGFibGVQcmV2U2libGluZy5fX25leHQgPSBpbnNlcnRLZXk7XG4gICAgfVxuICAgIHdyaXRhYmxlUGFyZW50Ll9fc2l6ZSsrO1xuICAgIHdyaXRhYmxlU2VsZi5fX3ByZXYgPSBpbnNlcnRLZXk7XG4gICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wcmV2ID0gcHJldktleTtcbiAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX25leHQgPSB3cml0YWJsZVNlbGYuX19rZXk7XG4gICAgd3JpdGFibGVOb2RlVG9JbnNlcnQuX19wYXJlbnQgPSB3cml0YWJsZVNlbGYuX19wYXJlbnQ7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChyZXN0b3JlU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgJHVwZGF0ZUVsZW1lbnRTZWxlY3Rpb25PbkNyZWF0ZURlbGV0ZU5vZGUoc2VsZWN0aW9uLCBwYXJlbnQsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVUb0luc2VydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaGFzIGEgcmVxdWlyZWQgcGFyZW50LiBVc2VkIGR1cmluZyBjb3B5ICsgcGFzdGUgb3BlcmF0aW9uc1xuICAgKiB0byBub3JtYWxpemUgbm9kZXMgdGhhdCB3b3VsZCBvdGhlcndpc2UgYmUgb3JwaGFuZWQuIEZvciBleGFtcGxlLCBMaXN0SXRlbU5vZGVzIHdpdGhvdXRcbiAgICogYSBMaXN0Tm9kZSBwYXJlbnQgb3IgVGV4dE5vZGVzIHdpdGggYSBQYXJhZ3JhcGhOb2RlIHBhcmVudC5cbiAgICpcbiAgICogKi9cbiAgaXNQYXJlbnRSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNyZWF0aW9uIGxvZ2ljIGZvciBhbnkgcmVxdWlyZWQgcGFyZW50LiBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaWYge0BsaW5rIGlzUGFyZW50UmVxdWlyZWR9IHJldHVybnMgdHJ1ZS5cbiAgICpcbiAgICogKi9cbiAgY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKSB7XG4gICAgcmV0dXJuICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gIH1cbiAgc2VsZWN0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0UHJldmlvdXMoKTtcbiAgfVxuICBzZWxlY3RFbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0TmV4dCgwLCAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlcyBzZWxlY3Rpb24gdG8gdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgdGhpcyBub2RlLCBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSBUaGUgYW5jaG9yIG9mZnNldCBmb3Igc2VsZWN0aW9uLlxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSAgVGhlIGZvY3VzIG9mZnNldCBmb3Igc2VsZWN0aW9uXG4gICAqICovXG4gIHNlbGVjdFByZXZpb3VzKGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gcGFyZW50LnNlbGVjdCgwLCAwKTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgIH0gZWxzZSBpZiAoISRpc1RleHROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgY29uc3QgaW5kZXggPSBwcmV2U2libGluZy5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgMTtcbiAgICAgIHJldHVybiBwYXJlbnQuc2VsZWN0KGluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBwcmV2U2libGluZy5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgc2VsZWN0aW9uIHRvIHRoZSBuZXh0IHNpYmxpbmcgb2YgdGhpcyBub2RlLCBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldHMuXG4gICAqXG4gICAqIEBwYXJhbSBhbmNob3JPZmZzZXQgLSBUaGUgYW5jaG9yIG9mZnNldCBmb3Igc2VsZWN0aW9uLlxuICAgKiBAcGFyYW0gZm9jdXNPZmZzZXQgLSAgVGhlIGZvY3VzIG9mZnNldCBmb3Igc2VsZWN0aW9uXG4gICAqICovXG4gIHNlbGVjdE5leHQoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCkge1xuICAgIGVycm9yT25SZWFkT25seSgpO1xuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmIChuZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHBhcmVudC5zZWxlY3QoKTtcbiAgICB9XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgcmV0dXJuIG5leHRTaWJsaW5nLnNlbGVjdCgwLCAwKTtcbiAgICB9IGVsc2UgaWYgKCEkaXNUZXh0Tm9kZShuZXh0U2libGluZykpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbmV4dFNpYmxpbmcuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgIHJldHVybiBwYXJlbnQuc2VsZWN0KGluZGV4LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0U2libGluZy5zZWxlY3QoYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCk7XG4gIH1cblxuICAvKipcbiAgICogTWFya3MgYSBub2RlIGRpcnR5LCB0cmlnZ2VyaW5nIHRyYW5zZm9ybXMgYW5kXG4gICAqIGZvcmNpbmcgaXQgdG8gYmUgcmVjb25jaWxlZCBkdXJpbmcgdGhlIHVwZGF0ZSBjeWNsZS5cbiAgICpcbiAgICogKi9cbiAgbWFya0RpcnR5KCkge1xuICAgIHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICpcbiAgICogV2hlbiB0aGUgcmVjb25jaWxlciBkZXRlY3RzIHRoYXQgYSBub2RlIHdhcyBtdXRhdGVkLCB0aGlzIG1ldGhvZFxuICAgKiBtYXkgYmUgY2FsbGVkIHRvIHJlc3RvcmUgdGhlIG5vZGUgdG8gYSBrbm93biBnb29kIHN0YXRlLlxuICAgKi9cbiAgcmVjb25jaWxlT2JzZXJ2ZWRNdXRhdGlvbihkb20sIGVkaXRvcikge1xuICAgIHRoaXMubWFya0RpcnR5KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yT25UeXBlS2xhc3NNaXNtYXRjaCh0eXBlLCBrbGFzcykge1xuICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IGdldFJlZ2lzdGVyZWROb2RlKGdldEFjdGl2ZUVkaXRvcigpLCB0eXBlKTtcbiAgLy8gQ29tbW9uIGVycm9yIC0gc3BsaXQgaW4gaXRzIG93biBpbnZhcmlhbnRcbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYENyZWF0ZSBub2RlOiBBdHRlbXB0ZWQgdG8gY3JlYXRlIG5vZGUgJHtrbGFzcy5uYW1lfSB0aGF0IHdhcyBub3QgY29uZmlndXJlZCB0byBiZSB1c2VkIG9uIHRoZSBlZGl0b3IuYCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGVkaXRvcktsYXNzID0gcmVnaXN0ZXJlZE5vZGUua2xhc3M7XG4gIGlmIChlZGl0b3JLbGFzcyAhPT0ga2xhc3MpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYENyZWF0ZSBub2RlOiBUeXBlICR7dHlwZX0gaW4gbm9kZSAke2tsYXNzLm5hbWV9IGRvZXMgbm90IG1hdGNoIHJlZ2lzdGVyZWQgbm9kZSAke2VkaXRvcktsYXNzLm5hbWV9IHdpdGggdGhlIHNhbWUgdHlwZWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEluc2VydCBhIHNlcmllcyBvZiBub2RlcyBhZnRlciB0aGlzIExleGljYWxOb2RlIChhcyBuZXh0IHNpYmxpbmdzKVxuICpcbiAqIEBwYXJhbSBmaXJzdFRvSW5zZXJ0IC0gVGhlIGZpcnN0IG5vZGUgdG8gaW5zZXJ0IGFmdGVyIHRoaXMgb25lLlxuICogQHBhcmFtIGxhc3RUb0luc2VydCAtIFRoZSBsYXN0IG5vZGUgdG8gaW5zZXJ0IGFmdGVyIHRoaXMgb25lLiBNdXN0IGJlIGFcbiAqIGxhdGVyIHNpYmxpbmcgb2YgRmlyc3ROb2RlLiBJZiBub3QgcHJvdmlkZWQsIGl0IHdpbGwgYmUgaXRzIGxhc3Qgc2libGluZy5cbiAqL1xuZnVuY3Rpb24gaW5zZXJ0UmFuZ2VBZnRlcihub2RlLCBmaXJzdFRvSW5zZXJ0LCBsYXN0VG9JbnNlcnQpIHtcbiAgY29uc3QgbGFzdFRvSW5zZXJ0MiA9IGZpcnN0VG9JbnNlcnQuZ2V0UGFyZW50T3JUaHJvdygpLmdldExhc3RDaGlsZCgpO1xuICBsZXQgY3VycmVudCA9IGZpcnN0VG9JbnNlcnQ7XG4gIGNvbnN0IG5vZGVzVG9JbnNlcnQgPSBbZmlyc3RUb0luc2VydF07XG4gIHdoaWxlIChjdXJyZW50ICE9PSBsYXN0VG9JbnNlcnQyKSB7XG4gICAgaWYgKCFjdXJyZW50LmdldE5leHRTaWJsaW5nKCkpIHtcbiAgICAgIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbnNlcnRSYW5nZUFmdGVyOiBsYXN0VG9JbnNlcnQgbXVzdCBiZSBhIGxhdGVyIHNpYmxpbmcgb2YgZmlyc3RUb0luc2VydGApO1xuICAgICAgfVxuICAgIH1cbiAgICBjdXJyZW50ID0gY3VycmVudC5nZXROZXh0U2libGluZygpO1xuICAgIG5vZGVzVG9JbnNlcnQucHVzaChjdXJyZW50KTtcbiAgfVxuICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICBmb3IgKGNvbnN0IG5vZGVUb0luc2VydCBvZiBub2Rlc1RvSW5zZXJ0KSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5pbnNlcnRBZnRlcihub2RlVG9JbnNlcnQpO1xuICB9XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpbmVCcmVha05vZGUgZXh0ZW5kcyBMZXhpY2FsTm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAnbGluZWJyZWFrJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGluZUJyZWFrTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICB9XG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIHJldHVybiAnXFxuJztcbiAgfVxuICBjcmVhdGVET00oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJyk7XG4gIH1cbiAgdXBkYXRlRE9NKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICBicjogbm9kZSA9PiB7XG4gICAgICAgIGlmIChpc09ubHlDaGlsZEluQmxvY2tOb2RlKG5vZGUpIHx8IGlzTGFzdENoaWxkSW5CbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0TGluZUJyZWFrRWxlbWVudCxcbiAgICAgICAgICBwcmlvcml0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZExpbmVCcmVha05vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUxpbmVCcmVha05vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTGluZUJyZWFrTm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGluZUJyZWFrRWxlbWVudChub2RlKSB7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpbmVCcmVha05vZGUoKVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZUxpbmVCcmVha05vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IExpbmVCcmVha05vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaW5lQnJlYWtOb2RlO1xufVxuZnVuY3Rpb24gaXNPbmx5Q2hpbGRJbkJsb2NrTm9kZShub2RlKSB7XG4gIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gIGlmIChwYXJlbnRFbGVtZW50ICE9PSBudWxsICYmIGlzQmxvY2tEb21Ob2RlKHBhcmVudEVsZW1lbnQpKSB7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmVudEVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbm9kZSB8fCBmaXJzdENoaWxkLm5leHRTaWJsaW5nID09PSBub2RlICYmIGlzV2hpdGVzcGFjZURvbVRleHROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICBjb25zdCBsYXN0Q2hpbGQgPSBwYXJlbnRFbGVtZW50Lmxhc3RDaGlsZDtcbiAgICAgIGlmIChsYXN0Q2hpbGQgPT09IG5vZGUgfHwgbGFzdENoaWxkLnByZXZpb3VzU2libGluZyA9PT0gbm9kZSAmJiBpc1doaXRlc3BhY2VEb21UZXh0Tm9kZShsYXN0Q2hpbGQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0xhc3RDaGlsZEluQmxvY2tOb2RlKG5vZGUpIHtcbiAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgaWYgKHBhcmVudEVsZW1lbnQgIT09IG51bGwgJiYgaXNCbG9ja0RvbU5vZGUocGFyZW50RWxlbWVudCkpIHtcbiAgICAvLyBjaGVjayBpZiBub2RlIGlzIGZpcnN0IGNoaWxkLCBiZWNhdXNlIG9ubHkgY2hpbGQgZG9udCBjb3VudFxuICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJlbnRFbGVtZW50LmZpcnN0Q2hpbGQ7XG4gICAgaWYgKGZpcnN0Q2hpbGQgPT09IG5vZGUgfHwgZmlyc3RDaGlsZC5uZXh0U2libGluZyA9PT0gbm9kZSAmJiBpc1doaXRlc3BhY2VEb21UZXh0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIGl0cyBsYXN0IGNoaWxkXG4gICAgY29uc3QgbGFzdENoaWxkID0gcGFyZW50RWxlbWVudC5sYXN0Q2hpbGQ7XG4gICAgaWYgKGxhc3RDaGlsZCA9PT0gbm9kZSB8fCBsYXN0Q2hpbGQucHJldmlvdXNTaWJsaW5nID09PSBub2RlICYmIGlzV2hpdGVzcGFjZURvbVRleHROb2RlKGxhc3RDaGlsZCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1doaXRlc3BhY2VEb21UZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBpc0RPTVRleHROb2RlKG5vZGUpICYmIC9eKCB8XFx0fFxccj9cXG4pKyQvLnRlc3Qobm9kZS50ZXh0Q29udGVudCB8fCAnJyk7XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRPdXRlclRhZyhub2RlLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdCAmIElTX0NPREUpIHtcbiAgICByZXR1cm4gJ2NvZGUnO1xuICB9XG4gIGlmIChmb3JtYXQgJiBJU19ISUdITElHSFQpIHtcbiAgICByZXR1cm4gJ21hcmsnO1xuICB9XG4gIGlmIChmb3JtYXQgJiBJU19TVUJTQ1JJUFQpIHtcbiAgICByZXR1cm4gJ3N1Yic7XG4gIH1cbiAgaWYgKGZvcm1hdCAmIElTX1NVUEVSU0NSSVBUKSB7XG4gICAgcmV0dXJuICdzdXAnO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RWxlbWVudElubmVyVGFnKG5vZGUsIGZvcm1hdCkge1xuICBpZiAoZm9ybWF0ICYgSVNfQk9MRCkge1xuICAgIHJldHVybiAnc3Ryb25nJztcbiAgfVxuICBpZiAoZm9ybWF0ICYgSVNfSVRBTElDKSB7XG4gICAgcmV0dXJuICdlbSc7XG4gIH1cbiAgcmV0dXJuICdzcGFuJztcbn1cbmZ1bmN0aW9uIHNldFRleHRUaGVtZUNsYXNzTmFtZXModGFnLCBwcmV2Rm9ybWF0LCBuZXh0Rm9ybWF0LCBkb20sIHRleHRDbGFzc05hbWVzKSB7XG4gIGNvbnN0IGRvbUNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7XG4gIC8vIEZpcnN0bHkgd2UgaGFuZGxlIHRoZSBiYXNlIHRoZW1lLlxuICBsZXQgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRleHRDbGFzc05hbWVzLCAnYmFzZScpO1xuICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZG9tQ2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgfVxuICAvLyBTZWNvbmRseSB3ZSBoYW5kbGUgdGhlIHNwZWNpYWwgY2FzZTogdW5kZXJsaW5lICsgc3RyaWtldGhyb3VnaC5cbiAgLy8gV2UgaGF2ZSB0byBkbyB0aGlzIGFzIHdlIG5lZWQgYSB3YXkgdG8gY29tcG9zZSB0aGUgZmFjdCB0aGF0XG4gIC8vIHRoZSBzYW1lIENTUyBwcm9wZXJ0eSB3aWxsIG5lZWQgdG8gYmUgdXNlZDogdGV4dC1kZWNvcmF0aW9uLlxuICAvLyBJbiBhbiBpZGVhbCB3b3JsZCB3ZSBzaG91bGRuJ3QgaGF2ZSB0byBkbyB0aGlzLCBidXQgdGhlcmUncyBub1xuICAvLyBlYXN5IHdvcmthcm91bmQgZm9yIG1hbnkgYXRvbWljIENTUyBzeXN0ZW1zIHRvZGF5LlxuICBjbGFzc05hbWVzID0gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkodGV4dENsYXNzTmFtZXMsICd1bmRlcmxpbmVTdHJpa2V0aHJvdWdoJyk7XG4gIGxldCBoYXNVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gZmFsc2U7XG4gIGNvbnN0IHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gcHJldkZvcm1hdCAmIElTX1VOREVSTElORSAmJiBwcmV2Rm9ybWF0ICYgSVNfU1RSSUtFVEhST1VHSDtcbiAgY29uc3QgbmV4dFVuZGVybGluZVN0cmlrZXRocm91Z2ggPSBuZXh0Rm9ybWF0ICYgSVNfVU5ERVJMSU5FICYmIG5leHRGb3JtYXQgJiBJU19TVFJJS0VUSFJPVUdIO1xuICBpZiAoY2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG5leHRVbmRlcmxpbmVTdHJpa2V0aHJvdWdoKSB7XG4gICAgICBoYXNVbmRlcmxpbmVTdHJpa2V0aHJvdWdoID0gdHJ1ZTtcbiAgICAgIGlmICghcHJldlVuZGVybGluZVN0cmlrZXRocm91Z2gpIHtcbiAgICAgICAgZG9tQ2xhc3NMaXN0LmFkZCguLi5jbGFzc05hbWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoKSB7XG4gICAgICBkb21DbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGtleSBpbiBURVhUX1RZUEVfVE9fRk9STUFUKSB7XG4gICAgY29uc3QgZm9ybWF0ID0ga2V5O1xuICAgIGNvbnN0IGZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW2Zvcm1hdF07XG4gICAgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KHRleHRDbGFzc05hbWVzLCBrZXkpO1xuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChuZXh0Rm9ybWF0ICYgZmxhZykge1xuICAgICAgICBpZiAoaGFzVW5kZXJsaW5lU3RyaWtldGhyb3VnaCAmJiAoa2V5ID09PSAndW5kZXJsaW5lJyB8fCBrZXkgPT09ICdzdHJpa2V0aHJvdWdoJykpIHtcbiAgICAgICAgICBpZiAocHJldkZvcm1hdCAmIGZsYWcpIHtcbiAgICAgICAgICAgIGRvbUNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgocHJldkZvcm1hdCAmIGZsYWcpID09PSAwIHx8IHByZXZVbmRlcmxpbmVTdHJpa2V0aHJvdWdoICYmIGtleSA9PT0gJ3VuZGVybGluZScgfHwga2V5ID09PSAnc3RyaWtldGhyb3VnaCcpIHtcbiAgICAgICAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByZXZGb3JtYXQgJiBmbGFnKSB7XG4gICAgICAgIGRvbUNsYXNzTGlzdC5yZW1vdmUoLi4uY2xhc3NOYW1lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkaWZmQ29tcG9zZWRUZXh0KGEsIGIpIHtcbiAgY29uc3QgYUxlbmd0aCA9IGEubGVuZ3RoO1xuICBjb25zdCBiTGVuZ3RoID0gYi5sZW5ndGg7XG4gIGxldCBsZWZ0ID0gMDtcbiAgbGV0IHJpZ2h0ID0gMDtcbiAgd2hpbGUgKGxlZnQgPCBhTGVuZ3RoICYmIGxlZnQgPCBiTGVuZ3RoICYmIGFbbGVmdF0gPT09IGJbbGVmdF0pIHtcbiAgICBsZWZ0Kys7XG4gIH1cbiAgd2hpbGUgKHJpZ2h0ICsgbGVmdCA8IGFMZW5ndGggJiYgcmlnaHQgKyBsZWZ0IDwgYkxlbmd0aCAmJiBhW2FMZW5ndGggLSByaWdodCAtIDFdID09PSBiW2JMZW5ndGggLSByaWdodCAtIDFdKSB7XG4gICAgcmlnaHQrKztcbiAgfVxuICByZXR1cm4gW2xlZnQsIGFMZW5ndGggLSBsZWZ0IC0gcmlnaHQsIGIuc2xpY2UobGVmdCwgYkxlbmd0aCAtIHJpZ2h0KV07XG59XG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudChuZXh0VGV4dCwgZG9tLCBub2RlKSB7XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBkb20uZmlyc3RDaGlsZDtcbiAgY29uc3QgaXNDb21wb3NpbmcgPSBub2RlLmlzQ29tcG9zaW5nKCk7XG4gIC8vIEFsd2F5cyBhZGQgYSBzdWZmaXggaWYgd2UncmUgY29tcG9zaW5nIGEgbm9kZVxuICBjb25zdCBzdWZmaXggPSBpc0NvbXBvc2luZyA/IENPTVBPU0lUSU9OX1NVRkZJWCA6ICcnO1xuICBjb25zdCB0ZXh0ID0gbmV4dFRleHQgKyBzdWZmaXg7XG4gIGlmIChmaXJzdENoaWxkID09IG51bGwpIHtcbiAgICBkb20udGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5vZGVWYWx1ZSA9IGZpcnN0Q2hpbGQubm9kZVZhbHVlO1xuICAgIGlmIChub2RlVmFsdWUgIT09IHRleHQpIHtcbiAgICAgIGlmIChpc0NvbXBvc2luZyB8fCBJU19GSVJFRk9YKSB7XG4gICAgICAgIC8vIFdlIGFsc28gdXNlIHRoZSBkaWZmIGNvbXBvc2VkIHRleHQgZm9yIGdlbmVyYWwgdGV4dCBpbiBGRiB0byBhdm9pZFxuICAgICAgICAvLyB0aGUgc3BlbGxjaGVjayByZWQgbGluZSBmcm9tIGZsaWNrZXJpbmcuXG4gICAgICAgIGNvbnN0IFtpbmRleCwgcmVtb3ZlLCBpbnNlcnRdID0gZGlmZkNvbXBvc2VkVGV4dChub2RlVmFsdWUsIHRleHQpO1xuICAgICAgICBpZiAocmVtb3ZlICE9PSAwKSB7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGZpcnN0Q2hpbGQuZGVsZXRlRGF0YShpbmRleCwgcmVtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0RGF0YShpbmRleCwgaW5zZXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRJbm5lckRPTShpbm5lckRPTSwgbm9kZSwgaW5uZXJUYWcsIGZvcm1hdCwgdGV4dCwgY29uZmlnKSB7XG4gIHNldFRleHRDb250ZW50KHRleHQsIGlubmVyRE9NLCBub2RlKTtcbiAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWU7XG4gIC8vIEFwcGx5IHRoZW1lIGNsYXNzIG5hbWVzXG4gIGNvbnN0IHRleHRDbGFzc05hbWVzID0gdGhlbWUudGV4dDtcbiAgaWYgKHRleHRDbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXRUZXh0VGhlbWVDbGFzc05hbWVzKGlubmVyVGFnLCAwLCBmb3JtYXQsIGlubmVyRE9NLCB0ZXh0Q2xhc3NOYW1lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCB0YWcpIHtcbiAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICByZXR1cm4gZWw7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcblxuLyoqIEBub0luaGVyaXREb2MgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcbmNsYXNzIFRleHROb2RlIGV4dGVuZHMgTGV4aWNhbE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0ZXh0JztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGV4dE5vZGUobm9kZS5fX3RleHQsIG5vZGUuX19rZXkpO1xuICB9XG4gIGFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKSB7XG4gICAgc3VwZXIuYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpO1xuICAgIHRoaXMuX190ZXh0ID0gcHJldk5vZGUuX190ZXh0O1xuICAgIHRoaXMuX19mb3JtYXQgPSBwcmV2Tm9kZS5fX2Zvcm1hdDtcbiAgICB0aGlzLl9fc3R5bGUgPSBwcmV2Tm9kZS5fX3N0eWxlO1xuICAgIHRoaXMuX19tb2RlID0gcHJldk5vZGUuX19tb2RlO1xuICAgIHRoaXMuX19kZXRhaWwgPSBwcmV2Tm9kZS5fX2RldGFpbDtcbiAgfVxuICBjb25zdHJ1Y3Rvcih0ZXh0ID0gJycsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3RleHQgPSB0ZXh0O1xuICAgIHRoaXMuX19mb3JtYXQgPSAwO1xuICAgIHRoaXMuX19zdHlsZSA9ICcnO1xuICAgIHRoaXMuX19tb2RlID0gMDtcbiAgICB0aGlzLl9fZGV0YWlsID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgMzItYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBUZXh0Rm9ybWF0VHlwZXMgY3VycmVudGx5IGFwcGxpZWQgdG8gdGhlXG4gICAqIFRleHROb2RlLiBZb3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkgLSBjb25zaWRlciB1c2luZyBUZXh0Tm9kZS5oYXNGb3JtYXQgaW5zdGVhZC5cbiAgICpcbiAgICogQHJldHVybnMgYSBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBmb3JtYXQgb2YgdGhlIHRleHQgbm9kZS5cbiAgICovXG4gIGdldEZvcm1hdCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX2Zvcm1hdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgMzItYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBUZXh0RGV0YWlsVHlwZXMgY3VycmVudGx5IGFwcGxpZWQgdG8gdGhlXG4gICAqIFRleHROb2RlLiBZb3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byB1c2UgdGhpcyBtZXRob2QgZGlyZWN0bHkgLSBjb25zaWRlciB1c2luZyBUZXh0Tm9kZS5pc0RpcmVjdGlvbmxlc3NcbiAgICogb3IgVGV4dE5vZGUuaXNVbm1lcmdlYWJsZSBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGRldGFpbCBvZiB0aGUgdGV4dCBub2RlLlxuICAgKi9cbiAgZ2V0RGV0YWlsKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fZGV0YWlsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG1vZGUgKFRleHRNb2RlVHlwZSkgb2YgdGhlIFRleHROb2RlLCB3aGljaCBtYXkgYmUgXCJub3JtYWxcIiwgXCJ0b2tlblwiLCBvciBcInNlZ21lbnRlZFwiXG4gICAqXG4gICAqIEByZXR1cm5zIFRleHRNb2RlVHlwZS5cbiAgICovXG4gIGdldE1vZGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIFRFWFRfVFlQRV9UT19NT0RFW3NlbGYuX19tb2RlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHlsZXMgY3VycmVudGx5IGFwcGxpZWQgdG8gdGhlIG5vZGUuIFRoaXMgaXMgYW5hbG9nb3VzIHRvIENTU1RleHQgaW4gdGhlIERPTS5cbiAgICpcbiAgICogQHJldHVybnMgQ1NTVGV4dC1saWtlIHN0cmluZyBvZiBzdHlsZXMgYXBwbGllZCB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS5cbiAgICovXG4gIGdldFN0eWxlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fc3R5bGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBpbiBcInRva2VuXCIgbW9kZS4gVGV4dE5vZGVzIGluIHRva2VuIG1vZGUgY2FuIGJlIG5hdmlnYXRlZCB0aHJvdWdoIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXJcbiAgICogd2l0aCBhIFJhbmdlU2VsZWN0aW9uLCBidXQgYXJlIGRlbGV0ZWQgYXMgYSBzaW5nbGUgZW50aXR5IChub3QgaW5kaXZpZHVhbGx5IGJ5IGNoYXJhY3RlcikuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgaW4gdG9rZW4gbW9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNUb2tlbigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX21vZGUgPT09IElTX1RPS0VOO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgTGV4aWNhbCBkZXRlY3RzIHRoYXQgYW4gSU1FIG9yIG90aGVyIDNyZC1wYXJ0eSBzY3JpcHQgaXMgYXR0ZW1wdGluZyB0b1xuICAgKiBtdXRhdGUgdGhlIFRleHROb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0NvbXBvc2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fX2tleSA9PT0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBpbiBcInNlZ21lbnRlZFwiIG1vZGUuIFRleHROb2RlcyBpbiBzZWdtZW50ZWQgbW9kZSBjYW4gYmUgbmF2aWdhdGVkIHRocm91Z2ggY2hhcmFjdGVyLWJ5LWNoYXJhY3RlclxuICAgKiB3aXRoIGEgUmFuZ2VTZWxlY3Rpb24sIGJ1dCBhcmUgZGVsZXRlZCBpbiBzcGFjZS1kZWxpbWl0ZWQgXCJzZWdtZW50c1wiLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIGluIHNlZ21lbnRlZCBtb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1NlZ21lbnRlZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gc2VsZi5fX21vZGUgPT09IElTX1NFR01FTlRFRDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBcImRpcmVjdGlvbmxlc3NcIi4gRGlyZWN0aW9ubGVzcyBub2RlcyBkb24ndCByZXNwZWN0IGNoYW5nZXMgYmV0d2VlbiBSVEwgYW5kIExUUiBtb2Rlcy5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBkaXJlY3Rpb25sZXNzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0RpcmVjdGlvbmxlc3MoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIChzZWxmLl9fZGV0YWlsICYgSVNfRElSRUNUSU9OTEVTUykgIT09IDA7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG5vZGUgaXMgdW5tZXJnZWFibGUuIEluIHNvbWUgc2NlbmFyaW9zLCBMZXhpY2FsIHRyaWVzIHRvIG1lcmdlXG4gICAqIGFkamFjZW50IFRleHROb2RlcyBpbnRvIGEgc2luZ2xlIFRleHROb2RlLiBJZiBhIFRleHROb2RlIGlzIHVubWVyZ2VhYmxlLCB0aGlzIHdvbid0IGhhcHBlbi5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyB1bm1lcmdlYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNVbm1lcmdlYWJsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gKHNlbGYuX19kZXRhaWwgJiBJU19VTk1FUkdFQUJMRSkgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBoYXMgdGhlIHByb3ZpZGVkIGZvcm1hdCBhcHBsaWVkLiBVc2UgdGhpcyB3aXRoIHRoZSBodW1hbi1yZWFkYWJsZSBUZXh0Rm9ybWF0VHlwZVxuICAgKiBzdHJpbmcgdmFsdWVzIHRvIGdldCB0aGUgZm9ybWF0IG9mIGEgVGV4dE5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gdGhlIFRleHRGb3JtYXRUeXBlIHRvIGNoZWNrIGZvci5cbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBoYXMgdGhlIHByb3ZpZGVkIGZvcm1hdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBmb3JtYXRGbGFnID0gVEVYVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgICByZXR1cm4gKHRoaXMuZ2V0Rm9ybWF0KCkgJiBmb3JtYXRGbGFnKSAhPT0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBub2RlIGlzIHNpbXBsZSB0ZXh0LiBTaW1wbGUgdGV4dCBpcyBkZWZpbmVkIGFzIGEgVGV4dE5vZGUgdGhhdCBoYXMgdGhlIHN0cmluZyB0eXBlIFwidGV4dFwiXG4gICAqIChpLmUuLCBub3QgYSBzdWJjbGFzcykgYW5kIGhhcyBubyBtb2RlIGFwcGxpZWQgdG8gaXQgKGkuZS4sIG5vdCBzZWdtZW50ZWQgb3IgdG9rZW4pLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIHNpbXBsZSB0ZXh0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1NpbXBsZVRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX190eXBlID09PSAndGV4dCcgJiYgdGhpcy5fX21vZGUgPT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBub2RlIGFzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbm9kZS5cbiAgICovXG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmb3JtYXQgZmxhZ3MgYXBwbGllZCB0byB0aGUgbm9kZSBhcyBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIG51bWJlciByZXByZXNlbnRpbmcgdGhlIFRleHRGb3JtYXRUeXBlcyBhcHBsaWVkIHRvIHRoZSBub2RlLlxuICAgKi9cbiAgZ2V0Rm9ybWF0RmxhZ3ModHlwZSwgYWxpZ25XaXRoRm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgZm9ybWF0ID0gc2VsZi5fX2Zvcm1hdDtcbiAgICByZXR1cm4gdG9nZ2xlVGV4dEZvcm1hdFR5cGUoZm9ybWF0LCB0eXBlLCBhbGlnbldpdGhGb3JtYXQpO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHRleHQgbm9kZSBzdXBwb3J0cyBmb250IHN0eWxpbmcsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGNhbkhhdmVGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdGV4dCBub2RlIGlzIGlubGluZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBWaWV3XG5cbiAgY3JlYXRlRE9NKGNvbmZpZywgZWRpdG9yKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5fX2Zvcm1hdDtcbiAgICBjb25zdCBvdXRlclRhZyA9IGdldEVsZW1lbnRPdXRlclRhZyh0aGlzLCBmb3JtYXQpO1xuICAgIGNvbnN0IGlubmVyVGFnID0gZ2V0RWxlbWVudElubmVyVGFnKHRoaXMsIGZvcm1hdCk7XG4gICAgY29uc3QgdGFnID0gb3V0ZXJUYWcgPT09IG51bGwgPyBpbm5lclRhZyA6IG91dGVyVGFnO1xuICAgIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICBsZXQgaW5uZXJET00gPSBkb207XG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdjb2RlJykpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3NwZWxsY2hlY2snLCAnZmFsc2UnKTtcbiAgICB9XG4gICAgaWYgKG91dGVyVGFnICE9PSBudWxsKSB7XG4gICAgICBpbm5lckRPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaW5uZXJUYWcpO1xuICAgICAgZG9tLmFwcGVuZENoaWxkKGlubmVyRE9NKTtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IHRoaXMuX190ZXh0O1xuICAgIGNyZWF0ZVRleHRJbm5lckRPTShpbm5lckRPTSwgdGhpcywgaW5uZXJUYWcsIGZvcm1hdCwgdGV4dCwgY29uZmlnKTtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuX19zdHlsZTtcbiAgICBpZiAoc3R5bGUgIT09ICcnKSB7XG4gICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IHN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBuZXh0VGV4dCA9IHRoaXMuX190ZXh0O1xuICAgIGNvbnN0IHByZXZGb3JtYXQgPSBwcmV2Tm9kZS5fX2Zvcm1hdDtcbiAgICBjb25zdCBuZXh0Rm9ybWF0ID0gdGhpcy5fX2Zvcm1hdDtcbiAgICBjb25zdCBwcmV2T3V0ZXJUYWcgPSBnZXRFbGVtZW50T3V0ZXJUYWcodGhpcywgcHJldkZvcm1hdCk7XG4gICAgY29uc3QgbmV4dE91dGVyVGFnID0gZ2V0RWxlbWVudE91dGVyVGFnKHRoaXMsIG5leHRGb3JtYXQpO1xuICAgIGNvbnN0IHByZXZJbm5lclRhZyA9IGdldEVsZW1lbnRJbm5lclRhZyh0aGlzLCBwcmV2Rm9ybWF0KTtcbiAgICBjb25zdCBuZXh0SW5uZXJUYWcgPSBnZXRFbGVtZW50SW5uZXJUYWcodGhpcywgbmV4dEZvcm1hdCk7XG4gICAgY29uc3QgcHJldlRhZyA9IHByZXZPdXRlclRhZyA9PT0gbnVsbCA/IHByZXZJbm5lclRhZyA6IHByZXZPdXRlclRhZztcbiAgICBjb25zdCBuZXh0VGFnID0gbmV4dE91dGVyVGFnID09PSBudWxsID8gbmV4dElubmVyVGFnIDogbmV4dE91dGVyVGFnO1xuICAgIGlmIChwcmV2VGFnICE9PSBuZXh0VGFnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByZXZPdXRlclRhZyA9PT0gbmV4dE91dGVyVGFnICYmIHByZXZJbm5lclRhZyAhPT0gbmV4dElubmVyVGFnKSB7XG4gICAgICAvLyBzaG91bGQgYWx3YXlzIGJlIGFuIGVsZW1lbnRcbiAgICAgIGNvbnN0IHByZXZJbm5lckRPTSA9IGRvbS5maXJzdENoaWxkO1xuICAgICAgaWYgKHByZXZJbm5lckRPTSA9PSBudWxsKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYHVwZGF0ZURPTTogcHJldklubmVyRE9NIGlzIG51bGwgb3IgdW5kZWZpbmVkYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRJbm5lckRPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobmV4dElubmVyVGFnKTtcbiAgICAgIGNyZWF0ZVRleHRJbm5lckRPTShuZXh0SW5uZXJET00sIHRoaXMsIG5leHRJbm5lclRhZywgbmV4dEZvcm1hdCwgbmV4dFRleHQsIGNvbmZpZyk7XG4gICAgICBkb20ucmVwbGFjZUNoaWxkKG5leHRJbm5lckRPTSwgcHJldklubmVyRE9NKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGlubmVyRE9NID0gZG9tO1xuICAgIGlmIChuZXh0T3V0ZXJUYWcgIT09IG51bGwpIHtcbiAgICAgIGlmIChwcmV2T3V0ZXJUYWcgIT09IG51bGwpIHtcbiAgICAgICAgaW5uZXJET00gPSBkb20uZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGlubmVyRE9NID09IG51bGwpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYHVwZGF0ZURPTTogaW5uZXJET00gaXMgbnVsbCBvciB1bmRlZmluZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc2V0VGV4dENvbnRlbnQobmV4dFRleHQsIGlubmVyRE9NLCB0aGlzKTtcbiAgICBjb25zdCB0aGVtZSA9IGNvbmZpZy50aGVtZTtcbiAgICAvLyBBcHBseSB0aGVtZSBjbGFzcyBuYW1lc1xuICAgIGNvbnN0IHRleHRDbGFzc05hbWVzID0gdGhlbWUudGV4dDtcbiAgICBpZiAodGV4dENsYXNzTmFtZXMgIT09IHVuZGVmaW5lZCAmJiBwcmV2Rm9ybWF0ICE9PSBuZXh0Rm9ybWF0KSB7XG4gICAgICBzZXRUZXh0VGhlbWVDbGFzc05hbWVzKG5leHRJbm5lclRhZywgcHJldkZvcm1hdCwgbmV4dEZvcm1hdCwgaW5uZXJET00sIHRleHRDbGFzc05hbWVzKTtcbiAgICB9XG4gICAgY29uc3QgcHJldlN0eWxlID0gcHJldk5vZGUuX19zdHlsZTtcbiAgICBjb25zdCBuZXh0U3R5bGUgPSB0aGlzLl9fc3R5bGU7XG4gICAgaWYgKHByZXZTdHlsZSAhPT0gbmV4dFN0eWxlKSB7XG4gICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG5leHRTdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICcjdGV4dCc6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGV4dERPTU5vZGUsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIGI6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRCcmluZ0F0dGVudGlvblRvRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgY29kZTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBlbTogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBpOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIG1hcms6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgczogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzcGFuOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0U3BhbkVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHN0cm9uZzogKCkgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogY29udmVydFRleHRGb3JtYXRFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICBzdWI6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pLFxuICAgICAgc3VwOiAoKSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHU6ICgpID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246IGNvbnZlcnRUZXh0Rm9ybWF0RWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlVGV4dE5vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldFRleHRDb250ZW50KHNlcmlhbGl6ZWROb2RlLnRleHQpLnNldEZvcm1hdChzZXJpYWxpemVkTm9kZS5mb3JtYXQpLnNldERldGFpbChzZXJpYWxpemVkTm9kZS5kZXRhaWwpLnNldE1vZGUoc2VyaWFsaXplZE5vZGUubW9kZSkuc2V0U3R5bGUoc2VyaWFsaXplZE5vZGUuc3R5bGUpO1xuICB9XG5cbiAgLy8gVGhpcyBpbXByb3ZlcyBMZXhpY2FsJ3MgYmFzaWMgdGV4dCBvdXRwdXQgaW4gY29weStwYXN0ZSBwbHVzXG4gIC8vIGZvciBoZWFkbGVzcyBtb2RlIHdoZXJlIHBlb3BsZSBtaWdodCB1c2UgTGV4aWNhbCB0byBnZW5lcmF0ZVxuICAvLyBIVE1MIGNvbnRlbnQgYW5kIG5vdCBoYXZlIHRoZSBhYmlsaXR5IHRvIHVzZSBDU1MgY2xhc3Nlcy5cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGxldCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUZXh0Tm9kZSBjcmVhdGVET00gdG8gYWx3YXlzIHJldHVybiBhIEhUTUxFbGVtZW50YCk7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG5cbiAgICAvLyBBZGQgdGV4dC10cmFuc2Zvcm0gc3R5bGVzIGZvciBjYXBpdGFsaXphdGlvbiBmb3JtYXRzXG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdsb3dlcmNhc2UnKSkge1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0VHJhbnNmb3JtID0gJ2xvd2VyY2FzZSc7XG4gICAgfSBlbHNlIGlmICh0aGlzLmhhc0Zvcm1hdCgndXBwZXJjYXNlJykpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUudGV4dFRyYW5zZm9ybSA9ICd1cHBlcmNhc2UnO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNGb3JtYXQoJ2NhcGl0YWxpemUnKSkge1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0VHJhbnNmb3JtID0gJ2NhcGl0YWxpemUnO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHByb3Blcmx5IGFkZCBzdXBwb3J0IGZvciBtb3N0IGNsaWVudHMsXG4gICAgLy8gZXZlbiBpZiBpdCdzIHNlbWFudGljYWxseSBpbmNvcnJlY3QgdG8gaGF2ZSB0byByZXNvcnQgdG8gdXNpbmdcbiAgICAvLyA8Yj4sIDx1PiwgPHM+LCA8aT4gZWxlbWVudHMuXG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdib2xkJykpIHtcbiAgICAgIGVsZW1lbnQgPSB3cmFwRWxlbWVudFdpdGgoZWxlbWVudCwgJ2InKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzRm9ybWF0KCdpdGFsaWMnKSkge1xuICAgICAgZWxlbWVudCA9IHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCAnaScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKSkge1xuICAgICAgZWxlbWVudCA9IHdyYXBFbGVtZW50V2l0aChlbGVtZW50LCAncycpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNGb3JtYXQoJ3VuZGVybGluZScpKSB7XG4gICAgICBlbGVtZW50ID0gd3JhcEVsZW1lbnRXaXRoKGVsZW1lbnQsICd1Jyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBkZXRhaWw6IHRoaXMuZ2V0RGV0YWlsKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0KCksXG4gICAgICBtb2RlOiB0aGlzLmdldE1vZGUoKSxcbiAgICAgIHN0eWxlOiB0aGlzLmdldFN0eWxlKCksXG4gICAgICB0ZXh0OiB0aGlzLmdldFRleHRDb250ZW50KCksXG4gICAgICAvLyBBcyBhbiBleGNlcHRpb24gaGVyZSB3ZSBpbnZva2Ugc3VwZXIgYXQgdGhlIGVuZCBmb3IgaGlzdG9yaWNhbCByZWFzb25zLlxuICAgICAgLy8gTmFtZWx5LCB0byBwcmVzZXJ2ZSB0aGUgb3JkZXIgb2YgdGhlIHByb3BlcnRpZXMgYW5kIG5vdCB0byBicmVhayB0aGUgdGVzdHNcbiAgICAgIC8vIHRoYXQgdXNlIHRoZSBzZXJpYWxpemVkIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKVxuICAgIH07XG4gIH1cblxuICAvLyBNdXRhdG9yc1xuICBzZWxlY3Rpb25UcmFuc2Zvcm0ocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub2RlIGZvcm1hdCB0byB0aGUgcHJvdmlkZWQgVGV4dEZvcm1hdFR5cGUgb3IgMzItYml0IGludGVnZXIuIE5vdGUgdGhhdCB0aGUgVGV4dEZvcm1hdFR5cGVcbiAgICogdmVyc2lvbiBvZiB0aGUgYXJndW1lbnQgY2FuIG9ubHkgc3BlY2lmeSBvbmUgZm9ybWF0IGFuZCBkb2luZyBzbyB3aWxsIHJlbW92ZSBhbGwgb3RoZXIgZm9ybWF0cyB0aGF0XG4gICAqIG1heSBiZSBhcHBsaWVkIHRvIHRoZSBub2RlLiBGb3IgdG9nZ2xpbmcgYmVoYXZpb3IsIGNvbnNpZGVyIHVzaW5nIHtAbGluayBUZXh0Tm9kZS50b2dnbGVGb3JtYXR9XG4gICAqXG4gICAqIEBwYXJhbSBmb3JtYXQgLSBUZXh0Rm9ybWF0VHlwZSBvciAzMi1iaXQgaW50ZWdlciByZXByZXNlbnRpbmcgdGhlIG5vZGUgZm9ybWF0LlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKiAvLyBUT0RPIDAuMTIgVGhpcyBzaG91bGQganVzdCBiZSBhIGBzdHJpbmdgLlxuICAgKi9cbiAgc2V0Rm9ybWF0KGZvcm1hdCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zvcm1hdCA9IHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnID8gVEVYVF9UWVBFX1RPX0ZPUk1BVFtmb3JtYXRdIDogZm9ybWF0O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIG5vZGUgZGV0YWlsIHRvIHRoZSBwcm92aWRlZCBUZXh0RGV0YWlsVHlwZSBvciAzMi1iaXQgaW50ZWdlci4gTm90ZSB0aGF0IHRoZSBUZXh0RGV0YWlsVHlwZVxuICAgKiB2ZXJzaW9uIG9mIHRoZSBhcmd1bWVudCBjYW4gb25seSBzcGVjaWZ5IG9uZSBkZXRhaWwgdmFsdWUgYW5kIGRvaW5nIHNvIHdpbGwgcmVtb3ZlIGFsbCBvdGhlciBkZXRhaWwgdmFsdWVzIHRoYXRcbiAgICogbWF5IGJlIGFwcGxpZWQgdG8gdGhlIG5vZGUuIEZvciB0b2dnbGluZyBiZWhhdmlvciwgY29uc2lkZXIgdXNpbmcge0BsaW5rIFRleHROb2RlLnRvZ2dsZURpcmVjdGlvbmxlc3N9XG4gICAqIG9yIHtAbGluayBUZXh0Tm9kZS50b2dnbGVVbm1lcmdlYWJsZX1cbiAgICpcbiAgICogQHBhcmFtIGRldGFpbCAtIFRleHREZXRhaWxUeXBlIG9yIDMyLWJpdCBpbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgbm9kZSBkZXRhaWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqIC8vIFRPRE8gMC4xMiBUaGlzIHNob3VsZCBqdXN0IGJlIGEgYHN0cmluZ2AuXG4gICAqL1xuICBzZXREZXRhaWwoZGV0YWlsKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fZGV0YWlsID0gdHlwZW9mIGRldGFpbCA9PT0gJ3N0cmluZycgPyBERVRBSUxfVFlQRV9UT19ERVRBSUxbZGV0YWlsXSA6IGRldGFpbDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBub2RlIHN0eWxlIHRvIHRoZSBwcm92aWRlZCBDU1NUZXh0LWxpa2Ugc3RyaW5nLiBTZXQgdGhpcyBwcm9wZXJ0eSBhcyB5b3VcbiAgICogd291bGQgYW4gSFRNTEVsZW1lbnQgc3R5bGUgYXR0cmlidXRlIHRvIGFwcGx5IGlubGluZSBzdHlsZXMgdG8gdGhlIHVuZGVybHlpbmcgRE9NIEVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHlsZSAtIENTU1RleHQgdG8gYmUgYXBwbGllZCB0byB0aGUgdW5kZXJseWluZyBIVE1MRWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fc3R5bGUgPSBzdHlsZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBwcm92aWRlZCBmb3JtYXQgdG8gdGhpcyBUZXh0Tm9kZSBpZiBpdCdzIG5vdCBwcmVzZW50LiBSZW1vdmVzIGl0IGlmIGl0J3MgcHJlc2VudC5cbiAgICogVGhlIHN1YnNjcmlwdCBhbmQgc3VwZXJzY3JpcHQgZm9ybWF0cyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgKiBQcmVmZXIgdXNpbmcgdGhpcyBtZXRob2QgdG8gdHVybiBzcGVjaWZpYyBmb3JtYXRzIG9uIGFuZCBvZmYuXG4gICAqXG4gICAqIEBwYXJhbSB0eXBlIC0gVGV4dEZvcm1hdFR5cGUgdG8gdG9nZ2xlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgdG9nZ2xlRm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldEZvcm1hdCgpO1xuICAgIGNvbnN0IG5ld0Zvcm1hdCA9IHRvZ2dsZVRleHRGb3JtYXRUeXBlKGZvcm1hdCwgdHlwZSwgbnVsbCk7XG4gICAgcmV0dXJuIHRoaXMuc2V0Rm9ybWF0KG5ld0Zvcm1hdCk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgZGlyZWN0aW9ubGVzcyBkZXRhaWwgdmFsdWUgb2YgdGhlIG5vZGUuIFByZWZlciB1c2luZyB0aGlzIG1ldGhvZCBvdmVyIHNldERldGFpbC5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHRvZ2dsZURpcmVjdGlvbmxlc3MoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fZGV0YWlsIF49IElTX0RJUkVDVElPTkxFU1M7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgdW5tZXJnZWFibGUgZGV0YWlsIHZhbHVlIG9mIHRoZSBub2RlLiBQcmVmZXIgdXNpbmcgdGhpcyBtZXRob2Qgb3ZlciBzZXREZXRhaWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuICB0b2dnbGVVbm1lcmdlYWJsZSgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kZXRhaWwgXj0gSVNfVU5NRVJHRUFCTEU7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbW9kZSBvZiB0aGUgbm9kZS5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHNldE1vZGUodHlwZSkge1xuICAgIGNvbnN0IG1vZGUgPSBURVhUX01PREVfVE9fVFlQRVt0eXBlXTtcbiAgICBpZiAodGhpcy5fX21vZGUgPT09IG1vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19tb2RlID0gbW9kZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0IC0gdGhlIHN0cmluZyB0byBzZXQgYXMgdGhlIHRleHQgdmFsdWUgb2YgdGhlIG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoaXMgVGV4dE5vZGUuXG4gICAqL1xuICBzZXRUZXh0Q29udGVudCh0ZXh0KSB7XG4gICAgaWYgKHRoaXMuX190ZXh0ID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fdGV4dCA9IHRleHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY3VycmVudCBMZXhpY2FsIHNlbGVjdGlvbiB0byBiZSBhIFJhbmdlU2VsZWN0aW9uIHdpdGggYW5jaG9yIGFuZCBmb2N1cyBvbiB0aGlzIFRleHROb2RlIGF0IHRoZSBwcm92aWRlZCBvZmZzZXRzLlxuICAgKlxuICAgKiBAcGFyYW0gX2FuY2hvck9mZnNldCAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIFNlbGVjdGlvbiBhbmNob3Igd2lsbCBiZSBwbGFjZWQuXG4gICAqIEBwYXJhbSBfZm9jdXNPZmZzZXQgLSB0aGUgb2Zmc2V0IGF0IHdoaWNoIHRoZSBTZWxlY3Rpb24gZm9jdXMgd2lsbCBiZSBwbGFjZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRoZSBuZXcgUmFuZ2VTZWxlY3Rpb24uXG4gICAqL1xuICBzZWxlY3QoX2FuY2hvck9mZnNldCwgX2ZvY3VzT2Zmc2V0KSB7XG4gICAgZXJyb3JPblJlYWRPbmx5KCk7XG4gICAgbGV0IGFuY2hvck9mZnNldCA9IF9hbmNob3JPZmZzZXQ7XG4gICAgbGV0IGZvY3VzT2Zmc2V0ID0gX2ZvY3VzT2Zmc2V0O1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCB0ZXh0ID0gdGhpcy5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7XG4gICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgbGFzdE9mZnNldCA9IHRleHQubGVuZ3RoO1xuICAgICAgaWYgKGFuY2hvck9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFuY2hvck9mZnNldCA9IGxhc3RPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAoZm9jdXNPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb2N1c09mZnNldCA9IGxhc3RPZmZzZXQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuY2hvck9mZnNldCA9IDA7XG4gICAgICBmb2N1c09mZnNldCA9IDA7XG4gICAgfVxuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuICRpbnRlcm5hbE1ha2VSYW5nZVNlbGVjdGlvbihrZXksIGFuY2hvck9mZnNldCwga2V5LCBmb2N1c09mZnNldCwgJ3RleHQnLCAndGV4dCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb21wb3NpdGlvbktleSA9ICRnZXRDb21wb3NpdGlvbktleSgpO1xuICAgICAgaWYgKGNvbXBvc2l0aW9uS2V5ID09PSBzZWxlY3Rpb24uYW5jaG9yLmtleSB8fCBjb21wb3NpdGlvbktleSA9PT0gc2VsZWN0aW9uLmZvY3VzLmtleSkge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkoa2V5KTtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKHRoaXMsIGFuY2hvck9mZnNldCwgdGhpcywgZm9jdXNPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9XG4gIHNlbGVjdFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdCgwLCAwKTtcbiAgfVxuICBzZWxlY3RFbmQoKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0KHNpemUsIHNpemUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgdGhlIHByb3ZpZGVkIHRleHQgaW50byB0aGlzIFRleHROb2RlIGF0IHRoZSBwcm92aWRlZCBvZmZzZXQsIGRlbGV0aW5nIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVyc1xuICAgKiBzcGVjaWZpZWQuIENhbiBvcHRpb25hbGx5IGNhbGN1bGF0ZSBhIG5ldyBzZWxlY3Rpb24gYWZ0ZXIgdGhlIG9wZXJhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICpcbiAgICogQHBhcmFtIG9mZnNldCAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIHNwbGljZSBvcGVyYXRpb24gc2hvdWxkIGJlZ2luLlxuICAgKiBAcGFyYW0gZGVsQ291bnQgLSB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgdG8gZGVsZXRlLCBzdGFydGluZyBmcm9tIHRoZSBvZmZzZXQuXG4gICAqIEBwYXJhbSBuZXdUZXh0IC0gdGhlIHRleHQgdG8gaW5zZXJ0IGludG8gdGhlIFRleHROb2RlIGF0IHRoZSBvZmZzZXQuXG4gICAqIEBwYXJhbSBtb3ZlU2VsZWN0aW9uIC0gb3B0aW9uYWwsIHdoZXRoZXIgb3Igbm90IHRvIG1vdmUgc2VsZWN0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGluc2VydGVkIHN1YnN0cmluZy5cbiAgICpcbiAgICogQHJldHVybnMgdGhpcyBUZXh0Tm9kZS5cbiAgICovXG4gIHNwbGljZVRleHQob2Zmc2V0LCBkZWxDb3VudCwgbmV3VGV4dCwgbW92ZVNlbGVjdGlvbikge1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB0ZXh0ID0gd3JpdGFibGVTZWxmLl9fdGV4dDtcbiAgICBjb25zdCBoYW5kbGVkVGV4dExlbmd0aCA9IG5ld1RleHQubGVuZ3RoO1xuICAgIGxldCBpbmRleCA9IG9mZnNldDtcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IGhhbmRsZWRUZXh0TGVuZ3RoICsgaW5kZXg7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChtb3ZlU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IG5ld09mZnNldCA9IG9mZnNldCArIGhhbmRsZWRUZXh0TGVuZ3RoO1xuICAgICAgc2VsZWN0aW9uLnNldFRleHROb2RlUmFuZ2Uod3JpdGFibGVTZWxmLCBuZXdPZmZzZXQsIHdyaXRhYmxlU2VsZiwgbmV3T2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlZFRleHQgPSB0ZXh0LnNsaWNlKDAsIGluZGV4KSArIG5ld1RleHQgKyB0ZXh0LnNsaWNlKGluZGV4ICsgZGVsQ291bnQpO1xuICAgIHdyaXRhYmxlU2VsZi5fX3RleHQgPSB1cGRhdGVkVGV4dDtcbiAgICByZXR1cm4gd3JpdGFibGVTZWxmO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlIG92ZXJyaWRkZW4gYnkgVGV4dE5vZGUgc3ViY2xhc3NlcyB0byBjb250cm9sIHRoZSBiZWhhdmlvciBvZiB0aG9zZSBub2Rlc1xuICAgKiB3aGVuIGEgdXNlciBldmVudCB3b3VsZCBjYXVzZSB0ZXh0IHRvIGJlIGluc2VydGVkIGJlZm9yZSB0aGVtIGluIHRoZSBlZGl0b3IuIElmIHRydWUsIExleGljYWwgd2lsbCBhdHRlbXB0XG4gICAqIHRvIGluc2VydCB0ZXh0IGludG8gdGhpcyBub2RlLiBJZiBmYWxzZSwgaXQgd2lsbCBpbnNlcnQgdGhlIHRleHQgaW4gYSBuZXcgc2libGluZyBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRleHQgY2FuIGJlIGluc2VydGVkIGJlZm9yZSB0aGUgbm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuIGJ5IFRleHROb2RlIHN1YmNsYXNzZXMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhvc2Ugbm9kZXNcbiAgICogd2hlbiBhIHVzZXIgZXZlbnQgd291bGQgY2F1c2UgdGV4dCB0byBiZSBpbnNlcnRlZCBhZnRlciB0aGVtIGluIHRoZSBlZGl0b3IuIElmIHRydWUsIExleGljYWwgd2lsbCBhdHRlbXB0XG4gICAqIHRvIGluc2VydCB0ZXh0IGludG8gdGhpcyBub2RlLiBJZiBmYWxzZSwgaXQgd2lsbCBpbnNlcnQgdGhlIHRleHQgaW4gYSBuZXcgc2libGluZyBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRleHQgY2FuIGJlIGluc2VydGVkIGFmdGVyIHRoZSBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogU3BsaXRzIHRoaXMgVGV4dE5vZGUgYXQgdGhlIHByb3ZpZGVkIGNoYXJhY3RlciBvZmZzZXRzLCBmb3JtaW5nIG5ldyBUZXh0Tm9kZXMgZnJvbSB0aGUgc3Vic3RyaW5nc1xuICAgKiBmb3JtZWQgYnkgdGhlIHNwbGl0LCBhbmQgaW5zZXJ0aW5nIHRob3NlIG5ldyBUZXh0Tm9kZXMgaW50byB0aGUgZWRpdG9yLCByZXBsYWNpbmcgdGhlIG9uZSB0aGF0IHdhcyBzcGxpdC5cbiAgICpcbiAgICogQHBhcmFtIHNwbGl0T2Zmc2V0cyAtIHJlc3QgcGFyYW0gb2YgdGhlIHRleHQgY29udGVudCBjaGFyYWN0ZXIgb2Zmc2V0cyBhdCB3aGljaCB0aGlzIG5vZGUgc2hvdWxkIGJlIHNwbGl0LlxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBBcnJheSBjb250YWluaW5nIHRoZSBuZXdseS1jcmVhdGVkIFRleHROb2Rlcy5cbiAgICovXG4gIHNwbGl0VGV4dCguLi5zcGxpdE9mZnNldHMpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCB0ZXh0Q29udGVudCA9IHNlbGYuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBpZiAodGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHNlbGYuX19rZXk7XG4gICAgY29uc3QgY29tcG9zaXRpb25LZXkgPSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dENvbnRlbnQubGVuZ3RoO1xuICAgIHNwbGl0T2Zmc2V0cy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgc3BsaXRPZmZzZXRzLnB1c2godGV4dExlbmd0aCk7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBjb25zdCBzcGxpdE9mZnNldHNMZW5ndGggPSBzcGxpdE9mZnNldHMubGVuZ3RoO1xuICAgIGZvciAobGV0IHN0YXJ0ID0gMCwgb2Zmc2V0SW5kZXggPSAwOyBzdGFydCA8IHRleHRMZW5ndGggJiYgb2Zmc2V0SW5kZXggPD0gc3BsaXRPZmZzZXRzTGVuZ3RoOyBvZmZzZXRJbmRleCsrKSB7XG4gICAgICBjb25zdCBlbmQgPSBzcGxpdE9mZnNldHNbb2Zmc2V0SW5kZXhdO1xuICAgICAgaWYgKGVuZCA+IHN0YXJ0KSB7XG4gICAgICAgIHBhcnRzLnB1c2godGV4dENvbnRlbnQuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFydHNMZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG4gICAgaWYgKHBhcnRzTGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gW3NlbGZdO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXJ0c1swXTtcbiAgICBjb25zdCBwYXJlbnQgPSBzZWxmLmdldFBhcmVudCgpO1xuICAgIGxldCB3cml0YWJsZU5vZGU7XG4gICAgY29uc3QgZm9ybWF0ID0gc2VsZi5nZXRGb3JtYXQoKTtcbiAgICBjb25zdCBzdHlsZSA9IHNlbGYuZ2V0U3R5bGUoKTtcbiAgICBjb25zdCBkZXRhaWwgPSBzZWxmLl9fZGV0YWlsO1xuICAgIGxldCBoYXNSZXBsYWNlZFNlbGYgPSBmYWxzZTtcblxuICAgIC8vIFByZXBhcmUgdG8gaGFuZGxlIHNlbGVjdGlvblxuICAgIGxldCBzdGFydFRleHRQb2ludCA9IG51bGw7XG4gICAgbGV0IGVuZFRleHRQb2ludCA9IG51bGw7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBbc3RhcnRQb2ludCwgZW5kUG9pbnRdID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKSA/IFtzZWxlY3Rpb24uZm9jdXMsIHNlbGVjdGlvbi5hbmNob3JdIDogW3NlbGVjdGlvbi5hbmNob3IsIHNlbGVjdGlvbi5mb2N1c107XG4gICAgICBpZiAoc3RhcnRQb2ludC50eXBlID09PSAndGV4dCcgJiYgc3RhcnRQb2ludC5rZXkgPT09IGtleSkge1xuICAgICAgICBzdGFydFRleHRQb2ludCA9IHN0YXJ0UG9pbnQ7XG4gICAgICB9XG4gICAgICBpZiAoZW5kUG9pbnQudHlwZSA9PT0gJ3RleHQnICYmIGVuZFBvaW50LmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGVuZFRleHRQb2ludCA9IGVuZFBvaW50O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZi5pc1NlZ21lbnRlZCgpKSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgVGV4dE5vZGVcbiAgICAgIHdyaXRhYmxlTm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShmaXJzdFBhcnQpO1xuICAgICAgd3JpdGFibGVOb2RlLl9fZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgd3JpdGFibGVOb2RlLl9fc3R5bGUgPSBzdHlsZTtcbiAgICAgIHdyaXRhYmxlTm9kZS5fX2RldGFpbCA9IGRldGFpbDtcbiAgICAgIHdyaXRhYmxlTm9kZS5fX3N0YXRlID0gJGNsb25lTm9kZVN0YXRlKHNlbGYsIHdyaXRhYmxlTm9kZSk7XG4gICAgICBoYXNSZXBsYWNlZFNlbGYgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgdGhlIGZpcnN0IHBhcnQsIHVwZGF0ZSB0aGUgZXhpc3Rpbmcgbm9kZVxuICAgICAgd3JpdGFibGVOb2RlID0gc2VsZi5zZXRUZXh0Q29udGVudChmaXJzdFBhcnQpO1xuICAgIH1cblxuICAgIC8vIFRoZW4gaGFuZGxlIGFsbCBvdGhlciBwYXJ0c1xuICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBbd3JpdGFibGVOb2RlXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhcnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGNvbnN0IHNpYmxpbmcgPSAkY3JlYXRlVGV4dE5vZGUocGFydCk7XG4gICAgICBzaWJsaW5nLl9fZm9ybWF0ID0gZm9ybWF0O1xuICAgICAgc2libGluZy5fX3N0eWxlID0gc3R5bGU7XG4gICAgICBzaWJsaW5nLl9fZGV0YWlsID0gZGV0YWlsO1xuICAgICAgc2libGluZy5fX3N0YXRlID0gJGNsb25lTm9kZVN0YXRlKHNlbGYsIHNpYmxpbmcpO1xuICAgICAgY29uc3Qgc2libGluZ0tleSA9IHNpYmxpbmcuX19rZXk7XG4gICAgICBpZiAoY29tcG9zaXRpb25LZXkgPT09IGtleSkge1xuICAgICAgICAkc2V0Q29tcG9zaXRpb25LZXkoc2libGluZ0tleSk7XG4gICAgICB9XG4gICAgICBzcGxpdE5vZGVzLnB1c2goc2libGluZyk7XG4gICAgfVxuXG4gICAgLy8gTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBiZXN0IGxvY2F0aW9uIGluIHRoZSBzcGxpdCBzdHJpbmcuXG4gICAgLy8gVGhlIGVuZCBwb2ludCBpcyBhbHdheXMgbGVmdC1iaWFzZWQsIGFuZCB0aGUgc3RhcnQgcG9pbnQgaXNcbiAgICAvLyBnZW5lcmFsbHkgbGVmdCBiaWFzZWQgdW5sZXNzIHRoZSBlbmQgcG9pbnQgd291bGQgbGFuZCBvbiBhXG4gICAgLy8gbGF0ZXIgbm9kZSBpbiB0aGUgc3BsaXQgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIHByZWZlciB0aGUgc3RhcnRcbiAgICAvLyBvZiB0aGF0IG5vZGUgc28gdGhleSB3aWxsIHRlbmQgdG8gYmUgb24gdGhlIHNhbWUgbm9kZS5cbiAgICBjb25zdCBvcmlnaW5hbFN0YXJ0T2Zmc2V0ID0gc3RhcnRUZXh0UG9pbnQgPyBzdGFydFRleHRQb2ludC5vZmZzZXQgOiBudWxsO1xuICAgIGNvbnN0IG9yaWdpbmFsRW5kT2Zmc2V0ID0gZW5kVGV4dFBvaW50ID8gZW5kVGV4dFBvaW50Lm9mZnNldCA6IG51bGw7XG4gICAgbGV0IHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc3BsaXROb2Rlcykge1xuICAgICAgaWYgKCEoc3RhcnRUZXh0UG9pbnQgfHwgZW5kVGV4dFBvaW50KSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIGlmIChzdGFydFRleHRQb2ludCAhPT0gbnVsbCAmJiBvcmlnaW5hbFN0YXJ0T2Zmc2V0ICE9PSBudWxsICYmIG9yaWdpbmFsU3RhcnRPZmZzZXQgPD0gZW5kT2Zmc2V0ICYmIG9yaWdpbmFsU3RhcnRPZmZzZXQgPj0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgLy8gU2V0IHRoZSBzdGFydCBwb2ludCB0byB0aGUgZmlyc3QgdmFsaWQgbm9kZVxuICAgICAgICBzdGFydFRleHRQb2ludC5zZXQobm9kZS5nZXRLZXkoKSwgb3JpZ2luYWxTdGFydE9mZnNldCAtIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICBpZiAob3JpZ2luYWxTdGFydE9mZnNldCA8IGVuZE9mZnNldCkge1xuICAgICAgICAgIC8vIFRoZSBzdGFydCBpc24ndCBvbiBhIGJvcmRlciBzbyB3ZSBjYW4gc3RvcCBjaGVja2luZ1xuICAgICAgICAgIHN0YXJ0VGV4dFBvaW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVuZFRleHRQb2ludCAhPT0gbnVsbCAmJiBvcmlnaW5hbEVuZE9mZnNldCAhPT0gbnVsbCAmJiBvcmlnaW5hbEVuZE9mZnNldCA8PSBlbmRPZmZzZXQgJiYgb3JpZ2luYWxFbmRPZmZzZXQgPj0gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgZW5kVGV4dFBvaW50LnNldChub2RlLmdldEtleSgpLCBvcmlnaW5hbEVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXJ0T2Zmc2V0ID0gZW5kT2Zmc2V0O1xuICAgIH1cblxuICAgIC8vIEluc2VydCB0aGUgbm9kZXMgaW50byB0aGUgcGFyZW50J3MgY2hpbGRyZW5cbiAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBpbnRlcm5hbE1hcmtTaWJsaW5nc0FzRGlydHkodGhpcyk7XG4gICAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IHBhcmVudC5nZXRXcml0YWJsZSgpO1xuICAgICAgY29uc3QgaW5zZXJ0aW9uSW5kZXggPSB0aGlzLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICBpZiAoaGFzUmVwbGFjZWRTZWxmKSB7XG4gICAgICAgIHdyaXRhYmxlUGFyZW50LnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgc3BsaXROb2Rlcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0YWJsZVBhcmVudC5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDEsIHNwbGl0Tm9kZXMpO1xuICAgICAgfVxuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgJHVwZGF0ZUVsZW1lbnRTZWxlY3Rpb25PbkNyZWF0ZURlbGV0ZU5vZGUoc2VsZWN0aW9uLCBwYXJlbnQsIGluc2VydGlvbkluZGV4LCBwYXJ0c0xlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3BsaXROb2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZXMgdGhlIHRhcmdldCBUZXh0Tm9kZSBpbnRvIHRoaXMgVGV4dE5vZGUsIHJlbW92aW5nIHRoZSB0YXJnZXQgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHRhcmdldCAtIHRoZSBUZXh0Tm9kZSB0byBtZXJnZSBpbnRvIHRoaXMgb25lLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGlzIFRleHROb2RlLlxuICAgKi9cbiAgbWVyZ2VXaXRoU2libGluZyh0YXJnZXQpIHtcbiAgICBjb25zdCBpc0JlZm9yZSA9IHRhcmdldCA9PT0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBpZiAoIWlzQmVmb3JlICYmIHRhcmdldCAhPT0gdGhpcy5nZXROZXh0U2libGluZygpKSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgbWVyZ2VXaXRoU2libGluZzogc2libGluZyBtdXN0IGJlIGEgcHJldmlvdXMgb3IgbmV4dCBzaWJsaW5nYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IHRoaXMuX19rZXk7XG4gICAgY29uc3QgdGFyZ2V0S2V5ID0gdGFyZ2V0Ll9fa2V5O1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLl9fdGV4dDtcbiAgICBjb25zdCB0ZXh0TGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgY29uc3QgY29tcG9zaXRpb25LZXkgPSAkZ2V0Q29tcG9zaXRpb25LZXkoKTtcbiAgICBpZiAoY29tcG9zaXRpb25LZXkgPT09IHRhcmdldEtleSkge1xuICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGtleSk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBhbmNob3Iua2V5ID09PSB0YXJnZXRLZXkpIHtcbiAgICAgICAgYWRqdXN0UG9pbnRPZmZzZXRGb3JNZXJnZWRTaWJsaW5nKGFuY2hvciwgaXNCZWZvcmUsIGtleSwgdGFyZ2V0LCB0ZXh0TGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGlmIChmb2N1cyAhPT0gbnVsbCAmJiBmb2N1cy5rZXkgPT09IHRhcmdldEtleSkge1xuICAgICAgICBhZGp1c3RQb2ludE9mZnNldEZvck1lcmdlZFNpYmxpbmcoZm9jdXMsIGlzQmVmb3JlLCBrZXksIHRhcmdldCwgdGV4dExlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldFRleHQgPSB0YXJnZXQuX190ZXh0O1xuICAgIGNvbnN0IG5ld1RleHQgPSBpc0JlZm9yZSA/IHRhcmdldFRleHQgKyB0ZXh0IDogdGV4dCArIHRhcmdldFRleHQ7XG4gICAgdGhpcy5zZXRUZXh0Q29udGVudChuZXdUZXh0KTtcbiAgICBjb25zdCB3cml0YWJsZVNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgdGFyZ2V0LnJlbW92ZSgpO1xuICAgIHJldHVybiB3cml0YWJsZVNlbGY7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbiBieSBUZXh0Tm9kZSBzdWJjbGFzc2VzIHRvIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mIHRob3NlIG5vZGVzXG4gICAqIHdoZW4gdXNlZCB3aXRoIHRoZSByZWdpc3RlckxleGljYWxUZXh0RW50aXR5IGZ1bmN0aW9uLiBJZiB5b3UncmUgdXNpbmcgcmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eSwgdGhlXG4gICAqIG5vZGUgY2xhc3MgdGhhdCB5b3UgY3JlYXRlIGFuZCByZXBsYWNlIG1hdGNoZWQgdGV4dCB3aXRoIHNob3VsZCByZXR1cm4gdHJ1ZSBmcm9tIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBub2RlIGlzIHRvIGJlIHRyZWF0ZWQgYXMgYSBcInRleHQgZW50aXR5XCIsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzVGV4dEVudGl0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnZlcnRTcGFuRWxlbWVudChkb21Ob2RlKSB7XG4gIC8vIGRvbU5vZGUgaXMgYSA8c3Bhbj4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICBjb25zdCBzcGFuID0gZG9tTm9kZTtcbiAgY29uc3Qgc3R5bGUgPSBzcGFuLnN0eWxlO1xuICByZXR1cm4ge1xuICAgIGZvckNoaWxkOiBhcHBseVRleHRGb3JtYXRGcm9tU3R5bGUoc3R5bGUpLFxuICAgIG5vZGU6IG51bGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCcmluZ0F0dGVudGlvblRvRWxlbWVudChkb21Ob2RlKSB7XG4gIC8vIGRvbU5vZGUgaXMgYSA8Yj4gc2luY2Ugd2UgbWF0Y2hlZCBpdCBieSBub2RlTmFtZVxuICBjb25zdCBiID0gZG9tTm9kZTtcbiAgLy8gR29vZ2xlIERvY3Mgd3JhcHMgYWxsIGNvcGllZCBIVE1MIGluIGEgPGI+IHdpdGggZm9udC13ZWlnaHQgbm9ybWFsXG4gIGNvbnN0IGhhc05vcm1hbEZvbnRXZWlnaHQgPSBiLnN0eWxlLmZvbnRXZWlnaHQgPT09ICdub3JtYWwnO1xuICByZXR1cm4ge1xuICAgIGZvckNoaWxkOiBhcHBseVRleHRGb3JtYXRGcm9tU3R5bGUoYi5zdHlsZSwgaGFzTm9ybWFsRm9udFdlaWdodCA/IHVuZGVmaW5lZCA6ICdib2xkJyksXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuY29uc3QgcHJlUGFyZW50Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaXNOb2RlUHJlKG5vZGUpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdQUkUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgd2hpdGVTcGFjZSA9IG5vZGUuc3R5bGUud2hpdGVTcGFjZTtcbiAgcmV0dXJuIHR5cGVvZiB3aGl0ZVNwYWNlID09PSAnc3RyaW5nJyAmJiB3aGl0ZVNwYWNlLnN0YXJ0c1dpdGgoJ3ByZScpO1xufVxuZnVuY3Rpb24gZmluZFBhcmVudFByZURPTU5vZGUobm9kZSkge1xuICBsZXQgY2FjaGVkO1xuICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICBjb25zdCB2aXNpdGVkID0gW25vZGVdO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIChjYWNoZWQgPSBwcmVQYXJlbnRDYWNoZS5nZXQocGFyZW50KSkgPT09IHVuZGVmaW5lZCAmJiAhaXNOb2RlUHJlKHBhcmVudCkpIHtcbiAgICB2aXNpdGVkLnB1c2gocGFyZW50KTtcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHROb2RlID0gY2FjaGVkID09PSB1bmRlZmluZWQgPyBwYXJlbnQgOiBjYWNoZWQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmlzaXRlZC5sZW5ndGg7IGkrKykge1xuICAgIHByZVBhcmVudENhY2hlLnNldCh2aXNpdGVkW2ldLCByZXN1bHROb2RlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Tm9kZTtcbn1cbmZ1bmN0aW9uICRjb252ZXJ0VGV4dERPTU5vZGUoZG9tTm9kZSkge1xuICBjb25zdCBkb21Ob2RlXyA9IGRvbU5vZGU7XG4gIGNvbnN0IHBhcmVudERvbSA9IGRvbU5vZGUucGFyZW50RWxlbWVudDtcbiAgaWYgKCEocGFyZW50RG9tICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgcGFyZW50RWxlbWVudCBvZiBUZXh0IG5vdCB0byBiZSBudWxsYCk7XG4gIH1cbiAgbGV0IHRleHRDb250ZW50ID0gZG9tTm9kZV8udGV4dENvbnRlbnQgfHwgJyc7XG4gIC8vIE5vIGNvbGxhcHNlIGFuZCBwcmVzZXJ2ZSBzZWdtZW50IGJyZWFrIGZvciBwcmUsIHByZS13cmFwIGFuZCBwcmUtbGluZVxuICBpZiAoZmluZFBhcmVudFByZURPTU5vZGUoZG9tTm9kZV8pICE9PSBudWxsKSB7XG4gICAgY29uc3QgcGFydHMgPSB0ZXh0Q29udGVudC5zcGxpdCgvKFxccj9cXG58XFx0KS8pO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgbGVuZ3RoID0gcGFydHMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIGlmIChwYXJ0ID09PSAnXFxuJyB8fCBwYXJ0ID09PSAnXFxyXFxuJykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVMaW5lQnJlYWtOb2RlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnXFx0Jykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUYWJOb2RlKCkpO1xuICAgICAgfSBlbHNlIGlmIChwYXJ0ICE9PSAnJykge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUZXh0Tm9kZShwYXJ0KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBub2Rlc1xuICAgIH07XG4gIH1cbiAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5yZXBsYWNlKC9cXHIvZywgJycpLnJlcGxhY2UoL1sgXFx0XFxuXSsvZywgJyAnKTtcbiAgaWYgKHRleHRDb250ZW50ID09PSAnJykge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuICBpZiAodGV4dENvbnRlbnRbMF0gPT09ICcgJykge1xuICAgIC8vIFRyYXZlcnNlIGJhY2t3YXJkIHdoaWxlIGluIHRoZSBzYW1lIGxpbmUuIElmIGNvbnRlbnQgY29udGFpbnMgbmV3IGxpbmUgb3IgdGFiIC0+IHBvdGVudGlhbFxuICAgIC8vIGRlbGV0ZSwgb3RoZXIgZWxlbWVudHMgY2FuIGJvcnJvdyBmcm9tIHRoaXMgb25lLiBEZWxldGlvbiBkZXBlbmRzIG9uIHdoZXRoZXIgaXQncyBhbHNvIHRoZVxuICAgIC8vIGxhc3Qgc3BhY2UgKHNlZSBuZXh0IGNvbmRpdGlvbjogdGV4dENvbnRlbnRbdGV4dENvbnRlbnQubGVuZ3RoIC0gMV0gPT09ICcgJykpXG4gICAgbGV0IHByZXZpb3VzVGV4dCA9IGRvbU5vZGVfO1xuICAgIGxldCBpc1N0YXJ0T2ZMaW5lID0gdHJ1ZTtcbiAgICB3aGlsZSAocHJldmlvdXNUZXh0ICE9PSBudWxsICYmIChwcmV2aW91c1RleHQgPSBmaW5kVGV4dEluTGluZShwcmV2aW91c1RleHQsIGZhbHNlKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzVGV4dENvbnRlbnQgPSBwcmV2aW91c1RleHQudGV4dENvbnRlbnQgfHwgJyc7XG4gICAgICBpZiAocHJldmlvdXNUZXh0Q29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGlmICgvWyBcXHRcXG5dJC8udGVzdChwcmV2aW91c1RleHRDb250ZW50KSkge1xuICAgICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaXNTdGFydE9mTGluZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzU3RhcnRPZkxpbmUpIHtcbiAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZXh0Q29udGVudFt0ZXh0Q29udGVudC5sZW5ndGggLSAxXSA9PT0gJyAnKSB7XG4gICAgLy8gVHJhdmVyc2UgZm9yd2FyZCB3aGlsZSBpbiB0aGUgc2FtZSBsaW5lLCBwcmVzZXJ2ZSBpZiBuZXh0IGlubGluZSB3aWxsIHJlcXVpcmUgYSBzcGFjZVxuICAgIGxldCBuZXh0VGV4dCA9IGRvbU5vZGVfO1xuICAgIGxldCBpc0VuZE9mTGluZSA9IHRydWU7XG4gICAgd2hpbGUgKG5leHRUZXh0ICE9PSBudWxsICYmIChuZXh0VGV4dCA9IGZpbmRUZXh0SW5MaW5lKG5leHRUZXh0LCB0cnVlKSkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5leHRUZXh0Q29udGVudCA9IChuZXh0VGV4dC50ZXh0Q29udGVudCB8fCAnJykucmVwbGFjZSgvXiggfFxcdHxcXHI/XFxuKSsvLCAnJyk7XG4gICAgICBpZiAobmV4dFRleHRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaXNFbmRPZkxpbmUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0VuZE9mTGluZSkge1xuICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCB0ZXh0Q29udGVudC5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRleHRDb250ZW50ID09PSAnJykge1xuICAgIHJldHVybiB7XG4gICAgICBub2RlOiBudWxsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGU6ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0Q29udGVudClcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpbmRUZXh0SW5MaW5lKHRleHQsIGZvcndhcmQpIHtcbiAgbGV0IG5vZGUgPSB0ZXh0O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbGV0IHNpYmxpbmc7XG4gICAgd2hpbGUgKChzaWJsaW5nID0gZm9yd2FyZCA/IG5vZGUubmV4dFNpYmxpbmcgOiBub2RlLnByZXZpb3VzU2libGluZykgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAocGFyZW50RWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICBub2RlID0gc2libGluZztcbiAgICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgICAgY29uc3QgZGlzcGxheSA9IG5vZGUuc3R5bGUuZGlzcGxheTtcbiAgICAgIGlmIChkaXNwbGF5ID09PSAnJyAmJiAhaXNJbmxpbmVEb21Ob2RlKG5vZGUpIHx8IGRpc3BsYXkgIT09ICcnICYmICFkaXNwbGF5LnN0YXJ0c1dpdGgoJ2lubGluZScpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZGVzY2VuZGFudCA9IG5vZGU7XG4gICAgd2hpbGUgKChkZXNjZW5kYW50ID0gZm9yd2FyZCA/IG5vZGUuZmlyc3RDaGlsZCA6IG5vZGUubGFzdENoaWxkKSAhPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IGRlc2NlbmRhbnQ7XG4gICAgfVxuICAgIGlmIChpc0RPTVRleHROb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgbm9kZU5hbWVUb1RleHRGb3JtYXQgPSB7XG4gIGNvZGU6ICdjb2RlJyxcbiAgZW06ICdpdGFsaWMnLFxuICBpOiAnaXRhbGljJyxcbiAgbWFyazogJ2hpZ2hsaWdodCcsXG4gIHM6ICdzdHJpa2V0aHJvdWdoJyxcbiAgc3Ryb25nOiAnYm9sZCcsXG4gIHN1YjogJ3N1YnNjcmlwdCcsXG4gIHN1cDogJ3N1cGVyc2NyaXB0JyxcbiAgdTogJ3VuZGVybGluZSdcbn07XG5mdW5jdGlvbiBjb252ZXJ0VGV4dEZvcm1hdEVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBmb3JtYXQgPSBub2RlTmFtZVRvVGV4dEZvcm1hdFtkb21Ob2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldO1xuICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBmb3JDaGlsZDogYXBwbHlUZXh0Rm9ybWF0RnJvbVN0eWxlKGRvbU5vZGUuc3R5bGUsIGZvcm1hdCksXG4gICAgbm9kZTogbnVsbFxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRleHROb2RlKHRleHQgPSAnJykge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUZXh0Tm9kZSh0ZXh0KSk7XG59XG5mdW5jdGlvbiAkaXNUZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGV4dE5vZGU7XG59XG5mdW5jdGlvbiBhcHBseVRleHRGb3JtYXRGcm9tU3R5bGUoc3R5bGUsIHNob3VsZEFwcGx5KSB7XG4gIGNvbnN0IGZvbnRXZWlnaHQgPSBzdHlsZS5mb250V2VpZ2h0O1xuICBjb25zdCB0ZXh0RGVjb3JhdGlvbiA9IHN0eWxlLnRleHREZWNvcmF0aW9uLnNwbGl0KCcgJyk7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgZm9udC13ZWlnaHQgZm9yIGJvbGQgdGV4dFxuICBjb25zdCBoYXNCb2xkRm9udFdlaWdodCA9IGZvbnRXZWlnaHQgPT09ICc3MDAnIHx8IGZvbnRXZWlnaHQgPT09ICdib2xkJztcbiAgLy8gR29vZ2xlIERvY3MgdXNlcyBzcGFuIHRhZ3MgKyB0ZXh0LWRlY29yYXRpb246IGxpbmUtdGhyb3VnaCBmb3Igc3RyaWtldGhyb3VnaCB0ZXh0XG4gIGNvbnN0IGhhc0xpbmV0aHJvdWdoVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygnbGluZS10aHJvdWdoJyk7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgZm9udC1zdHlsZSBmb3IgaXRhbGljIHRleHRcbiAgY29uc3QgaGFzSXRhbGljRm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID09PSAnaXRhbGljJztcbiAgLy8gR29vZ2xlIERvY3MgdXNlcyBzcGFuIHRhZ3MgKyB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBmb3IgdW5kZXJsaW5lIHRleHRcbiAgY29uc3QgaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygndW5kZXJsaW5lJyk7XG4gIC8vIEdvb2dsZSBEb2NzIHVzZXMgc3BhbiB0YWdzICsgdmVydGljYWwtYWxpZ24gdG8gc3BlY2lmeSBzdWJzY3JpcHQgYW5kIHN1cGVyc2NyaXB0XG4gIGNvbnN0IHZlcnRpY2FsQWxpZ24gPSBzdHlsZS52ZXJ0aWNhbEFsaWduO1xuICByZXR1cm4gbGV4aWNhbE5vZGUgPT4ge1xuICAgIGlmICghJGlzVGV4dE5vZGUobGV4aWNhbE5vZGUpKSB7XG4gICAgICByZXR1cm4gbGV4aWNhbE5vZGU7XG4gICAgfVxuICAgIGlmIChoYXNCb2xkRm9udFdlaWdodCAmJiAhbGV4aWNhbE5vZGUuaGFzRm9ybWF0KCdib2xkJykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnYm9sZCcpO1xuICAgIH1cbiAgICBpZiAoaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbiAmJiAhbGV4aWNhbE5vZGUuaGFzRm9ybWF0KCdzdHJpa2V0aHJvdWdoJykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgnc3RyaWtldGhyb3VnaCcpO1xuICAgIH1cbiAgICBpZiAoaGFzSXRhbGljRm9udFN0eWxlICYmICFsZXhpY2FsTm9kZS5oYXNGb3JtYXQoJ2l0YWxpYycpKSB7XG4gICAgICBsZXhpY2FsTm9kZS50b2dnbGVGb3JtYXQoJ2l0YWxpYycpO1xuICAgIH1cbiAgICBpZiAoaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24gJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdCgndW5kZXJsaW5lJykpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdCgndW5kZXJsaW5lJyk7XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbEFsaWduID09PSAnc3ViJyAmJiAhbGV4aWNhbE5vZGUuaGFzRm9ybWF0KCdzdWJzY3JpcHQnKSkge1xuICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdzdWJzY3JpcHQnKTtcbiAgICB9XG4gICAgaWYgKHZlcnRpY2FsQWxpZ24gPT09ICdzdXBlcicgJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdCgnc3VwZXJzY3JpcHQnKSkge1xuICAgICAgbGV4aWNhbE5vZGUudG9nZ2xlRm9ybWF0KCdzdXBlcnNjcmlwdCcpO1xuICAgIH1cbiAgICBpZiAoc2hvdWxkQXBwbHkgJiYgIWxleGljYWxOb2RlLmhhc0Zvcm1hdChzaG91bGRBcHBseSkpIHtcbiAgICAgIGxleGljYWxOb2RlLnRvZ2dsZUZvcm1hdChzaG91bGRBcHBseSk7XG4gICAgfVxuICAgIHJldHVybiBsZXhpY2FsTm9kZTtcbiAgfTtcbn1cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYk5vZGUgZXh0ZW5kcyBUZXh0Tm9kZSB7XG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGFiJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGFiTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuICBjb25zdHJ1Y3RvcihrZXkpIHtcbiAgICBzdXBlcignXFx0Jywga2V5KTtcbiAgICB0aGlzLl9fZGV0YWlsID0gSVNfVU5NRVJHRUFCTEU7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZG9tID0gc3VwZXIuY3JlYXRlRE9NKGNvbmZpZyk7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KGNvbmZpZy50aGVtZSwgJ3RhYicpO1xuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRvbUNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7XG4gICAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWRUYWJOb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZFRhYk5vZGUpO1xuICB9XG4gIHNldFRleHRDb250ZW50KHRleHQpIHtcbiAgICBpZiAoISh0ZXh0ID09PSAnXFx0JyB8fCB0ZXh0ID09PSAnJykpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFiTm9kZSBkb2VzIG5vdCBzdXBwb3J0IHNldFRleHRDb250ZW50YCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5zZXRUZXh0Q29udGVudCgnXFx0Jyk7XG4gIH1cbiAgc3BsaWNlVGV4dChvZmZzZXQsIGRlbENvdW50LCBuZXdUZXh0LCBtb3ZlU2VsZWN0aW9uKSB7XG4gICAgaWYgKCEobmV3VGV4dCA9PT0gJycgJiYgZGVsQ291bnQgPT09IDAgfHwgbmV3VGV4dCA9PT0gJ1xcdCcgJiYgZGVsQ291bnQgPT09IDEpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYk5vZGUgZG9lcyBub3Qgc3VwcG9ydCBzcGxpY2VUZXh0YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldERldGFpbChkZXRhaWwpIHtcbiAgICBpZiAoIShkZXRhaWwgPT09IElTX1VOTUVSR0VBQkxFKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUYWJOb2RlIGRvZXMgbm90IHN1cHBvcnQgc2V0RGV0YWlsYCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldE1vZGUodHlwZSkge1xuICAgIGlmICghKHR5cGUgPT09ICdub3JtYWwnKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUYWJOb2RlIGRvZXMgbm90IHN1cHBvcnQgc2V0TW9kZWApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjYW5JbnNlcnRUZXh0QmVmb3JlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFiTm9kZSgpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGFiTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYk5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYk5vZGU7XG59XG5cbmNsYXNzIFBvaW50IHtcbiAgY29uc3RydWN0b3Ioa2V5LCBvZmZzZXQsIHR5cGUpIHtcbiAgICB7XG4gICAgICAvLyBUaGlzIHByZXZlbnRzIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGVycm9yIHdoZW4gc2VyaWFsaXplZCBhcyBKU09OLFxuICAgICAgLy8gd2hpY2ggaGFwcGVucyBvbiB1bml0IHRlc3QgZmFpbHVyZXNcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX3NlbGVjdGlvbicsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fc2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGlzKHBvaW50KSB7XG4gICAgcmV0dXJuIHRoaXMua2V5ID09PSBwb2ludC5rZXkgJiYgdGhpcy5vZmZzZXQgPT09IHBvaW50Lm9mZnNldCAmJiB0aGlzLnR5cGUgPT09IHBvaW50LnR5cGU7XG4gIH1cbiAgaXNCZWZvcmUoYikge1xuICAgIGlmICh0aGlzLmtleSA9PT0gYi5rZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldCA8IGIub2Zmc2V0O1xuICAgIH1cbiAgICBjb25zdCBhQ2FyZXQgPSAkbm9ybWFsaXplQ2FyZXQoJGNhcmV0RnJvbVBvaW50KHRoaXMsICduZXh0JykpO1xuICAgIGNvbnN0IGJDYXJldCA9ICRub3JtYWxpemVDYXJldCgkY2FyZXRGcm9tUG9pbnQoYiwgJ25leHQnKSk7XG4gICAgcmV0dXJuICRjb21wYXJlUG9pbnRDYXJldE5leHQoYUNhcmV0LCBiQ2FyZXQpIDwgMDtcbiAgfVxuICBnZXROb2RlKCkge1xuICAgIGNvbnN0IGtleSA9IHRoaXMua2V5O1xuICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGtleSk7XG4gICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBQb2ludC5nZXROb2RlOiBub2RlIG5vdCBmb3VuZGApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBzZXQoa2V5LCBvZmZzZXQsIHR5cGUsIG9ubHlJZkNoYW5nZWQpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLl9zZWxlY3Rpb247XG4gICAgY29uc3Qgb2xkS2V5ID0gdGhpcy5rZXk7XG4gICAgaWYgKG9ubHlJZkNoYW5nZWQgJiYgdGhpcy5rZXkgPT09IGtleSAmJiB0aGlzLm9mZnNldCA9PT0gb2Zmc2V0ICYmIHRoaXMudHlwZSA9PT0gdHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGtleSk7XG4gICAgICBpZiAoISh0eXBlID09PSAndGV4dCcgPyAkaXNUZXh0Tm9kZShub2RlKSA6ICRpc0VsZW1lbnROb2RlKG5vZGUpKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFBvaW50VHlwZS5zZXQ6IG5vZGUgd2l0aCBrZXkgJHtrZXl9IGlzICR7bm9kZSA/IG5vZGUuX190eXBlIDogJ1tub3QgZm91bmRdJ30gYW5kIGNhbiBub3QgYmUgdXNlZCBmb3IgYSAke3R5cGV9IHBvaW50YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSkge1xuICAgICAgaWYgKCRnZXRDb21wb3NpdGlvbktleSgpID09PSBvbGRLZXkpIHtcbiAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KGtleSk7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZXRDYWNoZWROb2RlcyhudWxsKTtcbiAgICAgICAgc2VsZWN0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVQb2ludChrZXksIG9mZnNldCwgdHlwZSkge1xuICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlbnRpb25hbGx5IGNhc3QgYXMgd2UgdXNlIGEgY2xhc3MgZm9yIHBlcmYgcmVhc29uc1xuICByZXR1cm4gbmV3IFBvaW50KGtleSwgb2Zmc2V0LCB0eXBlKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFBvaW50T25Ob2RlKHBvaW50LCBub2RlKSB7XG4gIGxldCBrZXkgPSBub2RlLl9fa2V5O1xuICBsZXQgb2Zmc2V0ID0gcG9pbnQub2Zmc2V0O1xuICBsZXQgdHlwZSA9ICdlbGVtZW50JztcbiAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgdHlwZSA9ICd0ZXh0JztcbiAgICBjb25zdCB0ZXh0Q29udGVudExlbmd0aCA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgaWYgKG9mZnNldCA+IHRleHRDb250ZW50TGVuZ3RoKSB7XG4gICAgICBvZmZzZXQgPSB0ZXh0Q29udGVudExlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgaWYgKCRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAga2V5ID0gbmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgICAgdHlwZSA9ICd0ZXh0JztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICBrZXkgPSBwYXJlbnROb2RlLl9fa2V5O1xuICAgICAgICBvZmZzZXQgPSBub2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludC5zZXQoa2V5LCBvZmZzZXQsIHR5cGUpO1xufVxuZnVuY3Rpb24gJG1vdmVTZWxlY3Rpb25Qb2ludFRvRW5kKHBvaW50LCBub2RlKSB7XG4gIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IGxhc3ROb2RlID0gbm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShsYXN0Tm9kZSkgfHwgJGlzVGV4dE5vZGUobGFzdE5vZGUpKSB7XG4gICAgICBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbGFzdE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RQb2ludE9uTm9kZShwb2ludCwgbm9kZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNlbGVjdFBvaW50T25Ob2RlKHBvaW50LCBub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gJHRyYW5zZmVyU3RhcnRpbmdFbGVtZW50UG9pbnRUb1RleHRQb2ludChzdGFydCwgZW5kLCBmb3JtYXQsIHN0eWxlKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBzdGFydC5nZXROb2RlKCk7XG4gIGNvbnN0IHBsYWNlbWVudE5vZGUgPSBlbGVtZW50LmdldENoaWxkQXRJbmRleChzdGFydC5vZmZzZXQpO1xuICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICBjb25zdCB0YXJnZXQgPSAkaXNSb290Tm9kZShlbGVtZW50KSA/ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkuYXBwZW5kKHRleHROb2RlKSA6IHRleHROb2RlO1xuICB0ZXh0Tm9kZS5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgdGV4dE5vZGUuc2V0U3R5bGUoc3R5bGUpO1xuICBpZiAocGxhY2VtZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgIGVsZW1lbnQuYXBwZW5kKHRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgcGxhY2VtZW50Tm9kZS5pbnNlcnRCZWZvcmUodGFyZ2V0KTtcbiAgfVxuICAvLyBUcmFuc2ZlciB0aGUgZWxlbWVudCBwb2ludCB0byBhIHRleHQgcG9pbnQuXG4gIGlmIChzdGFydC5pcyhlbmQpKSB7XG4gICAgZW5kLnNldCh0ZXh0Tm9kZS5fX2tleSwgMCwgJ3RleHQnKTtcbiAgfVxuICBzdGFydC5zZXQodGV4dE5vZGUuX19rZXksIDAsICd0ZXh0Jyk7XG59XG5jbGFzcyBOb2RlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3Iob2JqZWN0cykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLl9ub2RlcyA9IG9iamVjdHM7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG4gIGdldENhY2hlZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWROb2RlcztcbiAgfVxuICBzZXRDYWNoZWROb2Rlcyhub2Rlcykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gIH1cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgaWYgKCEkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYSA9IHRoaXMuX25vZGVzO1xuICAgIGNvbnN0IGIgPSBzZWxlY3Rpb24uX25vZGVzO1xuICAgIHJldHVybiBhLnNpemUgPT09IGIuc2l6ZSAmJiBBcnJheS5mcm9tKGEpLmV2ZXJ5KGtleSA9PiBiLmhhcyhrZXkpKTtcbiAgfVxuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNCYWNrd2FyZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0U3RhcnRFbmRQb2ludHMoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgYWRkKGtleSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX25vZGVzLmFkZChrZXkpO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuICBkZWxldGUoa2V5KSB7XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fbm9kZXMuZGVsZXRlKGtleSk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX25vZGVzLmNsZWFyKCk7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuaGFzKGtleSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKG5ldyBTZXQodGhpcy5fbm9kZXMpKTtcbiAgfVxuICBleHRyYWN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gIH1cbiAgaW5zZXJ0UmF3VGV4dCh0ZXh0KSB7XG4gICAgLy8gRG8gbm90aGluZz9cbiAgfVxuICBpbnNlcnRUZXh0KCkge1xuICAgIC8vIERvIG5vdGhpbmc/XG4gIH1cbiAgaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXNMZW5ndGggPSBzZWxlY3RlZE5vZGVzLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0U2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tzZWxlY3RlZE5vZGVzTGVuZ3RoIC0gMV07XG4gICAgbGV0IHNlbGVjdGlvbkF0RW5kO1xuICAgIC8vIEluc2VydCBub2Rlc1xuICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0U2VsZWN0ZWROb2RlKSkge1xuICAgICAgc2VsZWN0aW9uQXRFbmQgPSBsYXN0U2VsZWN0ZWROb2RlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxhc3RTZWxlY3RlZE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICBzZWxlY3Rpb25BdEVuZCA9IGxhc3RTZWxlY3RlZE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdChpbmRleCwgaW5kZXgpO1xuICAgIH1cbiAgICBzZWxlY3Rpb25BdEVuZC5pbnNlcnROb2Rlcyhub2Rlcyk7XG4gICAgLy8gUmVtb3ZlIHNlbGVjdGVkIG5vZGVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3RlZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkTm9kZXNbaV0ucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIGdldE5vZGVzKCkge1xuICAgIGNvbnN0IGNhY2hlZE5vZGVzID0gdGhpcy5fY2FjaGVkTm9kZXM7XG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuICAgIGNvbnN0IG9iamVjdHMgPSB0aGlzLl9ub2RlcztcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3Qgb2JqZWN0IG9mIG9iamVjdHMpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KG9iamVjdCk7XG4gICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0ZXh0Q29udGVudCArPSBub2Rlc1tpXS5nZXRUZXh0Q29udGVudCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBub2RlcyBpbiB0aGUgTm9kZVNlbGVjdGlvbi4gSWYgdGhlcmUgd2VyZSBhbnkgbm9kZXMsXG4gICAqIHJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgbmV3IFJhbmdlU2VsZWN0aW9uIGF0IHRoZSBwcmV2aW91c1xuICAgKiBsb2NhdGlvbiBvZiB0aGUgZmlyc3Qgbm9kZS5cbiAgICovXG4gIGRlbGV0ZU5vZGVzKCkge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGlmICgoJGdldFNlbGVjdGlvbigpIHx8ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpKSA9PT0gdGhpcyAmJiBub2Rlc1swXSkge1xuICAgICAgY29uc3QgZmlyc3RDYXJldCA9ICRnZXRTaWJsaW5nQ2FyZXQobm9kZXNbMF0sICduZXh0Jyk7XG4gICAgICAkc2V0U2VsZWN0aW9uRnJvbUNhcmV0UmFuZ2UoJGdldENhcmV0UmFuZ2UoZmlyc3RDYXJldCwgZmlyc3RDYXJldCkpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkaXNSYW5nZVNlbGVjdGlvbih4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgUmFuZ2VTZWxlY3Rpb247XG59XG5jbGFzcyBSYW5nZVNlbGVjdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGFuY2hvciwgZm9jdXMsIGZvcm1hdCwgc3R5bGUpIHtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmZvY3VzID0gZm9jdXM7XG4gICAgYW5jaG9yLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIGZvY3VzLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICB9XG4gIGdldENhY2hlZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWROb2RlcztcbiAgfVxuICBzZXRDYWNoZWROb2Rlcyhub2Rlcykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBjaGVjayBpZiB0aGUgcHJvdmlkZWQgc2VsZWN0aW9ucyBpcyBlcXVhbCB0byB0aGlzIG9uZSBieSB2YWx1ZSxcbiAgICogaW5jbHVkaW5nIGFuY2hvciwgZm9jdXMsIGZvcm1hdCwgYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSBzZWxlY3Rpb24gLSB0aGUgU2VsZWN0aW9uIHRvIGNvbXBhcmUgdGhpcyBvbmUgdG8uXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFNlbGVjdGlvbnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpcyhzZWxlY3Rpb24pIHtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yLmlzKHNlbGVjdGlvbi5hbmNob3IpICYmIHRoaXMuZm9jdXMuaXMoc2VsZWN0aW9uLmZvY3VzKSAmJiB0aGlzLmZvcm1hdCA9PT0gc2VsZWN0aW9uLmZvcm1hdCAmJiB0aGlzLnN0eWxlID09PSBzZWxlY3Rpb24uc3R5bGU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTZWxlY3Rpb24gaXMgXCJjb2xsYXBzZWRcIiwgbWVhbmluZyB0aGUgYW5jaG9yIGFuZCBmb2N1cyBhcmVcbiAgICogdGhlIHNhbWUgbm9kZSBhbmQgaGF2ZSB0aGUgc2FtZSBvZmZzZXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFNlbGVjdGlvbiBpcyBjb2xsYXBzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzQ29sbGFwc2VkKCkge1xuICAgIHJldHVybiB0aGlzLmFuY2hvci5pcyh0aGlzLmZvY3VzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvbi4gVXNlcyBjYWNoaW5nIHRvIG1ha2UgaXQgZ2VuZXJhbGx5IHN1aXRhYmxlXG4gICAqIGZvciB1c2UgaW4gaG90IHBhdGhzLlxuICAgKlxuICAgKiBTZWUgYWxzbyB0aGUge0BsaW5rIENhcmV0UmFuZ2V9IEFQSXMgKHN0YXJ0aW5nIHdpdGhcbiAgICoge0BsaW5rICRjYXJldFJhbmdlRnJvbVNlbGVjdGlvbn0pLCB3aGljaCBhcmUgbGlrZWx5IHRvIHByb3ZpZGUgYSBiZXR0ZXJcbiAgICogZm91bmRhdGlvbiBmb3IgYW55IG9wZXJhdGlvbiB3aGVyZSBwYXJ0aWFsIHNlbGVjdGlvbiBpcyByZWxldmFudFxuICAgKiAoZS5nLiB0aGUgYW5jaG9yIG9yIGZvY3VzIGFyZSBpbnNpZGUgYW4gRWxlbWVudE5vZGUgYW5kIFRleHROb2RlKVxuICAgKlxuICAgKiBAcmV0dXJucyBhbiBBcnJheSBjb250YWluaW5nIGFsbCB0aGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvblxuICAgKi9cbiAgZ2V0Tm9kZXMoKSB7XG4gICAgY29uc3QgY2FjaGVkTm9kZXMgPSB0aGlzLl9jYWNoZWROb2RlcztcbiAgICBpZiAoY2FjaGVkTm9kZXMgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBjYWNoZWROb2RlcztcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UgPSAkZ2V0Q2FyZXRSYW5nZUluRGlyZWN0aW9uKCRjYXJldFJhbmdlRnJvbVNlbGVjdGlvbih0aGlzKSwgJ25leHQnKTtcbiAgICBjb25zdCBub2RlcyA9ICRnZXROb2Rlc0Zyb21DYXJldFJhbmdlQ29tcGF0KHJhbmdlKTtcbiAgICB7XG4gICAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCgpICYmIG5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAge1xuICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgUmFuZ2VTZWxlY3Rpb24uZ2V0Tm9kZXMoKSByZXR1cm5lZCAke1N0cmluZyhub2Rlcy5sZW5ndGgpfSA+IDEgbm9kZXMgaW4gYSBjb2xsYXBzZWQgc2VsZWN0aW9uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpKSB7XG4gICAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG5vZGVzO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGlzIFNlbGVjdGlvbiB0byBiZSBvZiB0eXBlIFwidGV4dFwiIGF0IHRoZSBwcm92aWRlZCBhbmNob3IgYW5kIGZvY3VzIHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIGFuY2hvck5vZGUgLSB0aGUgYW5jaG9yIG5vZGUgdG8gc2V0IG9uIHRoZSBTZWxlY3Rpb25cbiAgICogQHBhcmFtIGFuY2hvck9mZnNldCAtIHRoZSBvZmZzZXQgdG8gc2V0IG9uIHRoZSBTZWxlY3Rpb25cbiAgICogQHBhcmFtIGZvY3VzTm9kZSAtIHRoZSBmb2N1cyBub2RlIHRvIHNldCBvbiB0aGUgU2VsZWN0aW9uXG4gICAqIEBwYXJhbSBmb2N1c09mZnNldCAtIHRoZSBmb2N1cyBvZmZzZXQgdG8gc2V0IG9uIHRoZSBTZWxlY3Rpb25cbiAgICovXG4gIHNldFRleHROb2RlUmFuZ2UoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gICAgdGhpcy5hbmNob3Iuc2V0KGFuY2hvck5vZGUuX19rZXksIGFuY2hvck9mZnNldCwgJ3RleHQnKTtcbiAgICB0aGlzLmZvY3VzLnNldChmb2N1c05vZGUuX19rZXksIGZvY3VzT2Zmc2V0LCAndGV4dCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIChwbGFpbikgdGV4dCBjb250ZW50IG9mIGFsbCB0aGUgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0ZXh0IGNvbnRlbnQgb2YgYWxsIHRoZSBub2RlcyBpbiB0aGUgU2VsZWN0aW9uXG4gICAqL1xuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0Tm9kZSA9IG5vZGVzWzBdO1xuICAgIGNvbnN0IGxhc3ROb2RlID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IGlzQmVmb3JlID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKTtcbiAgICBjb25zdCBbYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldF0gPSAkZ2V0Q2hhcmFjdGVyT2Zmc2V0cyh0aGlzKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBsZXQgcHJldldhc0VsZW1lbnQgPSB0cnVlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIGlmICghcHJldldhc0VsZW1lbnQpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudCArPSAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBwcmV2V2FzRWxlbWVudCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZXYXNFbGVtZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldldhc0VsZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgbGV0IHRleHQgPSBub2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgaWYgKG5vZGUgPT09IGZpcnN0Tm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IGxhc3ROb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChhbmNob3IudHlwZSAhPT0gJ2VsZW1lbnQnIHx8IGZvY3VzLnR5cGUgIT09ICdlbGVtZW50JyB8fCBmb2N1cy5vZmZzZXQgPT09IGFuY2hvci5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gYW5jaG9yT2Zmc2V0IDwgZm9jdXNPZmZzZXQgPyB0ZXh0LnNsaWNlKGFuY2hvck9mZnNldCwgZm9jdXNPZmZzZXQpIDogdGV4dC5zbGljZShmb2N1c09mZnNldCwgYW5jaG9yT2Zmc2V0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGV4dCA9IGlzQmVmb3JlID8gdGV4dC5zbGljZShhbmNob3JPZmZzZXQpIDogdGV4dC5zbGljZShmb2N1c09mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlID09PSBsYXN0Tm9kZSkge1xuICAgICAgICAgICAgdGV4dCA9IGlzQmVmb3JlID8gdGV4dC5zbGljZSgwLCBmb2N1c09mZnNldCkgOiB0ZXh0LnNsaWNlKDAsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRDb250ZW50ICs9IHRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoKCRpc0RlY29yYXRvck5vZGUobm9kZSkgfHwgJGlzTGluZUJyZWFrTm9kZShub2RlKSkgJiYgKG5vZGUgIT09IGxhc3ROb2RlIHx8ICF0aGlzLmlzQ29sbGFwc2VkKCkpKSB7XG4gICAgICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0Q29udGVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBtYXAgYSBET00gc2VsZWN0aW9uIHJhbmdlIG9udG8gdGhpcyBMZXhpY2FsIFNlbGVjdGlvbixcbiAgICogc2V0dGluZyB0aGUgYW5jaG9yLCBmb2N1cywgYW5kIHR5cGUgYWNjb3JkaW5nbHlcbiAgICpcbiAgICogQHBhcmFtIHJhbmdlIGEgRE9NIFNlbGVjdGlvbiByYW5nZSBjb25mb3JtaW5nIHRvIHRoZSBTdGF0aWNSYW5nZSBpbnRlcmZhY2UuXG4gICAqL1xuICBhcHBseURPTVJhbmdlKHJhbmdlKSB7XG4gICAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gICAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCk7XG4gICAgY29uc3QgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICAgIGNvbnN0IHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzID0gJGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50cyhyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQsIHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0LCBlZGl0b3IsIGxhc3RTZWxlY3Rpb24pO1xuICAgIGlmIChyZXNvbHZlZFNlbGVjdGlvblBvaW50cyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbYW5jaG9yUG9pbnQsIGZvY3VzUG9pbnRdID0gcmVzb2x2ZWRTZWxlY3Rpb25Qb2ludHM7XG4gICAgdGhpcy5hbmNob3Iuc2V0KGFuY2hvclBvaW50LmtleSwgYW5jaG9yUG9pbnQub2Zmc2V0LCBhbmNob3JQb2ludC50eXBlLCB0cnVlKTtcbiAgICB0aGlzLmZvY3VzLnNldChmb2N1c1BvaW50LmtleSwgZm9jdXNQb2ludC5vZmZzZXQsIGZvY3VzUG9pbnQudHlwZSwgdHJ1ZSk7XG4gICAgLy8gRmlyZWZveCB3aWxsIHVzZSBhbiBlbGVtZW50IHBvaW50IHJhdGhlciB0aGFuIGEgdGV4dCBwb2ludCBpbiBzb21lIGNhc2VzLFxuICAgIC8vIHNvIHdlIG5vcm1hbGl6ZSBmb3IgdGhhdFxuICAgICRub3JtYWxpemVTZWxlY3Rpb24odGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSYW5nZVNlbGVjdGlvbiwgY29weWluZyBvdmVyIGFsbCB0aGUgcHJvcGVydHkgdmFsdWVzIGZyb20gdGhpcyBvbmUuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgbmV3IFJhbmdlU2VsZWN0aW9uIHdpdGggdGhlIHNhbWUgcHJvcGVydHkgdmFsdWVzIGFzIHRoaXMgb25lLlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBSYW5nZVNlbGVjdGlvbigkY3JlYXRlUG9pbnQoYW5jaG9yLmtleSwgYW5jaG9yLm9mZnNldCwgYW5jaG9yLnR5cGUpLCAkY3JlYXRlUG9pbnQoZm9jdXMua2V5LCBmb2N1cy5vZmZzZXQsIGZvY3VzLnR5cGUpLCB0aGlzLmZvcm1hdCwgdGhpcy5zdHlsZSk7XG4gICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBwcm92aWRlZCBmb3JtYXQgb24gYWxsIHRoZSBUZXh0Tm9kZXMgaW4gdGhlIFNlbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGZvcm1hdCBhIHN0cmluZyBUZXh0Rm9ybWF0VHlwZSB0byB0b2dnbGUgb24gdGhlIFRleHROb2RlcyBpbiB0aGUgc2VsZWN0aW9uXG4gICAqL1xuICB0b2dnbGVGb3JtYXQoZm9ybWF0KSB7XG4gICAgdGhpcy5mb3JtYXQgPSB0b2dnbGVUZXh0Rm9ybWF0VHlwZSh0aGlzLmZvcm1hdCwgZm9ybWF0LCBudWxsKTtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgZm9ybWF0IHByb3BlcnR5IG9uIHRoZSBTZWxlY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGZvcm1hdCAtIHRoZSBmb3JtYXQgdG8gc2V0IGF0IHRoZSB2YWx1ZSBvZiB0aGUgZm9ybWF0IHByb3BlcnR5LlxuICAgKi9cbiAgc2V0Rm9ybWF0KGZvcm1hdCkge1xuICAgIHRoaXMuZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiB0aGUgU2VsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBzdHlsZSAtIHRoZSBzdHlsZSB0byBzZXQgYXQgdGhlIHZhbHVlIG9mIHRoZSBzdHlsZSBwcm9wZXJ0eS5cbiAgICovXG4gIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgVGV4dEZvcm1hdFR5cGUgaXMgcHJlc2VudCBvbiB0aGUgU2VsZWN0aW9uLiBUaGlzIHdpbGwgYmUgdHJ1ZSBpZiBhbnkgbm9kZSBpbiB0aGUgU2VsZWN0aW9uXG4gICAqIGhhcyB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIFRleHRGb3JtYXRUeXBlIHRvIGNoZWNrIGZvci5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgZm9ybWF0IGlzIGN1cnJlbnRseSB0b2dnbGVkIG9uIG9uIHRoZSBTZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc0Zvcm1hdCh0eXBlKSB7XG4gICAgY29uc3QgZm9ybWF0RmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgcmV0dXJuICh0aGlzLmZvcm1hdCAmIGZvcm1hdEZsYWcpICE9PSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRzIHRvIGluc2VydCB0aGUgcHJvdmlkZWQgdGV4dCBpbnRvIHRoZSBFZGl0b3JTdGF0ZSBhdCB0aGUgY3VycmVudCBTZWxlY3Rpb24uXG4gICAqIGNvbnZlcnRzIHRhYnMsIG5ld2xpbmVzLCBhbmQgY2FycmlhZ2UgcmV0dXJucyBpbnRvIExleGljYWxOb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIHRleHQgdGhlIHRleHQgdG8gaW5zZXJ0IGludG8gdGhlIFNlbGVjdGlvblxuICAgKi9cbiAgaW5zZXJ0UmF3VGV4dCh0ZXh0KSB7XG4gICAgY29uc3QgcGFydHMgPSB0ZXh0LnNwbGl0KC8oXFxyP1xcbnxcXHQpLyk7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKHBhcnQgPT09ICdcXG4nIHx8IHBhcnQgPT09ICdcXHJcXG4nKSB7XG4gICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZUxpbmVCcmVha05vZGUoKSk7XG4gICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICdcXHQnKSB7XG4gICAgICAgIG5vZGVzLnB1c2goJGNyZWF0ZVRhYk5vZGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2Rlcy5wdXNoKCRjcmVhdGVUZXh0Tm9kZShwYXJ0KSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaW5zZXJ0Tm9kZXMobm9kZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCB0aGUgcHJvdmlkZWQgdGV4dCBpbnRvIHRoZSBFZGl0b3JTdGF0ZSBhdCB0aGUgY3VycmVudCBTZWxlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB0ZXh0IHRoZSB0ZXh0IHRvIGluc2VydCBpbnRvIHRoZSBTZWxlY3Rpb25cbiAgICovXG4gIGluc2VydFRleHQodGV4dCkge1xuICAgIC8vIE5vdyB0aGF0IFwicmVtb3ZlVGV4dFwiIGhhcyBiZWVuIGltcHJvdmVkIGFuZCBkb2VzIG5vdCBkZXBlbmQgb25cbiAgICAvLyBpbnNlcnRUZXh0LCBpbnNlcnRUZXh0IGNhbiBiZSBncmVhdGx5IHNpbXBsaWZpZWQuIFRoZSBuZXh0XG4gICAgLy8gY29tbWVudGVkIHZlcnNpb24gaXMgYSBXSVAgKGFib3V0IDUgdGVzdHMgZmFpbCkuXG4gICAgLy9cbiAgICAvLyB0aGlzLnJlbW92ZVRleHQoKTtcbiAgICAvLyBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAvLyAgIHJldHVybjtcbiAgICAvLyB9XG4gICAgLy8gY29uc3QgYW5jaG9yTm9kZSA9IHRoaXMuYW5jaG9yLmdldE5vZGUoKTtcbiAgICAvLyBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAvLyB0ZXh0Tm9kZS5zZXRGb3JtYXQodGhpcy5mb3JtYXQpO1xuICAgIC8vIHRleHROb2RlLnNldFN0eWxlKHRoaXMuc3R5bGUpO1xuICAgIC8vIGlmICgkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgIC8vICAgY29uc3QgcGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgLy8gICBpZiAodGhpcy5hbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgLy8gICAgIGlmIChwYXJlbnQuaXNJbmxpbmUoKSAmJiAhYW5jaG9yTm9kZS5fX3ByZXYpIHtcbiAgICAvLyAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRleHROb2RlKTtcbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICBhbmNob3JOb2RlLmluc2VydEJlZm9yZSh0ZXh0Tm9kZSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH0gZWxzZSBpZiAodGhpcy5hbmNob3Iub2Zmc2V0ID09PSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgLy8gICAgIGlmIChwYXJlbnQuaXNJbmxpbmUoKSAmJiAhYW5jaG9yTm9kZS5fX25leHQpIHtcbiAgICAvLyAgICAgICBwYXJlbnQuaW5zZXJ0QWZ0ZXIodGV4dE5vZGUpO1xuICAgIC8vICAgICB9IGVsc2Uge1xuICAgIC8vICAgICAgIGFuY2hvck5vZGUuaW5zZXJ0QWZ0ZXIodGV4dE5vZGUpO1xuICAgIC8vICAgICB9XG4gICAgLy8gICB9IGVsc2Uge1xuICAgIC8vICAgICBjb25zdCBbYmVmb3JlXSA9IGFuY2hvck5vZGUuc3BsaXRUZXh0KHRoaXMuYW5jaG9yLm9mZnNldCk7XG4gICAgLy8gICAgIGJlZm9yZS5pbnNlcnRBZnRlcih0ZXh0Tm9kZSk7XG4gICAgLy8gICB9XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgIGFuY2hvck5vZGUuc3BsaWNlKHRoaXMuYW5jaG9yLm9mZnNldCwgMCwgW3RleHROb2RlXSk7XG4gICAgLy8gfVxuICAgIC8vIGNvbnN0IG5vZGVUb1NlbGVjdCA9IHRleHROb2RlLmlzQXR0YWNoZWQoKSA/IHRleHROb2RlIDogYW5jaG9yTm9kZTtcbiAgICAvLyBub2RlVG9TZWxlY3Quc2VsZWN0RW5kKCk7XG4gICAgLy8gLy8gV2hlbiBjb21wb3NpbmcsIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBhbmNob3Igb2Zmc2V0IHNvIHRoYXRcbiAgICAvLyAvLyB3ZSBjb3JyZWN0bHkgcmVwbGFjZSB0aGF0IHJpZ2h0IHJhbmdlLlxuICAgIC8vIGlmIChcbiAgICAvLyAgIHRleHROb2RlLmlzQ29tcG9zaW5nKCkgJiZcbiAgICAvLyAgIHRoaXMuYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJlxuICAgIC8vICAgYW5jaG9yTm9kZS5nZXRUZXh0Q29udGVudCgpICE9PSAnJ1xuICAgIC8vICkge1xuICAgIC8vICAgdGhpcy5hbmNob3Iub2Zmc2V0IC09IHRleHQubGVuZ3RoO1xuICAgIC8vIH1cblxuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cztcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmZvcm1hdDtcbiAgICBjb25zdCBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgbGV0IGZpcnN0UG9pbnQgPSBhbmNob3I7XG4gICAgbGV0IGVuZFBvaW50ID0gZm9jdXM7XG4gICAgaWYgKCF0aGlzLmlzQ29sbGFwc2VkKCkgJiYgZm9jdXMuaXNCZWZvcmUoYW5jaG9yKSkge1xuICAgICAgZmlyc3RQb2ludCA9IGZvY3VzO1xuICAgICAgZW5kUG9pbnQgPSBhbmNob3I7XG4gICAgfVxuICAgIGlmIChmaXJzdFBvaW50LnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgJHRyYW5zZmVyU3RhcnRpbmdFbGVtZW50UG9pbnRUb1RleHRQb2ludChmaXJzdFBvaW50LCBlbmRQb2ludCwgZm9ybWF0LCBzdHlsZSk7XG4gICAgfVxuICAgIGlmIChlbmRQb2ludC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgICRzZXRQb2ludEZyb21DYXJldChlbmRQb2ludCwgJG5vcm1hbGl6ZUNhcmV0KCRjYXJldEZyb21Qb2ludChlbmRQb2ludCwgJ25leHQnKSkpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydE9mZnNldCA9IGZpcnN0UG9pbnQub2Zmc2V0O1xuICAgIGxldCBlbmRPZmZzZXQgPSBlbmRQb2ludC5vZmZzZXQ7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzTGVuZ3RoID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGg7XG4gICAgbGV0IGZpcnN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbMF07XG4gICAgaWYgKCEkaXNUZXh0Tm9kZShmaXJzdE5vZGUpKSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgaW5zZXJ0VGV4dDogZmlyc3Qgbm9kZSBpcyBub3QgYSB0ZXh0IG5vZGVgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZmlyc3ROb2RlVGV4dCA9IGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IGZpcnN0Tm9kZVRleHRMZW5ndGggPSBmaXJzdE5vZGVUZXh0Lmxlbmd0aDtcbiAgICBjb25zdCBmaXJzdE5vZGVQYXJlbnQgPSBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IHNlbGVjdGVkTm9kZXNMZW5ndGggLSAxO1xuICAgIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbbGFzdEluZGV4XTtcbiAgICBpZiAoc2VsZWN0ZWROb2Rlc0xlbmd0aCA9PT0gMSAmJiBlbmRQb2ludC50eXBlID09PSAnZWxlbWVudCcpIHtcbiAgICAgIGVuZE9mZnNldCA9IGZpcnN0Tm9kZVRleHRMZW5ndGg7XG4gICAgICBlbmRQb2ludC5zZXQoZmlyc3RQb2ludC5rZXksIGVuZE9mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb2xsYXBzZWQoKSAmJiBzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlVGV4dExlbmd0aCAmJiAoJGlzVG9rZW5PclNlZ21lbnRlZChmaXJzdE5vZGUpIHx8ICFmaXJzdE5vZGUuY2FuSW5zZXJ0VGV4dEFmdGVyKCkgfHwgIWZpcnN0Tm9kZVBhcmVudC5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSAmJiBmaXJzdE5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA9PT0gbnVsbCkpIHtcbiAgICAgIGxldCBuZXh0U2libGluZyA9IGZpcnN0Tm9kZS5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKCEkaXNUZXh0Tm9kZShuZXh0U2libGluZykgfHwgIW5leHRTaWJsaW5nLmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAkaXNUb2tlbk9yU2VnbWVudGVkKG5leHRTaWJsaW5nKSkge1xuICAgICAgICBuZXh0U2libGluZyA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICBuZXh0U2libGluZy5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgbmV4dFNpYmxpbmcuc2V0U3R5bGUoc3R5bGUpO1xuICAgICAgICBpZiAoIWZpcnN0Tm9kZVBhcmVudC5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSkge1xuICAgICAgICAgIGZpcnN0Tm9kZVBhcmVudC5pbnNlcnRBZnRlcihuZXh0U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3ROb2RlLmluc2VydEFmdGVyKG5leHRTaWJsaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dFNpYmxpbmcuc2VsZWN0KDAsIDApO1xuICAgICAgZmlyc3ROb2RlID0gbmV4dFNpYmxpbmc7XG4gICAgICBpZiAodGV4dCAhPT0gJycpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KHRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkgJiYgc3RhcnRPZmZzZXQgPT09IDAgJiYgKCRpc1Rva2VuT3JTZWdtZW50ZWQoZmlyc3ROb2RlKSB8fCAhZmlyc3ROb2RlLmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSAmJiBmaXJzdE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpKSB7XG4gICAgICBsZXQgcHJldlNpYmxpbmcgPSBmaXJzdE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoISRpc1RleHROb2RlKHByZXZTaWJsaW5nKSB8fCAkaXNUb2tlbk9yU2VnbWVudGVkKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBwcmV2U2libGluZyA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICBwcmV2U2libGluZy5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgaWYgKCFmaXJzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpKSB7XG4gICAgICAgICAgZmlyc3ROb2RlUGFyZW50Lmluc2VydEJlZm9yZShwcmV2U2libGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlyc3ROb2RlLmluc2VydEJlZm9yZShwcmV2U2libGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZXZTaWJsaW5nLnNlbGVjdCgpO1xuICAgICAgZmlyc3ROb2RlID0gcHJldlNpYmxpbmc7XG4gICAgICBpZiAodGV4dCAhPT0gJycpIHtcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KHRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaXJzdE5vZGUuaXNTZWdtZW50ZWQoKSAmJiBzdGFydE9mZnNldCAhPT0gZmlyc3ROb2RlVGV4dExlbmd0aCkge1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUoZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCkpO1xuICAgICAgdGV4dE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICBmaXJzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICBmaXJzdE5vZGUgPSB0ZXh0Tm9kZTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzQ29sbGFwc2VkKCkgJiYgdGV4dCAhPT0gJycpIHtcbiAgICAgIC8vIFdoZW4gdGhlIGZpcnN0Tm9kZSBvciBsYXN0Tm9kZSBwYXJlbnRzIGFyZSBlbGVtZW50cyB0aGF0XG4gICAgICAvLyBkbyBub3QgYWxsb3cgdGV4dCB0byBiZSBpbnNlcnRlZCBiZWZvcmUgb3IgYWZ0ZXIsIHdlIGZpcnN0XG4gICAgICAvLyBjbGVhciB0aGUgY29udGVudC4gVGhlbiB3ZSBub3JtYWxpemUgc2VsZWN0aW9uLCB0aGVuIGluc2VydFxuICAgICAgLy8gdGhlIG5ldyBjb250ZW50LlxuICAgICAgY29uc3QgbGFzdE5vZGVQYXJlbnQgPSBsYXN0Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICghZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhZmlyc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpIHx8ICRpc0VsZW1lbnROb2RlKGxhc3ROb2RlUGFyZW50KSAmJiAoIWxhc3ROb2RlUGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhbGFzdE5vZGVQYXJlbnQuY2FuSW5zZXJ0VGV4dEFmdGVyKCkpKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dCgnJyk7XG4gICAgICAgICRub3JtYWxpemVTZWxlY3Rpb25Qb2ludHNGb3JCb3VuZGFyaWVzKHRoaXMuYW5jaG9yLCB0aGlzLmZvY3VzLCBudWxsKTtcbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KHRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzZWxlY3RlZE5vZGVzTGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoJGlzVG9rZW5PclRhYihmaXJzdE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICB0ZXh0Tm9kZS5zZWxlY3QoKTtcbiAgICAgICAgZmlyc3ROb2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBmaXJzdE5vZGVGb3JtYXQgPSBmaXJzdE5vZGUuZ2V0Rm9ybWF0KCk7XG4gICAgICBjb25zdCBmaXJzdE5vZGVTdHlsZSA9IGZpcnN0Tm9kZS5nZXRTdHlsZSgpO1xuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBlbmRPZmZzZXQgJiYgKGZpcnN0Tm9kZUZvcm1hdCAhPT0gZm9ybWF0IHx8IGZpcnN0Tm9kZVN0eWxlICE9PSBzdHlsZSkpIHtcbiAgICAgICAgaWYgKGZpcnN0Tm9kZS5nZXRUZXh0Q29udGVudCgpID09PSAnJykge1xuICAgICAgICAgIGZpcnN0Tm9kZS5zZXRGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICBmaXJzdE5vZGUuc2V0U3R5bGUoc3R5bGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHRleHQpO1xuICAgICAgICAgIHRleHROb2RlLnNldEZvcm1hdChmb3JtYXQpO1xuICAgICAgICAgIHRleHROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgICB0ZXh0Tm9kZS5zZWxlY3QoKTtcbiAgICAgICAgICBpZiAoc3RhcnRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIGZpcnN0Tm9kZS5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIGZhbHNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgW3RhcmdldE5vZGVdID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCk7XG4gICAgICAgICAgICB0YXJnZXROb2RlLmluc2VydEFmdGVyKHRleHROb2RlLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFdoZW4gY29tcG9zaW5nLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYW5jaG9yIG9mZnNldCBzbyB0aGF0XG4gICAgICAgICAgLy8gd2UgY29ycmVjdGx5IHJlcGxhY2UgdGhhdCByaWdodCByYW5nZS5cbiAgICAgICAgICBpZiAodGV4dE5vZGUuaXNDb21wb3NpbmcoKSAmJiB0aGlzLmFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yLm9mZnNldCAtPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCRpc1RhYk5vZGUoZmlyc3ROb2RlKSkge1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNoZWNrIGZvciBkZWxDb3VudCBiZWNhdXNlIHRoZXJlIGlzIG9ubHkgdGhlIGVudGlyZSBzZWxlY3RlZCBub2RlIGNhc2VcbiAgICAgICAgLy8gdGhhdCBjYW4gaGl0IGhlcmUgZm9yIGNvbnRlbnQgc2l6ZSAxIGFuZCB3aXRoIGNhbkluc2VydFRleHRCZWZvcmVBZnRlciBmYWxzZVxuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgdGV4dE5vZGUuc2V0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIHRleHROb2RlLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgdGV4dE5vZGUuc2VsZWN0KCk7XG4gICAgICAgIGZpcnN0Tm9kZS5yZXBsYWNlKHRleHROb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGVsQ291bnQgPSBlbmRPZmZzZXQgLSBzdGFydE9mZnNldDtcbiAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5zcGxpY2VUZXh0KHN0YXJ0T2Zmc2V0LCBkZWxDb3VudCwgdGV4dCwgdHJ1ZSk7XG4gICAgICBpZiAoZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB7XG4gICAgICAgIGZpcnN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGlmIChmaXJzdE5vZGUuaXNDb21wb3NpbmcoKSkge1xuICAgICAgICAgIC8vIFdoZW4gY29tcG9zaW5nLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYW5jaG9yIG9mZnNldCBzbyB0aGF0XG4gICAgICAgICAgLy8gd2UgY29ycmVjdGx5IHJlcGxhY2UgdGhhdCByaWdodCByYW5nZS5cbiAgICAgICAgICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mb3JtYXQgPSBmaXJzdE5vZGVGb3JtYXQ7XG4gICAgICAgICAgdGhpcy5zdHlsZSA9IGZpcnN0Tm9kZVN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1hcmtlZE5vZGVLZXlzRm9yS2VlcCA9IG5ldyBTZXQoWy4uLmZpcnN0Tm9kZS5nZXRQYXJlbnRLZXlzKCksIC4uLmxhc3ROb2RlLmdldFBhcmVudEtleXMoKV0pO1xuXG4gICAgICAvLyBXZSBoYXZlIHRvIGdldCB0aGUgcGFyZW50IGVsZW1lbnRzIGJlZm9yZSB0aGUgbmV4dCBzZWN0aW9uLFxuICAgICAgLy8gYXMgaW4gdGhhdCBzZWN0aW9uIHdlIG1pZ2h0IG11dGF0ZSB0aGUgbGFzdE5vZGUuXG4gICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSAkaXNFbGVtZW50Tm9kZShmaXJzdE5vZGUpID8gZmlyc3ROb2RlIDogZmlyc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBsYXN0RWxlbWVudCA9ICRpc0VsZW1lbnROb2RlKGxhc3ROb2RlKSA/IGxhc3ROb2RlIDogbGFzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgbGV0IGxhc3RFbGVtZW50Q2hpbGQgPSBsYXN0Tm9kZTtcblxuICAgICAgLy8gSWYgdGhlIGxhc3QgZWxlbWVudCBpcyBpbmxpbmUsIHdlIHNob3VsZCBpbnN0ZWFkIGxvb2sgYXQgZ2V0dGluZ1xuICAgICAgLy8gdGhlIG5vZGVzIG9mIGl0cyBwYXJlbnQsIHJhdGhlciB0aGFuIGl0c2VsZi4gVGhpcyBiZWhhdmlvciB3aWxsXG4gICAgICAvLyB0aGVuIGJldHRlciBtYXRjaCBob3cgdGV4dCBub2RlIGluc2VydGlvbnMgd29yay4gV2Ugd2lsbCBuZWVkIHRvXG4gICAgICAvLyBhbHNvIHVwZGF0ZSB0aGUgbGFzdCBlbGVtZW50J3MgY2hpbGQgYWNjb3JkaW5nbHkgYXMgd2UgZG8gdGhpcy5cbiAgICAgIGlmICghZmlyc3RFbGVtZW50LmlzKGxhc3RFbGVtZW50KSAmJiBsYXN0RWxlbWVudC5pc0lubGluZSgpKSB7XG4gICAgICAgIC8vIEtlZXAgdHJhdmVyc2luZyB0aWxsIHdlIGhhdmUgYSBub24taW5saW5lIGVsZW1lbnQgcGFyZW50LlxuICAgICAgICBkbyB7XG4gICAgICAgICAgbGFzdEVsZW1lbnRDaGlsZCA9IGxhc3RFbGVtZW50O1xuICAgICAgICAgIGxhc3RFbGVtZW50ID0gbGFzdEVsZW1lbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgICB9IHdoaWxlIChsYXN0RWxlbWVudC5pc0lubGluZSgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIG11dGF0aW9ucyB0byB0aGUgbGFzdCBub2RlLlxuICAgICAgaWYgKGVuZFBvaW50LnR5cGUgPT09ICd0ZXh0JyAmJiAoZW5kT2Zmc2V0ICE9PSAwIHx8IGxhc3ROb2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB8fCBlbmRQb2ludC50eXBlID09PSAnZWxlbWVudCcgJiYgbGFzdE5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSA8IGVuZE9mZnNldCkge1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUobGFzdE5vZGUpICYmICEkaXNUb2tlbk9yVGFiKGxhc3ROb2RlKSAmJiBlbmRPZmZzZXQgIT09IGxhc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICAgICAgaWYgKGxhc3ROb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKGxhc3ROb2RlLmdldFRleHRDb250ZW50KCkpO1xuICAgICAgICAgICAgbGFzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgICBsYXN0Tm9kZSA9IHRleHROb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByb290IG5vZGUgc2VsZWN0aW9ucyBvbmx5IHNlbGVjdCB3aG9sZSBub2Rlcywgc28gbm8gdGV4dCBzcGxpY2UgaXMgbmVjZXNzYXJ5XG4gICAgICAgICAgaWYgKCEkaXNSb290Tm9kZShlbmRQb2ludC5nZXROb2RlKCkpICYmIGVuZFBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgbGFzdE5vZGUgPSBsYXN0Tm9kZS5zcGxpY2VUZXh0KDAsIGVuZE9mZnNldCwgJycpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtYXJrZWROb2RlS2V5c0ZvcktlZXAuYWRkKGxhc3ROb2RlLl9fa2V5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBsYXN0Tm9kZVBhcmVudCA9IGxhc3ROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgICBpZiAoIWxhc3ROb2RlUGFyZW50LmNhbkJlRW1wdHkoKSAmJiBsYXN0Tm9kZVBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgICAgICAgbGFzdE5vZGVQYXJlbnQucmVtb3ZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFya2VkTm9kZUtleXNGb3JLZWVwLmFkZChsYXN0Tm9kZS5fX2tleSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEVpdGhlciBtb3ZlIHRoZSByZW1haW5pbmcgbm9kZXMgb2YgdGhlIGxhc3QgcGFyZW50IHRvIGFmdGVyXG4gICAgICAvLyB0aGUgZmlyc3QgY2hpbGQsIG9yIHJlbW92ZSB0aGVtIGVudGlyZWx5LiBJZiB0aGUgbGFzdCBwYXJlbnRcbiAgICAgIC8vIGlzIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCBwYXJlbnQsIHRoaXMgbG9naWMgYWxzbyB3b3Jrcy5cbiAgICAgIGNvbnN0IGxhc3ROb2RlQ2hpbGRyZW4gPSBsYXN0RWxlbWVudC5nZXRDaGlsZHJlbigpO1xuICAgICAgY29uc3Qgc2VsZWN0ZWROb2Rlc1NldCA9IG5ldyBTZXQoc2VsZWN0ZWROb2Rlcyk7XG4gICAgICBjb25zdCBmaXJzdEFuZExhc3RFbGVtZW50c0FyZUVxdWFsID0gZmlyc3RFbGVtZW50LmlzKGxhc3RFbGVtZW50KTtcblxuICAgICAgLy8gV2UgY2hvb3NlIGEgdGFyZ2V0IHRvIGluc2VydCBhbGwgbm9kZXMgYWZ0ZXIuIEluIHRoZSBjYXNlIG9mIGhhdmluZ1xuICAgICAgLy8gYW5kIGlubGluZSBzdGFydGluZyBwYXJlbnQgZWxlbWVudCB3aXRoIGEgc3RhcnRpbmcgbm9kZSB0aGF0IGhhcyBub1xuICAgICAgLy8gc2libGluZ3MsIHdlIHNob3VsZCBpbnNlcnQgYWZ0ZXIgdGhlIHN0YXJ0aW5nIHBhcmVudCBlbGVtZW50LCBvdGhlcndpc2VcbiAgICAgIC8vIHdlIHdpbGwgaW5jb3JyZWN0bHkgbWVyZ2UgaW50byB0aGUgc3RhcnRpbmcgcGFyZW50IGVsZW1lbnQuXG4gICAgICAvLyBUT0RPOiBzaG91bGQgd2Uga2VlcCBvbiB0cmF2ZXJzaW5nIHBhcmVudHMgaWYgd2UncmUgaW5zaWRlIGFub3RoZXJcbiAgICAgIC8vIG5lc3RlZCBpbmxpbmUgZWxlbWVudD9cbiAgICAgIGNvbnN0IGluc2VydGlvblRhcmdldCA9IGZpcnN0RWxlbWVudC5pc0lubGluZSgpICYmIGZpcnN0Tm9kZS5nZXROZXh0U2libGluZygpID09PSBudWxsID8gZmlyc3RFbGVtZW50IDogZmlyc3ROb2RlO1xuICAgICAgZm9yIChsZXQgaSA9IGxhc3ROb2RlQ2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgbGFzdE5vZGVDaGlsZCA9IGxhc3ROb2RlQ2hpbGRyZW5baV07XG4gICAgICAgIGlmIChsYXN0Tm9kZUNoaWxkLmlzKGZpcnN0Tm9kZSkgfHwgJGlzRWxlbWVudE5vZGUobGFzdE5vZGVDaGlsZCkgJiYgbGFzdE5vZGVDaGlsZC5pc1BhcmVudE9mKGZpcnN0Tm9kZSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGFzdE5vZGVDaGlsZC5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICBpZiAoIXNlbGVjdGVkTm9kZXNTZXQuaGFzKGxhc3ROb2RlQ2hpbGQpIHx8IGxhc3ROb2RlQ2hpbGQuaXMobGFzdEVsZW1lbnRDaGlsZCkpIHtcbiAgICAgICAgICAgIGlmICghZmlyc3RBbmRMYXN0RWxlbWVudHNBcmVFcXVhbCkge1xuICAgICAgICAgICAgICBpbnNlcnRpb25UYXJnZXQuaW5zZXJ0QWZ0ZXIobGFzdE5vZGVDaGlsZCwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0Tm9kZUNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFmaXJzdEFuZExhc3RFbGVtZW50c0FyZUVxdWFsKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYWxyZWFkeSBtb3ZlZCBvdXQgYWxsIHRoZSBub2RlcyBvZiB0aGVcbiAgICAgICAgLy8gbGFzdCBwYXJlbnQsIGFuZCBpZiBzbywgdHJhdmVyc2UgdGhlIHBhcmVudCB0cmVlIGFuZCBtYXJrXG4gICAgICAgIC8vIHRoZW0gYWxsIGFzIGJlaW5nIGFibGUgdG8gZGVsZXRlZCB0b28uXG4gICAgICAgIGxldCBwYXJlbnQgPSBsYXN0RWxlbWVudDtcbiAgICAgICAgbGV0IGxhc3RSZW1vdmVkUGFyZW50ID0gbnVsbDtcbiAgICAgICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmdldENoaWxkcmVuKCk7XG4gICAgICAgICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAwIHx8IGNoaWxkcmVuW2NoaWxkcmVuTGVuZ3RoIC0gMV0uaXMobGFzdFJlbW92ZWRQYXJlbnQpKSB7XG4gICAgICAgICAgICBtYXJrZWROb2RlS2V5c0ZvcktlZXAuZGVsZXRlKHBhcmVudC5fX2tleSk7XG4gICAgICAgICAgICBsYXN0UmVtb3ZlZFBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEVuc3VyZSB3ZSBkbyBzcGxpY2luZyBhZnRlciBtb3Zpbmcgb2Ygbm9kZXMsIGFzIHNwbGljaW5nXG4gICAgICAvLyBjYW4gaGF2ZSBzaWRlLWVmZmVjdHMgKGluIHRoZSBjYXNlIG9mIGhhc2h0YWdzKS5cbiAgICAgIGlmICghJGlzVG9rZW5PclRhYihmaXJzdE5vZGUpKSB7XG4gICAgICAgIGZpcnN0Tm9kZSA9IGZpcnN0Tm9kZS5zcGxpY2VUZXh0KHN0YXJ0T2Zmc2V0LCBmaXJzdE5vZGVUZXh0TGVuZ3RoIC0gc3RhcnRPZmZzZXQsIHRleHQsIHRydWUpO1xuICAgICAgICBpZiAoZmlyc3ROb2RlLmdldFRleHRDb250ZW50KCkgPT09ICcnKSB7XG4gICAgICAgICAgZmlyc3ROb2RlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0Tm9kZS5pc0NvbXBvc2luZygpICYmIHRoaXMuYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIC8vIFdoZW4gY29tcG9zaW5nLCB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgYW5jaG9yIG9mZnNldCBzbyB0aGF0XG4gICAgICAgICAgLy8gd2UgY29ycmVjdGx5IHJlcGxhY2UgdGhhdCByaWdodCByYW5nZS5cbiAgICAgICAgICB0aGlzLmFuY2hvci5vZmZzZXQgLT0gdGV4dC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhcnRPZmZzZXQgPT09IGZpcnN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgZmlyc3ROb2RlLnNlbGVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdGV4dE5vZGUgPSAkY3JlYXRlVGV4dE5vZGUodGV4dCk7XG4gICAgICAgIHRleHROb2RlLnNlbGVjdCgpO1xuICAgICAgICBmaXJzdE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBhbGwgc2VsZWN0ZWQgbm9kZXMgdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiByZW1vdmVkLlxuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBzZWxlY3RlZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gc2VsZWN0ZWROb2Rlc1tpXTtcbiAgICAgICAgY29uc3Qga2V5ID0gc2VsZWN0ZWROb2RlLl9fa2V5O1xuICAgICAgICBpZiAoIW1hcmtlZE5vZGVLZXlzRm9yS2VlcC5oYXMoa2V5KSkge1xuICAgICAgICAgIHNlbGVjdGVkTm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSB0ZXh0IGluIHRoZSBTZWxlY3Rpb24sIGFkanVzdGluZyB0aGUgRWRpdG9yU3RhdGUgYWNjb3JkaW5nbHkuXG4gICAqL1xuICByZW1vdmVUZXh0KCkge1xuICAgIGNvbnN0IGlzQ3VycmVudFNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKSA9PT0gdGhpcztcbiAgICBjb25zdCBuZXdSYW5nZSA9ICRyZW1vdmVUZXh0RnJvbUNhcmV0UmFuZ2UoJGNhcmV0UmFuZ2VGcm9tU2VsZWN0aW9uKHRoaXMpKTtcbiAgICAkdXBkYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tQ2FyZXRSYW5nZSh0aGlzLCBuZXdSYW5nZSk7XG4gICAgaWYgKGlzQ3VycmVudFNlbGVjdGlvbiAmJiAkZ2V0U2VsZWN0aW9uKCkgIT09IHRoaXMpIHtcbiAgICAgICRzZXRTZWxlY3Rpb24odGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gVE8tRE86IE1pZ3JhdGUgdGhpcyBtZXRob2QgdG8gdGhlIG5ldyB1dGlsaXR5IGZ1bmN0aW9uICRmb3JFYWNoU2VsZWN0ZWRUZXh0Tm9kZSAoc2hhcmUgc2ltaWxhciBsb2dpYylcbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIGZvcm1hdCB0byB0aGUgVGV4dE5vZGVzIGluIHRoZSBTZWxlY3Rpb24sIHNwbGl0dGluZyBvclxuICAgKiBtZXJnaW5nIG5vZGVzIGFzIG5lY2Vzc2FyeS5cbiAgICpcbiAgICogQHBhcmFtIGZvcm1hdFR5cGUgdGhlIGZvcm1hdCB0eXBlIHRvIGFwcGx5IHRvIHRoZSBub2RlcyBpbiB0aGUgU2VsZWN0aW9uLlxuICAgKiBAcGFyYW0gYWxpZ25XaXRoRm9ybWF0IGEgMzItYml0IGludGVnZXIgcmVwcmVzZW50aW5nIGZvcm1hdHRpbmcgZmxhZ3MgdG8gYWxpZ24gd2l0aC5cbiAgICovXG4gIGZvcm1hdFRleHQoZm9ybWF0VHlwZSwgYWxpZ25XaXRoRm9ybWF0ID0gbnVsbCkge1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIHRoaXMudG9nZ2xlRm9ybWF0KGZvcm1hdFR5cGUpO1xuICAgICAgLy8gV2hlbiBjaGFuZ2luZyBmb3JtYXQsIHdlIHNob3VsZCBzdG9wIGNvbXBvc2l0aW9uXG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSB0aGlzLmdldE5vZGVzKCk7XG4gICAgY29uc3Qgc2VsZWN0ZWRUZXh0Tm9kZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNlbGVjdGVkTm9kZSBvZiBzZWxlY3RlZE5vZGVzKSB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoc2VsZWN0ZWROb2RlKSkge1xuICAgICAgICBzZWxlY3RlZFRleHROb2Rlcy5wdXNoKHNlbGVjdGVkTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFwcGx5Rm9ybWF0VG9FbGVtZW50cyA9IGFsaWduV2l0aCA9PiB7XG4gICAgICBzZWxlY3RlZE5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICAgIGNvbnN0IG5ld0Zvcm1hdCA9IG5vZGUuZ2V0Rm9ybWF0RmxhZ3MoZm9ybWF0VHlwZSwgYWxpZ25XaXRoKTtcbiAgICAgICAgICBub2RlLnNldFRleHRGb3JtYXQobmV3Rm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZWxlY3RlZFRleHROb2Rlc0xlbmd0aCA9IHNlbGVjdGVkVGV4dE5vZGVzLmxlbmd0aDtcbiAgICBpZiAoc2VsZWN0ZWRUZXh0Tm9kZXNMZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMudG9nZ2xlRm9ybWF0KGZvcm1hdFR5cGUpO1xuICAgICAgLy8gV2hlbiBjaGFuZ2luZyBmb3JtYXQsIHdlIHNob3VsZCBzdG9wIGNvbXBvc2l0aW9uXG4gICAgICAkc2V0Q29tcG9zaXRpb25LZXkobnVsbCk7XG4gICAgICBhcHBseUZvcm1hdFRvRWxlbWVudHMoYWxpZ25XaXRoRm9ybWF0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yID0gdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IGlzQmFja3dhcmQgPSB0aGlzLmlzQmFja3dhcmQoKTtcbiAgICBjb25zdCBzdGFydFBvaW50ID0gaXNCYWNrd2FyZCA/IGZvY3VzIDogYW5jaG9yO1xuICAgIGNvbnN0IGVuZFBvaW50ID0gaXNCYWNrd2FyZCA/IGFuY2hvciA6IGZvY3VzO1xuICAgIGxldCBmaXJzdEluZGV4ID0gMDtcbiAgICBsZXQgZmlyc3ROb2RlID0gc2VsZWN0ZWRUZXh0Tm9kZXNbMF07XG4gICAgbGV0IHN0YXJ0T2Zmc2V0ID0gc3RhcnRQb2ludC50eXBlID09PSAnZWxlbWVudCcgPyAwIDogc3RhcnRQb2ludC5vZmZzZXQ7XG5cbiAgICAvLyBJbiBjYXNlIHNlbGVjdGlvbiBzdGFydGVkIGF0IHRoZSBlbmQgb2YgdGV4dCBub2RlIHVzZSBuZXh0IHRleHQgbm9kZVxuICAgIGlmIChzdGFydFBvaW50LnR5cGUgPT09ICd0ZXh0JyAmJiBzdGFydE9mZnNldCA9PT0gZmlyc3ROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBmaXJzdEluZGV4ID0gMTtcbiAgICAgIGZpcnN0Tm9kZSA9IHNlbGVjdGVkVGV4dE5vZGVzWzFdO1xuICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgIH1cbiAgICBpZiAoZmlyc3ROb2RlID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3ROZXh0Rm9ybWF0ID0gZmlyc3ROb2RlLmdldEZvcm1hdEZsYWdzKGZvcm1hdFR5cGUsIGFsaWduV2l0aEZvcm1hdCk7XG4gICAgYXBwbHlGb3JtYXRUb0VsZW1lbnRzKGZpcnN0TmV4dEZvcm1hdCk7XG4gICAgY29uc3QgbGFzdEluZGV4ID0gc2VsZWN0ZWRUZXh0Tm9kZXNMZW5ndGggLSAxO1xuICAgIGxldCBsYXN0Tm9kZSA9IHNlbGVjdGVkVGV4dE5vZGVzW2xhc3RJbmRleF07XG4gICAgY29uc3QgZW5kT2Zmc2V0ID0gZW5kUG9pbnQudHlwZSA9PT0gJ3RleHQnID8gZW5kUG9pbnQub2Zmc2V0IDogbGFzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG5cbiAgICAvLyBTaW5nbGUgbm9kZSBzZWxlY3RlZFxuICAgIGlmIChmaXJzdE5vZGUuaXMobGFzdE5vZGUpKSB7XG4gICAgICAvLyBObyBhY3R1YWwgdGV4dCBpcyBzZWxlY3RlZCwgc28gZG8gbm90aGluZy5cbiAgICAgIGlmIChzdGFydE9mZnNldCA9PT0gZW5kT2Zmc2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBlbnRpcmUgbm9kZSBpcyBzZWxlY3RlZCBvciBpdCBpcyB0b2tlbiwgc28ganVzdCBmb3JtYXQgaXRcbiAgICAgIGlmICgkaXNUb2tlbk9yU2VnbWVudGVkKGZpcnN0Tm9kZSkgfHwgc3RhcnRPZmZzZXQgPT09IDAgJiYgZW5kT2Zmc2V0ID09PSBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgICAgZmlyc3ROb2RlLnNldEZvcm1hdChmaXJzdE5leHRGb3JtYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0IGludG8gdHdvIG5vZGVzXG4gICAgICAgIC8vIGFkZCBzdHlsZSB0aGUgc2VsZWN0ZWQgb25lLlxuICAgICAgICBjb25zdCBzcGxpdE5vZGVzID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzdGFydE9mZnNldCA9PT0gMCA/IHNwbGl0Tm9kZXNbMF0gOiBzcGxpdE5vZGVzWzFdO1xuICAgICAgICByZXBsYWNlbWVudC5zZXRGb3JtYXQoZmlyc3ROZXh0Rm9ybWF0KTtcblxuICAgICAgICAvLyBVcGRhdGUgc2VsZWN0aW9uIG9ubHkgaWYgc3RhcnRzL2VuZHMgb24gdGV4dCBub2RlXG4gICAgICAgIGlmIChzdGFydFBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIHN0YXJ0UG9pbnQuc2V0KHJlcGxhY2VtZW50Ll9fa2V5LCAwLCAndGV4dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRQb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICBlbmRQb2ludC5zZXQocmVwbGFjZW1lbnQuX19rZXksIGVuZE9mZnNldCAtIHN0YXJ0T2Zmc2V0LCAndGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1hdCA9IGZpcnN0TmV4dEZvcm1hdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gTXVsdGlwbGUgbm9kZXMgc2VsZWN0ZWRcbiAgICAvLyBUaGUgZW50aXJlIGZpcnN0IG5vZGUgaXNuJ3Qgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0XG4gICAgaWYgKHN0YXJ0T2Zmc2V0ICE9PSAwICYmICEkaXNUb2tlbk9yU2VnbWVudGVkKGZpcnN0Tm9kZSkpIHtcbiAgICAgIFssIGZpcnN0Tm9kZV0gPSBmaXJzdE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0KTtcbiAgICAgIHN0YXJ0T2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZmlyc3ROb2RlLnNldEZvcm1hdChmaXJzdE5leHRGb3JtYXQpO1xuICAgIGNvbnN0IGxhc3ROZXh0Rm9ybWF0ID0gbGFzdE5vZGUuZ2V0Rm9ybWF0RmxhZ3MoZm9ybWF0VHlwZSwgZmlyc3ROZXh0Rm9ybWF0KTtcbiAgICAvLyBJZiB0aGUgb2Zmc2V0IGlzIDAsIGl0IG1lYW5zIG5vIGFjdHVhbCBjaGFyYWN0ZXJzIGFyZSBzZWxlY3RlZCxcbiAgICAvLyBzbyB3ZSBza2lwIGZvcm1hdHRpbmcgdGhlIGxhc3Qgbm9kZSBhbHRvZ2V0aGVyLlxuICAgIGlmIChlbmRPZmZzZXQgPiAwKSB7XG4gICAgICBpZiAoZW5kT2Zmc2V0ICE9PSBsYXN0Tm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSAmJiAhJGlzVG9rZW5PclNlZ21lbnRlZChsYXN0Tm9kZSkpIHtcbiAgICAgICAgW2xhc3ROb2RlXSA9IGxhc3ROb2RlLnNwbGl0VGV4dChlbmRPZmZzZXQpO1xuICAgICAgfVxuICAgICAgbGFzdE5vZGUuc2V0Rm9ybWF0KGxhc3ROZXh0Rm9ybWF0KTtcbiAgICB9XG5cbiAgICAvLyBQcm9jZXNzIGFsbCB0ZXh0IG5vZGVzIGluIGJldHdlZW5cbiAgICBmb3IgKGxldCBpID0gZmlyc3RJbmRleCArIDE7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgY29uc3QgdGV4dE5vZGUgPSBzZWxlY3RlZFRleHROb2Rlc1tpXTtcbiAgICAgIGNvbnN0IG5leHRGb3JtYXQgPSB0ZXh0Tm9kZS5nZXRGb3JtYXRGbGFncyhmb3JtYXRUeXBlLCBsYXN0TmV4dEZvcm1hdCk7XG4gICAgICB0ZXh0Tm9kZS5zZXRGb3JtYXQobmV4dEZvcm1hdCk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHNlbGVjdGlvbiBvbmx5IGlmIHN0YXJ0cy9lbmRzIG9uIHRleHQgbm9kZVxuICAgIGlmIChzdGFydFBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgc3RhcnRQb2ludC5zZXQoZmlyc3ROb2RlLl9fa2V5LCBzdGFydE9mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgaWYgKGVuZFBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgZW5kUG9pbnQuc2V0KGxhc3ROb2RlLl9fa2V5LCBlbmRPZmZzZXQsICd0ZXh0Jyk7XG4gICAgfVxuICAgIHRoaXMuZm9ybWF0ID0gZmlyc3ROZXh0Rm9ybWF0IHwgbGFzdE5leHRGb3JtYXQ7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gXCJpbnRlbGxpZ2VudGx5XCIgaW5zZXJ0IGFuIGFyYml0cmFyeSBsaXN0IG9mIExleGljYWwgbm9kZXMgaW50byB0aGUgRWRpdG9yU3RhdGUgYXQgdGhlXG4gICAqIGN1cnJlbnQgU2VsZWN0aW9uIGFjY29yZGluZyB0byBhIHNldCBvZiBoZXVyaXN0aWNzIHRoYXQgZGV0ZXJtaW5lIGhvdyBzdXJyb3VuZGluZyBub2Rlc1xuICAgKiBzaG91bGQgYmUgY2hhbmdlZCwgcmVwbGFjZWQsIG9yIG1vdmVkIHRvIGFjY29tbW9kYXRlIHRoZSBpbmNvbWluZyBvbmVzLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZXMgLSB0aGUgbm9kZXMgdG8gaW5zZXJ0XG4gICAqL1xuICBpbnNlcnROb2Rlcyhub2Rlcykge1xuICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbmNob3Iua2V5ID09PSAncm9vdCcpIHtcbiAgICAgIHRoaXMuaW5zZXJ0UGFyYWdyYXBoKCk7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBSYW5nZVNlbGVjdGlvbiBhZnRlciBpbnNlcnRQYXJhZ3JhcGhgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMobm9kZXMpO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gdGhpcy5pc0JhY2t3YXJkKCkgPyB0aGlzLmZvY3VzIDogdGhpcy5hbmNob3I7XG4gICAgY29uc3QgZmlyc3ROb2RlID0gZmlyc3RQb2ludC5nZXROb2RlKCk7XG4gICAgY29uc3QgZmlyc3RCbG9jayA9ICRnZXRBbmNlc3RvcihmaXJzdE5vZGUsIElOVEVSTkFMXyRpc0Jsb2NrKTtcbiAgICBjb25zdCBsYXN0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMV07XG5cbiAgICAvLyBDQVNFIDE6IGluc2VydCBpbnNpZGUgYSBjb2RlIGJsb2NrXG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0QmxvY2spICYmICdfX2xhbmd1YWdlJyBpbiBmaXJzdEJsb2NrKSB7XG4gICAgICBpZiAoJ19fbGFuZ3VhZ2UnIGluIG5vZGVzWzBdKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dChub2Rlc1swXS5nZXRUZXh0Q29udGVudCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gJHJlbW92ZVRleHRBbmRTcGxpdEJsb2NrKHRoaXMpO1xuICAgICAgICBmaXJzdEJsb2NrLnNwbGljZShpbmRleCwgMCwgbm9kZXMpO1xuICAgICAgICBsYXN0LnNlbGVjdEVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENBU0UgMjogQWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheSBhcmUgaW5saW5lXG4gICAgY29uc3Qgbm90SW5saW5lID0gbm9kZSA9PiAoJGlzRWxlbWVudE5vZGUobm9kZSkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSkgJiYgIW5vZGUuaXNJbmxpbmUoKTtcbiAgICBpZiAoIW5vZGVzLnNvbWUobm90SW5saW5lKSkge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShmaXJzdEJsb2NrKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgJHtmaXJzdE5vZGUuY29uc3RydWN0b3IubmFtZX0gb2YgdHlwZSAke2ZpcnN0Tm9kZS5nZXRUeXBlKCl9IHRvIGhhdmUgYSBibG9jayBFbGVtZW50Tm9kZSBhbmNlc3RvcmApO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5kZXggPSAkcmVtb3ZlVGV4dEFuZFNwbGl0QmxvY2sodGhpcyk7XG4gICAgICBmaXJzdEJsb2NrLnNwbGljZShpbmRleCwgMCwgbm9kZXMpO1xuICAgICAgbGFzdC5zZWxlY3RFbmQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDQVNFIDM6IEF0IGxlYXN0IDEgZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgbm90IGlubGluZVxuICAgIGNvbnN0IGJsb2Nrc1BhcmVudCA9ICR3cmFwSW5saW5lTm9kZXMobm9kZXMpO1xuICAgIGNvbnN0IG5vZGVUb1NlbGVjdCA9IGJsb2Nrc1BhcmVudC5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgIGNvbnN0IGJsb2NrcyA9IGJsb2Nrc1BhcmVudC5nZXRDaGlsZHJlbigpO1xuICAgIGNvbnN0IGlzTWVyZ2VhYmxlID0gbm9kZSA9PiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBJTlRFUk5BTF8kaXNCbG9jayhub2RlKSAmJiAhbm9kZS5pc0VtcHR5KCkgJiYgJGlzRWxlbWVudE5vZGUoZmlyc3RCbG9jaykgJiYgKCFmaXJzdEJsb2NrLmlzRW1wdHkoKSB8fCBmaXJzdEJsb2NrLmNhbk1lcmdlV2hlbkVtcHR5KCkpO1xuICAgIGNvbnN0IHNob3VsZEluc2VydCA9ICEkaXNFbGVtZW50Tm9kZShmaXJzdEJsb2NrKSB8fCAhZmlyc3RCbG9jay5pc0VtcHR5KCk7XG4gICAgY29uc3QgaW5zZXJ0ZWRQYXJhZ3JhcGggPSBzaG91bGRJbnNlcnQgPyB0aGlzLmluc2VydFBhcmFncmFwaCgpIDogbnVsbDtcbiAgICBjb25zdCBsYXN0VG9JbnNlcnQgPSBibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdO1xuICAgIGxldCBmaXJzdFRvSW5zZXJ0ID0gYmxvY2tzWzBdO1xuICAgIGlmIChpc01lcmdlYWJsZShmaXJzdFRvSW5zZXJ0KSkge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShmaXJzdEJsb2NrKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgJHtmaXJzdE5vZGUuY29uc3RydWN0b3IubmFtZX0gb2YgdHlwZSAke2ZpcnN0Tm9kZS5nZXRUeXBlKCl9IHRvIGhhdmUgYSBibG9jayBFbGVtZW50Tm9kZSBhbmNlc3RvcmApO1xuICAgICAgfVxuICAgICAgZmlyc3RCbG9jay5hcHBlbmQoLi4uZmlyc3RUb0luc2VydC5nZXRDaGlsZHJlbigpKTtcbiAgICAgIGZpcnN0VG9JbnNlcnQgPSBibG9ja3NbMV07XG4gICAgfVxuICAgIGlmIChmaXJzdFRvSW5zZXJ0KSB7XG4gICAgICBpZiAoIShmaXJzdEJsb2NrICE9PSBudWxsKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgJHtmaXJzdE5vZGUuY29uc3RydWN0b3IubmFtZX0gb2YgdHlwZSAke2ZpcnN0Tm9kZS5nZXRUeXBlKCl9IHRvIGhhdmUgYSBibG9jayBhbmNlc3RvcmApO1xuICAgICAgfVxuICAgICAgaW5zZXJ0UmFuZ2VBZnRlcihmaXJzdEJsb2NrLCBmaXJzdFRvSW5zZXJ0KTtcbiAgICB9XG4gICAgY29uc3QgbGFzdEluc2VydGVkQmxvY2sgPSAkZ2V0QW5jZXN0b3Iobm9kZVRvU2VsZWN0LCBJTlRFUk5BTF8kaXNCbG9jayk7XG4gICAgaWYgKGluc2VydGVkUGFyYWdyYXBoICYmICRpc0VsZW1lbnROb2RlKGxhc3RJbnNlcnRlZEJsb2NrKSAmJiAoaW5zZXJ0ZWRQYXJhZ3JhcGguY2FuTWVyZ2VXaGVuRW1wdHkoKSB8fCBJTlRFUk5BTF8kaXNCbG9jayhsYXN0VG9JbnNlcnQpKSkge1xuICAgICAgbGFzdEluc2VydGVkQmxvY2suYXBwZW5kKC4uLmluc2VydGVkUGFyYWdyYXBoLmdldENoaWxkcmVuKCkpO1xuICAgICAgaW5zZXJ0ZWRQYXJhZ3JhcGgucmVtb3ZlKCk7XG4gICAgfVxuICAgIGlmICgkaXNFbGVtZW50Tm9kZShmaXJzdEJsb2NrKSAmJiBmaXJzdEJsb2NrLmlzRW1wdHkoKSkge1xuICAgICAgZmlyc3RCbG9jay5yZW1vdmUoKTtcbiAgICB9XG4gICAgbm9kZVRvU2VsZWN0LnNlbGVjdEVuZCgpO1xuXG4gICAgLy8gVG8gdW5kZXJzdGFuZCB0aGlzIHRha2UgYSBsb29rIGF0IHRoZSB0ZXN0IFwiY2FuIHdyYXAgcG9zdC1saW5lYnJlYWsgbm9kZXMgaW50byBuZXcgZWxlbWVudFwiXG4gICAgY29uc3QgbGFzdENoaWxkID0gJGlzRWxlbWVudE5vZGUoZmlyc3RCbG9jaykgPyBmaXJzdEJsb2NrLmdldExhc3RDaGlsZCgpIDogbnVsbDtcbiAgICBpZiAoJGlzTGluZUJyZWFrTm9kZShsYXN0Q2hpbGQpICYmIGxhc3RJbnNlcnRlZEJsb2NrICE9PSBmaXJzdEJsb2NrKSB7XG4gICAgICBsYXN0Q2hpbGQucmVtb3ZlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgYSBuZXcgUGFyYWdyYXBoTm9kZSBpbnRvIHRoZSBFZGl0b3JTdGF0ZSBhdCB0aGUgY3VycmVudCBTZWxlY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMgdGhlIG5ld2x5IGluc2VydGVkIG5vZGUuXG4gICAqL1xuICBpbnNlcnRQYXJhZ3JhcGgoKSB7XG4gICAgaWYgKHRoaXMuYW5jaG9yLmtleSA9PT0gJ3Jvb3QnKSB7XG4gICAgICBjb25zdCBwYXJhZ3JhcGggPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgJGdldFJvb3QoKS5zcGxpY2UodGhpcy5hbmNob3Iub2Zmc2V0LCAwLCBbcGFyYWdyYXBoXSk7XG4gICAgICBwYXJhZ3JhcGguc2VsZWN0KCk7XG4gICAgICByZXR1cm4gcGFyYWdyYXBoO1xuICAgIH1cbiAgICBjb25zdCBpbmRleCA9ICRyZW1vdmVUZXh0QW5kU3BsaXRCbG9jayh0aGlzKTtcbiAgICBjb25zdCBibG9jayA9ICRnZXRBbmNlc3Rvcih0aGlzLmFuY2hvci5nZXROb2RlKCksIElOVEVSTkFMXyRpc0Jsb2NrKTtcbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKGJsb2NrKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBhbmNlc3RvciB0byBiZSBhIGJsb2NrIEVsZW1lbnROb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0VG9BcHBlbmQgPSBibG9jay5nZXRDaGlsZEF0SW5kZXgoaW5kZXgpO1xuICAgIGNvbnN0IG5vZGVzVG9JbnNlcnQgPSBmaXJzdFRvQXBwZW5kID8gW2ZpcnN0VG9BcHBlbmQsIC4uLmZpcnN0VG9BcHBlbmQuZ2V0TmV4dFNpYmxpbmdzKCldIDogW107XG4gICAgY29uc3QgbmV3QmxvY2sgPSBibG9jay5pbnNlcnROZXdBZnRlcih0aGlzLCBmYWxzZSk7XG4gICAgaWYgKG5ld0Jsb2NrKSB7XG4gICAgICBuZXdCbG9jay5hcHBlbmQoLi4ubm9kZXNUb0luc2VydCk7XG4gICAgICBuZXdCbG9jay5zZWxlY3RTdGFydCgpO1xuICAgICAgcmV0dXJuIG5ld0Jsb2NrO1xuICAgIH1cbiAgICAvLyBpZiBuZXdCbG9jayBpcyBudWxsLCBpdCBtZWFucyB0aGF0IGJsb2NrIGlzIG9mIHR5cGUgQ29kZU5vZGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBhIGxvZ2ljYWwgbGluZWJyZWFrLCB3aGljaCBtYXkgYmUgYSBuZXcgTGluZUJyZWFrTm9kZSBvciBhIG5ldyBQYXJhZ3JhcGhOb2RlLCBpbnRvIHRoZSBFZGl0b3JTdGF0ZSBhdCB0aGVcbiAgICogY3VycmVudCBTZWxlY3Rpb24uXG4gICAqL1xuICBpbnNlcnRMaW5lQnJlYWsoc2VsZWN0U3RhcnQpIHtcbiAgICBjb25zdCBsaW5lQnJlYWsgPSAkY3JlYXRlTGluZUJyZWFrTm9kZSgpO1xuICAgIHRoaXMuaW5zZXJ0Tm9kZXMoW2xpbmVCcmVha10pO1xuICAgIC8vIHRoaXMgaXMgdXNlZCBpbiBNYWNPUyB3aXRoIHRoZSBjb21tYW5kICdjdHJsLU8nIChvcGVuTGluZUJyZWFrKVxuICAgIGlmIChzZWxlY3RTdGFydCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gbGluZUJyZWFrLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGluZUJyZWFrLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICBwYXJlbnQuc2VsZWN0KGluZGV4LCBpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBub2RlcyBpbiB0aGUgU2VsZWN0aW9uLCBzcGxpdHRpbmcgbm9kZXMgd2hlcmUgbmVjZXNzYXJ5XG4gICAqIHRvIGdldCBvZmZzZXQtbGV2ZWwgcHJlY2lzaW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgbm9kZXMgaW4gdGhlIFNlbGVjdGlvblxuICAgKi9cbiAgZXh0cmFjdCgpIHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZXNMZW5ndGggPSBzZWxlY3RlZE5vZGVzLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBzZWxlY3RlZE5vZGVzTGVuZ3RoIC0gMTtcbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXM7XG4gICAgbGV0IGZpcnN0Tm9kZSA9IHNlbGVjdGVkTm9kZXNbMF07XG4gICAgbGV0IGxhc3ROb2RlID0gc2VsZWN0ZWROb2Rlc1tsYXN0SW5kZXhdO1xuICAgIGNvbnN0IFthbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0XSA9ICRnZXRDaGFyYWN0ZXJPZmZzZXRzKHRoaXMpO1xuICAgIGlmIChzZWxlY3RlZE5vZGVzTGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChzZWxlY3RlZE5vZGVzTGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSAmJiAhdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gYW5jaG9yT2Zmc2V0ID4gZm9jdXNPZmZzZXQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgICAgY29uc3Qgc3BsaXROb2RlcyA9IGZpcnN0Tm9kZS5zcGxpdFRleHQoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzdGFydE9mZnNldCA9PT0gMCA/IHNwbGl0Tm9kZXNbMF0gOiBzcGxpdE5vZGVzWzFdO1xuICAgICAgICByZXR1cm4gbm9kZSAhPSBudWxsID8gW25vZGVdIDogW107XG4gICAgICB9XG4gICAgICByZXR1cm4gW2ZpcnN0Tm9kZV07XG4gICAgfVxuICAgIGNvbnN0IGlzQmVmb3JlID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUoZmlyc3ROb2RlKSkge1xuICAgICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpc0JlZm9yZSA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgaWYgKHN0YXJ0T2Zmc2V0ID09PSBmaXJzdE5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgICAgc2VsZWN0ZWROb2Rlcy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydE9mZnNldCAhPT0gMCkge1xuICAgICAgICBbLCBmaXJzdE5vZGVdID0gZmlyc3ROb2RlLnNwbGl0VGV4dChzdGFydE9mZnNldCk7XG4gICAgICAgIHNlbGVjdGVkTm9kZXNbMF0gPSBmaXJzdE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGxhc3ROb2RlVGV4dCA9IGxhc3ROb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZVRleHRMZW5ndGggPSBsYXN0Tm9kZVRleHQubGVuZ3RoO1xuICAgICAgY29uc3QgZW5kT2Zmc2V0ID0gaXNCZWZvcmUgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgIGlmIChlbmRPZmZzZXQgPT09IDApIHtcbiAgICAgICAgc2VsZWN0ZWROb2Rlcy5wb3AoKTtcbiAgICAgIH0gZWxzZSBpZiAoZW5kT2Zmc2V0ICE9PSBsYXN0Tm9kZVRleHRMZW5ndGgpIHtcbiAgICAgICAgW2xhc3ROb2RlXSA9IGxhc3ROb2RlLnNwbGl0VGV4dChlbmRPZmZzZXQpO1xuICAgICAgICBzZWxlY3RlZE5vZGVzW2xhc3RJbmRleF0gPSBsYXN0Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdGVkTm9kZXM7XG4gIH1cblxuICAvKipcbiAgICogTW9kaWZpZXMgdGhlIFNlbGVjdGlvbiBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlcnMgYW5kIGEgc2V0IG9mIGhldXJpc3RpY3MgdGhhdCBhY2NvdW50IGZvclxuICAgKiB2YXJpb3VzIG5vZGUgdHlwZXMuIENhbiBiZSB1c2VkIHRvIHNhZmVseSBtb3ZlIG9yIGV4dGVuZCBzZWxlY3Rpb24gYnkgb25lIGxvZ2ljYWwgXCJ1bml0XCIgd2l0aG91dFxuICAgKiBkZWFsaW5nIGV4cGxpY2l0bHkgd2l0aCBhbGwgdGhlIHBvc3NpYmxlIG5vZGUgdHlwZXMuXG4gICAqXG4gICAqIEBwYXJhbSBhbHRlciB0aGUgdHlwZSBvZiBtb2RpZmljYXRpb24gdG8gcGVyZm9ybVxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCBzZWxlY3Rpb24gaXMgYmFja3dhcmRzXG4gICAqIEBwYXJhbSBncmFudWxhcml0eSB0aGUgZ3JhbnVsYXJpdHkgYXQgd2hpY2ggdG8gYXBwbHkgdGhlIG1vZGlmaWNhdGlvblxuICAgKi9cbiAgbW9kaWZ5KGFsdGVyLCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSkge1xuICAgIGlmICgkbW9kaWZ5U2VsZWN0aW9uQXJvdW5kRGVjb3JhdG9yc0FuZEJsb2Nrcyh0aGlzLCBhbHRlciwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbGxhcHNlID0gYWx0ZXIgPT09ICdtb3ZlJztcbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZ2V0V2luZG93KGVkaXRvcikpO1xuICAgIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLl9yb290RWxlbWVudDtcbiAgICBjb25zdCBmb2N1c05vZGUgPSB0aGlzLmZvY3VzLmdldE5vZGUoKTtcbiAgICAvLyBSZW1vdmUgdGhlIGJsb2NrIGN1cnNvciBlbGVtZW50IGlmIGl0IGV4aXN0cy4gVGhpcyB3aWxsIGVuc3VyZSBzZWxlY3Rpb25cbiAgICAvLyB3b3JrcyBhcyBpbnRlbmRlZC4gSWYgd2UgbGVhdmUgaXQgaW4gdGhlIERPTSBhbGwgc29ydHMgb2Ygc3RyYW5nZSBidWdzXG4gICAgLy8gb2NjdXIuIDovXG4gICAgaWYgKHJvb3RFbGVtZW50ICE9PSBudWxsICYmIGJsb2NrQ3Vyc29yRWxlbWVudCAhPT0gbnVsbCAmJiAkaXNFbGVtZW50Tm9kZShmb2N1c05vZGUpICYmICFmb2N1c05vZGUuaXNJbmxpbmUoKSAmJiAhZm9jdXNOb2RlLmNhbkJlRW1wdHkoKSkge1xuICAgICAgcmVtb3ZlRE9NQmxvY2tDdXJzb3JFbGVtZW50KGJsb2NrQ3Vyc29yRWxlbWVudCwgZWRpdG9yLCByb290RWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICBsZXQgbmV4dEFuY2hvckRPTSA9IGdldEVsZW1lbnRCeUtleU9yVGhyb3coZWRpdG9yLCB0aGlzLmFuY2hvci5rZXkpO1xuICAgICAgbGV0IG5leHRGb2N1c0RPTSA9IGdldEVsZW1lbnRCeUtleU9yVGhyb3coZWRpdG9yLCB0aGlzLmZvY3VzLmtleSk7XG4gICAgICBpZiAodGhpcy5hbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIG5leHRBbmNob3JET00gPSBnZXRET01UZXh0Tm9kZShuZXh0QW5jaG9yRE9NKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICBuZXh0Rm9jdXNET00gPSBnZXRET01UZXh0Tm9kZShuZXh0Rm9jdXNET00pO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRBbmNob3JET00gJiYgbmV4dEZvY3VzRE9NKSB7XG4gICAgICAgIHNldERPTVNlbGVjdGlvbkJhc2VBbmRFeHRlbnQoZG9tU2VsZWN0aW9uLCBuZXh0QW5jaG9yRE9NLCB0aGlzLmFuY2hvci5vZmZzZXQsIG5leHRGb2N1c0RPTSwgdGhpcy5mb2N1cy5vZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBXZSB1c2UgdGhlIERPTSBzZWxlY3Rpb24ubW9kaWZ5IEFQSSBoZXJlIHRvIFwidGVsbFwiIHVzIHdoYXQgdGhlIHNlbGVjdGlvblxuICAgIC8vIHdpbGwgYmUuIFdlIHRoZW4gdXNlIGl0IHRvIHVwZGF0ZSB0aGUgTGV4aWNhbCBzZWxlY3Rpb24gYWNjb3JkaW5nbHkuIFRoaXNcbiAgICAvLyBpcyBtdWNoIG1vcmUgcmVsaWFibGUgdGhhbiB3YWl0aW5nIGZvciBhIGJlZm9yZWlucHV0IGFuZCB1c2luZyB0aGUgcmFuZ2VzXG4gICAgLy8gZnJvbSBnZXRUYXJnZXRSYW5nZXMoKSwgYW5kIGlzIGFsc28gYmV0dGVyIHRoYW4gdHJ5aW5nIHRvIGRvIGl0IG91cnNlbHZlc1xuICAgIC8vIHVzaW5nIEludGwuU2VnbWVudGVyIG9yIG90aGVyIHdvcmthcm91bmRzIHRoYXQgc3RydWdnbGUgd2l0aCB3b3JkIHNlZ21lbnRzXG4gICAgLy8gYW5kIGxpbmUgc2VnbWVudHMgKGVzcGVjaWFsbHkgd2l0aCB3b3JkIHdyYXBwaW5nIGFuZCBub24tUm9tYW4gbGFuZ3VhZ2VzKS5cbiAgICBtb3ZlTmF0aXZlU2VsZWN0aW9uKGRvbVNlbGVjdGlvbiwgYWx0ZXIsIGlzQmFja3dhcmQgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnLCBncmFudWxhcml0eSk7XG4gICAgLy8gR3VhcmQgYWdhaW5zdCBubyByYW5nZXNcbiAgICBpZiAoZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICBjb25zdCByYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgLy8gQXBwbHkgdGhlIERPTSBzZWxlY3Rpb24gdG8gb3VyIExleGljYWwgc2VsZWN0aW9uLlxuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IHRoaXMuYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IHJvb3QgPSAkaXNSb290Tm9kZShhbmNob3JOb2RlKSA/IGFuY2hvck5vZGUgOiAkZ2V0TmVhcmVzdFJvb3RPclNoYWRvd1Jvb3QoYW5jaG9yTm9kZSk7XG4gICAgICB0aGlzLmFwcGx5RE9NUmFuZ2UocmFuZ2UpO1xuICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICBpZiAoIWNvbGxhcHNlKSB7XG4gICAgICAgIC8vIFZhbGlkYXRlIHNlbGVjdGlvbjsgbWFrZSBzdXJlIHRoYXQgdGhlIG5ldyBleHRlbmRlZCBzZWxlY3Rpb24gcmVzcGVjdHMgc2hhZG93IHJvb3RzXG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2RlcygpO1xuICAgICAgICBjb25zdCB2YWxpZE5vZGVzID0gW107XG4gICAgICAgIGxldCBzaHJpbmtTZWxlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgaWYgKCRoYXNBbmNlc3RvcihuZXh0Tm9kZSwgcm9vdCkpIHtcbiAgICAgICAgICAgIHZhbGlkTm9kZXMucHVzaChuZXh0Tm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNocmlua1NlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaHJpbmtTZWxlY3Rpb24gJiYgdmFsaWROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gdmFsaWROb2RlcyBsZW5ndGggY2hlY2sgaXMgYSBzYWZlZ3VhcmQgYWdhaW5zdCBhbiBpbnZhbGlkIHNlbGVjdGlvbjsgYXMgZ2V0Tm9kZXMoKVxuICAgICAgICAgIC8vIHdpbGwgcmV0dXJuIGFuIGVtcHR5IGFycmF5IGluIHRoaXMgY2FzZVxuICAgICAgICAgIGlmIChpc0JhY2t3YXJkKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbGlkTm9kZSA9IHZhbGlkTm9kZXNbMF07XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoZmlyc3RWYWxpZE5vZGUpKSB7XG4gICAgICAgICAgICAgIGZpcnN0VmFsaWROb2RlLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaXJzdFZhbGlkTm9kZS5nZXRQYXJlbnRPclRocm93KCkuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbGFzdFZhbGlkTm9kZSA9IHZhbGlkTm9kZXNbdmFsaWROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShsYXN0VmFsaWROb2RlKSkge1xuICAgICAgICAgICAgICBsYXN0VmFsaWROb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbGFzdFZhbGlkTm9kZS5nZXRQYXJlbnRPclRocm93KCkuc2VsZWN0RW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmVjYXVzZSBhIHJhbmdlIHdvcmtzIG9uIHN0YXJ0IGFuZCBlbmQsIHdlIG1pZ2h0IG5lZWQgdG8gZmxpcFxuICAgICAgICAvLyB0aGUgYW5jaG9yIGFuZCBmb2N1cyBwb2ludHMgdG8gbWF0Y2ggd2hhdCB0aGUgRE9NIGhhcywgbm90IHdoYXRcbiAgICAgICAgLy8gdGhlIHJhbmdlIGhhcyBzcGVjaWZpY2FsbHkuXG4gICAgICAgIGlmIChkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSAhPT0gcmFuZ2Uuc3RhcnRDb250YWluZXIgfHwgZG9tU2VsZWN0aW9uLmFuY2hvck9mZnNldCAhPT0gcmFuZ2Uuc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICAkc3dhcFBvaW50cyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ3JhbnVsYXJpdHkgPT09ICdsaW5lYm91bmRhcnknKSB7XG4gICAgICAkbW9kaWZ5U2VsZWN0aW9uQXJvdW5kRGVjb3JhdG9yc0FuZEJsb2Nrcyh0aGlzLCBhbHRlciwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHksICdkZWNvcmF0b3JzJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIZWxwZXIgZm9yIGhhbmRsaW5nIGZvcndhcmQgY2hhcmFjdGVyIGFuZCB3b3JkIGRlbGV0aW9uIHRoYXQgcHJldmVudHMgZWxlbWVudCBub2Rlc1xuICAgKiBsaWtlIGEgdGFibGUsIGNvbHVtbnMgbGF5b3V0IGJlaW5nIGRlc3Ryb3llZFxuICAgKlxuICAgKiBAcGFyYW0gYW5jaG9yIHRoZSBhbmNob3JcbiAgICogQHBhcmFtIGFuY2hvck5vZGUgdGhlIGFuY2hvciBub2RlIGluIHRoZSBzZWxlY3Rpb25cbiAgICogQHBhcmFtIGlzQmFja3dhcmQgd2hldGhlciBvciBub3Qgc2VsZWN0aW9uIGlzIGJhY2t3YXJkc1xuICAgKi9cbiAgZm9yd2FyZERlbGV0aW9uKGFuY2hvciwgYW5jaG9yTm9kZSwgaXNCYWNrd2FyZCkge1xuICAgIGlmICghaXNCYWNrd2FyZCAmJiAoXG4gICAgLy8gRGVsZXRlIGZvcndhcmQgaGFuZGxlIGNhc2VcbiAgICBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmICRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpICYmIGFuY2hvci5vZmZzZXQgPT09IGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgfHwgYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJiBhbmNob3Iub2Zmc2V0ID09PSBhbmNob3JOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSkge1xuICAgICAgY29uc3QgcGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gYW5jaG9yTm9kZS5nZXROZXh0U2libGluZygpIHx8IChwYXJlbnQgPT09IG51bGwgPyBudWxsIDogcGFyZW50LmdldE5leHRTaWJsaW5nKCkpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5leHRTaWJsaW5nKSAmJiBuZXh0U2libGluZy5pc1NoYWRvd1Jvb3QoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIG9uZSBsb2dpY2FsIGNoYXJhY3RlciBkZWxldGlvbiBvcGVyYXRpb24gb24gdGhlIEVkaXRvclN0YXRlIGJhc2VkIG9uIHRoZSBjdXJyZW50IFNlbGVjdGlvbi5cbiAgICogSGFuZGxlcyBkaWZmZXJlbnQgbm9kZSB0eXBlcy5cbiAgICpcbiAgICogQHBhcmFtIGlzQmFja3dhcmQgd2hldGhlciBvciBub3QgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZHMuXG4gICAqL1xuICBkZWxldGVDaGFyYWN0ZXIoaXNCYWNrd2FyZCkge1xuICAgIGNvbnN0IHdhc0NvbGxhcHNlZCA9IHRoaXMuaXNDb2xsYXBzZWQoKTtcbiAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcbiAgICAgIGxldCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGlmICh0aGlzLmZvcndhcmREZWxldGlvbihhbmNob3IsIGFuY2hvck5vZGUsIGlzQmFja3dhcmQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGlzQmFja3dhcmQgPyAncHJldmlvdXMnIDogJ25leHQnO1xuICAgICAgY29uc3QgaW5pdGlhbENhcmV0ID0gJGNhcmV0RnJvbVBvaW50KGFuY2hvciwgZGlyZWN0aW9uKTtcbiAgICAgIGNvbnN0IGluaXRpYWxSYW5nZSA9ICRleHRlbmRDYXJldFRvUmFuZ2UoaW5pdGlhbENhcmV0KTtcbiAgICAgIGlmIChpbml0aWFsUmFuZ2UuZ2V0VGV4dFNsaWNlcygpLmV2ZXJ5KHNsaWNlID0+IHNsaWNlID09PSBudWxsIHx8IHNsaWNlLmRpc3RhbmNlID09PSAwKSkge1xuICAgICAgICAvLyBUaGVyZSdzIG5vIHRleHQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgZGVsZXRpb24gc28gd2UgY2FuIGV4cGxvcmUgb3VyIG9wdGlvbnNcbiAgICAgICAgbGV0IHN0YXRlID0ge1xuICAgICAgICAgIHR5cGU6ICdpbml0aWFsJ1xuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGNhcmV0IG9mIGluaXRpYWxSYW5nZS5pdGVyTm9kZUNhcmV0cygnc2hhZG93Um9vdCcpKSB7XG4gICAgICAgICAgaWYgKCRpc0NoaWxkQ2FyZXQoY2FyZXQpKSB7XG4gICAgICAgICAgICBpZiAoY2FyZXQub3JpZ2luLmlzSW5saW5lKCkpIDsgZWxzZSBpZiAoY2FyZXQub3JpZ2luLmlzU2hhZG93Um9vdCgpKSB7XG4gICAgICAgICAgICAgIGlmIChzdGF0ZS50eXBlID09PSAnbWVyZ2UtYmxvY2snKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRG9uJ3QgbWVyZ2Ugd2l0aCBhIHNoYWRvdyByb290IGJsb2NrXG4gICAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShpbml0aWFsUmFuZ2UuYW5jaG9yLm9yaWdpbikgJiYgaW5pdGlhbFJhbmdlLmFuY2hvci5vcmlnaW4uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIGFuIGVtcHR5IHBhcmFncmFwaCBsaWtlIHRoZSBEZWNvcmF0b3JOb2RlIGNhc2VcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtQ2FyZXQgPSAkbm9ybWFsaXplQ2FyZXQoY2FyZXQpO1xuICAgICAgICAgICAgICAgICR1cGRhdGVSYW5nZVNlbGVjdGlvbkZyb21DYXJldFJhbmdlKHRoaXMsICRnZXRDYXJldFJhbmdlKG5vcm1DYXJldCwgbm9ybUNhcmV0KSk7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFJhbmdlLmFuY2hvci5vcmlnaW4ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZS50eXBlID09PSAnbWVyZ2UtbmV4dC1ibG9jaycgfHwgc3RhdGUudHlwZSA9PT0gJ21lcmdlLWJsb2NrJykge1xuICAgICAgICAgICAgICAvLyBLZWVwIGRlc2NlbmRpbmcgQ2hpbGRDYXJldCB0byBmaW5kIHdoaWNoIGJsb2NrIHRvIG1lcmdlIHdpdGhcbiAgICAgICAgICAgICAgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgYmxvY2s6IHN0YXRlLmJsb2NrLFxuICAgICAgICAgICAgICAgIGNhcmV0LFxuICAgICAgICAgICAgICAgIHR5cGU6ICdtZXJnZS1ibG9jaydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLnR5cGUgPT09ICdtZXJnZS1ibG9jaycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJGlzU2libGluZ0NhcmV0KGNhcmV0KSkge1xuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNhcmV0Lm9yaWdpbikpIHtcbiAgICAgICAgICAgICAgaWYgKCFjYXJldC5vcmlnaW4uaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgYmxvY2s6IGNhcmV0Lm9yaWdpbixcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdtZXJnZS1uZXh0LWJsb2NrJ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWNhcmV0Lm9yaWdpbi5pc1BhcmVudE9mKGluaXRpYWxSYW5nZS5hbmNob3Iub3JpZ2luKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgkaXNEZWNvcmF0b3JOb2RlKGNhcmV0Lm9yaWdpbikpIHtcbiAgICAgICAgICAgICAgaWYgKGNhcmV0Lm9yaWdpbi5pc0lzb2xhdGVkKCkpIDsgZWxzZSBpZiAoc3RhdGUudHlwZSA9PT0gJ21lcmdlLW5leHQtYmxvY2snICYmIChjYXJldC5vcmlnaW4uaXNLZXlib2FyZFNlbGVjdGFibGUoKSB8fCAhY2FyZXQub3JpZ2luLmlzSW5saW5lKCkpICYmICRpc0VsZW1lbnROb2RlKGluaXRpYWxSYW5nZS5hbmNob3Iub3JpZ2luKSAmJiBpbml0aWFsUmFuZ2UuYW5jaG9yLm9yaWdpbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYW5jaG9yIGlzIGFuIGVtcHR5IGVsZW1lbnQgdGhhdCBpcyBhZGphY2VudCB0byBhXG4gICAgICAgICAgICAgICAgLy8gZGVjb3JhdG9yIHRoZW4gd2UgcmVtb3ZlIHRoZSBwYXJhZ3JhcGggYW5kIHNlbGVjdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBkZWNvcmF0b3JcbiAgICAgICAgICAgICAgICBpbml0aWFsUmFuZ2UuYW5jaG9yLm9yaWdpbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlU2VsZWN0aW9uID0gJGNyZWF0ZU5vZGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBub2RlU2VsZWN0aW9uLmFkZChjYXJldC5vcmlnaW4uZ2V0S2V5KCkpO1xuICAgICAgICAgICAgICAgICRzZXRTZWxlY3Rpb24obm9kZVNlbGVjdGlvbik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgYW5jaG9yIGlzIG5vdCBhbiBlbXB0eSBlbGVtZW50IHRoZW4gdGhlXG4gICAgICAgICAgICAgICAgLy8gYWRqYWNlbnQgZGVjb3JhdG9yIGlzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICBjYXJldC5vcmlnaW4ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYWx3YXlzIHN0b3Agd2hlbiBhIGRlY29yYXRvciBpcyBlbmNvdW50ZXJlZFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnR5cGUgPT09ICdtZXJnZS1ibG9jaycpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjYXJldCxcbiAgICAgICAgICAgIGJsb2NrXG4gICAgICAgICAgfSA9IHN0YXRlO1xuICAgICAgICAgICR1cGRhdGVSYW5nZVNlbGVjdGlvbkZyb21DYXJldFJhbmdlKHRoaXMsICRnZXRDYXJldFJhbmdlKCFjYXJldC5vcmlnaW4uaXNFbXB0eSgpICYmIGJsb2NrLmlzRW1wdHkoKSA/ICRyZXdpbmRTaWJsaW5nQ2FyZXQoJGdldFNpYmxpbmdDYXJldChibG9jaywgY2FyZXQuZGlyZWN0aW9uKSkgOiBpbml0aWFsUmFuZ2UuYW5jaG9yLCBjYXJldCkpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVRleHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBIYW5kbGUgdGhlIGRlbGV0aW9uIGFyb3VuZCBkZWNvcmF0b3JzLlxuICAgICAgY29uc3QgZm9jdXMgPSB0aGlzLmZvY3VzO1xuICAgICAgdGhpcy5tb2RpZnkoJ2V4dGVuZCcsIGlzQmFja3dhcmQsICdjaGFyYWN0ZXInKTtcbiAgICAgIGlmICghdGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLnR5cGUgPT09ICd0ZXh0JyA/IGZvY3VzLmdldE5vZGUoKSA6IG51bGw7XG4gICAgICAgIGFuY2hvck5vZGUgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKSA6IG51bGw7XG4gICAgICAgIGlmIChmb2N1c05vZGUgIT09IG51bGwgJiYgZm9jdXNOb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gICAgICAgICAgY29uc3QgdGV4dENvbnRlbnRTaXplID0gZm9jdXNOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgICAgICAgIGlmIChmb2N1c05vZGUuaXMoYW5jaG9yTm9kZSkgfHwgaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IHRleHRDb250ZW50U2l6ZSB8fCAhaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICRyZW1vdmVTZWdtZW50KGZvY3VzTm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYW5jaG9yTm9kZSAhPT0gbnVsbCAmJiBhbmNob3JOb2RlLmlzU2VnbWVudGVkKCkpIHtcbiAgICAgICAgICBjb25zdCBvZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50U2l6ZSA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICAgICAgaWYgKGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKSB8fCBpc0JhY2t3YXJkICYmIG9mZnNldCAhPT0gMCB8fCAhaXNCYWNrd2FyZCAmJiBvZmZzZXQgIT09IHRleHRDb250ZW50U2l6ZSkge1xuICAgICAgICAgICAgJHJlbW92ZVNlZ21lbnQoYW5jaG9yTm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHVwZGF0ZUNhcmV0U2VsZWN0aW9uRm9yVW5pY29kZUNoYXJhY3Rlcih0aGlzLCBpc0JhY2t3YXJkKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNCYWNrd2FyZCAmJiBhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgYXJvdW5kIHJpY2ggdGV4dCBub2Rlc1xuICAgICAgICBpZiAoJGNvbGxhcHNlQXRTdGFydCh0aGlzLCBhbmNob3IuZ2V0Tm9kZSgpKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlbW92ZVRleHQoKTtcbiAgICBpZiAoaXNCYWNrd2FyZCAmJiAhd2FzQ29sbGFwc2VkICYmIHRoaXMuaXNDb2xsYXBzZWQoKSAmJiB0aGlzLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgdGhpcy5hbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gdGhpcy5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKGFuY2hvck5vZGUuaXNFbXB0eSgpICYmICRpc1Jvb3ROb2RlKGFuY2hvck5vZGUuZ2V0UGFyZW50KCkpICYmIGFuY2hvck5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgJGNvbGxhcHNlQXRTdGFydCh0aGlzLCBhbmNob3JOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgb25lIGxvZ2ljYWwgbGluZSBkZWxldGlvbiBvcGVyYXRpb24gb24gdGhlIEVkaXRvclN0YXRlIGJhc2VkIG9uIHRoZSBjdXJyZW50IFNlbGVjdGlvbi5cbiAgICogSGFuZGxlcyBkaWZmZXJlbnQgbm9kZSB0eXBlcy5cbiAgICpcbiAgICogQHBhcmFtIGlzQmFja3dhcmQgd2hldGhlciBvciBub3QgdGhlIHNlbGVjdGlvbiBpcyBiYWNrd2FyZHMuXG4gICAqL1xuICBkZWxldGVMaW5lKGlzQmFja3dhcmQpIHtcbiAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICB0aGlzLm1vZGlmeSgnZXh0ZW5kJywgaXNCYWNrd2FyZCwgJ2xpbmVib3VuZGFyeScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIHdhcyBhbHJlYWR5IGNvbGxhcHNlZCBhdCB0aGUgbGluZWJvdW5kYXJ5LFxuICAgICAgLy8gdXNlIHRoZSBkZWxldGVDaGFyYWN0ZXIgb3BlcmF0aW9uIHRvIGhhbmRsZSBhbGwgb2YgdGhlIGxvZ2ljIGFzc29jaWF0ZWRcbiAgICAgIC8vIHdpdGggbmF2aWdhdGluZyB0aHJvdWdoIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgICAgdGhpcy5kZWxldGVDaGFyYWN0ZXIoaXNCYWNrd2FyZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlVGV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBvbmUgbG9naWNhbCB3b3JkIGRlbGV0aW9uIG9wZXJhdGlvbiBvbiB0aGUgRWRpdG9yU3RhdGUgYmFzZWQgb24gdGhlIGN1cnJlbnQgU2VsZWN0aW9uLlxuICAgKiBIYW5kbGVzIGRpZmZlcmVudCBub2RlIHR5cGVzLlxuICAgKlxuICAgKiBAcGFyYW0gaXNCYWNrd2FyZCB3aGV0aGVyIG9yIG5vdCB0aGUgc2VsZWN0aW9uIGlzIGJhY2t3YXJkcy5cbiAgICovXG4gIGRlbGV0ZVdvcmQoaXNCYWNrd2FyZCkge1xuICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBpZiAodGhpcy5mb3J3YXJkRGVsZXRpb24oYW5jaG9yLCBhbmNob3JOb2RlLCBpc0JhY2t3YXJkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLm1vZGlmeSgnZXh0ZW5kJywgaXNCYWNrd2FyZCwgJ3dvcmQnKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVUZXh0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTZWxlY3Rpb24gaXMgXCJiYWNrd2FyZHNcIiwgbWVhbmluZyB0aGUgZm9jdXNcbiAgICogbG9naWNhbGx5IHByZWNlZGVzIHRoZSBhbmNob3IgaW4gdGhlIEVkaXRvclN0YXRlLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgYmFja3dhcmRzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0JhY2t3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzLmlzQmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgfVxuICBnZXRTdGFydEVuZFBvaW50cygpIHtcbiAgICByZXR1cm4gW3RoaXMuYW5jaG9yLCB0aGlzLmZvY3VzXTtcbiAgfVxufVxuZnVuY3Rpb24gJGlzTm9kZVNlbGVjdGlvbih4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uIGdldENoYXJhY3Rlck9mZnNldChwb2ludCkge1xuICBjb25zdCBvZmZzZXQgPSBwb2ludC5vZmZzZXQ7XG4gIGlmIChwb2ludC50eXBlID09PSAndGV4dCcpIHtcbiAgICByZXR1cm4gb2Zmc2V0O1xuICB9XG4gIGNvbnN0IHBhcmVudCA9IHBvaW50LmdldE5vZGUoKTtcbiAgcmV0dXJuIG9mZnNldCA9PT0gcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID8gcGFyZW50LmdldFRleHRDb250ZW50KCkubGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uICRnZXRDaGFyYWN0ZXJPZmZzZXRzKHNlbGVjdGlvbikge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBpZiAoYW5jaG9yQW5kRm9jdXMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG4gIGNvbnN0IFthbmNob3IsIGZvY3VzXSA9IGFuY2hvckFuZEZvY3VzO1xuICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50JyAmJiBmb2N1cy50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmtleSA9PT0gZm9jdXMua2V5ICYmIGFuY2hvci5vZmZzZXQgPT09IGZvY3VzLm9mZnNldCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgcmV0dXJuIFtnZXRDaGFyYWN0ZXJPZmZzZXQoYW5jaG9yKSwgZ2V0Q2hhcmFjdGVyT2Zmc2V0KGZvY3VzKV07XG59XG5mdW5jdGlvbiAkY29sbGFwc2VBdFN0YXJ0KHNlbGVjdGlvbiwgc3RhcnROb2RlKSB7XG4gIGZvciAobGV0IG5vZGUgPSBzdGFydE5vZGU7IG5vZGU7IG5vZGUgPSBub2RlLmdldFBhcmVudCgpKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICBpZiAobm9kZS5jb2xsYXBzZUF0U3RhcnQoc2VsZWN0aW9uKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRzd2FwUG9pbnRzKHNlbGVjdGlvbikge1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yLmtleTtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgYW5jaG9yVHlwZSA9IGFuY2hvci50eXBlO1xuICBhbmNob3Iuc2V0KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlLCB0cnVlKTtcbiAgZm9jdXMuc2V0KGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBhbmNob3JUeXBlLCB0cnVlKTtcbn1cbmZ1bmN0aW9uIG1vdmVOYXRpdmVTZWxlY3Rpb24oZG9tU2VsZWN0aW9uLCBhbHRlciwgZGlyZWN0aW9uLCBncmFudWxhcml0eSkge1xuICAvLyBTZWxlY3Rpb24ubW9kaWZ5KCkgbWV0aG9kIGFwcGxpZXMgYSBjaGFuZ2UgdG8gdGhlIGN1cnJlbnQgc2VsZWN0aW9uIG9yIGN1cnNvciBwb3NpdGlvbixcbiAgLy8gYnV0IGlzIHN0aWxsIG5vbi1zdGFuZGFyZCBpbiBzb21lIGJyb3dzZXJzLlxuICBkb21TZWxlY3Rpb24ubW9kaWZ5KGFsdGVyLCBkaXJlY3Rpb24sIGdyYW51bGFyaXR5KTtcbn1cblxuLyoqXG4gKiBDYWxsZWQgYnkgYFJhbmdlU2VsZWN0aW9uLmRlbGV0ZUNoYXJhY3RlcmAgdG8gZGV0ZXJtaW5lIGlmXG4gKiBgdGhpcy5tb2RpZnkoJ2V4dGVuZCcsIGlzQmFja3dhcmQsICdjaGFyYWN0ZXInKWAgZXh0ZW5kZWQgdGhlIHNlbGVjdGlvblxuICogZnVydGhlciB0aGFuIGEgdXNlciB3b3VsZCBleHBlY3QgZm9yIHRoYXQgb3BlcmF0aW9uLlxuICpcbiAqIEEgc2hvcnQoPykgSmF2YVNjcmlwdCBzdHJpbmcgdnMuIFVuaWNvZGUgcHJpbWVyOlxuICpcbiAqIFN0cmluZ3MgaW4gSmF2YVNjcmlwdCB1c2UgYW4gVVRGLTE2IGVuY29kaW5nLCBhbmQgdGhlIG9mZnNldHMgaW50byBhXG4gKiBzdHJpbmcgYXJlIGJhc2VkIG9uIHRob3NlIFVURi0xNiAqY29kZSB1bml0cyouIFRoaXMgaXMgYmFzaWNhbGx5IGFcbiAqIGhpc3RvcmljYWwgbWlzdGFrZSAodGhvdWdoIGxvZ2ljYWwgYXQgdGhhdCB0aW1lLCBkZWNhZGVzIGFnbyksIGJ1dFxuICogY2FuIG5ldmVyIHJlYWxseSBiZSBmaXhlZCBmb3IgY29tcGF0aWJpbGl0eSByZWFzb25zLlxuICpcbiAqIEluIFVuaWNvZGUsIGEgKmNvZGUgcG9pbnQqIGlzIHRoZSBjb21iaW5hdGlvbiBvZiBvbmUgb3IgbW9yZSAqY29kZSB1bml0cyouXG4gKiBhbmQgdGhlIHJhbmdlIG9mIGEgKmNvZGUgcG9pbnQqIGNhbiBmaXQgaW50byAyMSBiaXRzLlxuICpcbiAqIEV2ZXJ5IHZhbGlkICpjb2RlIHBvaW50KiBjYW4gYmUgcmVwcmVzZW50ZWQgd2l0aCBvbmUgb3IgdHdvXG4gKiAqVVRGLTE2IGNvZGUgdW5pdHMqLiBPbmUgdW5pdCBpcyB1c2VkIHdoZW4gdGhlIGNvZGUgcG9pbnQgaXMgaW4gdGhlXG4gKiBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmUgKEJNUCkgYW5kIGlzIGA8IDB4RkZGRmAuIEFueXRoaW5nIG91dHNpZGVcbiAqIG9mIHRoYXQgcGxhbmUgaXMgZW5jb2RlZCB3aXRoIGEgKnN1cnJvZ2F0ZSBwYWlyKiBvZiAqY29kZSB1bml0cyogYW5kXG4gKiBgL1tcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vYCBpcyBhIHJlZ2V4IHRoYXQgeW91IGNvdWxkIHVzZSB0b1xuICogZmluZCBhbnkgdmFsaWQgKnN1cnJvZ2F0ZSBwYWlyKi4gQXMgZmFyIGFzIFVuaWNvZGUgaXMgY29uY2VybmVkLCB0aGVzZVxuICogcGFpcnMgcmVwcmVzZW50IGEgc2luZ2xlICpjb2RlIHBvaW50KiwgYnV0IGluIEphdmFTY3JpcHQsIHRoZXNlIHBhaXJzXG4gKiBoYXZlIGEgbGVuZ3RoIG9mIDIgKGBwYWlyLmNoYXJDb2RlQXQobilgIGlzIHJlYWxseSByZXR1cm5pbmcgYVxuICogVVRGLTE2ICpjb2RlIHVuaXQqLCBub3QgYSB1bmljb2RlICpjb2RlIHBvaW50KikuIEl0IGlzIHBvc3NpYmxlIHRvIHJlcXVlc3RcbiAqIGEgKmNvZGUgcG9pbnQqIHdpdGggYHBhaXIuY29kZVBvaW50QXQoMClgIGFuZCBlbnVtZXJhdGUgY29kZSBwb2ludHNcbiAqIGluIGEgc3RyaW5nIHdpdGggYFsuLi5zdHJpbmddYCBidXQgdGhlIG9mZnNldHMgd2Ugd29yayB3aXRoLCBhbmRcbiAqIHRoZSBzdHJpbmcgbGVuZ3RoLCBhcmUgYmFzZWQgaW4gKmNvZGUgdW5pdHMqIHNvIHRoYXQgZnVuY3Rpb25hbGl0eVxuICogaXMgdW5mb3J0dW5hdGVseSBub3QgdmVyeSB1c2VmdWwgaGVyZS5cbiAqXG4gKiBUaGlzIG9ubHkgZ2V0cyB1cyBhcyBmYXIgYXMgKmNvZGUgcG9pbnRzKi4gV2Ugbm93IGtub3cgdGhhdCB3ZSBtdXN0XG4gKiBjb25zaWRlciB0aGF0IGVhY2ggKmNvZGUgcG9pbnQqIGNhbiBoYXZlIGEgbGVuZ3RoIG9mIDEgb3IgMiBpbiBKYXZhU2NyaXB0XG4gKiBzdHJpbmcgZGlzdGFuY2UuIEl0IGdldHMgZXZlbiB0cmlja2llciBiZWNhdXNlIHRoZSB2aXN1YWwgcmVwcmVzZW50YXRpb25cbiAqIG9mIGEgY2hhcmFjdGVyIGlzIGEgKmdyYXBoZW1lKiAoYXBwcm94aW1hdGVseSB3aGF0IHRoZSB1c2VyIHRoaW5rcyBvZlxuICogYXMgYSBjaGFyYWN0ZXIpLiBBICpncmFwaGVtZSogaXMgb25lIG9yIG1vcmUgKmNvZGUgcG9pbnRzKiwgYW5kIGNhblxuICogZXNzZW50aWFsbHkgYmUgYXJiaXRyYXJpbHkgbG9uZywgYXMgdGhlcmUgYXJlIG1hbnkgd2F5cyB0byBjb21iaW5lXG4gKiB0aGVtLlxuICpcbiAqIFRoZSBgdGhpcy5tb2RpZnko4oCmKWAgY2FsbCBoYXMgYWxyZWFkeSBleHRlbmRlZCBvdXIgc2VsZWN0aW9uIGJ5IG9uZVxuICogKmdyYXBoZW1lKiBpbiB0aGUgZGlyZWN0aW9uIHdlIHdhbnQgdG8gZGVsZXRlLiBTb3VuZHMgZ3JlYXQsIGl0J3MgZG9uZVxuICogYSBsb3Qgb2YgYXdmdWxseSB0cmlja3kgd29yayBmb3IgdXMgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uYWxpdHkgaGFzIG9ubHlcbiAqIHJlY2VudGx5IGJlY29tZSBhdmFpbGFibGUgaW4gSmF2YVNjcmlwdCB2aWEgYEludGwuU2VnbWVudGVyYC4gVGhlXG4gKiBwcm9ibGVtIGlzIHRoYXQgaW4gbWFueSBjYXNlcyB0aGUgZXhwZWN0ZWQgYmVoYXZpb3Igb2YgYmFja3NwYWNlIG9yXG4gKiBkZWxldGUgaXMgKm5vdCBhbHdheXMgdG8gZGVsZXRlIGEgd2hvbGUgZ3JhcGhlbWUqLiBJbiBzb21lIGxhbmd1YWdlc1xuICogaXQncyBhbHdheXMgZXhwZWN0ZWQgdGhhdCBiYWNrc3BhY2Ugb3VnaHQgdG8gZGVsZXRlIG9uZSBjb2RlIHBvaW50LCBub3QgdGhlXG4gKiB3aG9sZSBncmFwaGVtZS4gSW4gb3RoZXIgc2l0dWF0aW9ucyBzdWNoIGFzIGVtb2ppIHRoYXQgdXNlIHZhcmlhdGlvblxuICogc2VsZWN0b3JzIHlvdSAqZG8qIHdhbnQgdG8gZGVsZXRlIHRoZSB3aG9sZSAqZ3JhcGhlbWUqLlxuICpcbiAqIEluIGEgZmV3IHNpdHVhdGlvbnMgdGhlIGJlaGF2aW9yIGlzIGV2ZW4gYXBwbGljYXRpb24gZGVwZW5kZW50LCBzdWNoIGFzXG4gKiB3aXRoIGxhdGluIGxhbmd1YWdlcyB3aGVyZSB5b3UgaGF2ZSBtdWx0aXBsZSB3YXlzIHRvIHJlcHJlc2VudCB0aGUgc2FtZVxuICogY2hhcmFjdGVyIHZpc3VhbGx5IChlLmcuIGEgbGV0dGVyIHdpdGggYW4gYWNjZW50IGluIG9uZSBjb2RlIHBvaW50LCBvciBhXG4gKiBsZXR0ZXIgZm9sbG93ZWQgYnkgYSBjb21iaW5pbmcgbWFyayBpbiBhIHNlY29uZCBjb2RlIHBvaW50KTsgc29tZSBhcHBzIHdpbGxcbiAqIGRlbGV0ZSB0aGUgd2hvbGUgZ3JhcGhlbWUgYW5kIG90aGVycyB3aWxsIGRlbGV0ZSBvbmx5IHRoZSBjb21iaW5pbmcgbWFyayxcbiAqIHByb2JhYmx5IGJhc2VkIG9uIHdoZXRoZXIgdGhleSBwZXJmb3JtIHNvbWUgc29ydCBvZiAqbm9ybWFsaXphdGlvbiogb24gdGhlaXJcbiAqIGlucHV0IHRvIGVuc3VyZSB0aGF0IG9ubHkgb25lIGZvcm0gaXMgdXNlZCB3aGVuIHR3byBzZXF1ZW5jZXMgb2YgY29kZSBwb2ludHNcbiAqIGNhbiByZXByZXNlbnQgdGhlIHNhbWUgdmlzdWFsIGNoYXJhY3Rlci4gTGV4aWNhbCBjdXJyZW50bHkgY2hvb3NlcyBub3RcbiAqIHRvIHBlcmZvcm0gYW55IG5vcm1hbGl6YXRpb24gc28gdGhpcyB0eXBlIG9mIGNvbWJpbmluZyBtYXJrcyB3aWxsIGJlXG4gKiBkZWxldGVkIGFzIGEgKmNvZGUgcG9pbnQqIHdpdGhvdXQgZGVsZXRpbmcgdGhlIHdob2xlICpncmFwaGVtZSouXG4gKlxuICogU2VlIGFsc286XG4gKiBodHRwczovL3d3dy51bmljb2RlLm9yZy92ZXJzaW9ucy9Vbmljb2RlMTYuMC4wL2NvcmUtc3BlYy9jaGFwdGVyLTIvI0cyNTU2NFxuICogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvdmVyc2lvbnMvVW5pY29kZTE2LjAuMC9jb3JlLXNwZWMvY2hhcHRlci0zLyNHMzA2MDJcbiAqIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3ZlcnNpb25zL1VuaWNvZGUxNi4wLjAvY29yZS1zcGVjL2NoYXB0ZXItMy8jRzQ5NTM3XG4gKiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC11bmljb2RlXG4gKi9cbmZ1bmN0aW9uICR1cGRhdGVDYXJldFNlbGVjdGlvbkZvclVuaWNvZGVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBpZiAoYW5jaG9yTm9kZSA9PT0gZm9jdXNOb2RlICYmIGFuY2hvci50eXBlID09PSAndGV4dCcgJiYgZm9jdXMudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgLy8gSGFuZGxpbmcgb2YgbXVsdGlieXRlIGNoYXJhY3RlcnNcbiAgICBjb25zdCBhbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICAgIGNvbnN0IGlzQmVmb3JlID0gYW5jaG9yT2Zmc2V0IDwgZm9jdXNPZmZzZXQ7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBpc0JlZm9yZSA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzQmVmb3JlID8gZm9jdXNPZmZzZXQgOiBhbmNob3JPZmZzZXQ7XG4gICAgY29uc3QgY2hhcmFjdGVyT2Zmc2V0ID0gZW5kT2Zmc2V0IC0gMTtcbiAgICBpZiAoc3RhcnRPZmZzZXQgIT09IGNoYXJhY3Rlck9mZnNldCkge1xuICAgICAgY29uc3QgdGV4dCA9IGFuY2hvck5vZGUuZ2V0VGV4dENvbnRlbnQoKS5zbGljZShzdGFydE9mZnNldCwgZW5kT2Zmc2V0KTtcbiAgICAgIGlmIChzaG91bGREZWxldGVFeGFjdGx5T25lQ29kZVVuaXQodGV4dCkpIHtcbiAgICAgICAgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgICAgICBmb2N1cy5zZXQoZm9jdXMua2V5LCBjaGFyYWN0ZXJPZmZzZXQsIGZvY3VzLnR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuY2hvci5zZXQoYW5jaG9yLmtleSwgY2hhcmFjdGVyT2Zmc2V0LCBhbmNob3IudHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZERlbGV0ZUV4YWN0bHlPbmVDb2RlVW5pdCh0ZXh0KSB7XG4gIHtcbiAgICBpZiAoISh0ZXh0Lmxlbmd0aCA+IDEpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYHNob3VsZERlbGV0ZUV4YWN0bHlPbmVDb2RlVW5pdDogZXhwZWN0aW5nIHRvIGJlIGNhbGxlZCBvbmx5IHdpdGggc2VxdWVuY2VzIG9mIHR3byBvciBtb3JlIGNvZGUgdW5pdHNgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICEoZG9lc0NvbnRhaW5TdXJyb2dhdGVQYWlyKHRleHQpIHx8IGRvZXNDb250YWluRW1vamkodGV4dCkpO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSB3YWxsIG9mIHRleHQgaW4gJHVwZGF0ZUNhcmV0U2VsZWN0aW9uRm9yVW5pY29kZUNoYXJhY3RlciwgeW91J2RcbiAqIHRoaW5rIHRoYXQgdGhlIHNvbHV0aW9uIG1pZ2h0IGJlIGNvbXBsZXgsIGJ1dCB0aGUgb25seSBjdXJyZW50bHkga25vd25cbiAqIGNhc2VzIGdpdmVuIHRoZSBhYm92ZSBjb25zdHJhaW50cyB3aGVyZSB3ZSB3YW50IHRvIGRlbGV0ZSBhIHdob2xlIGdyYXBoZW1lXG4gKiBhcmUgd2hlbiBlbW9qaSBpcyBpbnZvbHZlZC4gU2luY2UgRVM2IHdlIGNhbiB1c2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlc1xuICogaW4gcmVnZXhwIHdoaWNoIG1ha2VzIHRoaXMgc2ltcGxlLlxuICpcbiAqIEl0IG1heSBtYWtlIHNlbnNlIHRvIGFkZCB0byB0aGlzIGhldXJpc3RpYyBpbiB0aGUgZnV0dXJlIGlmIG90aGVyXG4gKiBlZGdlIGNhc2VzIGFyZSBkaXNjb3ZlcmVkLCB3aGljaCBpcyB3aHkgZGV0YWlsZWQgbm90ZXMgcmVtYWluLlxuICpcbiAqIFRoaXMgaXMgaW1wbGVtZW50ZWQgd2l0aCBydW50aW1lIGZlYXR1cmUgZGV0ZWN0aW9uIGFuZCB3aWxsIGFsd2F5c1xuICogcmV0dXJuIGZhbHNlIG9uIHByZS0yMDIwIHBsYXRmb3JtcyB0aGF0IGRvIG5vdCBoYXZlIHVuaWNvZGUgY2hhcmFjdGVyXG4gKiBjbGFzcyBzdXBwb3J0LlxuICovXG5jb25zdCBkb2VzQ29udGFpbkVtb2ppID0gKCgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAoJ1xcXFxwe0Vtb2ppfScsICd1Jyk7XG4gICAgY29uc3QgdGVzdCA9IHJlLnRlc3QuYmluZChyZSk7XG4gICAgLy8gU2FuaXR5IGNoZWNrIGEgZmV3IGVtb2ppIHRvIG1ha2Ugc3VyZSB0aGUgcmVnZXhwIHdhcyBwYXJzZWRcbiAgICAvLyBhbmQgd29ya3MgY29ycmVjdGx5LiBBbnkgb25lIG9mIHRoZXNlIHNob3VsZCBiZSBzdWZmaWNpZW50LFxuICAgIC8vIGJ1dCB0aGV5J3JlIGNoZWFwIGFuZCBpdCBvbmx5IHJ1bnMgb25jZS5cbiAgICBpZiAoXG4gICAgLy8gRW1vamkgaW4gdGhlIEJNUCAoaGVhcnQpIHdpdGggdmFyaWF0aW9uIHNlbGVjdG9yXG4gICAgdGVzdCgnXFx1Mjc2NFxcdWZlMGYnKSAmJlxuICAgIC8vIEVtb2ppIGluIHRoZSBCTVAgKCMpIHdpdGggdmFyaWF0aW9uIHNlbGVjdG9yXG4gICAgdGVzdCgnI1xcdWZlMGZcXHUyMGUzJykgJiZcbiAgICAvLyBFbW9qaSBvdXRzaWRlIHRoZSBCTVAgKHRodW1icyB1cCkgdGhhdCBpcyBlbmNvZGVkIHdpdGggYSBzdXJyb2dhdGUgcGFpclxuICAgIHRlc3QoJ1xcdWQ4M2RcXHVkYzRkJykpIHtcbiAgICAgIHJldHVybiB0ZXN0O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFN5bnRheEVycm9yXG4gIH1cbiAgLy8gZmFsbGJhY2ssIHN1cnJvZ2F0ZSBwYWlyIGFscmVhZHkgY2hlY2tlZFxuICByZXR1cm4gKCkgPT4gZmFsc2U7XG59KSgpO1xuZnVuY3Rpb24gJHJlbW92ZVNlZ21lbnQobm9kZSwgaXNCYWNrd2FyZCwgb2Zmc2V0KSB7XG4gIGNvbnN0IHRleHROb2RlID0gbm9kZTtcbiAgY29uc3QgdGV4dENvbnRlbnQgPSB0ZXh0Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICBjb25zdCBzcGxpdCA9IHRleHRDb250ZW50LnNwbGl0KC8oPz1cXHMpL2cpO1xuICBjb25zdCBzcGxpdExlbmd0aCA9IHNwbGl0Lmxlbmd0aDtcbiAgbGV0IHNlZ21lbnRPZmZzZXQgPSAwO1xuICBsZXQgcmVzdG9yZU9mZnNldCA9IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3BsaXRMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHRleHQgPSBzcGxpdFtpXTtcbiAgICBjb25zdCBpc0xhc3QgPSBpID09PSBzcGxpdExlbmd0aCAtIDE7XG4gICAgcmVzdG9yZU9mZnNldCA9IHNlZ21lbnRPZmZzZXQ7XG4gICAgc2VnbWVudE9mZnNldCArPSB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoaXNCYWNrd2FyZCAmJiBzZWdtZW50T2Zmc2V0ID09PSBvZmZzZXQgfHwgc2VnbWVudE9mZnNldCA+IG9mZnNldCB8fCBpc0xhc3QpIHtcbiAgICAgIHNwbGl0LnNwbGljZShpLCAxKTtcbiAgICAgIGlmIChpc0xhc3QpIHtcbiAgICAgICAgcmVzdG9yZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBuZXh0VGV4dENvbnRlbnQgPSBzcGxpdC5qb2luKCcnKS50cmltKCk7XG4gIGlmIChuZXh0VGV4dENvbnRlbnQgPT09ICcnKSB7XG4gICAgdGV4dE5vZGUucmVtb3ZlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGV4dE5vZGUuc2V0VGV4dENvbnRlbnQobmV4dFRleHRDb250ZW50KTtcbiAgICB0ZXh0Tm9kZS5zZWxlY3QocmVzdG9yZU9mZnNldCwgcmVzdG9yZU9mZnNldCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNob3VsZFJlc29sdmVBbmNlc3RvcihyZXNvbHZlZEVsZW1lbnQsIHJlc29sdmVkT2Zmc2V0LCBsYXN0UG9pbnQpIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZWRFbGVtZW50LmdldFBhcmVudCgpO1xuICByZXR1cm4gbGFzdFBvaW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gbnVsbCB8fCAhcGFyZW50LmNhbkJlRW1wdHkoKSB8fCBwYXJlbnQgIT09IGxhc3RQb2ludC5nZXROb2RlKCk7XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnQoZG9tLCBvZmZzZXQsIGxhc3RQb2ludCwgZWRpdG9yKSB7XG4gIGxldCByZXNvbHZlZE9mZnNldCA9IG9mZnNldDtcbiAgbGV0IHJlc29sdmVkTm9kZTtcbiAgLy8gSWYgd2UgaGF2ZSBzZWxlY3Rpb24gb24gYW4gZWxlbWVudCwgd2Ugd2lsbFxuICAvLyBuZWVkIHRvIGZpZ3VyZSBvdXQgKHVzaW5nIHRoZSBvZmZzZXQpIHdoYXQgdGV4dFxuICAvLyBub2RlIHNob3VsZCBiZSBzZWxlY3RlZC5cblxuICBpZiAoaXNIVE1MRWxlbWVudChkb20pKSB7XG4gICAgLy8gUmVzb2x2ZSBlbGVtZW50IHRvIGEgRWxlbWVudE5vZGUsIG9yIFRleHROb2RlLCBvciBudWxsXG4gICAgbGV0IG1vdmVTZWxlY3Rpb25Ub0VuZCA9IGZhbHNlO1xuICAgIC8vIEdpdmVuIHdlJ3JlIG1vdmluZyBzZWxlY3Rpb24gdG8gYW5vdGhlciBub2RlLCBzZWxlY3Rpb24gaXNcbiAgICAvLyBkZWZpbml0ZWx5IGRpcnR5LlxuICAgIC8vIFdlIHVzZSB0aGUgYW5jaG9yIHRvIGZpbmQgd2hpY2ggY2hpbGQgbm9kZSB0byBzZWxlY3RcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gZG9tLmNoaWxkTm9kZXM7XG4gICAgY29uc3QgY2hpbGROb2Rlc0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudCA9IGVkaXRvci5fYmxvY2tDdXJzb3JFbGVtZW50O1xuICAgIC8vIElmIHRoZSBhbmNob3IgaXMgdGhlIHNhbWUgYXMgbGVuZ3RoLCB0aGVuIHRoaXMgbWVhbnMgd2VcbiAgICAvLyBuZWVkIHRvIHNlbGVjdCB0aGUgdmVyeSBsYXN0IHRleHQgbm9kZS5cbiAgICBpZiAocmVzb2x2ZWRPZmZzZXQgPT09IGNoaWxkTm9kZXNMZW5ndGgpIHtcbiAgICAgIG1vdmVTZWxlY3Rpb25Ub0VuZCA9IHRydWU7XG4gICAgICByZXNvbHZlZE9mZnNldCA9IGNoaWxkTm9kZXNMZW5ndGggLSAxO1xuICAgIH1cbiAgICBsZXQgY2hpbGRET00gPSBjaGlsZE5vZGVzW3Jlc29sdmVkT2Zmc2V0XTtcbiAgICBsZXQgaGFzQmxvY2tDdXJzb3IgPSBmYWxzZTtcbiAgICBpZiAoY2hpbGRET00gPT09IGJsb2NrQ3Vyc29yRWxlbWVudCkge1xuICAgICAgY2hpbGRET00gPSBjaGlsZE5vZGVzW3Jlc29sdmVkT2Zmc2V0ICsgMV07XG4gICAgICBoYXNCbG9ja0N1cnNvciA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yRWxlbWVudFBhcmVudCA9IGJsb2NrQ3Vyc29yRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgaWYgKGRvbSA9PT0gYmxvY2tDdXJzb3JFbGVtZW50UGFyZW50KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrQ3Vyc29yT2Zmc2V0ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChibG9ja0N1cnNvckVsZW1lbnRQYXJlbnQuY2hpbGRyZW4sIGJsb2NrQ3Vyc29yRWxlbWVudCk7XG4gICAgICAgIGlmIChvZmZzZXQgPiBibG9ja0N1cnNvck9mZnNldCkge1xuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0LS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmVzb2x2ZWROb2RlID0gJGdldE5vZGVGcm9tRE9NKGNoaWxkRE9NKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUocmVzb2x2ZWROb2RlKSkge1xuICAgICAgcmVzb2x2ZWRPZmZzZXQgPSAkZ2V0VGV4dE5vZGVPZmZzZXQocmVzb2x2ZWROb2RlLCBtb3ZlU2VsZWN0aW9uVG9FbmQgPyAnbmV4dCcgOiAncHJldmlvdXMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHJlc29sdmVkRWxlbWVudCA9ICRnZXROb2RlRnJvbURPTShkb20pO1xuICAgICAgLy8gRW5zdXJlIHJlc29sdmVkRWxlbWVudCBpcyBhY3R1YWxseSBhIGVsZW1lbnQuXG4gICAgICBpZiAocmVzb2x2ZWRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHJlc29sdmVkRWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkocmVzb2x2ZWRFbGVtZW50LmdldEtleSgpKTtcbiAgICAgICAgaWYgKCEoZWxlbWVudERPTSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludDogbm9kZSBpbiBET00gYnV0IG5vdCBrZXlUb0RPTU1hcGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNsb3QgPSByZXNvbHZlZEVsZW1lbnQuZ2V0RE9NU2xvdChlbGVtZW50RE9NKTtcbiAgICAgICAgW3Jlc29sdmVkRWxlbWVudCwgcmVzb2x2ZWRPZmZzZXRdID0gc2xvdC5yZXNvbHZlQ2hpbGRJbmRleChyZXNvbHZlZEVsZW1lbnQsIGVsZW1lbnRET00sIGRvbSwgb2Zmc2V0KTtcbiAgICAgICAgLy8gVGhpcyBpcyBqdXN0IGEgdHlwZXNjcmlwdCB3b3JrYXJvdW5kLCBpdCBpcyB0cnVlIGJ1dCBsb3N0IGR1ZSB0byBtdXRhYmlsaXR5XG4gICAgICAgIGlmICghJGlzRWxlbWVudE5vZGUocmVzb2x2ZWRFbGVtZW50KSkge1xuICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50OiByZXNvbHZlZEVsZW1lbnQgaXMgbm90IGFuIEVsZW1lbnROb2RlYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1vdmVTZWxlY3Rpb25Ub0VuZCAmJiByZXNvbHZlZE9mZnNldCA+PSByZXNvbHZlZEVsZW1lbnQuZ2V0Q2hpbGRyZW5TaXplKCkpIHtcbiAgICAgICAgICByZXNvbHZlZE9mZnNldCA9IE1hdGgubWF4KDAsIHJlc29sdmVkRWxlbWVudC5nZXRDaGlsZHJlblNpemUoKSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZCA9IHJlc29sdmVkRWxlbWVudC5nZXRDaGlsZEF0SW5kZXgocmVzb2x2ZWRPZmZzZXQpO1xuICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpICYmIHNob3VsZFJlc29sdmVBbmNlc3RvcihjaGlsZCwgcmVzb2x2ZWRPZmZzZXQsIGxhc3RQb2ludCkpIHtcbiAgICAgICAgICBjb25zdCBkZXNjZW5kYW50ID0gbW92ZVNlbGVjdGlvblRvRW5kID8gY2hpbGQuZ2V0TGFzdERlc2NlbmRhbnQoKSA6IGNoaWxkLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgIGlmIChkZXNjZW5kYW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXNvbHZlZEVsZW1lbnQgPSBjaGlsZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQgPSBkZXNjZW5kYW50O1xuICAgICAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gJGlzRWxlbWVudE5vZGUoY2hpbGQpID8gY2hpbGQgOiBjaGlsZC5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmVkT2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgcmVzb2x2ZWROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgcmVzb2x2ZWRFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICByZXNvbHZlZE9mZnNldCA9ICRnZXRUZXh0Tm9kZU9mZnNldChjaGlsZCwgbW92ZVNlbGVjdGlvblRvRW5kID8gJ25leHQnIDogJ3ByZXZpb3VzJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGQgIT09IHJlc29sdmVkRWxlbWVudCAmJiBtb3ZlU2VsZWN0aW9uVG9FbmQgJiYgIWhhc0Jsb2NrQ3Vyc29yKSB7XG4gICAgICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShyZXNvbHZlZEVsZW1lbnQpKSB7XG4gICAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGludmFyaWFudGApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlZE9mZnNldCA9IE1hdGgubWluKHJlc29sdmVkRWxlbWVudC5nZXRDaGlsZHJlblNpemUoKSwgcmVzb2x2ZWRPZmZzZXQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZXNvbHZlZEVsZW1lbnQuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKTtcbiAgICAgICAgLy8gV2hlbiBzZWxlY3RpbmcgZGVjb3JhdG9ycywgdGhlcmUgY2FuIGJlIHNvbWUgc2VsZWN0aW9uIGlzc3VlcyB3aGVuIHVzaW5nIHJlc29sdmVkT2Zmc2V0LFxuICAgICAgICAvLyBhbmQgaW5zdGVhZCB3ZSBzaG91bGQgYmUgY2hlY2tpbmcgaWYgd2UncmUgdXNpbmcgdGhlIG9mZnNldFxuICAgICAgICBpZiAob2Zmc2V0ID09PSAwICYmICRpc0RlY29yYXRvck5vZGUocmVzb2x2ZWRFbGVtZW50KSAmJiAkZ2V0Tm9kZUZyb21ET00oZG9tKSA9PT0gcmVzb2x2ZWRFbGVtZW50KSB7XG4gICAgICAgICAgcmVzb2x2ZWRPZmZzZXQgPSBpbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlZE9mZnNldCA9IGluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlZEVsZW1lbnQgPSByZXNvbHZlZEVsZW1lbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgICAgfVxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHJlc29sdmVkRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuICRjcmVhdGVQb2ludChyZXNvbHZlZEVsZW1lbnQuX19rZXksIHJlc29sdmVkT2Zmc2V0LCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUZXh0Tm9kZSBvciBudWxsXG4gICAgcmVzb2x2ZWROb2RlID0gJGdldE5vZGVGcm9tRE9NKGRvbSk7XG4gIH1cbiAgaWYgKCEkaXNUZXh0Tm9kZShyZXNvbHZlZE5vZGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuICRjcmVhdGVQb2ludChyZXNvbHZlZE5vZGUuX19rZXksICRnZXRUZXh0Tm9kZU9mZnNldChyZXNvbHZlZE5vZGUsIHJlc29sdmVkT2Zmc2V0LCAnY2xhbXAnKSwgJ3RleHQnKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb25Qb2ludE9uQm91bmRhcnkocG9pbnQsIGlzQmFja3dhcmQsIGlzQ29sbGFwc2VkKSB7XG4gIGNvbnN0IG9mZnNldCA9IHBvaW50Lm9mZnNldDtcbiAgY29uc3Qgbm9kZSA9IHBvaW50LmdldE5vZGUoKTtcbiAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgIGlmICghaXNCYWNrd2FyZCkge1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHByZXZTaWJsaW5nKSAmJiAhaXNDb2xsYXBzZWQgJiYgcHJldlNpYmxpbmcuaXNJbmxpbmUoKSkge1xuICAgICAgICBwb2ludC5zZXQocHJldlNpYmxpbmcuX19rZXksIHByZXZTaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpLCAnZWxlbWVudCcpO1xuICAgICAgfSBlbHNlIGlmICgkaXNUZXh0Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgICAgcG9pbnQuc2V0KHByZXZTaWJsaW5nLl9fa2V5LCBwcmV2U2libGluZy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aCwgJ3RleHQnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpc0NvbGxhcHNlZCB8fCAhaXNCYWNrd2FyZCkgJiYgcHJldlNpYmxpbmcgPT09IG51bGwgJiYgJGlzRWxlbWVudE5vZGUocGFyZW50KSAmJiBwYXJlbnQuaXNJbmxpbmUoKSkge1xuICAgICAgY29uc3QgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShwYXJlbnRTaWJsaW5nKSkge1xuICAgICAgICBwb2ludC5zZXQocGFyZW50U2libGluZy5fX2tleSwgcGFyZW50U2libGluZy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aCwgJ3RleHQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAob2Zmc2V0ID09PSBub2RlLmdldFRleHRDb250ZW50KCkubGVuZ3RoKSB7XG4gICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAoaXNCYWNrd2FyZCAmJiAkaXNFbGVtZW50Tm9kZShuZXh0U2libGluZykgJiYgbmV4dFNpYmxpbmcuaXNJbmxpbmUoKSkge1xuICAgICAgcG9pbnQuc2V0KG5leHRTaWJsaW5nLl9fa2V5LCAwLCAnZWxlbWVudCcpO1xuICAgIH0gZWxzZSBpZiAoKGlzQ29sbGFwc2VkIHx8IGlzQmFja3dhcmQpICYmIG5leHRTaWJsaW5nID09PSBudWxsICYmICRpc0VsZW1lbnROb2RlKHBhcmVudCkgJiYgcGFyZW50LmlzSW5saW5lKCkgJiYgIXBhcmVudC5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSkge1xuICAgICAgY29uc3QgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKCRpc1RleHROb2RlKHBhcmVudFNpYmxpbmcpKSB7XG4gICAgICAgIHBvaW50LnNldChwYXJlbnRTaWJsaW5nLl9fa2V5LCAwLCAndGV4dCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJG5vcm1hbGl6ZVNlbGVjdGlvblBvaW50c0ZvckJvdW5kYXJpZXMoYW5jaG9yLCBmb2N1cywgbGFzdFNlbGVjdGlvbikge1xuICBpZiAoYW5jaG9yLnR5cGUgPT09ICd0ZXh0JyAmJiBmb2N1cy50eXBlID09PSAndGV4dCcpIHtcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gYW5jaG9yLmlzQmVmb3JlKGZvY3VzKTtcbiAgICBjb25zdCBpc0NvbGxhcHNlZCA9IGFuY2hvci5pcyhmb2N1cyk7XG5cbiAgICAvLyBBdHRlbXB0IHRvIG5vcm1hbGl6ZSB0aGUgb2Zmc2V0IHRvIHRoZSBwcmV2aW91cyBzaWJsaW5nIGlmIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHN0YXJ0IG9mIGEgdGV4dCBub2RlIGFuZCB0aGUgc2libGluZyBpcyBhIHRleHQgbm9kZSBvciBpbmxpbmUgZWxlbWVudC5cbiAgICByZXNvbHZlU2VsZWN0aW9uUG9pbnRPbkJvdW5kYXJ5KGFuY2hvciwgaXNCYWNrd2FyZCwgaXNDb2xsYXBzZWQpO1xuICAgIHJlc29sdmVTZWxlY3Rpb25Qb2ludE9uQm91bmRhcnkoZm9jdXMsICFpc0JhY2t3YXJkLCBpc0NvbGxhcHNlZCk7XG4gICAgaWYgKGlzQ29sbGFwc2VkKSB7XG4gICAgICBmb2N1cy5zZXQoYW5jaG9yLmtleSwgYW5jaG9yLm9mZnNldCwgYW5jaG9yLnR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBpZiAoZWRpdG9yLmlzQ29tcG9zaW5nKCkgJiYgZWRpdG9yLl9jb21wb3NpdGlvbktleSAhPT0gYW5jaG9yLmtleSAmJiAkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgbGFzdEFuY2hvciA9IGxhc3RTZWxlY3Rpb24uYW5jaG9yO1xuICAgICAgY29uc3QgbGFzdEZvY3VzID0gbGFzdFNlbGVjdGlvbi5mb2N1cztcbiAgICAgIGFuY2hvci5zZXQobGFzdEFuY2hvci5rZXksIGxhc3RBbmNob3Iub2Zmc2V0LCBsYXN0QW5jaG9yLnR5cGUsIHRydWUpO1xuICAgICAgZm9jdXMuc2V0KGxhc3RGb2N1cy5rZXksIGxhc3RGb2N1cy5vZmZzZXQsIGxhc3RGb2N1cy50eXBlLCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludHMoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQsIGZvY3VzRE9NLCBmb2N1c09mZnNldCwgZWRpdG9yLCBsYXN0U2VsZWN0aW9uKSB7XG4gIGlmIChhbmNob3JET00gPT09IG51bGwgfHwgZm9jdXNET00gPT09IG51bGwgfHwgIWlzU2VsZWN0aW9uV2l0aGluRWRpdG9yKGVkaXRvciwgYW5jaG9yRE9NLCBmb2N1c0RPTSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZXNvbHZlZEFuY2hvclBvaW50ID0gJGludGVybmFsUmVzb2x2ZVNlbGVjdGlvblBvaW50KGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0LCAkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSA/IGxhc3RTZWxlY3Rpb24uYW5jaG9yIDogbnVsbCwgZWRpdG9yKTtcbiAgaWYgKHJlc29sdmVkQW5jaG9yUG9pbnQgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCByZXNvbHZlZEZvY3VzUG9pbnQgPSAkaW50ZXJuYWxSZXNvbHZlU2VsZWN0aW9uUG9pbnQoZm9jdXNET00sIGZvY3VzT2Zmc2V0LCAkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSA/IGxhc3RTZWxlY3Rpb24uZm9jdXMgOiBudWxsLCBlZGl0b3IpO1xuICBpZiAocmVzb2x2ZWRGb2N1c1BvaW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAge1xuICAgICR2YWxpZGF0ZVBvaW50KCdhbmNob3InLCByZXNvbHZlZEFuY2hvclBvaW50KTtcbiAgICAkdmFsaWRhdGVQb2ludCgnZm9jdXMnLCByZXNvbHZlZEZvY3VzUG9pbnQpO1xuICB9XG4gIGlmIChyZXNvbHZlZEFuY2hvclBvaW50LnR5cGUgPT09ICdlbGVtZW50JyAmJiByZXNvbHZlZEZvY3VzUG9pbnQudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9ICRnZXROb2RlRnJvbURPTShhbmNob3JET00pO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9ICRnZXROb2RlRnJvbURPTShmb2N1c0RPTSk7XG4gICAgLy8gRW5zdXJlIGlmIHdlJ3JlIHNlbGVjdGluZyB0aGUgY29udGVudCBvZiBhIGRlY29yYXRvciB0aGF0IHdlXG4gICAgLy8gcmV0dXJuIG51bGwgZm9yIHRoaXMgcG9pbnQsIGFzIGl0J3Mgbm90IGluIHRoZSBjb250cm9sbGVkIHNjb3BlXG4gICAgLy8gb2YgTGV4aWNhbC5cbiAgICBpZiAoJGlzRGVjb3JhdG9yTm9kZShhbmNob3JOb2RlKSAmJiAkaXNEZWNvcmF0b3JOb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBub3JtYWxpemF0aW9uIG9mIHNlbGVjdGlvbiB3aGVuIGl0IGlzIGF0IHRoZSBib3VuZGFyaWVzLlxuICAkbm9ybWFsaXplU2VsZWN0aW9uUG9pbnRzRm9yQm91bmRhcmllcyhyZXNvbHZlZEFuY2hvclBvaW50LCByZXNvbHZlZEZvY3VzUG9pbnQsIGxhc3RTZWxlY3Rpb24pO1xuICByZXR1cm4gW3Jlc29sdmVkQW5jaG9yUG9pbnQsIHJlc29sdmVkRm9jdXNQb2ludF07XG59XG5mdW5jdGlvbiAkaXNCbG9ja0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgcmV0dXJuICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCk7XG59XG5cbi8vIFRoaXMgaXMgdXNlZCB0byBtYWtlIGEgc2VsZWN0aW9uIHdoZW4gdGhlIGV4aXN0aW5nXG4vLyBzZWxlY3Rpb24gaXMgbnVsbCwgaS5lLiBmb3JjaW5nIHNlbGVjdGlvbiBvbiB0aGUgZWRpdG9yXG4vLyB3aGVuIGl0IGN1cnJlbnQgZXhpc3RzIG91dHNpZGUgdGhlIGVkaXRvci5cblxuZnVuY3Rpb24gJGludGVybmFsTWFrZVJhbmdlU2VsZWN0aW9uKGFuY2hvcktleSwgYW5jaG9yT2Zmc2V0LCBmb2N1c0tleSwgZm9jdXNPZmZzZXQsIGFuY2hvclR5cGUsIGZvY3VzVHlwZSkge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBSYW5nZVNlbGVjdGlvbigkY3JlYXRlUG9pbnQoYW5jaG9yS2V5LCBhbmNob3JPZmZzZXQsIGFuY2hvclR5cGUpLCAkY3JlYXRlUG9pbnQoZm9jdXNLZXksIGZvY3VzT2Zmc2V0LCBmb2N1c1R5cGUpLCAwLCAnJyk7XG4gIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gIGVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IGFuY2hvciA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIGNvbnN0IGZvY3VzID0gJGNyZWF0ZVBvaW50KCdyb290JywgMCwgJ2VsZW1lbnQnKTtcbiAgcmV0dXJuIG5ldyBSYW5nZVNlbGVjdGlvbihhbmNob3IsIGZvY3VzLCAwLCAnJyk7XG59XG5mdW5jdGlvbiAkY3JlYXRlTm9kZVNlbGVjdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBOb2RlU2VsZWN0aW9uKG5ldyBTZXQoKSk7XG59XG5mdW5jdGlvbiAkaW50ZXJuYWxDcmVhdGVTZWxlY3Rpb24oZWRpdG9yLCBldmVudCkge1xuICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZ2V0V2luZG93KGVkaXRvcikpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24obGFzdFNlbGVjdGlvbikgfHwgbGFzdFNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuICRpbnRlcm5hbENyZWF0ZVJhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24sIGRvbVNlbGVjdGlvbiwgZWRpdG9yLCBldmVudCk7XG4gIH1cbiAgcmV0dXJuIGxhc3RTZWxlY3Rpb24uY2xvbmUoKTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVSYW5nZVNlbGVjdGlvbkZyb21Eb20oZG9tU2VsZWN0aW9uLCBlZGl0b3IpIHtcbiAgcmV0dXJuICRpbnRlcm5hbENyZWF0ZVJhbmdlU2VsZWN0aW9uKG51bGwsIGRvbVNlbGVjdGlvbiwgZWRpdG9yLCBudWxsKTtcbn1cbmZ1bmN0aW9uICRpbnRlcm5hbENyZWF0ZVJhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24sIGRvbVNlbGVjdGlvbiwgZWRpdG9yLCBldmVudCkge1xuICBjb25zdCB3aW5kb3dPYmogPSBlZGl0b3IuX3dpbmRvdztcbiAgaWYgKHdpbmRvd09iaiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFdoZW4gd2UgY3JlYXRlIGEgc2VsZWN0aW9uLCB3ZSB0cnkgdG8gdXNlIHRoZSBwcmV2aW91c1xuICAvLyBzZWxlY3Rpb24gd2hlcmUgcG9zc2libGUsIHVubGVzcyBhbiBhY3R1YWwgdXNlciBzZWxlY3Rpb25cbiAgLy8gY2hhbmdlIGhhcyBvY2N1cnJlZC4gV2hlbiB3ZSBkbyBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBzZWxlY3Rpb25cbiAgLy8gd2UgdmFsaWRhdGUgd2UgY2FuIGhhdmUgdGV4dCBub2RlcyBmb3IgYm90aCBhbmNob3IgYW5kIGZvY3VzXG4gIC8vIG5vZGVzLiBJZiB0aGF0IGhvbGRzIHRydWUsIHdlIHRoZW4gcmV0dXJuIHRoYXQgc2VsZWN0aW9uXG4gIC8vIGFzIGEgbXV0YWJsZSBvYmplY3QgdGhhdCB3ZSB1c2UgZm9yIHRoZSBlZGl0b3Igc3RhdGUgZm9yIHRoaXNcbiAgLy8gdXBkYXRlIGN5Y2xlLiBJZiBhIHNlbGVjdGlvbiBnZXRzIGNoYW5nZWQsIGFuZCByZXF1aXJlcyBhXG4gIC8vIHVwZGF0ZSB0byBuYXRpdmUgRE9NIHNlbGVjdGlvbiwgaXQgZ2V0cyBtYXJrZWQgYXMgXCJkaXJ0eVwiLlxuICAvLyBJZiB0aGUgc2VsZWN0aW9uIGNoYW5nZXMsIGJ1dCBtYXRjaGVzIHdpdGggdGhlIGV4aXN0aW5nXG4gIC8vIERPTSBzZWxlY3Rpb24sIHRoZW4gd2Ugb25seSBuZWVkIHRvIHN5bmMgaXQuIE90aGVyd2lzZSxcbiAgLy8gd2UgZ2VuZXJhbGx5IGJhaWwgb3V0IG9mIGRvaW5nIGFuIHVwZGF0ZSB0byBzZWxlY3Rpb24gZHVyaW5nXG4gIC8vIHJlY29uY2lsaWF0aW9uIHVubGVzcyB0aGVyZSBhcmUgZGlydHkgbm9kZXMgdGhhdCBuZWVkXG4gIC8vIHJlY29uY2lsaW5nLlxuXG4gIGNvbnN0IHdpbmRvd0V2ZW50ID0gZXZlbnQgfHwgd2luZG93T2JqLmV2ZW50O1xuICBjb25zdCBldmVudFR5cGUgPSB3aW5kb3dFdmVudCA/IHdpbmRvd0V2ZW50LnR5cGUgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGlzU2VsZWN0aW9uQ2hhbmdlID0gZXZlbnRUeXBlID09PSAnc2VsZWN0aW9uY2hhbmdlJztcbiAgY29uc3QgdXNlRE9NU2VsZWN0aW9uID0gIWdldElzUHJvY2Vzc2luZ011dGF0aW9ucygpICYmIChpc1NlbGVjdGlvbkNoYW5nZSB8fCBldmVudFR5cGUgPT09ICdiZWZvcmVpbnB1dCcgfHwgZXZlbnRUeXBlID09PSAnY29tcG9zaXRpb25zdGFydCcgfHwgZXZlbnRUeXBlID09PSAnY29tcG9zaXRpb25lbmQnIHx8IGV2ZW50VHlwZSA9PT0gJ2NsaWNrJyAmJiB3aW5kb3dFdmVudCAmJiB3aW5kb3dFdmVudC5kZXRhaWwgPT09IDMgfHwgZXZlbnRUeXBlID09PSAnZHJvcCcgfHwgZXZlbnRUeXBlID09PSB1bmRlZmluZWQpO1xuICBsZXQgYW5jaG9yRE9NLCBmb2N1c0RPTSwgYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldDtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSB8fCB1c2VET01TZWxlY3Rpb24pIHtcbiAgICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgYW5jaG9yRE9NID0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgZm9jdXNET00gPSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlO1xuICAgIGFuY2hvck9mZnNldCA9IGRvbVNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gICAgZm9jdXNPZmZzZXQgPSBkb21TZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG4gICAgaWYgKGlzU2VsZWN0aW9uQ2hhbmdlICYmICRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pICYmICFpc1NlbGVjdGlvbldpdGhpbkVkaXRvcihlZGl0b3IsIGFuY2hvckRPTSwgZm9jdXNET00pKSB7XG4gICAgICByZXR1cm4gbGFzdFNlbGVjdGlvbi5jbG9uZSgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGFzdFNlbGVjdGlvbi5jbG9uZSgpO1xuICB9XG4gIC8vIExldCdzIHJlc29sdmUgdGhlIHRleHQgbm9kZXMgZnJvbSB0aGUgb2Zmc2V0cyBhbmQgRE9NIG5vZGVzIHdlIGhhdmUgZnJvbVxuICAvLyBuYXRpdmUgc2VsZWN0aW9uLlxuICBjb25zdCByZXNvbHZlZFNlbGVjdGlvblBvaW50cyA9ICRpbnRlcm5hbFJlc29sdmVTZWxlY3Rpb25Qb2ludHMoYW5jaG9yRE9NLCBhbmNob3JPZmZzZXQsIGZvY3VzRE9NLCBmb2N1c09mZnNldCwgZWRpdG9yLCBsYXN0U2VsZWN0aW9uKTtcbiAgaWYgKHJlc29sdmVkU2VsZWN0aW9uUG9pbnRzID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgW3Jlc29sdmVkQW5jaG9yUG9pbnQsIHJlc29sdmVkRm9jdXNQb2ludF0gPSByZXNvbHZlZFNlbGVjdGlvblBvaW50cztcbiAgcmV0dXJuIG5ldyBSYW5nZVNlbGVjdGlvbihyZXNvbHZlZEFuY2hvclBvaW50LCByZXNvbHZlZEZvY3VzUG9pbnQsICEkaXNSYW5nZVNlbGVjdGlvbihsYXN0U2VsZWN0aW9uKSA/IDAgOiBsYXN0U2VsZWN0aW9uLmZvcm1hdCwgISRpc1JhbmdlU2VsZWN0aW9uKGxhc3RTZWxlY3Rpb24pID8gJycgOiBsYXN0U2VsZWN0aW9uLnN0eWxlKTtcbn1cbmZ1bmN0aW9uICR2YWxpZGF0ZVBvaW50KG5hbWUsIHBvaW50KSB7XG4gIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHBvaW50LmtleSk7XG4gIGlmICghKG5vZGUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCR2YWxpZGF0ZVBvaW50OiAke25hbWV9IGtleSAke3BvaW50LmtleX0gbm90IGZvdW5kIGluIGN1cnJlbnQgZWRpdG9yU3RhdGVgKTtcbiAgfVxuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgaWYgKCEkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkdmFsaWRhdGVQb2ludDogJHtuYW1lfSBrZXkgJHtwb2ludC5rZXl9IGlzIG5vdCBhIFRleHROb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICAgIGlmICghKHBvaW50Lm9mZnNldCA8PSBzaXplKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkdmFsaWRhdGVQb2ludDogJHtuYW1lfSBwb2ludC5vZmZzZXQgPiBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpICgke1N0cmluZyhwb2ludC5vZmZzZXQpfSA+ICR7U3RyaW5nKHNpemUpfSlgKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkdmFsaWRhdGVQb2ludDogJHtuYW1lfSBrZXkgJHtwb2ludC5rZXl9IGlzIG5vdCBhbiBFbGVtZW50Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gbm9kZS5nZXRDaGlsZHJlblNpemUoKTtcbiAgICBpZiAoIShwb2ludC5vZmZzZXQgPD0gc2l6ZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJHZhbGlkYXRlUG9pbnQ6ICR7bmFtZX0gcG9pbnQub2Zmc2V0ID4gbm9kZS5nZXRDaGlsZHJlblNpemUoKSAoJHtTdHJpbmcocG9pbnQub2Zmc2V0KX0gPiAke1N0cmluZyhzaXplKX0pYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkZ2V0U2VsZWN0aW9uKCkge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIHJldHVybiBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGdldFByZXZpb3VzU2VsZWN0aW9uKCkge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fZWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICR1cGRhdGVFbGVtZW50U2VsZWN0aW9uT25DcmVhdGVEZWxldGVOb2RlKHNlbGVjdGlvbiwgcGFyZW50Tm9kZSwgbm9kZU9mZnNldCwgdGltZXMgPSAxKSB7XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBpZiAoIXBhcmVudE5vZGUuaXMoYW5jaG9yTm9kZSkgJiYgIXBhcmVudE5vZGUuaXMoZm9jdXNOb2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYXJlbnRLZXkgPSBwYXJlbnROb2RlLl9fa2V5O1xuICAvLyBTaW5nbGUgbm9kZS4gV2Ugc2hpZnQgc2VsZWN0aW9uIGJ1dCBuZXZlciByZWRpbWVuc2lvbiBpdFxuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBjb25zdCBzZWxlY3Rpb25PZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICAgIGlmIChub2RlT2Zmc2V0IDw9IHNlbGVjdGlvbk9mZnNldCAmJiB0aW1lcyA+IDAgfHwgbm9kZU9mZnNldCA8IHNlbGVjdGlvbk9mZnNldCAmJiB0aW1lcyA8IDApIHtcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbk9mZnNldCA9IE1hdGgubWF4KDAsIHNlbGVjdGlvbk9mZnNldCArIHRpbWVzKTtcbiAgICAgIGFuY2hvci5zZXQocGFyZW50S2V5LCBuZXdTZWxlY3Rpb25PZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICBmb2N1cy5zZXQocGFyZW50S2V5LCBuZXdTZWxlY3Rpb25PZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICAvLyBUaGUgbmV3IHNlbGVjdGlvbiBtaWdodCBwb2ludCB0byB0ZXh0IG5vZGVzLCB0cnkgdG8gcmVzb2x2ZSB0aGVtXG4gICAgICAkdXBkYXRlU2VsZWN0aW9uUmVzb2x2ZVRleHROb2RlcyhzZWxlY3Rpb24pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBNdWx0aXBsZSBub2RlcyBzZWxlY3RlZC4gV2Ugc2hpZnQgb3IgcmVkaW1lbnNpb24gc2VsZWN0aW9uXG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGlzQmFja3dhcmQgPyBmb2N1cyA6IGFuY2hvcjtcbiAgICBjb25zdCBmaXJzdFBvaW50Tm9kZSA9IGZpcnN0UG9pbnQuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGlzQmFja3dhcmQgPyBhbmNob3IgOiBmb2N1cztcbiAgICBjb25zdCBsYXN0UG9pbnROb2RlID0gbGFzdFBvaW50LmdldE5vZGUoKTtcbiAgICBpZiAocGFyZW50Tm9kZS5pcyhmaXJzdFBvaW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IGZpcnN0UG9pbnRPZmZzZXQgPSBmaXJzdFBvaW50Lm9mZnNldDtcbiAgICAgIGlmIChub2RlT2Zmc2V0IDw9IGZpcnN0UG9pbnRPZmZzZXQgJiYgdGltZXMgPiAwIHx8IG5vZGVPZmZzZXQgPCBmaXJzdFBvaW50T2Zmc2V0ICYmIHRpbWVzIDwgMCkge1xuICAgICAgICBmaXJzdFBvaW50LnNldChwYXJlbnRLZXksIE1hdGgubWF4KDAsIGZpcnN0UG9pbnRPZmZzZXQgKyB0aW1lcyksICdlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJlbnROb2RlLmlzKGxhc3RQb2ludE5vZGUpKSB7XG4gICAgICBjb25zdCBsYXN0UG9pbnRPZmZzZXQgPSBsYXN0UG9pbnQub2Zmc2V0O1xuICAgICAgaWYgKG5vZGVPZmZzZXQgPD0gbGFzdFBvaW50T2Zmc2V0ICYmIHRpbWVzID4gMCB8fCBub2RlT2Zmc2V0IDwgbGFzdFBvaW50T2Zmc2V0ICYmIHRpbWVzIDwgMCkge1xuICAgICAgICBsYXN0UG9pbnQuc2V0KHBhcmVudEtleSwgTWF0aC5tYXgoMCwgbGFzdFBvaW50T2Zmc2V0ICsgdGltZXMpLCAnZWxlbWVudCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBUaGUgbmV3IHNlbGVjdGlvbiBtaWdodCBwb2ludCB0byB0ZXh0IG5vZGVzLCB0cnkgdG8gcmVzb2x2ZSB0aGVtXG4gICR1cGRhdGVTZWxlY3Rpb25SZXNvbHZlVGV4dE5vZGVzKHNlbGVjdGlvbik7XG59XG5mdW5jdGlvbiAkdXBkYXRlU2VsZWN0aW9uUmVzb2x2ZVRleHROb2RlcyhzZWxlY3Rpb24pIHtcbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgY29uc3QgYW5jaG9yT2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXM7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBpZiAoc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0QXRFbmQgPSBhbmNob3JPZmZzZXQgPj0gY2hpbGRTaXplO1xuICAgIGNvbnN0IGNoaWxkID0gYW5jaG9yT2Zmc2V0QXRFbmQgPyBhbmNob3JOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGFuY2hvck5vZGUuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvck9mZnNldCk7XG4gICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG4gICAgICBpZiAoYW5jaG9yT2Zmc2V0QXRFbmQpIHtcbiAgICAgICAgbmV3T2Zmc2V0ID0gY2hpbGQuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG4gICAgICBhbmNob3Iuc2V0KGNoaWxkLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7XG4gICAgICBmb2N1cy5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShhbmNob3JOb2RlKSkge1xuICAgIGNvbnN0IGNoaWxkU2l6ZSA9IGFuY2hvck5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgY29uc3QgYW5jaG9yT2Zmc2V0QXRFbmQgPSBhbmNob3JPZmZzZXQgPj0gY2hpbGRTaXplO1xuICAgIGNvbnN0IGNoaWxkID0gYW5jaG9yT2Zmc2V0QXRFbmQgPyBhbmNob3JOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGFuY2hvck5vZGUuZ2V0Q2hpbGRBdEluZGV4KGFuY2hvck9mZnNldCk7XG4gICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG4gICAgICBpZiAoYW5jaG9yT2Zmc2V0QXRFbmQpIHtcbiAgICAgICAgbmV3T2Zmc2V0ID0gY2hpbGQuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG4gICAgICBhbmNob3Iuc2V0KGNoaWxkLl9fa2V5LCBuZXdPZmZzZXQsICd0ZXh0Jyk7XG4gICAgfVxuICB9XG4gIGlmICgkaXNFbGVtZW50Tm9kZShmb2N1c05vZGUpKSB7XG4gICAgY29uc3QgY2hpbGRTaXplID0gZm9jdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IGZvY3VzT2Zmc2V0QXRFbmQgPSBmb2N1c09mZnNldCA+PSBjaGlsZFNpemU7XG4gICAgY29uc3QgY2hpbGQgPSBmb2N1c09mZnNldEF0RW5kID8gZm9jdXNOb2RlLmdldENoaWxkQXRJbmRleChjaGlsZFNpemUgLSAxKSA6IGZvY3VzTm9kZS5nZXRDaGlsZEF0SW5kZXgoZm9jdXNPZmZzZXQpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgIGxldCBuZXdPZmZzZXQgPSAwO1xuICAgICAgaWYgKGZvY3VzT2Zmc2V0QXRFbmQpIHtcbiAgICAgICAgbmV3T2Zmc2V0ID0gY2hpbGQuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICB9XG4gICAgICBmb2N1cy5zZXQoY2hpbGQuX19rZXksIG5ld09mZnNldCwgJ3RleHQnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGx5U2VsZWN0aW9uVHJhbnNmb3JtcyhuZXh0RWRpdG9yU3RhdGUsIGVkaXRvcikge1xuICBjb25zdCBwcmV2RWRpdG9yU3RhdGUgPSBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9IHByZXZFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBuZXh0U2VsZWN0aW9uID0gbmV4dEVkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGFuY2hvciA9IG5leHRTZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gbmV4dFNlbGVjdGlvbi5mb2N1cztcbiAgICBsZXQgYW5jaG9yTm9kZTtcbiAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBhbmNob3JOb2RlLnNlbGVjdGlvblRyYW5zZm9ybShwcmV2U2VsZWN0aW9uLCBuZXh0U2VsZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgaWYgKGFuY2hvck5vZGUgIT09IGZvY3VzTm9kZSkge1xuICAgICAgICBmb2N1c05vZGUuc2VsZWN0aW9uVHJhbnNmb3JtKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbW92ZVNlbGVjdGlvblBvaW50VG9TaWJsaW5nKHBvaW50LCBub2RlLCBwYXJlbnQsIHByZXZTaWJsaW5nLCBuZXh0U2libGluZykge1xuICBsZXQgc2libGluZ0tleSA9IG51bGw7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBsZXQgdHlwZSA9IG51bGw7XG4gIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgIHNpYmxpbmdLZXkgPSBwcmV2U2libGluZy5fX2tleTtcbiAgICBpZiAoJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICBvZmZzZXQgPSBwcmV2U2libGluZy5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgfSBlbHNlIGlmICgkaXNFbGVtZW50Tm9kZShwcmV2U2libGluZykpIHtcbiAgICAgIG9mZnNldCA9IHByZXZTaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgICAgdHlwZSA9ICdlbGVtZW50JztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzaWJsaW5nS2V5ID0gbmV4dFNpYmxpbmcuX19rZXk7XG4gICAgICBpZiAoJGlzVGV4dE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIHR5cGUgPSAndGV4dCc7XG4gICAgICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICB0eXBlID0gJ2VsZW1lbnQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoc2libGluZ0tleSAhPT0gbnVsbCAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgcG9pbnQuc2V0KHNpYmxpbmdLZXksIG9mZnNldCwgdHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0ID0gbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpO1xuICAgIGlmIChvZmZzZXQgPT09IC0xKSB7XG4gICAgICAvLyBNb3ZlIHNlbGVjdGlvbiB0byBlbmQgb2YgcGFyZW50XG4gICAgICBvZmZzZXQgPSBwYXJlbnQuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgfVxuICAgIHBvaW50LnNldChwYXJlbnQuX19rZXksIG9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0UG9pbnRPZmZzZXRGb3JNZXJnZWRTaWJsaW5nKHBvaW50LCBpc0JlZm9yZSwga2V5LCB0YXJnZXQsIHRleHRMZW5ndGgpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHBvaW50LnNldChrZXksIHBvaW50Lm9mZnNldCArIChpc0JlZm9yZSA/IDAgOiB0ZXh0TGVuZ3RoKSwgJ3RleHQnKTtcbiAgfSBlbHNlIGlmIChwb2ludC5vZmZzZXQgPiB0YXJnZXQuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSkge1xuICAgIHBvaW50LnNldChwb2ludC5rZXksIHBvaW50Lm9mZnNldCAtIDEsICdlbGVtZW50Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldERPTVNlbGVjdGlvbkJhc2VBbmRFeHRlbnQoZG9tU2VsZWN0aW9uLCBuZXh0QW5jaG9yRE9NLCBuZXh0QW5jaG9yT2Zmc2V0LCBuZXh0Rm9jdXNET00sIG5leHRGb2N1c09mZnNldCkge1xuICAvLyBBcHBseSB0aGUgdXBkYXRlZCBzZWxlY3Rpb24gdG8gdGhlIERPTS4gTm90ZTogdGhpcyB3aWxsIHRyaWdnZXJcbiAgLy8gYSBcInNlbGVjdGlvbmNoYW5nZVwiIGV2ZW50LCBhbHRob3VnaCBpdCB3aWxsIGJlIGFzeW5jaHJvbm91cy5cbiAgdHJ5IHtcbiAgICBkb21TZWxlY3Rpb24uc2V0QmFzZUFuZEV4dGVudChuZXh0QW5jaG9yRE9NLCBuZXh0QW5jaG9yT2Zmc2V0LCBuZXh0Rm9jdXNET00sIG5leHRGb2N1c09mZnNldCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVycm9yLCBjb250aW51ZS4gVGhpcyBjYW4gc29tZXRpbWVzXG4gICAgLy8gb2NjdXIgd2l0aCBGRiBhbmQgdGhlcmUncyBubyBnb29kIHJlYXNvbiBhcyB0byB3aHkgaXRcbiAgICAvLyBzaG91bGQgaGFwcGVuLlxuICAgIHtcbiAgICAgIGNvbnNvbGUud2FybihlcnJvcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVET01TZWxlY3Rpb24ocHJldlNlbGVjdGlvbiwgbmV4dFNlbGVjdGlvbiwgZWRpdG9yLCBkb21TZWxlY3Rpb24sIHRhZ3MsIHJvb3RFbGVtZW50LCBub2RlQ291bnQpIHtcbiAgY29uc3QgYW5jaG9yRE9NTm9kZSA9IGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlO1xuICBjb25zdCBmb2N1c0RPTU5vZGUgPSBkb21TZWxlY3Rpb24uZm9jdXNOb2RlO1xuICBjb25zdCBhbmNob3JPZmZzZXQgPSBkb21TZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICBjb25zdCBmb2N1c09mZnNldCA9IGRvbVNlbGVjdGlvbi5mb2N1c09mZnNldDtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgLy8gVE9ETzogbWFrZSB0aGlzIG5vdCBoYXJkLWNvZGVkLCBhbmQgYWRkIGFub3RoZXIgY29uZmlnIG9wdGlvblxuICAvLyB0aGF0IG1ha2VzIHRoaXMgY29uZmlndXJhYmxlLlxuICBpZiAodGFncy5oYXMoQ09MTEFCT1JBVElPTl9UQUcpICYmIGFjdGl2ZUVsZW1lbnQgIT09IHJvb3RFbGVtZW50IHx8IGFjdGl2ZUVsZW1lbnQgIT09IG51bGwgJiYgaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQoYWN0aXZlRWxlbWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSkge1xuICAgIC8vIFdlIGRvbid0IHJlbW92ZSBzZWxlY3Rpb24gaWYgdGhlIHByZXZTZWxlY3Rpb24gaXMgbnVsbCBiZWNhdXNlXG4gICAgLy8gb2YgZWRpdG9yLnNldFJvb3RFbGVtZW50KCkuIElmIHRoaXMgb2NjdXJzIG9uIGluaXQgd2hlbiB0aGVcbiAgICAvLyBlZGl0b3IgaXMgYWxyZWFkeSBmb2N1c2VkLCB0aGVuIHRoaXMgY2FuIGNhdXNlIHRoZSBlZGl0b3IgdG9cbiAgICAvLyBsb3NlIGZvY3VzLlxuICAgIGlmIChwcmV2U2VsZWN0aW9uICE9PSBudWxsICYmIGlzU2VsZWN0aW9uV2l0aGluRWRpdG9yKGVkaXRvciwgYW5jaG9yRE9NTm9kZSwgZm9jdXNET01Ob2RlKSkge1xuICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gIGNvbnN0IGZvY3VzID0gbmV4dFNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yLmtleTtcbiAgY29uc3QgZm9jdXNLZXkgPSBmb2N1cy5rZXk7XG4gIGNvbnN0IGFuY2hvckRPTSA9IGdldEVsZW1lbnRCeUtleU9yVGhyb3coZWRpdG9yLCBhbmNob3JLZXkpO1xuICBjb25zdCBmb2N1c0RPTSA9IGdldEVsZW1lbnRCeUtleU9yVGhyb3coZWRpdG9yLCBmb2N1c0tleSk7XG4gIGNvbnN0IG5leHRBbmNob3JPZmZzZXQgPSBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBuZXh0Rm9jdXNPZmZzZXQgPSBmb2N1cy5vZmZzZXQ7XG4gIGNvbnN0IG5leHRGb3JtYXQgPSBuZXh0U2VsZWN0aW9uLmZvcm1hdDtcbiAgY29uc3QgbmV4dFN0eWxlID0gbmV4dFNlbGVjdGlvbi5zdHlsZTtcbiAgY29uc3QgaXNDb2xsYXBzZWQgPSBuZXh0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCk7XG4gIGxldCBuZXh0QW5jaG9yTm9kZSA9IGFuY2hvckRPTTtcbiAgbGV0IG5leHRGb2N1c05vZGUgPSBmb2N1c0RPTTtcbiAgbGV0IGFuY2hvckZvcm1hdE9yU3R5bGVDaGFuZ2VkID0gZmFsc2U7XG4gIGlmIChhbmNob3IudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgbmV4dEFuY2hvck5vZGUgPSBnZXRET01UZXh0Tm9kZShhbmNob3JET00pO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGFuY2hvckZvcm1hdE9yU3R5bGVDaGFuZ2VkID0gYW5jaG9yTm9kZS5nZXRGb3JtYXQoKSAhPT0gbmV4dEZvcm1hdCB8fCBhbmNob3JOb2RlLmdldFN0eWxlKCkgIT09IG5leHRTdHlsZTtcbiAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAndGV4dCcpIHtcbiAgICBhbmNob3JGb3JtYXRPclN0eWxlQ2hhbmdlZCA9IHRydWU7XG4gIH1cbiAgaWYgKGZvY3VzLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIG5leHRGb2N1c05vZGUgPSBnZXRET01UZXh0Tm9kZShmb2N1c0RPTSk7XG4gIH1cblxuICAvLyBJZiB3ZSBjYW4ndCBnZXQgYW4gdW5kZXJseWluZyB0ZXh0IG5vZGUgZm9yIHNlbGVjdGlvbiwgdGhlblxuICAvLyB3ZSBzaG91bGQgYXZvaWQgc2V0dGluZyBzZWxlY3Rpb24gdG8gc29tZXRoaW5nIGluY29ycmVjdC5cbiAgaWYgKG5leHRBbmNob3JOb2RlID09PSBudWxsIHx8IG5leHRGb2N1c05vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlzQ29sbGFwc2VkICYmIChwcmV2U2VsZWN0aW9uID09PSBudWxsIHx8IGFuY2hvckZvcm1hdE9yU3R5bGVDaGFuZ2VkIHx8ICRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIChwcmV2U2VsZWN0aW9uLmZvcm1hdCAhPT0gbmV4dEZvcm1hdCB8fCBwcmV2U2VsZWN0aW9uLnN0eWxlICE9PSBuZXh0U3R5bGUpKSkge1xuICAgIG1hcmtDb2xsYXBzZWRTZWxlY3Rpb25Gb3JtYXQobmV4dEZvcm1hdCwgbmV4dFN0eWxlLCBuZXh0QW5jaG9yT2Zmc2V0LCBhbmNob3JLZXksIHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgfVxuXG4gIC8vIERpZmYgYWdhaW5zdCB0aGUgbmF0aXZlIERPTSBzZWxlY3Rpb24gdG8gZW5zdXJlIHdlIGRvbid0IGRvXG4gIC8vIGFuIHVubmVjZXNzYXJ5IHNlbGVjdGlvbiB1cGRhdGUuIFdlIGFsc28gc2tpcCB0aGlzIGNoZWNrIGlmXG4gIC8vIHdlJ3JlIG1vdmluZyBzZWxlY3Rpb24gdG8gd2l0aGluIGFuIGVsZW1lbnQsIGFzIHRoaXMgY2FuXG4gIC8vIHNvbWV0aW1lcyBiZSBwcm9ibGVtYXRpYyBhcm91bmQgc2Nyb2xsaW5nLlxuICBpZiAoYW5jaG9yT2Zmc2V0ID09PSBuZXh0QW5jaG9yT2Zmc2V0ICYmIGZvY3VzT2Zmc2V0ID09PSBuZXh0Rm9jdXNPZmZzZXQgJiYgYW5jaG9yRE9NTm9kZSA9PT0gbmV4dEFuY2hvck5vZGUgJiYgZm9jdXNET01Ob2RlID09PSBuZXh0Rm9jdXNOb2RlICYmXG4gIC8vIEJhZGx5IGludGVycHJldGVkIHJhbmdlIHNlbGVjdGlvbiB3aGVuIGNvbGxhcHNlZCAtICMxNDgyXG4gICEoZG9tU2VsZWN0aW9uLnR5cGUgPT09ICdSYW5nZScgJiYgaXNDb2xsYXBzZWQpKSB7XG4gICAgLy8gSWYgdGhlIHJvb3QgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGZvY3VzLCBlbnN1cmUgaXQgaGFzIGZvY3VzXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IG51bGwgfHwgIXJvb3RFbGVtZW50LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICByb290RWxlbWVudC5mb2N1cyh7XG4gICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYW5jaG9yLnR5cGUgIT09ICdlbGVtZW50Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFwcGx5IHRoZSB1cGRhdGVkIHNlbGVjdGlvbiB0byB0aGUgRE9NLiBOb3RlOiB0aGlzIHdpbGwgdHJpZ2dlclxuICAvLyBhIFwic2VsZWN0aW9uY2hhbmdlXCIgZXZlbnQsIGFsdGhvdWdoIGl0IHdpbGwgYmUgYXN5bmNocm9ub3VzLlxuICBzZXRET01TZWxlY3Rpb25CYXNlQW5kRXh0ZW50KGRvbVNlbGVjdGlvbiwgbmV4dEFuY2hvck5vZGUsIG5leHRBbmNob3JPZmZzZXQsIG5leHRGb2N1c05vZGUsIG5leHRGb2N1c09mZnNldCk7XG4gIGlmICghdGFncy5oYXMoU0tJUF9TQ1JPTExfSU5UT19WSUVXX1RBRykgJiYgbmV4dFNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHJvb3RFbGVtZW50ICE9PSBudWxsICYmIHJvb3RFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uVGFyZ2V0ID0gJGlzUmFuZ2VTZWxlY3Rpb24obmV4dFNlbGVjdGlvbikgJiYgbmV4dFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnID8gbmV4dEFuY2hvck5vZGUuY2hpbGROb2Rlc1tuZXh0QW5jaG9yT2Zmc2V0XSB8fCBudWxsIDogZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwID8gZG9tU2VsZWN0aW9uLmdldFJhbmdlQXQoMCkgOiBudWxsO1xuICAgIGlmIChzZWxlY3Rpb25UYXJnZXQgIT09IG51bGwpIHtcbiAgICAgIGxldCBzZWxlY3Rpb25SZWN0O1xuICAgICAgaWYgKHNlbGVjdGlvblRhcmdldCBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlKHNlbGVjdGlvblRhcmdldCk7XG4gICAgICAgIHNlbGVjdGlvblJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGVjdGlvblJlY3QgPSBzZWxlY3Rpb25UYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgICBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKGVkaXRvciwgc2VsZWN0aW9uUmVjdCwgcm9vdEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBtYXJrU2VsZWN0aW9uQ2hhbmdlRnJvbURPTVVwZGF0ZSgpO1xufVxuZnVuY3Rpb24gJGluc2VydE5vZGVzKG5vZGVzKSB7XG4gIGxldCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICBzZWxlY3Rpb24gPSAkZ2V0Um9vdCgpLnNlbGVjdEVuZCgpO1xuICB9XG4gIHNlbGVjdGlvbi5pbnNlcnROb2Rlcyhub2Rlcyk7XG59XG5mdW5jdGlvbiAkZ2V0VGV4dENvbnRlbnQoKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKHNlbGVjdGlvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlVGV4dEFuZFNwbGl0QmxvY2soc2VsZWN0aW9uKSB7XG4gIGxldCBzZWxlY3Rpb25fID0gc2VsZWN0aW9uO1xuICBpZiAoIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgc2VsZWN0aW9uXy5yZW1vdmVUZXh0KCk7XG4gIH1cbiAgLy8gQSBuZXcgc2VsZWN0aW9uIGNhbiBvcmlnaW5hdGUgYXMgYSByZXN1bHQgb2Ygbm9kZSByZXBsYWNlbWVudCwgaW4gd2hpY2ggY2FzZSBpcyByZWdpc3RlcmVkIHZpYVxuICAvLyAkc2V0U2VsZWN0aW9uXG4gIGNvbnN0IG5ld1NlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKG5ld1NlbGVjdGlvbikpIHtcbiAgICBzZWxlY3Rpb25fID0gbmV3U2VsZWN0aW9uO1xuICB9XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uXykpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFVuZXhwZWN0ZWQgZGlydHkgc2VsZWN0aW9uIHRvIGJlIG51bGxgKTtcbiAgfVxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb25fLmFuY2hvcjtcbiAgbGV0IG5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICBsZXQgb2Zmc2V0ID0gYW5jaG9yLm9mZnNldDtcbiAgd2hpbGUgKCFJTlRFUk5BTF8kaXNCbG9jayhub2RlKSkge1xuICAgIGNvbnN0IHByZXZOb2RlID0gbm9kZTtcbiAgICBbbm9kZSwgb2Zmc2V0XSA9ICRzcGxpdE5vZGVBdFBvaW50KG5vZGUsIG9mZnNldCk7XG4gICAgaWYgKHByZXZOb2RlLmlzKG5vZGUpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9mZnNldDtcbn1cbmZ1bmN0aW9uICRzcGxpdE5vZGVBdFBvaW50KG5vZGUsIG9mZnNldCkge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICBpZiAoIXBhcmVudCkge1xuICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgJGdldFJvb3QoKS5hcHBlbmQocGFyYWdyYXBoKTtcbiAgICBwYXJhZ3JhcGguc2VsZWN0KCk7XG4gICAgcmV0dXJuIFskZ2V0Um9vdCgpLCAwXTtcbiAgfVxuICBpZiAoJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICBjb25zdCBzcGxpdCA9IG5vZGUuc3BsaXRUZXh0KG9mZnNldCk7XG4gICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtwYXJlbnQsIG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKV07XG4gICAgfVxuICAgIGNvbnN0IHggPSBvZmZzZXQgPT09IDAgPyAwIDogMTtcbiAgICBjb25zdCBpbmRleCA9IHNwbGl0WzBdLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyB4O1xuICAgIHJldHVybiBbcGFyZW50LCBpbmRleF07XG4gIH1cbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSB8fCBvZmZzZXQgPT09IDApIHtcbiAgICByZXR1cm4gW3BhcmVudCwgbm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpXTtcbiAgfVxuICBjb25zdCBmaXJzdFRvQXBwZW5kID0gbm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcbiAgaWYgKGZpcnN0VG9BcHBlbmQpIHtcbiAgICBjb25zdCBpbnNlcnRQb2ludCA9IG5ldyBSYW5nZVNlbGVjdGlvbigkY3JlYXRlUG9pbnQobm9kZS5fX2tleSwgb2Zmc2V0LCAnZWxlbWVudCcpLCAkY3JlYXRlUG9pbnQobm9kZS5fX2tleSwgb2Zmc2V0LCAnZWxlbWVudCcpLCAwLCAnJyk7XG4gICAgY29uc3QgbmV3RWxlbWVudCA9IG5vZGUuaW5zZXJ0TmV3QWZ0ZXIoaW5zZXJ0UG9pbnQpO1xuICAgIGlmIChuZXdFbGVtZW50KSB7XG4gICAgICBuZXdFbGVtZW50LmFwcGVuZChmaXJzdFRvQXBwZW5kLCAuLi5maXJzdFRvQXBwZW5kLmdldE5leHRTaWJsaW5ncygpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtwYXJlbnQsIG5vZGUuZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDFdO1xufVxuZnVuY3Rpb24gJHdyYXBJbmxpbmVOb2Rlcyhub2Rlcykge1xuICAvLyBXZSB0ZW1wb3JhcmlseSBpbnNlcnQgdGhlIHRvcExldmVsTm9kZXMgaW50byBhbiBhcmJpdHJhcnkgRWxlbWVudE5vZGUsXG4gIC8vIHNpbmNlIGluc2VydEFmdGVyIGRvZXMgbm90IHdvcmsgb24gbm9kZXMgdGhhdCBoYXZlIG5vIHBhcmVudCAoVE8tRE86IGZpeCB0aGF0KS5cbiAgY29uc3QgdmlydHVhbFJvb3QgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBsZXQgY3VycmVudEJsb2NrID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICBjb25zdCBpc0xpbmVCcmVha05vZGUgPSAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpO1xuICAgIGlmIChpc0xpbmVCcmVha05vZGUgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiBub2RlLmlzSW5saW5lKCkgfHwgJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpIHx8ICRpc1RleHROb2RlKG5vZGUpIHx8IG5vZGUuaXNQYXJlbnRSZXF1aXJlZCgpKSB7XG4gICAgICBpZiAoY3VycmVudEJsb2NrID09PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRCbG9jayA9IG5vZGUuY3JlYXRlUGFyZW50RWxlbWVudE5vZGUoKTtcbiAgICAgICAgdmlydHVhbFJvb3QuYXBwZW5kKGN1cnJlbnRCbG9jayk7XG4gICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIExpbmVCcmVha05vZGUsIHdlIGp1c3QgbmVlZCB0b1xuICAgICAgICAvLyBhZGQgYW4gZW1wdHkgUGFyYWdyYXBoTm9kZSB0byB0aGUgdG9wTGV2ZWxCbG9ja3MuXG4gICAgICAgIGlmIChpc0xpbmVCcmVha05vZGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRCbG9jayAhPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50QmxvY2suYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2aXJ0dWFsUm9vdC5hcHBlbmQobm9kZSk7XG4gICAgICBjdXJyZW50QmxvY2sgPSBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmlydHVhbFJvb3Q7XG59XG5cbi8qKlxuICogR2V0IGFsbCBub2RlcyBpbiBhIENhcmV0UmFuZ2UgaW4gYSB3YXkgdGhhdCBjb21wbGllcyB3aXRoIGFsbCBvZiB0aGVcbiAqIHF1aXJrcyBvZiB0aGUgb3JpZ2luYWwgUmFuZ2VTZWxlY3Rpb24uZ2V0Tm9kZXMoKS5cbiAqXG4gKiBAcGFyYW0gcmFuZ2UgVGhlIENhcmV0UmFuZ2VcbiAqL1xuZnVuY3Rpb24gJGdldE5vZGVzRnJvbUNhcmV0UmFuZ2VDb21wYXQoXG4vLyBnZXROb2RlcyByZXR1cm5lZCBub2RlcyBpbiBkb2N1bWVudCBvcmRlclxucmFuZ2UpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgY29uc3QgW2JlZm9yZVNsaWNlLCBhZnRlclNsaWNlXSA9IHJhbmdlLmdldFRleHRTbGljZXMoKTtcbiAgaWYgKGJlZm9yZVNsaWNlKSB7XG4gICAgbm9kZXMucHVzaChiZWZvcmVTbGljZS5jYXJldC5vcmlnaW4pO1xuICB9XG4gIGNvbnN0IHNlZW5BbmNlc3RvcnMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHNlZW5FbGVtZW50cyA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBjYXJldCBvZiByYW5nZSkge1xuICAgIGlmICgkaXNDaGlsZENhcmV0KGNhcmV0KSkge1xuICAgICAgLy8gRW11bGF0ZSB0aGUgbGVhZGluZyB1bmRlci1zZWxlY3Rpb24gYmVoYXZpb3Igb2YgZ2V0Tm9kZXMgYnlcbiAgICAgIC8vIGlnbm9yaW5nIHRoZSAnZW50ZXInIG9mIGFueSBFbGVtZW50Tm9kZSB1bnRpbCB3ZSd2ZSBzZWVuIGFcbiAgICAgIC8vIFNpYmxpbmdDYXJldFxuICAgICAgY29uc3Qge1xuICAgICAgICBvcmlnaW5cbiAgICAgIH0gPSBjYXJldDtcbiAgICAgIGlmIChub2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VlbkFuY2VzdG9ycy5hZGQob3JpZ2luKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW5FbGVtZW50cy5hZGQob3JpZ2luKTtcbiAgICAgICAgbm9kZXMucHVzaChvcmlnaW4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9yaWdpblxuICAgICAgfSA9IGNhcmV0O1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShvcmlnaW4pIHx8ICFzZWVuRWxlbWVudHMuaGFzKG9yaWdpbikpIHtcbiAgICAgICAgbm9kZXMucHVzaChvcmlnaW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoYWZ0ZXJTbGljZSkge1xuICAgIG5vZGVzLnB1c2goYWZ0ZXJTbGljZS5jYXJldC5vcmlnaW4pO1xuICB9XG4gIC8vIEVtdWxhdGUgdGhlIHRyYWlsaW5nIHVuZGVyc2VsZWN0aW9uIGJlaGF2aW9yIHdoZW4gdGhlIGxhc3Qgb2Zmc2V0IG9mXG4gIC8vIGFuIGVsZW1lbnQgaXMgc2VsZWN0ZWRcbiAgaWYgKCRpc1NpYmxpbmdDYXJldChyYW5nZS5mb2N1cykgJiYgJGlzRWxlbWVudE5vZGUocmFuZ2UuZm9jdXMub3JpZ2luKSAmJiByYW5nZS5mb2N1cy5nZXROb2RlQXRDYXJldCgpID09PSBudWxsKSB7XG4gICAgZm9yIChsZXQgcmV2ZXJzZUNhcmV0ID0gJGdldENoaWxkQ2FyZXQocmFuZ2UuZm9jdXMub3JpZ2luLCAncHJldmlvdXMnKTsgJGlzQ2hpbGRDYXJldChyZXZlcnNlQ2FyZXQpICYmIHNlZW5BbmNlc3RvcnMuaGFzKHJldmVyc2VDYXJldC5vcmlnaW4pICYmICFyZXZlcnNlQ2FyZXQub3JpZ2luLmlzRW1wdHkoKSAmJiByZXZlcnNlQ2FyZXQub3JpZ2luLmlzKG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdKTsgcmV2ZXJzZUNhcmV0ID0gJGdldEFkamFjZW50Q2hpbGRDYXJldChyZXZlcnNlQ2FyZXQpKSB7XG4gICAgICBzZWVuQW5jZXN0b3JzLmRlbGV0ZShyZXZlcnNlQ2FyZXQub3JpZ2luKTtcbiAgICAgIG5vZGVzLnBvcCgpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAobm9kZXMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IGxhc3RJbmNsdWRlZE5vZGUgPSBub2Rlc1tub2Rlcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobGFzdEluY2x1ZGVkTm9kZSkpIHtcbiAgICAgIGlmIChzZWVuRWxlbWVudHMuaGFzKGxhc3RJbmNsdWRlZE5vZGUpIHx8IGxhc3RJbmNsdWRlZE5vZGUuaXNFbXB0eSgpIHx8IHNlZW5BbmNlc3RvcnMuaGFzKGxhc3RJbmNsdWRlZE5vZGUpKSA7IGVsc2Uge1xuICAgICAgICBub2Rlcy5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIGlmIChub2Rlcy5sZW5ndGggPT09IDAgJiYgcmFuZ2UuaXNDb2xsYXBzZWQoKSkge1xuICAgIC8vIEVtdWxhdGUgdGhlIGNvbGxhcHNlZCBiZWhhdmlvciBvZiBnZXROb2RlcyBieSByZXR1cm5pbmcgdGhlIGRlc2NlbmRhbnRcbiAgICBjb25zdCBub3JtQ2FyZXQgPSAkbm9ybWFsaXplQ2FyZXQocmFuZ2UuYW5jaG9yKTtcbiAgICBjb25zdCBmbGlwcGVkTm9ybUNhcmV0ID0gJG5vcm1hbGl6ZUNhcmV0KHJhbmdlLmFuY2hvci5nZXRGbGlwcGVkKCkpO1xuICAgIGNvbnN0ICRnZXRDYW5kaWRhdGUgPSBjYXJldCA9PiAkaXNUZXh0UG9pbnRDYXJldChjYXJldCkgPyBjYXJldC5vcmlnaW4gOiBjYXJldC5nZXROb2RlQXRDYXJldCgpO1xuICAgIGNvbnN0IG5vZGUgPSAkZ2V0Q2FuZGlkYXRlKG5vcm1DYXJldCkgfHwgJGdldENhbmRpZGF0ZShmbGlwcGVkTm9ybUNhcmV0KSB8fCAocmFuZ2UuYW5jaG9yLmdldE5vZGVBdENhcmV0KCkgPyBub3JtQ2FyZXQub3JpZ2luIDogZmxpcHBlZE5vcm1DYXJldC5vcmlnaW4pO1xuICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIE1vZGlmeSB0aGUgZm9jdXMgb2YgdGhlIGZvY3VzIGFyb3VuZCBwb3NzaWJsZSBkZWNvcmF0b3JzIGFuZCBibG9ja3MgYW5kIHJldHVybiB0cnVlXG4gKiBpZiB0aGUgbW92ZW1lbnQgaXMgZG9uZS5cbiAqL1xuZnVuY3Rpb24gJG1vZGlmeVNlbGVjdGlvbkFyb3VuZERlY29yYXRvcnNBbmRCbG9ja3Moc2VsZWN0aW9uLCBhbHRlciwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHksIG1vZGUgPSAnZGVjb3JhdG9ycy1hbmQtYmxvY2tzJykge1xuICBpZiAoYWx0ZXIgPT09ICdtb3ZlJyAmJiBncmFudWxhcml0eSA9PT0gJ2NoYXJhY3RlcicgJiYgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgLy8gbW92aW5nIGxlZnQgb3IgcmlnaHQgd2hlbiB0aGUgc2VsZWN0aW9uIGlzbid0IGNvbGxhcHNlZCB3aWxsXG4gICAgLy8ganVzdCBzZXQgdGhlIGFuY2hvciB0byB0aGUgZm9jdXMgb3IgdmljZSB2ZXJzYSBkZXBlbmRpbmcgb25cbiAgICAvLyBkaXJlY3Rpb25cbiAgICBjb25zdCBbc3JjLCBkc3RdID0gaXNCYWNrd2FyZCA9PT0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKSA/IFtzZWxlY3Rpb24uZm9jdXMsIHNlbGVjdGlvbi5hbmNob3JdIDogW3NlbGVjdGlvbi5hbmNob3IsIHNlbGVjdGlvbi5mb2N1c107XG4gICAgZHN0LnNldChzcmMua2V5LCBzcmMub2Zmc2V0LCBzcmMudHlwZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgaW5pdGlhbEZvY3VzID0gJGNhcmV0RnJvbVBvaW50KHNlbGVjdGlvbi5mb2N1cywgaXNCYWNrd2FyZCA/ICdwcmV2aW91cycgOiAnbmV4dCcpO1xuICBjb25zdCBpc0xpbmVCb3VuZGFyeSA9IGdyYW51bGFyaXR5ID09PSAnbGluZWJvdW5kYXJ5JztcbiAgY29uc3QgY29sbGFwc2UgPSBhbHRlciA9PT0gJ21vdmUnO1xuICBsZXQgZm9jdXMgPSBpbml0aWFsRm9jdXM7XG4gIGxldCBjaGVja0ZvckJsb2NrID0gbW9kZSA9PT0gJ2RlY29yYXRvcnMtYW5kLWJsb2Nrcyc7XG4gIGlmICghJGlzRXh0ZW5kYWJsZVRleHRQb2ludENhcmV0KGZvY3VzKSkge1xuICAgIGZvciAoY29uc3Qgc2libGluZ0NhcmV0IG9mIGZvY3VzKSB7XG4gICAgICBjaGVja0ZvckJsb2NrID0gZmFsc2U7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9yaWdpblxuICAgICAgfSA9IHNpYmxpbmdDYXJldDtcbiAgICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKG9yaWdpbikgJiYgIW9yaWdpbi5pc0lzb2xhdGVkKCkpIHtcbiAgICAgICAgZm9jdXMgPSBzaWJsaW5nQ2FyZXQ7XG4gICAgICAgIGlmIChpc0xpbmVCb3VuZGFyeSAmJiBvcmlnaW4uaXNJbmxpbmUoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGNoZWNrRm9yQmxvY2spIHtcbiAgICAgIGZvciAoY29uc3QgbmV4dENhcmV0IG9mICRleHRlbmRDYXJldFRvUmFuZ2UoaW5pdGlhbEZvY3VzKS5pdGVyTm9kZUNhcmV0cyhhbHRlciA9PT0gJ2V4dGVuZCcgPyAnc2hhZG93Um9vdCcgOiAncm9vdCcpKSB7XG4gICAgICAgIGlmICgkaXNDaGlsZENhcmV0KG5leHRDYXJldCkpIHtcbiAgICAgICAgICBpZiAoIW5leHRDYXJldC5vcmlnaW4uaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgZm9jdXMgPSBuZXh0Q2FyZXQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKG5leHRDYXJldC5vcmlnaW4pKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoJGlzRGVjb3JhdG9yTm9kZShuZXh0Q2FyZXQub3JpZ2luKSAmJiAhbmV4dENhcmV0Lm9yaWdpbi5pc0lubGluZSgpKSB7XG4gICAgICAgICAgZm9jdXMgPSBuZXh0Q2FyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChmb2N1cyA9PT0gaW5pdGlhbEZvY3VzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFmdGVyIHRoaXMgcG9pbnQgY2hlY2tGb3JCbG9jayBpcyB0cnVlIGlmIGFuZCBvbmx5IGlmIHdlIG1vdmVkIHRvIGFcbiAgLy8gZGlmZmVyZW50IGJsb2NrLCBzbyB3ZSBzaG91bGQgc3RvcCByZWdhcmRsZXNzIG9mIHRoZSBncmFudWxhcml0eVxuICBpZiAoY29sbGFwc2UgJiYgIWlzTGluZUJvdW5kYXJ5ICYmICRpc0RlY29yYXRvck5vZGUoZm9jdXMub3JpZ2luKSAmJiBmb2N1cy5vcmlnaW4uaXNLZXlib2FyZFNlbGVjdGFibGUoKSkge1xuICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gbW92ZSBzZWxlY3Rpb24gZnJvbSByYW5nZSBzZWxlY3Rpb24gdG9cbiAgICAvLyBub2RlIHNlbGVjdGlvbiBvbiB0aGUgbm9kZS5cbiAgICBjb25zdCBub2RlU2VsZWN0aW9uID0gJGNyZWF0ZU5vZGVTZWxlY3Rpb24oKTtcbiAgICBub2RlU2VsZWN0aW9uLmFkZChmb2N1cy5vcmlnaW4uZ2V0S2V5KCkpO1xuICAgICRzZXRTZWxlY3Rpb24obm9kZVNlbGVjdGlvbik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZm9jdXMgPSAkbm9ybWFsaXplQ2FyZXQoZm9jdXMpO1xuICBpZiAoY29sbGFwc2UpIHtcbiAgICAkc2V0UG9pbnRGcm9tQ2FyZXQoc2VsZWN0aW9uLmFuY2hvciwgZm9jdXMpO1xuICB9XG4gICRzZXRQb2ludEZyb21DYXJldChzZWxlY3Rpb24uZm9jdXMsIGZvY3VzKTtcbiAgcmV0dXJuIGNoZWNrRm9yQmxvY2sgfHwgIWlzTGluZUJvdW5kYXJ5O1xufVxuXG5sZXQgYWN0aXZlRWRpdG9yU3RhdGUgPSBudWxsO1xubGV0IGFjdGl2ZUVkaXRvciA9IG51bGw7XG5sZXQgaXNSZWFkT25seU1vZGUgPSBmYWxzZTtcbmxldCBpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yID0gZmFsc2U7XG5sZXQgaW5maW5pdGVUcmFuc2Zvcm1Db3VudCA9IDA7XG5jb25zdCBvYnNlcnZlck9wdGlvbnMgPSB7XG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgc3VidHJlZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkge1xuICByZXR1cm4gaXNSZWFkT25seU1vZGUgfHwgYWN0aXZlRWRpdG9yU3RhdGUgIT09IG51bGwgJiYgYWN0aXZlRWRpdG9yU3RhdGUuX3JlYWRPbmx5O1xufVxuZnVuY3Rpb24gZXJyb3JPblJlYWRPbmx5KCkge1xuICBpZiAoaXNSZWFkT25seU1vZGUpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYENhbm5vdCB1c2UgbWV0aG9kIGluIHJlYWQtb25seSBtb2RlLmApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZXJyb3JPbkluZmluaXRlVHJhbnNmb3JtcygpIHtcbiAgaWYgKGluZmluaXRlVHJhbnNmb3JtQ291bnQgPiA5OSkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgT25lIG9yIG1vcmUgdHJhbnNmb3JtcyBhcmUgZW5kbGVzc2x5IHRyaWdnZXJpbmcgYWRkaXRpb25hbCB0cmFuc2Zvcm1zLiBNYXkgaGF2ZSBlbmNvdW50ZXJlZCBpbmZpbml0ZSByZWN1cnNpb24gY2F1c2VkIGJ5IHRyYW5zZm9ybXMgdGhhdCBoYXZlIHRoZWlyIHByZWNvbmRpdGlvbnMgdG9vIGxvc2UgYW5kL29yIGNvbmZsaWN0IHdpdGggZWFjaCBvdGhlci5gKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEFjdGl2ZUVkaXRvclN0YXRlKCkge1xuICBpZiAoYWN0aXZlRWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFVuYWJsZSB0byBmaW5kIGFuIGFjdGl2ZSBlZGl0b3Igc3RhdGUuIFN0YXRlIGhlbHBlcnMgb3Igbm9kZSBtZXRob2RzIGNhbiBvbmx5IGJlIHVzZWQgc3luY2hyb25vdXNseSBkdXJpbmcgdGhlIGNhbGxiYWNrIG9mIGVkaXRvci51cGRhdGUoKSwgZWRpdG9yLnJlYWQoKSwgb3IgZWRpdG9yU3RhdGUucmVhZCgpLiR7Y29sbGVjdEJ1aWxkSW5mb3JtYXRpb24oKX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFjdGl2ZUVkaXRvclN0YXRlO1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlRWRpdG9yKCkge1xuICBpZiAoYWN0aXZlRWRpdG9yID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBVbmFibGUgdG8gZmluZCBhbiBhY3RpdmUgZWRpdG9yLiBUaGlzIG1ldGhvZCBjYW4gb25seSBiZSB1c2VkIHN5bmNocm9ub3VzbHkgZHVyaW5nIHRoZSBjYWxsYmFjayBvZiBlZGl0b3IudXBkYXRlKCkgb3IgZWRpdG9yLnJlYWQoKS4ke2NvbGxlY3RCdWlsZEluZm9ybWF0aW9uKCl9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhY3RpdmVFZGl0b3I7XG59XG5mdW5jdGlvbiBjb2xsZWN0QnVpbGRJbmZvcm1hdGlvbigpIHtcbiAgbGV0IGNvbXBhdGlibGVFZGl0b3JzID0gMDtcbiAgY29uc3QgaW5jb21wYXRpYmxlRWRpdG9ycyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgdGhpc1ZlcnNpb24gPSBMZXhpY2FsRWRpdG9yLnZlcnNpb247XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbY29udGVudGVkaXRhYmxlXScpKSB7XG4gICAgICBjb25zdCBlZGl0b3IgPSBnZXRFZGl0b3JQcm9wZXJ0eUZyb21ET01Ob2RlKG5vZGUpO1xuICAgICAgaWYgKGlzTGV4aWNhbEVkaXRvcihlZGl0b3IpKSB7XG4gICAgICAgIGNvbXBhdGlibGVFZGl0b3JzKys7XG4gICAgICB9IGVsc2UgaWYgKGVkaXRvcikge1xuICAgICAgICBsZXQgdmVyc2lvbiA9IFN0cmluZyhlZGl0b3IuY29uc3RydWN0b3IudmVyc2lvbiB8fCAnPDAuMTcuMScpO1xuICAgICAgICBpZiAodmVyc2lvbiA9PT0gdGhpc1ZlcnNpb24pIHtcbiAgICAgICAgICB2ZXJzaW9uICs9ICcgKHNlcGFyYXRlbHkgYnVpbHQsIGxpa2VseSBhIGJ1bmRsZXIgY29uZmlndXJhdGlvbiBpc3N1ZSknO1xuICAgICAgICB9XG4gICAgICAgIGluY29tcGF0aWJsZUVkaXRvcnMuYWRkKHZlcnNpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgb3V0cHV0ID0gYCBEZXRlY3RlZCBvbiB0aGUgcGFnZTogJHtjb21wYXRpYmxlRWRpdG9yc30gY29tcGF0aWJsZSBlZGl0b3Iocykgd2l0aCB2ZXJzaW9uICR7dGhpc1ZlcnNpb259YDtcbiAgaWYgKGluY29tcGF0aWJsZUVkaXRvcnMuc2l6ZSkge1xuICAgIG91dHB1dCArPSBgIGFuZCBpbmNvbXBhdGlibGUgZWRpdG9ycyB3aXRoIHZlcnNpb25zICR7QXJyYXkuZnJvbShpbmNvbXBhdGlibGVFZGl0b3JzKS5qb2luKCcsICcpfWA7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIGludGVybmFsR2V0QWN0aXZlRWRpdG9yKCkge1xuICByZXR1cm4gYWN0aXZlRWRpdG9yO1xufVxuZnVuY3Rpb24gaW50ZXJuYWxHZXRBY3RpdmVFZGl0b3JTdGF0ZSgpIHtcbiAgcmV0dXJuIGFjdGl2ZUVkaXRvclN0YXRlO1xufVxuZnVuY3Rpb24gJGFwcGx5VHJhbnNmb3JtcyhlZGl0b3IsIG5vZGUsIHRyYW5zZm9ybXNDYWNoZSkge1xuICBjb25zdCB0eXBlID0gbm9kZS5fX3R5cGU7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gZ2V0UmVnaXN0ZXJlZE5vZGVPclRocm93KGVkaXRvciwgdHlwZSk7XG4gIGxldCB0cmFuc2Zvcm1zQXJyID0gdHJhbnNmb3Jtc0NhY2hlLmdldCh0eXBlKTtcbiAgaWYgKHRyYW5zZm9ybXNBcnIgPT09IHVuZGVmaW5lZCkge1xuICAgIHRyYW5zZm9ybXNBcnIgPSBBcnJheS5mcm9tKHJlZ2lzdGVyZWROb2RlLnRyYW5zZm9ybXMpO1xuICAgIHRyYW5zZm9ybXNDYWNoZS5zZXQodHlwZSwgdHJhbnNmb3Jtc0Fycik7XG4gIH1cbiAgY29uc3QgdHJhbnNmb3Jtc0Fyckxlbmd0aCA9IHRyYW5zZm9ybXNBcnIubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybXNBcnJMZW5ndGg7IGkrKykge1xuICAgIHRyYW5zZm9ybXNBcnJbaV0obm9kZSk7XG4gICAgaWYgKCFub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkaXNOb2RlVmFsaWRGb3JUcmFuc2Zvcm0obm9kZSwgY29tcG9zaXRpb25LZXkpIHtcbiAgcmV0dXJuIG5vZGUgIT09IHVuZGVmaW5lZCAmJlxuICAvLyBXZSBkb24ndCB3YW50IHRvIHRyYW5zZm9ybSBub2RlcyBiZWluZyBjb21wb3NlZFxuICBub2RlLl9fa2V5ICE9PSBjb21wb3NpdGlvbktleSAmJiBub2RlLmlzQXR0YWNoZWQoKTtcbn1cbmZ1bmN0aW9uICRub3JtYWxpemVBbGxEaXJ0eVRleHROb2RlcyhlZGl0b3JTdGF0ZSwgZWRpdG9yKSB7XG4gIGNvbnN0IGRpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgY29uc3Qgbm9kZU1hcCA9IGVkaXRvclN0YXRlLl9ub2RlTWFwO1xuICBmb3IgKGNvbnN0IG5vZGVLZXkgb2YgZGlydHlMZWF2ZXMpIHtcbiAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobm9kZUtleSk7XG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpICYmIG5vZGUuaXNBdHRhY2hlZCgpICYmIG5vZGUuaXNTaW1wbGVUZXh0KCkgJiYgIW5vZGUuaXNVbm1lcmdlYWJsZSgpKSB7XG4gICAgICAkbm9ybWFsaXplVGV4dE5vZGUobm9kZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRUYWdzKGVkaXRvciwgdGFncykge1xuICBpZiAoIXRhZ3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdXBkYXRlVGFncyA9IGVkaXRvci5fdXBkYXRlVGFncztcbiAgbGV0IHRhZ3NfID0gdGFncztcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRhZ3MpKSB7XG4gICAgdGFnc18gPSBbdGFnc107XG4gIH1cbiAgZm9yIChjb25zdCB0YWcgb2YgdGFnc18pIHtcbiAgICB1cGRhdGVUYWdzLmFkZCh0YWcpO1xuICB9XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGhldXJpc3RpYzpcbiAqIDEuIFdlIHRyYW5zZm9ybSBsZWF2ZXMgZmlyc3QuIElmIHRyYW5zZm9ybXMgZ2VuZXJhdGUgYWRkaXRpb25hbCBkaXJ0eSBub2RlcyB3ZSByZXBlYXQgc3RlcCAxLlxuICogVGhlIHJlYXNvbmluZyBiZWhpbmQgdGhpcyBpcyB0aGF0IG1hcmtpbmcgYSBsZWFmIGFzIGRpcnR5IG1hcmtzIGFsbCBpdHMgcGFyZW50IGVsZW1lbnRzIGFzIGRpcnR5IHRvby5cbiAqIDIuIFdlIHRyYW5zZm9ybSBlbGVtZW50cy4gSWYgZWxlbWVudCB0cmFuc2Zvcm1zIGdlbmVyYXRlIGFkZGl0aW9uYWwgZGlydHkgbm9kZXMgd2UgcmVwZWF0IHN0ZXAgMS5cbiAqIElmIGVsZW1lbnQgdHJhbnNmb3JtcyBvbmx5IGdlbmVyYXRlIGFkZGl0aW9uYWwgZGlydHkgZWxlbWVudHMgd2Ugb25seSByZXBlYXQgc3RlcCAyLlxuICpcbiAqIE5vdGUgdGhhdCB0byBrZWVwIHRyYWNrIG9mIG5ld2x5IGRpcnR5IG5vZGVzIGFuZCBzdWJ0cmVlcyB3ZSBsZXZlcmFnZSB0aGUgZWRpdG9yLl9kaXJ0eU5vZGVzIGFuZFxuICogZWRpdG9yLl9zdWJ0cmVlcyB3aGljaCB3ZSByZXNldCBpbiBldmVyeSBsb29wLlxuICovXG5mdW5jdGlvbiAkYXBwbHlBbGxUcmFuc2Zvcm1zKGVkaXRvclN0YXRlLCBlZGl0b3IpIHtcbiAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IGNvbXBvc2l0aW9uS2V5ID0gJGdldENvbXBvc2l0aW9uS2V5KCk7XG4gIGNvbnN0IHRyYW5zZm9ybXNDYWNoZSA9IG5ldyBNYXAoKTtcbiAgbGV0IHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcyA9IGRpcnR5TGVhdmVzO1xuICBsZXQgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzLnNpemU7XG4gIGxldCB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50cyA9IGRpcnR5RWxlbWVudHM7XG4gIGxldCB1bnRyYW5zZm9ybWVkRGlydHlFbGVtZW50c0xlbmd0aCA9IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzLnNpemU7XG4gIHdoaWxlICh1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPiAwIHx8IHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzTGVuZ3RoID4gMCkge1xuICAgIGlmICh1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPiAwKSB7XG4gICAgICAvLyBXZSBsZXZlcmFnZSBlZGl0b3IuX2RpcnR5TGVhdmVzIHRvIHRyYWNrIHRoZSBuZXcgZGlydHkgbGVhdmVzIGFmdGVyIHRoZSB0cmFuc2Zvcm1zXG4gICAgICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCBub2RlS2V5IG9mIHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobm9kZUtleSk7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSAmJiBub2RlLmlzQXR0YWNoZWQoKSAmJiBub2RlLmlzU2ltcGxlVGV4dCgpICYmICFub2RlLmlzVW5tZXJnZWFibGUoKSkge1xuICAgICAgICAgICRub3JtYWxpemVUZXh0Tm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSAhPT0gdW5kZWZpbmVkICYmICRpc05vZGVWYWxpZEZvclRyYW5zZm9ybShub2RlLCBjb21wb3NpdGlvbktleSkpIHtcbiAgICAgICAgICAkYXBwbHlUcmFuc2Zvcm1zKGVkaXRvciwgbm9kZSwgdHJhbnNmb3Jtc0NhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBkaXJ0eUxlYXZlcy5hZGQobm9kZUtleSk7XG4gICAgICB9XG4gICAgICB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICAgICAgdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5TGVhdmVzLnNpemU7XG5cbiAgICAgIC8vIFdlIHdhbnQgdG8gcHJpb3JpdGl6ZSBub2RlIHRyYW5zZm9ybXMgb3ZlciBlbGVtZW50IHRyYW5zZm9ybXNcbiAgICAgIGlmICh1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXNMZW5ndGggPiAwKSB7XG4gICAgICAgIGluZmluaXRlVHJhbnNmb3JtQ291bnQrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWxsIGRpcnR5IGxlYXZlcyBoYXZlIGJlZW4gcHJvY2Vzc2VkLiBMZXQncyBkbyBlbGVtZW50cyFcbiAgICAvLyBXZSBoYXZlIHByZXZpb3VzbHkgcHJvY2Vzc2VkIGRpcnR5IGxlYXZlcywgc28gbGV0J3MgcmVzdGFydCB0aGUgZWRpdG9yIGxlYXZlcyBTZXQgdG8gdHJhY2tcbiAgICAvLyBuZXcgb25lcyBjYXVzZWQgYnkgZWxlbWVudCB0cmFuc2Zvcm1zXG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcbiAgICBlZGl0b3IuX2RpcnR5RWxlbWVudHMgPSBuZXcgTWFwKCk7XG5cbiAgICAvLyBUaGUgcm9vdCBpcyBhbHdheXMgY29uc2lkZXJlZCBpbnRlbnRpb25hbGx5IGRpcnR5IGlmIGFueSBhdHRhY2hlZCBub2RlXG4gICAgLy8gaXMgZGlydHkgYW5kIGJ5IGRlbGV0aW5nIGFuZCByZS1pbnNlcnRpbmcgd2Ugd2lsbCBhcHBseSBpdHMgdHJhbnNmb3Jtc1xuICAgIC8vIGxhc3QgKGUuZy4gaXRzIHRyYW5zZm9ybSBjYW4gYmUgdXNlZCBhcyBhIHNvcnQgb2YgXCJ1cGRhdGUgZmluYWxpemVyXCIpXG4gICAgY29uc3Qgcm9vdERpcnR5ID0gdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMuZGVsZXRlKCdyb290Jyk7XG4gICAgaWYgKHJvb3REaXJ0eSkge1xuICAgICAgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMuc2V0KCdyb290JywgdHJ1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY3VycmVudFVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnQgb2YgdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMpIHtcbiAgICAgIGNvbnN0IG5vZGVLZXkgPSBjdXJyZW50VW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudFswXTtcbiAgICAgIGNvbnN0IGludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5ID0gY3VycmVudFVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRbMV07XG4gICAgICBkaXJ0eUVsZW1lbnRzLnNldChub2RlS2V5LCBpbnRlbnRpb25hbGx5TWFya2VkQXNEaXJ0eSk7XG4gICAgICBpZiAoIWludGVudGlvbmFsbHlNYXJrZWRBc0RpcnR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVNYXAuZ2V0KG5vZGVLZXkpO1xuICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCAmJiAkaXNOb2RlVmFsaWRGb3JUcmFuc2Zvcm0obm9kZSwgY29tcG9zaXRpb25LZXkpKSB7XG4gICAgICAgICRhcHBseVRyYW5zZm9ybXMoZWRpdG9yLCBub2RlLCB0cmFuc2Zvcm1zQ2FjaGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB1bnRyYW5zZm9ybWVkRGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICAgIHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlc0xlbmd0aCA9IHVudHJhbnNmb3JtZWREaXJ0eUxlYXZlcy5zaXplO1xuICAgIHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICAgIHVudHJhbnNmb3JtZWREaXJ0eUVsZW1lbnRzTGVuZ3RoID0gdW50cmFuc2Zvcm1lZERpcnR5RWxlbWVudHMuc2l6ZTtcbiAgICBpbmZpbml0ZVRyYW5zZm9ybUNvdW50Kys7XG4gIH1cbiAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IGRpcnR5TGVhdmVzO1xuICBlZGl0b3IuX2RpcnR5RWxlbWVudHMgPSBkaXJ0eUVsZW1lbnRzO1xufVxuZnVuY3Rpb24gJHBhcnNlU2VyaWFsaXplZE5vZGUoc2VyaWFsaXplZE5vZGUpIHtcbiAgY29uc3QgaW50ZXJuYWxTZXJpYWxpemVkTm9kZSA9IHNlcmlhbGl6ZWROb2RlO1xuICByZXR1cm4gJHBhcnNlU2VyaWFsaXplZE5vZGVJbXBsKGludGVybmFsU2VyaWFsaXplZE5vZGUsIGdldEFjdGl2ZUVkaXRvcigpLl9ub2Rlcyk7XG59XG5mdW5jdGlvbiAkcGFyc2VTZXJpYWxpemVkTm9kZUltcGwoc2VyaWFsaXplZE5vZGUsIHJlZ2lzdGVyZWROb2Rlcykge1xuICBjb25zdCB0eXBlID0gc2VyaWFsaXplZE5vZGUudHlwZTtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSByZWdpc3RlcmVkTm9kZXMuZ2V0KHR5cGUpO1xuICBpZiAocmVnaXN0ZXJlZE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgcGFyc2VFZGl0b3JTdGF0ZTogdHlwZSBcIiR7dHlwZX1cIiArIG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICBjb25zdCBub2RlQ2xhc3MgPSByZWdpc3RlcmVkTm9kZS5rbGFzcztcbiAgaWYgKHNlcmlhbGl6ZWROb2RlLnR5cGUgIT09IG5vZGVDbGFzcy5nZXRUeXBlKCkpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYExleGljYWxOb2RlOiBOb2RlICR7bm9kZUNsYXNzLm5hbWV9IGRvZXMgbm90IGltcGxlbWVudCAuaW1wb3J0SlNPTigpLmApO1xuICAgIH1cbiAgfVxuICBjb25zdCBub2RlID0gbm9kZUNsYXNzLmltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpO1xuICBjb25zdCBjaGlsZHJlbiA9IHNlcmlhbGl6ZWROb2RlLmNoaWxkcmVuO1xuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzZXJpYWxpemVkSlNPTkNoaWxkTm9kZSA9IGNoaWxkcmVuW2ldO1xuICAgICAgY29uc3QgY2hpbGROb2RlID0gJHBhcnNlU2VyaWFsaXplZE5vZGVJbXBsKHNlcmlhbGl6ZWRKU09OQ2hpbGROb2RlLCByZWdpc3RlcmVkTm9kZXMpO1xuICAgICAgbm9kZS5hcHBlbmQoY2hpbGROb2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBwYXJzZUVkaXRvclN0YXRlKHNlcmlhbGl6ZWRFZGl0b3JTdGF0ZSwgZWRpdG9yLCB1cGRhdGVGbikge1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgY29uc3QgcHJldmlvdXNEaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBjb25zdCBwcmV2aW91c0RpcnR5TGVhdmVzID0gZWRpdG9yLl9kaXJ0eUxlYXZlcztcbiAgY29uc3QgcHJldmlvdXNDbG9uZU5vdE5lZWRlZCA9IGVkaXRvci5fY2xvbmVOb3ROZWVkZWQ7XG4gIGNvbnN0IHByZXZpb3VzRGlydHlUeXBlID0gZWRpdG9yLl9kaXJ0eVR5cGU7XG4gIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZCA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSAwO1xuICBhY3RpdmVFZGl0b3JTdGF0ZSA9IGVkaXRvclN0YXRlO1xuICBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlO1xuICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gIHNldFBlbmRpbmdOb2RlVG9DbG9uZShudWxsKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZXMgPSBlZGl0b3IuX25vZGVzO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gc2VyaWFsaXplZEVkaXRvclN0YXRlLnJvb3Q7XG4gICAgJHBhcnNlU2VyaWFsaXplZE5vZGVJbXBsKHNlcmlhbGl6ZWROb2RlLCByZWdpc3RlcmVkTm9kZXMpO1xuICAgIGlmICh1cGRhdGVGbikge1xuICAgICAgdXBkYXRlRm4oKTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHRoZSBlZGl0b3JTdGF0ZSBpbW11dGFibGVcbiAgICBlZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuICAgIHtcbiAgICAgIGhhbmRsZURFVk9ubHlQZW5kaW5nVXBkYXRlR3VhcmFudGVlcyhlZGl0b3JTdGF0ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBlZGl0b3IuX29uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBlZGl0b3IuX2RpcnR5RWxlbWVudHMgPSBwcmV2aW91c0RpcnR5RWxlbWVudHM7XG4gICAgZWRpdG9yLl9kaXJ0eUxlYXZlcyA9IHByZXZpb3VzRGlydHlMZWF2ZXM7XG4gICAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZCA9IHByZXZpb3VzQ2xvbmVOb3ROZWVkZWQ7XG4gICAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBwcmV2aW91c0RpcnR5VHlwZTtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgaXNSZWFkT25seU1vZGUgPSBwcmV2aW91c1JlYWRPbmx5TW9kZTtcbiAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgfVxuICByZXR1cm4gZWRpdG9yU3RhdGU7XG59XG5cbi8vIFRoaXMgdGVjaG5pY2FsbHkgaXNuJ3QgYW4gdXBkYXRlIGJ1dCBnaXZlbiB3ZSBuZWVkXG4vLyBleHBvc3VyZSB0byB0aGUgbW9kdWxlJ3MgYWN0aXZlIGJpbmRpbmdzLCB3ZSBoYXZlIHRoaXNcbi8vIGZ1bmN0aW9uIGhlcmVcblxuZnVuY3Rpb24gcmVhZEVkaXRvclN0YXRlKGVkaXRvciwgZWRpdG9yU3RhdGUsIGNhbGxiYWNrRm4pIHtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZSA9IGFjdGl2ZUVkaXRvclN0YXRlO1xuICBjb25zdCBwcmV2aW91c1JlYWRPbmx5TW9kZSA9IGlzUmVhZE9ubHlNb2RlO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvciA9IGFjdGl2ZUVkaXRvcjtcbiAgYWN0aXZlRWRpdG9yU3RhdGUgPSBlZGl0b3JTdGF0ZTtcbiAgaXNSZWFkT25seU1vZGUgPSB0cnVlO1xuICBhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrRm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgaXNSZWFkT25seU1vZGUgPSBwcmV2aW91c1JlYWRPbmx5TW9kZTtcbiAgICBhY3RpdmVFZGl0b3IgPSBwcmV2aW91c0FjdGl2ZUVkaXRvcjtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlREVWT25seVBlbmRpbmdVcGRhdGVHdWFyYW50ZWVzKHBlbmRpbmdFZGl0b3JTdGF0ZSkge1xuICAvLyBHaXZlbiB3ZSBjYW4ndCBPYmplY3QuZnJlZXplIHRoZSBub2RlTWFwIGFzIGl0J3MgYSBNYXAsXG4gIC8vIHdlIGluc3RlYWQgcmVwbGFjZSBpdHMgc2V0LCBjbGVhciBhbmQgZGVsZXRlIG1ldGhvZHMuXG4gIGNvbnN0IG5vZGVNYXAgPSBwZW5kaW5nRWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIG5vZGVNYXAuc2V0ID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgc2V0KCkgb24gYSBmcm96ZW4gTGV4aWNhbCBub2RlIG1hcCcpO1xuICB9O1xuICBub2RlTWFwLmNsZWFyID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgY2xlYXIoKSBvbiBhIGZyb3plbiBMZXhpY2FsIG5vZGUgbWFwJyk7XG4gIH07XG4gIG5vZGVNYXAuZGVsZXRlID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNhbGwgZGVsZXRlKCkgb24gYSBmcm96ZW4gTGV4aWNhbCBub2RlIG1hcCcpO1xuICB9O1xufVxuZnVuY3Rpb24gJGNvbW1pdFBlbmRpbmdVcGRhdGVzKGVkaXRvciwgcmVjb3ZlcnlFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuX3Jvb3RFbGVtZW50O1xuICBjb25zdCBzaG91bGRTa2lwRE9NID0gZWRpdG9yLl9oZWFkbGVzcyB8fCByb290RWxlbWVudCA9PT0gbnVsbDtcbiAgaWYgKHBlbmRpbmdFZGl0b3JTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vID09PT09PVxuICAvLyBSZWNvbmNpbGlhdGlvbiBoYXMgc3RhcnRlZC5cbiAgLy8gPT09PT09XG5cbiAgY29uc3QgY3VycmVudEVkaXRvclN0YXRlID0gZWRpdG9yLl9lZGl0b3JTdGF0ZTtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuICBjb25zdCBwZW5kaW5nU2VsZWN0aW9uID0gcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gIGNvbnN0IG5lZWRzVXBkYXRlID0gZWRpdG9yLl9kaXJ0eVR5cGUgIT09IE5PX0RJUlRZX05PREVTO1xuICBjb25zdCBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlID0gYWN0aXZlRWRpdG9yU3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUmVhZE9ubHlNb2RlID0gaXNSZWFkT25seU1vZGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yID0gYWN0aXZlRWRpdG9yO1xuICBjb25zdCBwcmV2aW91c2x5VXBkYXRpbmcgPSBlZGl0b3IuX3VwZGF0aW5nO1xuICBjb25zdCBvYnNlcnZlciA9IGVkaXRvci5fb2JzZXJ2ZXI7XG4gIGxldCBtdXRhdGVkTm9kZXMgPSBudWxsO1xuICBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IG51bGw7XG4gIGVkaXRvci5fZWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGlmICghc2hvdWxkU2tpcERPTSAmJiBuZWVkc1VwZGF0ZSAmJiBvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIGFjdGl2ZUVkaXRvciA9IGVkaXRvcjtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlO1xuICAgIC8vIFdlIGRvbid0IHdhbnQgdXBkYXRlcyB0byBzeW5jIGJsb2NrIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICBlZGl0b3IuX3VwZGF0aW5nID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGlydHlUeXBlID0gZWRpdG9yLl9kaXJ0eVR5cGU7XG4gICAgICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICAgICAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgbXV0YXRlZE5vZGVzID0gJHJlY29uY2lsZVJvb3QoY3VycmVudEVkaXRvclN0YXRlLCBwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvciwgZGlydHlUeXBlLCBkaXJ0eUVsZW1lbnRzLCBkaXJ0eUxlYXZlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIFJlcG9ydCBlcnJvcnNcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGVkaXRvci5fb25FcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IGVkaXRvciBhbmQgcmVzdG9yZSBpbmNvbWluZyBlZGl0b3Igc3RhdGUgdG8gdGhlIERPTVxuICAgICAgaWYgKCFpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yKSB7XG4gICAgICAgIHJlc2V0RWRpdG9yKGVkaXRvciwgbnVsbCwgcm9vdEVsZW1lbnQsIHBlbmRpbmdFZGl0b3JTdGF0ZSk7XG4gICAgICAgIGluaXRNdXRhdGlvbk9ic2VydmVyKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgICAgIGlzQXR0ZW1wdGluZ1RvUmVjb3ZlckZyb21SZWNvbmNpbGVyRXJyb3IgPSB0cnVlO1xuICAgICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXMoZWRpdG9yLCBjdXJyZW50RWRpdG9yU3RhdGUpO1xuICAgICAgICBpc0F0dGVtcHRpbmdUb1JlY292ZXJGcm9tUmVjb25jaWxlckVycm9yID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUbyBhdm9pZCBhIHBvc3NpYmxlIHNpdHVhdGlvbiBvZiBpbmZpbml0ZSBsb29wcywgbGV0cyB0aHJvd1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWxlbWVudCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gICAgICBhY3RpdmVFZGl0b3JTdGF0ZSA9IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGU7XG4gICAgICBpc1JlYWRPbmx5TW9kZSA9IHByZXZpb3VzUmVhZE9ubHlNb2RlO1xuICAgICAgYWN0aXZlRWRpdG9yID0gcHJldmlvdXNBY3RpdmVFZGl0b3I7XG4gICAgfVxuICB9XG4gIGlmICghcGVuZGluZ0VkaXRvclN0YXRlLl9yZWFkT25seSkge1xuICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuICAgIHtcbiAgICAgIGhhbmRsZURFVk9ubHlQZW5kaW5nVXBkYXRlR3VhcmFudGVlcyhwZW5kaW5nRWRpdG9yU3RhdGUpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICAgIE9iamVjdC5mcmVlemUocGVuZGluZ1NlbGVjdGlvbi5hbmNob3IpO1xuICAgICAgICBPYmplY3QuZnJlZXplKHBlbmRpbmdTZWxlY3Rpb24uZm9jdXMpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmZyZWV6ZShwZW5kaW5nU2VsZWN0aW9uKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGlydHlMZWF2ZXMgPSBlZGl0b3IuX2RpcnR5TGVhdmVzO1xuICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICBjb25zdCBub3JtYWxpemVkTm9kZXMgPSBlZGl0b3IuX25vcm1hbGl6ZWROb2RlcztcbiAgY29uc3QgdGFncyA9IGVkaXRvci5fdXBkYXRlVGFncztcbiAgY29uc3QgZGVmZXJyZWQgPSBlZGl0b3IuX2RlZmVycmVkO1xuICBpZiAobmVlZHNVcGRhdGUpIHtcbiAgICBlZGl0b3IuX2RpcnR5VHlwZSA9IE5PX0RJUlRZX05PREVTO1xuICAgIGVkaXRvci5fY2xvbmVOb3ROZWVkZWQuY2xlYXIoKTtcbiAgICBlZGl0b3IuX2RpcnR5TGVhdmVzID0gbmV3IFNldCgpO1xuICAgIGVkaXRvci5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBlZGl0b3IuX25vcm1hbGl6ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICBlZGl0b3IuX3VwZGF0ZVRhZ3MgPSBuZXcgU2V0KCk7XG4gIH1cbiAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWREZWNvcmF0b3JzKGVkaXRvciwgcGVuZGluZ0VkaXRvclN0YXRlKTtcblxuICAvLyA9PT09PT1cbiAgLy8gUmVjb25jaWxpYXRpb24gaGFzIGZpbmlzaGVkLiBOb3cgdXBkYXRlIHNlbGVjdGlvbiBhbmQgdHJpZ2dlciBsaXN0ZW5lcnMuXG4gIC8vID09PT09PVxuXG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IHNob3VsZFNraXBET00gPyBudWxsIDogZ2V0RE9NU2VsZWN0aW9uKGdldFdpbmRvdyhlZGl0b3IpKTtcblxuICAvLyBBdHRlbXB0IHRvIHVwZGF0ZSB0aGUgRE9NIHNlbGVjdGlvbiwgaW5jbHVkaW5nIGZvY3VzaW5nIG9mIHRoZSByb290IGVsZW1lbnQsXG4gIC8vIGFuZCBzY3JvbGwgaW50byB2aWV3IGlmIG5lZWRlZC5cbiAgaWYgKGVkaXRvci5fZWRpdGFibGUgJiZcbiAgLy8gZG9tU2VsZWN0aW9uIHdpbGwgYmUgbnVsbCBpbiBoZWFkbGVzc1xuICBkb21TZWxlY3Rpb24gIT09IG51bGwgJiYgKG5lZWRzVXBkYXRlIHx8IHBlbmRpbmdTZWxlY3Rpb24gPT09IG51bGwgfHwgcGVuZGluZ1NlbGVjdGlvbi5kaXJ0eSkgJiYgcm9vdEVsZW1lbnQgIT09IG51bGwgJiYgIXRhZ3MuaGFzKFNLSVBfRE9NX1NFTEVDVElPTl9UQUcpKSB7XG4gICAgYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICAgIGFjdGl2ZUVkaXRvclN0YXRlID0gcGVuZGluZ0VkaXRvclN0YXRlO1xuICAgIHRyeSB7XG4gICAgICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgfVxuICAgICAgaWYgKG5lZWRzVXBkYXRlIHx8IHBlbmRpbmdTZWxlY3Rpb24gPT09IG51bGwgfHwgcGVuZGluZ1NlbGVjdGlvbi5kaXJ0eSkge1xuICAgICAgICBjb25zdCBibG9ja0N1cnNvckVsZW1lbnQgPSBlZGl0b3IuX2Jsb2NrQ3Vyc29yRWxlbWVudDtcbiAgICAgICAgaWYgKGJsb2NrQ3Vyc29yRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlbW92ZURPTUJsb2NrQ3Vyc29yRWxlbWVudChibG9ja0N1cnNvckVsZW1lbnQsIGVkaXRvciwgcm9vdEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZURPTVNlbGVjdGlvbihjdXJyZW50U2VsZWN0aW9uLCBwZW5kaW5nU2VsZWN0aW9uLCBlZGl0b3IsIGRvbVNlbGVjdGlvbiwgdGFncywgcm9vdEVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdXBkYXRlRE9NQmxvY2tDdXJzb3JFbGVtZW50KGVkaXRvciwgcm9vdEVsZW1lbnQsIHBlbmRpbmdTZWxlY3Rpb24pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyb290RWxlbWVudCwgb2JzZXJ2ZXJPcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGFjdGl2ZUVkaXRvciA9IHByZXZpb3VzQWN0aXZlRWRpdG9yO1xuICAgICAgYWN0aXZlRWRpdG9yU3RhdGUgPSBwcmV2aW91c0FjdGl2ZUVkaXRvclN0YXRlO1xuICAgIH1cbiAgfVxuICBpZiAobXV0YXRlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgdHJpZ2dlck11dGF0aW9uTGlzdGVuZXJzKGVkaXRvciwgbXV0YXRlZE5vZGVzLCB0YWdzLCBkaXJ0eUxlYXZlcywgY3VycmVudEVkaXRvclN0YXRlKTtcbiAgfVxuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pICYmIHBlbmRpbmdTZWxlY3Rpb24gIT09IG51bGwgJiYgKGN1cnJlbnRTZWxlY3Rpb24gPT09IG51bGwgfHwgIWN1cnJlbnRTZWxlY3Rpb24uaXMocGVuZGluZ1NlbGVjdGlvbikpKSB7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH1cbiAgLyoqXG4gICAqIENhcHR1cmUgcGVuZGluZ0RlY29yYXRvcnMgYWZ0ZXIgZ2FyYmFnZSBjb2xsZWN0aW5nIGRldGFjaGVkIGRlY29yYXRvcnNcbiAgICovXG4gIGNvbnN0IHBlbmRpbmdEZWNvcmF0b3JzID0gZWRpdG9yLl9wZW5kaW5nRGVjb3JhdG9ycztcbiAgaWYgKHBlbmRpbmdEZWNvcmF0b3JzICE9PSBudWxsKSB7XG4gICAgZWRpdG9yLl9kZWNvcmF0b3JzID0gcGVuZGluZ0RlY29yYXRvcnM7XG4gICAgZWRpdG9yLl9wZW5kaW5nRGVjb3JhdG9ycyA9IG51bGw7XG4gICAgdHJpZ2dlckxpc3RlbmVycygnZGVjb3JhdG9yJywgZWRpdG9yLCB0cnVlLCBwZW5kaW5nRGVjb3JhdG9ycyk7XG4gIH1cblxuICAvLyBJZiByZWNvbmNpbGVyIGZhaWxzLCB3ZSByZXNldCB3aG9sZSBlZGl0b3IgKHNvIGN1cnJlbnQgZWRpdG9yIHN0YXRlIGJlY29tZXMgZW1wdHkpXG4gIC8vIGFuZCBhdHRlbXB0IHRvIHJlLXJlbmRlciBwZW5kaW5nRWRpdG9yU3RhdGUuIElmIHRoYXQgZ29lcyB0aHJvdWdoIHdlIHRyaWdnZXJcbiAgLy8gbGlzdGVuZXJzLCBidXQgaW5zdGVhZCB1c2UgcmVjb3ZlckVkaXRvclN0YXRlIHdoaWNoIGlzIGN1cnJlbnQgZWRpdG9yIHN0YXRlIGJlZm9yZSByZXNldFxuICAvLyBUaGlzIHNwZWNpZmljYWxseSBpbXBvcnRhbnQgZm9yIGNvbGxhYiB0aGF0IHJlbGllcyBvbiBwcmV2RWRpdG9yU3RhdGUgZnJvbSB1cGRhdGVcbiAgLy8gbGlzdGVuZXIgdG8gY2FsY3VsYXRlIGRlbHRhIG9mIGNoYW5nZWQgbm9kZXMvcHJvcGVydGllc1xuICB0cmlnZ2VyVGV4dENvbnRlbnRMaXN0ZW5lcnMoZWRpdG9yLCByZWNvdmVyeUVkaXRvclN0YXRlIHx8IGN1cnJlbnRFZGl0b3JTdGF0ZSwgcGVuZGluZ0VkaXRvclN0YXRlKTtcbiAgdHJpZ2dlckxpc3RlbmVycygndXBkYXRlJywgZWRpdG9yLCB0cnVlLCB7XG4gICAgZGlydHlFbGVtZW50cyxcbiAgICBkaXJ0eUxlYXZlcyxcbiAgICBlZGl0b3JTdGF0ZTogcGVuZGluZ0VkaXRvclN0YXRlLFxuICAgIG11dGF0ZWROb2RlcyxcbiAgICBub3JtYWxpemVkTm9kZXMsXG4gICAgcHJldkVkaXRvclN0YXRlOiByZWNvdmVyeUVkaXRvclN0YXRlIHx8IGN1cnJlbnRFZGl0b3JTdGF0ZSxcbiAgICB0YWdzXG4gIH0pO1xuICB0cmlnZ2VyRGVmZXJyZWRVcGRhdGVDYWxsYmFja3MoZWRpdG9yLCBkZWZlcnJlZCk7XG4gICR0cmlnZ2VyRW5xdWV1ZWRVcGRhdGVzKGVkaXRvcik7XG59XG5mdW5jdGlvbiB0cmlnZ2VyVGV4dENvbnRlbnRMaXN0ZW5lcnMoZWRpdG9yLCBjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBjdXJyZW50VGV4dENvbnRlbnQgPSBnZXRFZGl0b3JTdGF0ZVRleHRDb250ZW50KGN1cnJlbnRFZGl0b3JTdGF0ZSk7XG4gIGNvbnN0IGxhdGVzdFRleHRDb250ZW50ID0gZ2V0RWRpdG9yU3RhdGVUZXh0Q29udGVudChwZW5kaW5nRWRpdG9yU3RhdGUpO1xuICBpZiAoY3VycmVudFRleHRDb250ZW50ICE9PSBsYXRlc3RUZXh0Q29udGVudCkge1xuICAgIHRyaWdnZXJMaXN0ZW5lcnMoJ3RleHRjb250ZW50JywgZWRpdG9yLCB0cnVlLCBsYXRlc3RUZXh0Q29udGVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJNdXRhdGlvbkxpc3RlbmVycyhlZGl0b3IsIG11dGF0ZWROb2RlcywgdXBkYXRlVGFncywgZGlydHlMZWF2ZXMsIHByZXZFZGl0b3JTdGF0ZSkge1xuICBjb25zdCBsaXN0ZW5lcnMgPSBBcnJheS5mcm9tKGVkaXRvci5fbGlzdGVuZXJzLm11dGF0aW9uKTtcbiAgY29uc3QgbGlzdGVuZXJzTGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IFtsaXN0ZW5lciwga2xhc3NTZXRdID0gbGlzdGVuZXJzW2ldO1xuICAgIGZvciAoY29uc3Qga2xhc3Mgb2Yga2xhc3NTZXQpIHtcbiAgICAgIGNvbnN0IG11dGF0ZWROb2Rlc0J5VHlwZSA9IG11dGF0ZWROb2Rlcy5nZXQoa2xhc3MpO1xuICAgICAgaWYgKG11dGF0ZWROb2Rlc0J5VHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxpc3RlbmVyKG11dGF0ZWROb2Rlc0J5VHlwZSwge1xuICAgICAgICAgIGRpcnR5TGVhdmVzLFxuICAgICAgICAgIHByZXZFZGl0b3JTdGF0ZSxcbiAgICAgICAgICB1cGRhdGVUYWdzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdHJpZ2dlckxpc3RlbmVycyh0eXBlLCBlZGl0b3IsIGlzQ3VycmVudGx5RW5xdWV1aW5nVXBkYXRlcywgLi4ucGF5bG9hZCkge1xuICBjb25zdCBwcmV2aW91c2x5VXBkYXRpbmcgPSBlZGl0b3IuX3VwZGF0aW5nO1xuICBlZGl0b3IuX3VwZGF0aW5nID0gaXNDdXJyZW50bHlFbnF1ZXVpbmdVcGRhdGVzO1xuICB0cnkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IEFycmF5LmZyb20oZWRpdG9yLl9saXN0ZW5lcnNbdHlwZV0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkobnVsbCwgcGF5bG9hZCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyaWdnZXJDb21tYW5kTGlzdGVuZXJzKGVkaXRvciwgdHlwZSwgcGF5bG9hZCkge1xuICBjb25zdCBlZGl0b3JzID0gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKGVkaXRvcik7XG4gIGZvciAobGV0IGkgPSA0OyBpID49IDA7IGktLSkge1xuICAgIGZvciAobGV0IGUgPSAwOyBlIDwgZWRpdG9ycy5sZW5ndGg7IGUrKykge1xuICAgICAgY29uc3QgY3VycmVudEVkaXRvciA9IGVkaXRvcnNbZV07XG4gICAgICBjb25zdCBjb21tYW5kTGlzdGVuZXJzID0gY3VycmVudEVkaXRvci5fY29tbWFuZHM7XG4gICAgICBjb25zdCBsaXN0ZW5lckluUHJpb3JpdHlPcmRlciA9IGNvbW1hbmRMaXN0ZW5lcnMuZ2V0KHR5cGUpO1xuICAgICAgaWYgKGxpc3RlbmVySW5Qcmlvcml0eU9yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzU2V0ID0gbGlzdGVuZXJJblByaW9yaXR5T3JkZXJbaV07XG4gICAgICAgIGlmIChsaXN0ZW5lcnNTZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IEFycmF5LmZyb20obGlzdGVuZXJzU2V0KTtcbiAgICAgICAgICBjb25zdCBsaXN0ZW5lcnNMZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICAgIGxldCByZXR1cm5WYWwgPSBmYWxzZTtcbiAgICAgICAgICB1cGRhdGVFZGl0b3JTeW5jKGN1cnJlbnRFZGl0b3IsICgpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGlzdGVuZXJzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1tqXShwYXlsb2FkLCBlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuVmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmV0dXJuVmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiAkdHJpZ2dlckVucXVldWVkVXBkYXRlcyhlZGl0b3IpIHtcbiAgY29uc3QgcXVldWVkVXBkYXRlcyA9IGVkaXRvci5fdXBkYXRlcztcbiAgaWYgKHF1ZXVlZFVwZGF0ZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgY29uc3QgcXVldWVkVXBkYXRlID0gcXVldWVkVXBkYXRlcy5zaGlmdCgpO1xuICAgIGlmIChxdWV1ZWRVcGRhdGUpIHtcbiAgICAgIGNvbnN0IFt1cGRhdGVGbiwgb3B0aW9uc10gPSBxdWV1ZWRVcGRhdGU7XG4gICAgICAkYmVnaW5VcGRhdGUoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiB0cmlnZ2VyRGVmZXJyZWRVcGRhdGVDYWxsYmFja3MoZWRpdG9yLCBkZWZlcnJlZCkge1xuICBlZGl0b3IuX2RlZmVycmVkID0gW107XG4gIGlmIChkZWZlcnJlZC5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBwcmV2aW91c2x5VXBkYXRpbmcgPSBlZGl0b3IuX3VwZGF0aW5nO1xuICAgIGVkaXRvci5fdXBkYXRpbmcgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZmVycmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlZmVycmVkW2ldKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkcHJvY2Vzc05lc3RlZFVwZGF0ZXMoZWRpdG9yLCBpbml0aWFsU2tpcFRyYW5zZm9ybXMpIHtcbiAgY29uc3QgcXVldWVkVXBkYXRlcyA9IGVkaXRvci5fdXBkYXRlcztcbiAgbGV0IHNraXBUcmFuc2Zvcm1zID0gaW5pdGlhbFNraXBUcmFuc2Zvcm1zIHx8IGZhbHNlO1xuXG4gIC8vIFVwZGF0ZXMgbWlnaHQgZ3JvdyBhcyB3ZSBwcm9jZXNzIHRoZW0sIHdlIHNvIHdlJ2xsIG5lZWRcbiAgLy8gdG8gaGFuZGxlIGVhY2ggdXBkYXRlIGFzIHdlIGdvIHVudGlsIHRoZSB1cGRhdGVzIGFycmF5IGlzXG4gIC8vIGVtcHR5LlxuICB3aGlsZSAocXVldWVkVXBkYXRlcy5sZW5ndGggIT09IDApIHtcbiAgICBjb25zdCBxdWV1ZWRVcGRhdGUgPSBxdWV1ZWRVcGRhdGVzLnNoaWZ0KCk7XG4gICAgaWYgKHF1ZXVlZFVwZGF0ZSkge1xuICAgICAgY29uc3QgW25leHRVcGRhdGVGbiwgb3B0aW9uc10gPSBxdWV1ZWRVcGRhdGU7XG4gICAgICBjb25zdCBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICAgIGxldCBvblVwZGF0ZTtcbiAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25VcGRhdGUgPSBvcHRpb25zLm9uVXBkYXRlO1xuICAgICAgICBpZiAob3B0aW9ucy5za2lwVHJhbnNmb3Jtcykge1xuICAgICAgICAgIHNraXBUcmFuc2Zvcm1zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5kaXNjcmV0ZSkge1xuICAgICAgICAgIGlmICghKHBlbmRpbmdFZGl0b3JTdGF0ZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVW5leHBlY3RlZCBlbXB0eSBwZW5kaW5nIGVkaXRvciBzdGF0ZSBvbiBkaXNjcmV0ZSBuZXN0ZWQgdXBkYXRlYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgICBlZGl0b3IuX2RlZmVycmVkLnB1c2gob25VcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFRhZ3MoZWRpdG9yLCBvcHRpb25zLnRhZyk7XG4gICAgICB9XG4gICAgICBpZiAocGVuZGluZ0VkaXRvclN0YXRlID09IG51bGwpIHtcbiAgICAgICAgJGJlZ2luVXBkYXRlKGVkaXRvciwgbmV4dFVwZGF0ZUZuLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRVcGRhdGVGbigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2tpcFRyYW5zZm9ybXM7XG59XG5mdW5jdGlvbiAkYmVnaW5VcGRhdGUoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucykge1xuICBjb25zdCB1cGRhdGVUYWdzID0gZWRpdG9yLl91cGRhdGVUYWdzO1xuICBsZXQgb25VcGRhdGU7XG4gIGxldCBza2lwVHJhbnNmb3JtcyA9IGZhbHNlO1xuICBsZXQgZGlzY3JldGUgPSBmYWxzZTtcbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIG9uVXBkYXRlID0gb3B0aW9ucy5vblVwZGF0ZTtcbiAgICBhZGRUYWdzKGVkaXRvciwgb3B0aW9ucy50YWcpO1xuICAgIHNraXBUcmFuc2Zvcm1zID0gb3B0aW9ucy5za2lwVHJhbnNmb3JtcyB8fCBmYWxzZTtcbiAgICBkaXNjcmV0ZSA9IG9wdGlvbnMuZGlzY3JldGUgfHwgZmFsc2U7XG4gIH1cbiAgaWYgKG9uVXBkYXRlKSB7XG4gICAgZWRpdG9yLl9kZWZlcnJlZC5wdXNoKG9uVXBkYXRlKTtcbiAgfVxuICBjb25zdCBjdXJyZW50RWRpdG9yU3RhdGUgPSBlZGl0b3IuX2VkaXRvclN0YXRlO1xuICBsZXQgcGVuZGluZ0VkaXRvclN0YXRlID0gZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGxldCBlZGl0b3JTdGF0ZVdhc0Nsb25lZCA9IGZhbHNlO1xuICBpZiAocGVuZGluZ0VkaXRvclN0YXRlID09PSBudWxsIHx8IHBlbmRpbmdFZGl0b3JTdGF0ZS5fcmVhZE9ubHkpIHtcbiAgICBwZW5kaW5nRWRpdG9yU3RhdGUgPSBlZGl0b3IuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IGNsb25lRWRpdG9yU3RhdGUocGVuZGluZ0VkaXRvclN0YXRlIHx8IGN1cnJlbnRFZGl0b3JTdGF0ZSk7XG4gICAgZWRpdG9yU3RhdGVXYXNDbG9uZWQgPSB0cnVlO1xuICB9XG4gIHBlbmRpbmdFZGl0b3JTdGF0ZS5fZmx1c2hTeW5jID0gZGlzY3JldGU7XG4gIGNvbnN0IHByZXZpb3VzQWN0aXZlRWRpdG9yU3RhdGUgPSBhY3RpdmVFZGl0b3JTdGF0ZTtcbiAgY29uc3QgcHJldmlvdXNSZWFkT25seU1vZGUgPSBpc1JlYWRPbmx5TW9kZTtcbiAgY29uc3QgcHJldmlvdXNBY3RpdmVFZGl0b3IgPSBhY3RpdmVFZGl0b3I7XG4gIGNvbnN0IHByZXZpb3VzbHlVcGRhdGluZyA9IGVkaXRvci5fdXBkYXRpbmc7XG4gIGFjdGl2ZUVkaXRvclN0YXRlID0gcGVuZGluZ0VkaXRvclN0YXRlO1xuICBpc1JlYWRPbmx5TW9kZSA9IGZhbHNlO1xuICBlZGl0b3IuX3VwZGF0aW5nID0gdHJ1ZTtcbiAgYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuICBjb25zdCBoZWFkbGVzcyA9IGVkaXRvci5faGVhZGxlc3MgfHwgZWRpdG9yLmdldFJvb3RFbGVtZW50KCkgPT09IG51bGw7XG4gIHNldFBlbmRpbmdOb2RlVG9DbG9uZShudWxsKTtcbiAgdHJ5IHtcbiAgICBpZiAoZWRpdG9yU3RhdGVXYXNDbG9uZWQpIHtcbiAgICAgIGlmIChoZWFkbGVzcykge1xuICAgICAgICBpZiAoY3VycmVudEVkaXRvclN0YXRlLl9zZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICBwZW5kaW5nRWRpdG9yU3RhdGUuX3NlbGVjdGlvbiA9IGN1cnJlbnRFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlbmRpbmdFZGl0b3JTdGF0ZS5fc2VsZWN0aW9uID0gJGludGVybmFsQ3JlYXRlU2VsZWN0aW9uKGVkaXRvciwgb3B0aW9ucyAmJiBvcHRpb25zLmV2ZW50IHx8IG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGFydGluZ0NvbXBvc2l0aW9uS2V5ID0gZWRpdG9yLl9jb21wb3NpdGlvbktleTtcbiAgICB1cGRhdGVGbigpO1xuICAgIHNraXBUcmFuc2Zvcm1zID0gJHByb2Nlc3NOZXN0ZWRVcGRhdGVzKGVkaXRvciwgc2tpcFRyYW5zZm9ybXMpO1xuICAgIGFwcGx5U2VsZWN0aW9uVHJhbnNmb3JtcyhwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvcik7XG4gICAgaWYgKGVkaXRvci5fZGlydHlUeXBlICE9PSBOT19ESVJUWV9OT0RFUykge1xuICAgICAgaWYgKHNraXBUcmFuc2Zvcm1zKSB7XG4gICAgICAgICRub3JtYWxpemVBbGxEaXJ0eVRleHROb2RlcyhwZW5kaW5nRWRpdG9yU3RhdGUsIGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkYXBwbHlBbGxUcmFuc2Zvcm1zKHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yKTtcbiAgICAgIH1cbiAgICAgICRwcm9jZXNzTmVzdGVkVXBkYXRlcyhlZGl0b3IpO1xuICAgICAgJGdhcmJhZ2VDb2xsZWN0RGV0YWNoZWROb2RlcyhjdXJyZW50RWRpdG9yU3RhdGUsIHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yLl9kaXJ0eUxlYXZlcywgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzKTtcbiAgICB9XG4gICAgY29uc3QgZW5kaW5nQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICAgIGlmIChzdGFydGluZ0NvbXBvc2l0aW9uS2V5ICE9PSBlbmRpbmdDb21wb3NpdGlvbktleSkge1xuICAgICAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBwZW5kaW5nU2VsZWN0aW9uID0gcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb247XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHBlbmRpbmdTZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBwZW5kaW5nTm9kZU1hcCA9IHBlbmRpbmdFZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgICAgIGNvbnN0IGFuY2hvcktleSA9IHBlbmRpbmdTZWxlY3Rpb24uYW5jaG9yLmtleTtcbiAgICAgIGNvbnN0IGZvY3VzS2V5ID0gcGVuZGluZ1NlbGVjdGlvbi5mb2N1cy5rZXk7XG4gICAgICBpZiAocGVuZGluZ05vZGVNYXAuZ2V0KGFuY2hvcktleSkgPT09IHVuZGVmaW5lZCB8fCBwZW5kaW5nTm9kZU1hcC5nZXQoZm9jdXNLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAge1xuICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgdXBkYXRlRWRpdG9yOiBzZWxlY3Rpb24gaGFzIGJlZW4gbG9zdCBiZWNhdXNlIHRoZSBwcmV2aW91c2x5IHNlbGVjdGVkIG5vZGVzIGhhdmUgYmVlbiByZW1vdmVkIGFuZCBzZWxlY3Rpb24gd2Fzbid0IG1vdmVkIHRvIGFub3RoZXIgbm9kZS4gRW5zdXJlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIHJlbW92aW5nL3JlcGxhY2luZyBhIHNlbGVjdGVkIG5vZGUuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCRpc05vZGVTZWxlY3Rpb24ocGVuZGluZ1NlbGVjdGlvbikpIHtcbiAgICAgIC8vIFRPRE86IHdlIHNob3VsZCBhbHNvIHZhbGlkYXRlIG5vZGUgc2VsZWN0aW9uP1xuICAgICAgaWYgKHBlbmRpbmdTZWxlY3Rpb24uX25vZGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgcGVuZGluZ0VkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBSZXBvcnQgZXJyb3JzXG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGVkaXRvci5fb25FcnJvcihlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gUmVzdG9yZSBleGlzdGluZyBlZGl0b3Igc3RhdGUgdG8gdGhlIERPTVxuICAgIGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gY3VycmVudEVkaXRvclN0YXRlO1xuICAgIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5jbGVhcigpO1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzLmNsZWFyKCk7XG4gICAgJGNvbW1pdFBlbmRpbmdVcGRhdGVzKGVkaXRvcik7XG4gICAgcmV0dXJuO1xuICB9IGZpbmFsbHkge1xuICAgIGFjdGl2ZUVkaXRvclN0YXRlID0gcHJldmlvdXNBY3RpdmVFZGl0b3JTdGF0ZTtcbiAgICBpc1JlYWRPbmx5TW9kZSA9IHByZXZpb3VzUmVhZE9ubHlNb2RlO1xuICAgIGFjdGl2ZUVkaXRvciA9IHByZXZpb3VzQWN0aXZlRWRpdG9yO1xuICAgIGVkaXRvci5fdXBkYXRpbmcgPSBwcmV2aW91c2x5VXBkYXRpbmc7XG4gICAgaW5maW5pdGVUcmFuc2Zvcm1Db3VudCA9IDA7XG4gIH1cbiAgY29uc3Qgc2hvdWxkVXBkYXRlID0gZWRpdG9yLl9kaXJ0eVR5cGUgIT09IE5PX0RJUlRZX05PREVTIHx8IGVkaXRvci5fZGVmZXJyZWQubGVuZ3RoID4gMCB8fCBlZGl0b3JTdGF0ZUhhc0RpcnR5U2VsZWN0aW9uKHBlbmRpbmdFZGl0b3JTdGF0ZSwgZWRpdG9yKTtcbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIGlmIChwZW5kaW5nRWRpdG9yU3RhdGUuX2ZsdXNoU3luYykge1xuICAgICAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSBmYWxzZTtcbiAgICAgICRjb21taXRQZW5kaW5nVXBkYXRlcyhlZGl0b3IpO1xuICAgIH0gZWxzZSBpZiAoZWRpdG9yU3RhdGVXYXNDbG9uZWQpIHtcbiAgICAgIHNjaGVkdWxlTWljcm9UYXNrKCgpID0+IHtcbiAgICAgICAgJGNvbW1pdFBlbmRpbmdVcGRhdGVzKGVkaXRvcik7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGVuZGluZ0VkaXRvclN0YXRlLl9mbHVzaFN5bmMgPSBmYWxzZTtcbiAgICBpZiAoZWRpdG9yU3RhdGVXYXNDbG9uZWQpIHtcbiAgICAgIHVwZGF0ZVRhZ3MuY2xlYXIoKTtcbiAgICAgIGVkaXRvci5fZGVmZXJyZWQgPSBbXTtcbiAgICAgIGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIHZhcmlhbnQgb2YgdXBkYXRlRWRpdG9yIHRoYXQgd2lsbCBub3QgZGVmZXIgaWYgaXQgaXMgbmVzdGVkIGluIGFuIHVwZGF0ZVxuICogdG8gdGhlIHNhbWUgZWRpdG9yLCBtdWNoIGxpa2UgaWYgaXQgd2FzIGFuIGVkaXRvci5kaXNwYXRjaENvbW1hbmQgaXNzdWVkXG4gKiB3aXRoaW4gYW4gdXBkYXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUVkaXRvclN5bmMoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucykge1xuICBpZiAoYWN0aXZlRWRpdG9yID09PSBlZGl0b3IgJiYgb3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdXBkYXRlRm4oKTtcbiAgfSBlbHNlIHtcbiAgICAkYmVnaW5VcGRhdGUoZWRpdG9yLCB1cGRhdGVGbiwgb3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUVkaXRvcihlZGl0b3IsIHVwZGF0ZUZuLCBvcHRpb25zKSB7XG4gIGlmIChlZGl0b3IuX3VwZGF0aW5nKSB7XG4gICAgZWRpdG9yLl91cGRhdGVzLnB1c2goW3VwZGF0ZUZuLCBvcHRpb25zXSk7XG4gIH0gZWxzZSB7XG4gICAgJGJlZ2luVXBkYXRlKGVkaXRvciwgdXBkYXRlRm4sIG9wdGlvbnMpO1xuICB9XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcblxuLyoqXG4gKiBBIHV0aWxpdHkgY2xhc3MgZm9yIG1hbmFnaW5nIHRoZSBET00gY2hpbGRyZW4gb2YgYW4gRWxlbWVudE5vZGVcbiAqL1xuY2xhc3MgRWxlbWVudERPTVNsb3Qge1xuICBjb25zdHJ1Y3RvcigvKiogVGhlIGVsZW1lbnQgcmV0dXJuZWQgYnkgY3JlYXRlRE9NICovXG4gIGVsZW1lbnQsIC8qKiBBbGwgbWFuYWdlZCBjaGlsZHJlbiB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGlzIG5vZGUsIGlmIGRlZmluZWQgKi9cbiAgYmVmb3JlLCAvKiogQWxsIG1hbmFnZWQgY2hpbGRyZW4gd2lsbCBiZSBpbnNlcnRlZCBhZnRlciB0aGlzIG5vZGUsIGlmIGRlZmluZWQgKi9cbiAgYWZ0ZXIpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuYmVmb3JlID0gYmVmb3JlIHx8IG51bGw7XG4gICAgdGhpcy5hZnRlciA9IGFmdGVyIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBFbGVtZW50RE9NU2xvdCB3aGVyZSBhbGwgbWFuYWdlZCBjaGlsZHJlbiB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGlzIG5vZGVcbiAgICovXG4gIHdpdGhCZWZvcmUoYmVmb3JlKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50RE9NU2xvdCh0aGlzLmVsZW1lbnQsIGJlZm9yZSwgdGhpcy5hZnRlcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBFbGVtZW50RE9NU2xvdCB3aGVyZSBhbGwgbWFuYWdlZCBjaGlsZHJlbiB3aWxsIGJlIGluc2VydGVkIGFmdGVyIHRoaXMgbm9kZVxuICAgKi9cbiAgd2l0aEFmdGVyKGFmdGVyKSB7XG4gICAgcmV0dXJuIG5ldyBFbGVtZW50RE9NU2xvdCh0aGlzLmVsZW1lbnQsIHRoaXMuYmVmb3JlLCBhZnRlcik7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiBhIG5ldyBFbGVtZW50RE9NU2xvdCB3aXRoIGFuIHVwZGF0ZWQgcm9vdCBlbGVtZW50XG4gICAqL1xuICB3aXRoRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuZWxlbWVudCA9PT0gZWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRWxlbWVudERPTVNsb3QoZWxlbWVudCwgdGhpcy5iZWZvcmUsIHRoaXMuYWZ0ZXIpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgdGhlIGdpdmVuIGNoaWxkIGJlZm9yZSB0aGlzLmJlZm9yZSBhbmQgYW55IHJlY29uY2lsZXIgbWFuYWdlZCBsaW5lIGJyZWFrIG5vZGUsXG4gICAqIG9yIGFwcGVuZCBpdCBpZiB0aGlzLmJlZm9yZSBpcyBub3QgZGVmaW5lZFxuICAgKi9cbiAgaW5zZXJ0Q2hpbGQoZG9tKSB7XG4gICAgY29uc3QgYmVmb3JlID0gdGhpcy5iZWZvcmUgfHwgdGhpcy5nZXRNYW5hZ2VkTGluZUJyZWFrKCk7XG4gICAgaWYgKCEoYmVmb3JlID09PSBudWxsIHx8IGJlZm9yZS5wYXJlbnRFbGVtZW50ID09PSB0aGlzLmVsZW1lbnQpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEVsZW1lbnRET01TbG90Lmluc2VydENoaWxkOiBiZWZvcmUgaXMgbm90IGluIGVsZW1lbnRgKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50Lmluc2VydEJlZm9yZShkb20sIGJlZm9yZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgbWFuYWdlZCBjaGlsZCBmcm9tIHRoaXMgY29udGFpbmVyLCB3aWxsIHRocm93IGlmIGl0IHdhcyBub3QgYWxyZWFkeSB0aGVyZVxuICAgKi9cbiAgcmVtb3ZlQ2hpbGQoZG9tKSB7XG4gICAgaWYgKCEoZG9tLnBhcmVudEVsZW1lbnQgPT09IHRoaXMuZWxlbWVudCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRWxlbWVudERPTVNsb3QucmVtb3ZlQ2hpbGQ6IGRvbSBpcyBub3QgaW4gZWxlbWVudGApO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSBtYW5hZ2VkIGNoaWxkIHByZXZEb20gd2l0aCBkb20uIFdpbGwgdGhyb3cgaWYgcHJldkRvbSBpcyBub3QgYSBjaGlsZFxuICAgKlxuICAgKiBAcGFyYW0gZG9tIFRoZSBuZXcgbm9kZSB0byByZXBsYWNlIHByZXZEb21cbiAgICogQHBhcmFtIHByZXZEb20gdGhlIG5vZGUgdGhhdCB3aWxsIGJlIHJlcGxhY2VkXG4gICAqL1xuICByZXBsYWNlQ2hpbGQoZG9tLCBwcmV2RG9tKSB7XG4gICAgaWYgKCEocHJldkRvbS5wYXJlbnRFbGVtZW50ID09PSB0aGlzLmVsZW1lbnQpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEVsZW1lbnRET01TbG90LnJlcGxhY2VDaGlsZDogcHJldkRvbSBpcyBub3QgaW4gZWxlbWVudGApO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQucmVwbGFjZUNoaWxkKGRvbSwgcHJldkRvbSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IG1hbmFnZWQgY2hpbGQgb2YgdGhpcyBub2RlLFxuICAgKiB3aGljaCB3aWxsIGVpdGhlciBiZSB0aGlzLmFmdGVyLm5leHRTaWJsaW5nIG9yIHRoaXMuZWxlbWVudC5maXJzdENoaWxkLFxuICAgKiBhbmQgd2lsbCBuZXZlciBiZSB0aGlzLmJlZm9yZSBpZiBpdCBpcyBkZWZpbmVkLlxuICAgKi9cbiAgZ2V0Rmlyc3RDaGlsZCgpIHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gdGhpcy5hZnRlciA/IHRoaXMuYWZ0ZXIubmV4dFNpYmxpbmcgOiB0aGlzLmVsZW1lbnQuZmlyc3RDaGlsZDtcbiAgICByZXR1cm4gZmlyc3RDaGlsZCA9PT0gdGhpcy5iZWZvcmUgfHwgZmlyc3RDaGlsZCA9PT0gdGhpcy5nZXRNYW5hZ2VkTGluZUJyZWFrKCkgPyBudWxsIDogZmlyc3RDaGlsZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRNYW5hZ2VkTGluZUJyZWFrKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgcmV0dXJuIGVsZW1lbnQuX19sZXhpY2FsTGluZUJyZWFrIHx8IG51bGw7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRNYW5hZ2VkTGluZUJyZWFrKGxpbmVCcmVha1R5cGUpIHtcbiAgICBpZiAobGluZUJyZWFrVHlwZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5yZW1vdmVNYW5hZ2VkTGluZUJyZWFrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHdlYmtpdEhhY2sgPSBsaW5lQnJlYWtUeXBlID09PSAnZGVjb3JhdG9yJyAmJiAoSVNfSU9TIHx8IElTX1NBRkFSSSk7XG4gICAgICB0aGlzLmluc2VydE1hbmFnZWRMaW5lQnJlYWsod2Via2l0SGFjayk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICByZW1vdmVNYW5hZ2VkTGluZUJyZWFrKCkge1xuICAgIGNvbnN0IGJyID0gdGhpcy5nZXRNYW5hZ2VkTGluZUJyZWFrKCk7XG4gICAgaWYgKGJyKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgICAgY29uc3Qgc2libGluZyA9IGJyLm5vZGVOYW1lID09PSAnSU1HJyA/IGJyLm5leHRTaWJsaW5nIDogbnVsbDtcbiAgICAgIGlmIChzaWJsaW5nKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQ2hpbGQoc2libGluZyk7XG4gICAgICB9XG4gICAgICBlbGVtZW50LnJlbW92ZUNoaWxkKGJyKTtcbiAgICAgIGVsZW1lbnQuX19sZXhpY2FsTGluZUJyZWFrID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGluc2VydE1hbmFnZWRMaW5lQnJlYWsod2Via2l0SGFjaykge1xuICAgIGNvbnN0IHByZXZCcmVhayA9IHRoaXMuZ2V0TWFuYWdlZExpbmVCcmVhaygpO1xuICAgIGlmIChwcmV2QnJlYWspIHtcbiAgICAgIGlmICh3ZWJraXRIYWNrID09PSAocHJldkJyZWFrLm5vZGVOYW1lID09PSAnSU1HJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW1vdmVNYW5hZ2VkTGluZUJyZWFrKCk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgY29uc3QgYmVmb3JlID0gdGhpcy5iZWZvcmU7XG4gICAgY29uc3QgYnIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpO1xuICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGJyLCBiZWZvcmUpO1xuICAgIGlmICh3ZWJraXRIYWNrKSB7XG4gICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1saW5lYnJlYWsnLCAndHJ1ZScpO1xuICAgICAgaW1nLnN0eWxlLmNzc1RleHQgPSAnZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7IGJvcmRlcjogMHB4ICFpbXBvcnRhbnQ7IG1hcmdpbjogMHB4ICFpbXBvcnRhbnQ7JztcbiAgICAgIGltZy5hbHQgPSAnJztcbiAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKGltZywgYnIpO1xuICAgICAgZWxlbWVudC5fX2xleGljYWxMaW5lQnJlYWsgPSBpbWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuX19sZXhpY2FsTGluZUJyZWFrID0gYnI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXQgb2YgdGhlIGZpcnN0IGNoaWxkXG4gICAqL1xuICBnZXRGaXJzdENoaWxkT2Zmc2V0KCkge1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKGxldCBub2RlID0gdGhpcy5hZnRlcjsgbm9kZSAhPT0gbnVsbDsgbm9kZSA9IG5vZGUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVzb2x2ZUNoaWxkSW5kZXgoZWxlbWVudCwgZWxlbWVudERPTSwgaW5pdGlhbERPTSwgaW5pdGlhbE9mZnNldCkge1xuICAgIGlmIChpbml0aWFsRE9NID09PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGRPZmZzZXQgPSB0aGlzLmdldEZpcnN0Q2hpbGRPZmZzZXQoKTtcbiAgICAgIHJldHVybiBbZWxlbWVudCwgTWF0aC5taW4oZmlyc3RDaGlsZE9mZnNldCArIGVsZW1lbnQuZ2V0Q2hpbGRyZW5TaXplKCksIE1hdGgubWF4KGZpcnN0Q2hpbGRPZmZzZXQsIGluaXRpYWxPZmZzZXQpKV07XG4gICAgfVxuICAgIC8vIFRoZSByZXNvbHZlZCBvZmZzZXQgbXVzdCBiZSBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGNoaWxkcmVuXG4gICAgY29uc3QgaW5pdGlhbFBhdGggPSBpbmRleFBhdGgoZWxlbWVudERPTSwgaW5pdGlhbERPTSk7XG4gICAgaW5pdGlhbFBhdGgucHVzaChpbml0aWFsT2Zmc2V0KTtcbiAgICBjb25zdCBlbGVtZW50UGF0aCA9IGluZGV4UGF0aChlbGVtZW50RE9NLCB0aGlzLmVsZW1lbnQpO1xuICAgIGxldCBvZmZzZXQgPSBlbGVtZW50LmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50UGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gaW5pdGlhbFBhdGhbaV07XG4gICAgICBjb25zdCBzb3VyY2UgPSBlbGVtZW50UGF0aFtpXTtcbiAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPCBzb3VyY2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRhcmdldCA+IHNvdXJjZSkge1xuICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbZWxlbWVudC5nZXRQYXJlbnRPclRocm93KCksIG9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIGluZGV4UGF0aChyb290LCBjaGlsZCkge1xuICBjb25zdCBwYXRoID0gW107XG4gIGxldCBub2RlID0gY2hpbGQ7XG4gIGZvciAoOyBub2RlICE9PSByb290ICYmIG5vZGUgIT09IG51bGw7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgc2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nOyBzaWJsaW5nICE9PSBudWxsOyBzaWJsaW5nID0gc2libGluZy5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcGF0aC5wdXNoKGkpO1xuICB9XG4gIGlmICghKG5vZGUgPT09IHJvb3QpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbmRleFBhdGg6IHJvb3QgaXMgbm90IGEgcGFyZW50IG9mIGNoaWxkYCk7XG4gIH1cbiAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpO1xufVxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZGVjbGFyYXRpb24tbWVyZ2luZ1xuY2xhc3MgRWxlbWVudE5vZGUgZXh0ZW5kcyBMZXhpY2FsTm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX2ZpcnN0ID0gbnVsbDtcbiAgICB0aGlzLl9fbGFzdCA9IG51bGw7XG4gICAgdGhpcy5fX3NpemUgPSAwO1xuICAgIHRoaXMuX19mb3JtYXQgPSAwO1xuICAgIHRoaXMuX19zdHlsZSA9ICcnO1xuICAgIHRoaXMuX19pbmRlbnQgPSAwO1xuICAgIHRoaXMuX19kaXIgPSBudWxsO1xuICAgIHRoaXMuX190ZXh0Rm9ybWF0ID0gMDtcbiAgICB0aGlzLl9fdGV4dFN0eWxlID0gJyc7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpIHtcbiAgICBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSk7XG4gICAgaWYgKHRoaXMuX19rZXkgPT09IHByZXZOb2RlLl9fa2V5KSB7XG4gICAgICB0aGlzLl9fZmlyc3QgPSBwcmV2Tm9kZS5fX2ZpcnN0O1xuICAgICAgdGhpcy5fX2xhc3QgPSBwcmV2Tm9kZS5fX2xhc3Q7XG4gICAgICB0aGlzLl9fc2l6ZSA9IHByZXZOb2RlLl9fc2l6ZTtcbiAgICB9XG4gICAgdGhpcy5fX2luZGVudCA9IHByZXZOb2RlLl9faW5kZW50O1xuICAgIHRoaXMuX19mb3JtYXQgPSBwcmV2Tm9kZS5fX2Zvcm1hdDtcbiAgICB0aGlzLl9fc3R5bGUgPSBwcmV2Tm9kZS5fX3N0eWxlO1xuICAgIHRoaXMuX19kaXIgPSBwcmV2Tm9kZS5fX2RpcjtcbiAgICB0aGlzLl9fdGV4dEZvcm1hdCA9IHByZXZOb2RlLl9fdGV4dEZvcm1hdDtcbiAgICB0aGlzLl9fdGV4dFN0eWxlID0gcHJldk5vZGUuX190ZXh0U3R5bGU7XG4gIH1cbiAgZ2V0Rm9ybWF0KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fZm9ybWF0O1xuICB9XG4gIGdldEZvcm1hdFR5cGUoKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRGb3JtYXQoKTtcbiAgICByZXR1cm4gRUxFTUVOVF9GT1JNQVRfVE9fVFlQRVtmb3JtYXRdIHx8ICcnO1xuICB9XG4gIGdldFN0eWxlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fc3R5bGU7XG4gIH1cbiAgZ2V0SW5kZW50KCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9faW5kZW50O1xuICB9XG4gIGdldENoaWxkcmVuKCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gW107XG4gICAgbGV0IGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIGdldENoaWxkcmVuS2V5cygpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgIGxldCBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZC5fX2tleSk7XG4gICAgICBjaGlsZCA9IGNoaWxkLmdldE5leHRTaWJsaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuICBnZXRDaGlsZHJlblNpemUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19zaXplO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDA7XG4gIH1cbiAgaXNEaXJ0eSgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICBjb25zdCBkaXJ0eUVsZW1lbnRzID0gZWRpdG9yLl9kaXJ0eUVsZW1lbnRzO1xuICAgIHJldHVybiBkaXJ0eUVsZW1lbnRzICE9PSBudWxsICYmIGRpcnR5RWxlbWVudHMuaGFzKHRoaXMuX19rZXkpO1xuICB9XG4gIGlzTGFzdENoaWxkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IHBhcmVudExhc3RDaGlsZCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpLmdldExhc3RDaGlsZCgpO1xuICAgIHJldHVybiBwYXJlbnRMYXN0Q2hpbGQgIT09IG51bGwgJiYgcGFyZW50TGFzdENoaWxkLmlzKHNlbGYpO1xuICB9XG4gIGdldEFsbFRleHROb2RlcygpIHtcbiAgICBjb25zdCB0ZXh0Tm9kZXMgPSBbXTtcbiAgICBsZXQgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgdGV4dE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgICBjb25zdCBzdWJDaGlsZHJlbk5vZGVzID0gY2hpbGQuZ2V0QWxsVGV4dE5vZGVzKCk7XG4gICAgICAgIHRleHROb2Rlcy5wdXNoKC4uLnN1YkNoaWxkcmVuTm9kZXMpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dE5vZGVzO1xuICB9XG4gIGdldEZpcnN0RGVzY2VuZGFudCgpIHtcbiAgICBsZXQgbm9kZSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIHdoaWxlICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZ2V0TGFzdERlc2NlbmRhbnQoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuICAgIHdoaWxlICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgY29uc3QgY2hpbGQgPSBub2RlLmdldExhc3RDaGlsZCgpO1xuICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IGNoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBnZXREZXNjZW5kYW50QnlJbmRleChpbmRleCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIC8vIEZvciBub24tZW1wdHkgZWxlbWVudCBub2Rlcywgd2UgcmVzb2x2ZSBpdHMgZGVzY2VuZGFudFxuICAgIC8vIChlaXRoZXIgYSBsZWFmIG5vZGUgb3IgdGhlIGJvdHRvbS1tb3N0IGVsZW1lbnQpXG4gICAgaWYgKGluZGV4ID49IGNoaWxkcmVuTGVuZ3RoKSB7XG4gICAgICBjb25zdCByZXNvbHZlZE5vZGUgPSBjaGlsZHJlbltjaGlsZHJlbkxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuICRpc0VsZW1lbnROb2RlKHJlc29sdmVkTm9kZSkgJiYgcmVzb2x2ZWROb2RlLmdldExhc3REZXNjZW5kYW50KCkgfHwgcmVzb2x2ZWROb2RlIHx8IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkTm9kZSA9IGNoaWxkcmVuW2luZGV4XTtcbiAgICByZXR1cm4gJGlzRWxlbWVudE5vZGUocmVzb2x2ZWROb2RlKSAmJiByZXNvbHZlZE5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCkgfHwgcmVzb2x2ZWROb2RlIHx8IG51bGw7XG4gIH1cbiAgZ2V0Rmlyc3RDaGlsZCgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBmaXJzdEtleSA9IHNlbGYuX19maXJzdDtcbiAgICByZXR1cm4gZmlyc3RLZXkgPT09IG51bGwgPyBudWxsIDogJGdldE5vZGVCeUtleShmaXJzdEtleSk7XG4gIH1cbiAgZ2V0Rmlyc3RDaGlsZE9yVGhyb3coKSB7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmIChmaXJzdENoaWxkID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgbm9kZSAke3RoaXMuX19rZXl9IHRvIGhhdmUgYSBmaXJzdCBjaGlsZC5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpcnN0Q2hpbGQ7XG4gIH1cbiAgZ2V0TGFzdENoaWxkKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IGxhc3RLZXkgPSBzZWxmLl9fbGFzdDtcbiAgICByZXR1cm4gbGFzdEtleSA9PT0gbnVsbCA/IG51bGwgOiAkZ2V0Tm9kZUJ5S2V5KGxhc3RLZXkpO1xuICB9XG4gIGdldExhc3RDaGlsZE9yVGhyb3coKSB7XG4gICAgY29uc3QgbGFzdENoaWxkID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAobGFzdENoaWxkID09PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgbm9kZSAke3RoaXMuX19rZXl9IHRvIGhhdmUgYSBsYXN0IGNoaWxkLmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGFzdENoaWxkO1xuICB9XG4gIGdldENoaWxkQXRJbmRleChpbmRleCkge1xuICAgIGNvbnN0IHNpemUgPSB0aGlzLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGxldCBub2RlO1xuICAgIGxldCBpO1xuICAgIGlmIChpbmRleCA8IHNpemUgLyAyKSB7XG4gICAgICBub2RlID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpID0gMDtcbiAgICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGkgPD0gaW5kZXgpIHtcbiAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG5vZGUgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuICAgIGkgPSBzaXplIC0gMTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBpID49IGluZGV4KSB7XG4gICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGktLTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgbGV0IHRleHRDb250ZW50ID0gJyc7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmdldENoaWxkcmVuKCk7XG4gICAgY29uc3QgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgdGV4dENvbnRlbnQgKz0gY2hpbGQuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkgJiYgaSAhPT0gY2hpbGRyZW5MZW5ndGggLSAxICYmICFjaGlsZC5pc0lubGluZSgpKSB7XG4gICAgICAgIHRleHRDb250ZW50ICs9IERPVUJMRV9MSU5FX0JSRUFLO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnRTaXplKCkge1xuICAgIGxldCB0ZXh0Q29udGVudFNpemUgPSAwO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5nZXRDaGlsZHJlbigpO1xuICAgIGNvbnN0IGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIHRleHRDb250ZW50U2l6ZSArPSBjaGlsZC5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkgJiYgaSAhPT0gY2hpbGRyZW5MZW5ndGggLSAxICYmICFjaGlsZC5pc0lubGluZSgpKSB7XG4gICAgICAgIHRleHRDb250ZW50U2l6ZSArPSBET1VCTEVfTElORV9CUkVBSy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0ZXh0Q29udGVudFNpemU7XG4gIH1cbiAgZ2V0RGlyZWN0aW9uKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fZGlyO1xuICB9XG4gIGdldFRleHRGb3JtYXQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX190ZXh0Rm9ybWF0O1xuICB9XG4gIGhhc0Zvcm1hdCh0eXBlKSB7XG4gICAgaWYgKHR5cGUgIT09ICcnKSB7XG4gICAgICBjb25zdCBmb3JtYXRGbGFnID0gRUxFTUVOVF9UWVBFX1RPX0ZPUk1BVFt0eXBlXTtcbiAgICAgIHJldHVybiAodGhpcy5nZXRGb3JtYXQoKSAmIGZvcm1hdEZsYWcpICE9PSAwO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGFzVGV4dEZvcm1hdCh0eXBlKSB7XG4gICAgY29uc3QgZm9ybWF0RmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgcmV0dXJuICh0aGlzLmdldFRleHRGb3JtYXQoKSAmIGZvcm1hdEZsYWcpICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmb3JtYXQgZmxhZ3MgYXBwbGllZCB0byB0aGUgbm9kZSBhcyBhIDMyLWJpdCBpbnRlZ2VyLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIG51bWJlciByZXByZXNlbnRpbmcgdGhlIFRleHRGb3JtYXRUeXBlcyBhcHBsaWVkIHRvIHRoZSBub2RlLlxuICAgKi9cbiAgZ2V0Rm9ybWF0RmxhZ3ModHlwZSwgYWxpZ25XaXRoRm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgY29uc3QgZm9ybWF0ID0gc2VsZi5fX3RleHRGb3JtYXQ7XG4gICAgcmV0dXJuIHRvZ2dsZVRleHRGb3JtYXRUeXBlKGZvcm1hdCwgdHlwZSwgYWxpZ25XaXRoRm9ybWF0KTtcbiAgfVxuICBnZXRUZXh0U3R5bGUoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX190ZXh0U3R5bGU7XG4gIH1cblxuICAvLyBNdXRhdG9yc1xuXG4gIHNlbGVjdChfYW5jaG9yT2Zmc2V0LCBfZm9jdXNPZmZzZXQpIHtcbiAgICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgbGV0IGFuY2hvck9mZnNldCA9IF9hbmNob3JPZmZzZXQ7XG4gICAgbGV0IGZvY3VzT2Zmc2V0ID0gX2ZvY3VzT2Zmc2V0O1xuICAgIGNvbnN0IGNoaWxkcmVuQ291bnQgPSB0aGlzLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGlmICghdGhpcy5jYW5CZUVtcHR5KCkpIHtcbiAgICAgIGlmIChfYW5jaG9yT2Zmc2V0ID09PSAwICYmIF9mb2N1c09mZnNldCA9PT0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdENoaWxkKSB8fCAkaXNFbGVtZW50Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBmaXJzdENoaWxkLnNlbGVjdCgwLCAwKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoX2FuY2hvck9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IF9hbmNob3JPZmZzZXQgPT09IGNoaWxkcmVuQ291bnQpICYmIChfZm9jdXNPZmZzZXQgPT09IHVuZGVmaW5lZCB8fCBfZm9jdXNPZmZzZXQgPT09IGNoaWxkcmVuQ291bnQpKSB7XG4gICAgICAgIGNvbnN0IGxhc3RDaGlsZCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG4gICAgICAgIGlmICgkaXNUZXh0Tm9kZShsYXN0Q2hpbGQpIHx8ICRpc0VsZW1lbnROb2RlKGxhc3RDaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gbGFzdENoaWxkLnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhbmNob3JPZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYW5jaG9yT2Zmc2V0ID0gY2hpbGRyZW5Db3VudDtcbiAgICB9XG4gICAgaWYgKGZvY3VzT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvY3VzT2Zmc2V0ID0gY2hpbGRyZW5Db3VudDtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gdGhpcy5fX2tleTtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiAkaW50ZXJuYWxNYWtlUmFuZ2VTZWxlY3Rpb24oa2V5LCBhbmNob3JPZmZzZXQsIGtleSwgZm9jdXNPZmZzZXQsICdlbGVtZW50JywgJ2VsZW1lbnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZWN0aW9uLmFuY2hvci5zZXQoa2V5LCBhbmNob3JPZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICBzZWxlY3Rpb24uZm9jdXMuc2V0KGtleSwgZm9jdXNPZmZzZXQsICdlbGVtZW50Jyk7XG4gICAgICBzZWxlY3Rpb24uZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0aW9uO1xuICB9XG4gIHNlbGVjdFN0YXJ0KCkge1xuICAgIGNvbnN0IGZpcnN0Tm9kZSA9IHRoaXMuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gICAgcmV0dXJuIGZpcnN0Tm9kZSA/IGZpcnN0Tm9kZS5zZWxlY3RTdGFydCgpIDogdGhpcy5zZWxlY3QoKTtcbiAgfVxuICBzZWxlY3RFbmQoKSB7XG4gICAgY29uc3QgbGFzdE5vZGUgPSB0aGlzLmdldExhc3REZXNjZW5kYW50KCk7XG4gICAgcmV0dXJuIGxhc3ROb2RlID8gbGFzdE5vZGUuc2VsZWN0RW5kKCkgOiB0aGlzLnNlbGVjdCgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGNoaWxkLnJlbW92ZSgpKTtcbiAgICByZXR1cm4gd3JpdGFibGVTZWxmO1xuICB9XG4gIGFwcGVuZCguLi5ub2Rlc1RvQXBwZW5kKSB7XG4gICAgcmV0dXJuIHRoaXMuc3BsaWNlKHRoaXMuZ2V0Q2hpbGRyZW5TaXplKCksIDAsIG5vZGVzVG9BcHBlbmQpO1xuICB9XG4gIHNldERpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19kaXIgPSBkaXJlY3Rpb247XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgc2V0Rm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19mb3JtYXQgPSB0eXBlICE9PSAnJyA/IEVMRU1FTlRfVFlQRV9UT19GT1JNQVRbdHlwZV0gOiAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNldFN0eWxlKHN0eWxlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fc3R5bGUgPSBzdHlsZSB8fCAnJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzZXRUZXh0Rm9ybWF0KHR5cGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX190ZXh0Rm9ybWF0ID0gdHlwZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBzZXRUZXh0U3R5bGUoc3R5bGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX190ZXh0U3R5bGUgPSBzdHlsZTtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBzZXRJbmRlbnQoaW5kZW50TGV2ZWwpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19pbmRlbnQgPSBpbmRlbnRMZXZlbDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBub2Rlc1RvSW5zZXJ0KSB7XG4gICAgY29uc3Qgbm9kZXNUb0luc2VydExlbmd0aCA9IG5vZGVzVG9JbnNlcnQubGVuZ3RoO1xuICAgIGNvbnN0IG9sZFNpemUgPSB0aGlzLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgIGNvbnN0IHdyaXRhYmxlU2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBpZiAoIShzdGFydCArIGRlbGV0ZUNvdW50IDw9IG9sZFNpemUpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEVsZW1lbnROb2RlLnNwbGljZTogc3RhcnQgKyBkZWxldGVDb3VudCA+IG9sZFNpemUgKCR7U3RyaW5nKHN0YXJ0KX0gKyAke1N0cmluZyhkZWxldGVDb3VudCl9ID4gJHtTdHJpbmcob2xkU2l6ZSl9KWApO1xuICAgIH1cbiAgICBjb25zdCB3cml0YWJsZVNlbGZLZXkgPSB3cml0YWJsZVNlbGYuX19rZXk7XG4gICAgY29uc3Qgbm9kZXNUb0luc2VydEtleXMgPSBbXTtcbiAgICBjb25zdCBub2Rlc1RvUmVtb3ZlS2V5cyA9IFtdO1xuICAgIGNvbnN0IG5vZGVBZnRlclJhbmdlID0gdGhpcy5nZXRDaGlsZEF0SW5kZXgoc3RhcnQgKyBkZWxldGVDb3VudCk7XG4gICAgbGV0IG5vZGVCZWZvcmVSYW5nZSA9IG51bGw7XG4gICAgbGV0IG5ld1NpemUgPSBvbGRTaXplIC0gZGVsZXRlQ291bnQgKyBub2Rlc1RvSW5zZXJ0TGVuZ3RoO1xuICAgIGlmIChzdGFydCAhPT0gMCkge1xuICAgICAgaWYgKHN0YXJ0ID09PSBvbGRTaXplKSB7XG4gICAgICAgIG5vZGVCZWZvcmVSYW5nZSA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXRDaGlsZEF0SW5kZXgoc3RhcnQpO1xuICAgICAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGVCZWZvcmVSYW5nZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlbGV0ZUNvdW50ID4gMCkge1xuICAgICAgbGV0IG5vZGVUb0RlbGV0ZSA9IG5vZGVCZWZvcmVSYW5nZSA9PT0gbnVsbCA/IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpIDogbm9kZUJlZm9yZVJhbmdlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbGV0ZUNvdW50OyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGVUb0RlbGV0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgc3BsaWNlOiBzaWJsaW5nIG5vdCBmb3VuZGApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGVUb0RlbGV0ZS5nZXROZXh0U2libGluZygpO1xuICAgICAgICBjb25zdCBub2RlS2V5VG9EZWxldGUgPSBub2RlVG9EZWxldGUuX19rZXk7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlTm9kZVRvRGVsZXRlID0gbm9kZVRvRGVsZXRlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9EZWxldGUpO1xuICAgICAgICBub2Rlc1RvUmVtb3ZlS2V5cy5wdXNoKG5vZGVLZXlUb0RlbGV0ZSk7XG4gICAgICAgIG5vZGVUb0RlbGV0ZSA9IG5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcHJldk5vZGUgPSBub2RlQmVmb3JlUmFuZ2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvSW5zZXJ0TGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGVUb0luc2VydCA9IG5vZGVzVG9JbnNlcnRbaV07XG4gICAgICBpZiAocHJldk5vZGUgIT09IG51bGwgJiYgbm9kZVRvSW5zZXJ0LmlzKHByZXZOb2RlKSkge1xuICAgICAgICBub2RlQmVmb3JlUmFuZ2UgPSBwcmV2Tm9kZSA9IHByZXZOb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd3JpdGFibGVOb2RlVG9JbnNlcnQgPSBub2RlVG9JbnNlcnQuZ2V0V3JpdGFibGUoKTtcbiAgICAgIGlmICh3cml0YWJsZU5vZGVUb0luc2VydC5fX3BhcmVudCA9PT0gd3JpdGFibGVTZWxmS2V5KSB7XG4gICAgICAgIG5ld1NpemUtLTtcbiAgICAgIH1cbiAgICAgIHJlbW92ZUZyb21QYXJlbnQod3JpdGFibGVOb2RlVG9JbnNlcnQpO1xuICAgICAgY29uc3Qgbm9kZUtleVRvSW5zZXJ0ID0gbm9kZVRvSW5zZXJ0Ll9fa2V5O1xuICAgICAgaWYgKHByZXZOb2RlID09PSBudWxsKSB7XG4gICAgICAgIHdyaXRhYmxlU2VsZi5fX2ZpcnN0ID0gbm9kZUtleVRvSW5zZXJ0O1xuICAgICAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2Tm9kZSA9IHByZXZOb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUHJldk5vZGUuX19uZXh0ID0gbm9kZUtleVRvSW5zZXJ0O1xuICAgICAgICB3cml0YWJsZU5vZGVUb0luc2VydC5fX3ByZXYgPSB3cml0YWJsZVByZXZOb2RlLl9fa2V5O1xuICAgICAgfVxuICAgICAgaWYgKG5vZGVUb0luc2VydC5fX2tleSA9PT0gd3JpdGFibGVTZWxmS2V5KSB7XG4gICAgICAgIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGFwcGVuZDogYXR0ZW1wdGluZyB0byBhcHBlbmQgc2VsZmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBTZXQgY2hpbGQgcGFyZW50IHRvIHNlbGZcbiAgICAgIHdyaXRhYmxlTm9kZVRvSW5zZXJ0Ll9fcGFyZW50ID0gd3JpdGFibGVTZWxmS2V5O1xuICAgICAgbm9kZXNUb0luc2VydEtleXMucHVzaChub2RlS2V5VG9JbnNlcnQpO1xuICAgICAgcHJldk5vZGUgPSBub2RlVG9JbnNlcnQ7XG4gICAgfVxuICAgIGlmIChzdGFydCArIGRlbGV0ZUNvdW50ID09PSBvbGRTaXplKSB7XG4gICAgICBpZiAocHJldk5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgd3JpdGFibGVQcmV2Tm9kZSA9IHByZXZOb2RlLmdldFdyaXRhYmxlKCk7XG4gICAgICAgIHdyaXRhYmxlUHJldk5vZGUuX19uZXh0ID0gbnVsbDtcbiAgICAgICAgd3JpdGFibGVTZWxmLl9fbGFzdCA9IHByZXZOb2RlLl9fa2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZUFmdGVyUmFuZ2UgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHdyaXRhYmxlTm9kZUFmdGVyUmFuZ2UgPSBub2RlQWZ0ZXJSYW5nZS5nZXRXcml0YWJsZSgpO1xuICAgICAgaWYgKHByZXZOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdyaXRhYmxlUHJldk5vZGUgPSBwcmV2Tm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgICB3cml0YWJsZU5vZGVBZnRlclJhbmdlLl9fcHJldiA9IHByZXZOb2RlLl9fa2V5O1xuICAgICAgICB3cml0YWJsZVByZXZOb2RlLl9fbmV4dCA9IG5vZGVBZnRlclJhbmdlLl9fa2V5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JpdGFibGVOb2RlQWZ0ZXJSYW5nZS5fX3ByZXYgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB3cml0YWJsZVNlbGYuX19zaXplID0gbmV3U2l6ZTtcblxuICAgIC8vIEluIGNhc2Ugb2YgZGVsZXRpb24gd2UgbmVlZCB0byBhZGp1c3Qgc2VsZWN0aW9uLCB1bmxpbmsgcmVtb3ZlZCBub2Rlc1xuICAgIC8vIGFuZCBjbGVhbiB1cCBub2RlIGl0c2VsZiBpZiBpdCBiZWNvbWVzIGVtcHR5LiBOb25lIG9mIHRoZXNlIG5lZWRlZFxuICAgIC8vIGZvciBpbnNlcnRpb24tb25seSBjYXNlc1xuICAgIGlmIChub2Rlc1RvUmVtb3ZlS2V5cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkanVzdGluZyBzZWxlY3Rpb24sIGluIGNhc2Ugbm9kZSB0aGF0IHdhcyBhbmNob3IvZm9jdXMgd2lsbCBiZSBkZWxldGVkXG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBjb25zdCBub2Rlc1RvUmVtb3ZlS2V5U2V0ID0gbmV3IFNldChub2Rlc1RvUmVtb3ZlS2V5cyk7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9JbnNlcnRLZXlTZXQgPSBuZXcgU2V0KG5vZGVzVG9JbnNlcnRLZXlzKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICBmb2N1c1xuICAgICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBpZiAoaXNQb2ludFJlbW92ZWQoYW5jaG9yLCBub2Rlc1RvUmVtb3ZlS2V5U2V0LCBub2Rlc1RvSW5zZXJ0S2V5U2V0KSkge1xuICAgICAgICAgIG1vdmVTZWxlY3Rpb25Qb2ludFRvU2libGluZyhhbmNob3IsIGFuY2hvci5nZXROb2RlKCksIHRoaXMsIG5vZGVCZWZvcmVSYW5nZSwgbm9kZUFmdGVyUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BvaW50UmVtb3ZlZChmb2N1cywgbm9kZXNUb1JlbW92ZUtleVNldCwgbm9kZXNUb0luc2VydEtleVNldCkpIHtcbiAgICAgICAgICBtb3ZlU2VsZWN0aW9uUG9pbnRUb1NpYmxpbmcoZm9jdXMsIGZvY3VzLmdldE5vZGUoKSwgdGhpcywgbm9kZUJlZm9yZVJhbmdlLCBub2RlQWZ0ZXJSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYW51cCBpZiBub2RlIGNhbid0IGJlIGVtcHR5XG4gICAgICAgIGlmIChuZXdTaXplID09PSAwICYmICF0aGlzLmNhbkJlRW1wdHkoKSAmJiAhJGlzUm9vdE9yU2hhZG93Um9vdCh0aGlzKSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHdyaXRhYmxlU2VsZjtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqXG4gICAqIEFuIGV4cGVyaW1lbnRhbCBBUEkgdGhhdCBhbiBFbGVtZW50Tm9kZSBjYW4gb3ZlcnJpZGUgdG8gY29udHJvbCB3aGVyZSBpdHNcbiAgICogY2hpbGRyZW4gYXJlIGluc2VydGVkIGludG8gdGhlIERPTSwgdGhpcyBpcyB1c2VmdWwgdG8gYWRkIGEgd3JhcHBpbmcgbm9kZVxuICAgKiBvciBhY2Nlc3Nvcnkgbm9kZXMgYmVmb3JlIG9yIGFmdGVyIHRoZSBjaGlsZHJlbi4gVGhlIHJvb3Qgb2YgdGhlIG5vZGUgcmV0dXJuZWRcbiAgICogYnkgY3JlYXRlRE9NIG11c3Qgc3RpbGwgYmUgZXhhY3RseSBvbmUgSFRNTEVsZW1lbnQuXG4gICAqL1xuICBnZXRET01TbG90KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRET01TbG90KGVsZW1lbnQpO1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBpbmRlbnQgPSB0aGlzLmdldEluZGVudCgpO1xuICAgICAgaWYgKGluZGVudCA+IDApIHtcbiAgICAgICAgLy8gcGFkZGluZy1pbmxpbmUtc3RhcnQgaXMgbm90IHdpZGVseSBzdXBwb3J0ZWQgaW4gZW1haWwgSFRNTFxuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vd3d3LmNhbmllbWFpbC5jb20vZmVhdHVyZXMvY3NzLXBhZGRpbmctaW5saW5lLXN0YXJ0LWVuZC8pLFxuICAgICAgICAvLyBJZiB5b3Ugd2FudCB0byB1c2UgSFRNTCBvdXRwdXQgZm9yIGVtYWlsLCBjb25zaWRlciBvdmVycmlkaW5nIHRoZSBzZXJpYWxpemF0aW9uXG4gICAgICAgIC8vIHRvIHVzZSBgcGFkZGluZy1yaWdodGAgaW4gUlRMIGxhbmd1YWdlcywgYHBhZGRpbmctbGVmdGAgaW4gYExUUmAgbGFuZ3VhZ2VzLCBvclxuICAgICAgICAvLyBgdGV4dC1pbmRlbnRgIGlmIHlvdSBhcmUgb2sgd2l0aCBmaXJzdC1saW5lIGluZGVudHMuXG4gICAgICAgIC8vIFdlIHJlY29tbWVuZCBrZWVwaW5nIG11bHRpcGxlcyBvZiA0MHB4IHRvIG1haW50YWluIGNvbnNpc3RlbmN5IHdpdGggbGlzdC1pdGVtc1xuICAgICAgICAvLyAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9sZXhpY2FsL3B1bGwvNDAyNSlcbiAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nSW5saW5lU3RhcnQgPSBgJHtpbmRlbnQgKiA0MH1weGA7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBlbGVtZW50LmRpciA9IGRpcmVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIC8vIEpTT04gc2VyaWFsaXphdGlvblxuICBleHBvcnRKU09OKCkge1xuICAgIGNvbnN0IGpzb24gPSB7XG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZ2V0RGlyZWN0aW9uKCksXG4gICAgICBmb3JtYXQ6IHRoaXMuZ2V0Rm9ybWF0VHlwZSgpLFxuICAgICAgaW5kZW50OiB0aGlzLmdldEluZGVudCgpLFxuICAgICAgLy8gQXMgYW4gZXhjZXB0aW9uIGhlcmUgd2UgaW52b2tlIHN1cGVyIGF0IHRoZSBlbmQgZm9yIGhpc3RvcmljYWwgcmVhc29ucy5cbiAgICAgIC8vIE5hbWVseSwgdG8gcHJlc2VydmUgdGhlIG9yZGVyIG9mIHRoZSBwcm9wZXJ0aWVzIGFuZCBub3QgdG8gYnJlYWsgdGhlIHRlc3RzXG4gICAgICAvLyB0aGF0IHVzZSB0aGUgc2VyaWFsaXplZCBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKClcbiAgICB9O1xuICAgIGNvbnN0IHRleHRGb3JtYXQgPSB0aGlzLmdldFRleHRGb3JtYXQoKTtcbiAgICBjb25zdCB0ZXh0U3R5bGUgPSB0aGlzLmdldFRleHRTdHlsZSgpO1xuICAgIGlmICh0ZXh0Rm9ybWF0ICE9PSAwKSB7XG4gICAgICBqc29uLnRleHRGb3JtYXQgPSB0ZXh0Rm9ybWF0O1xuICAgIH1cbiAgICBpZiAodGV4dFN0eWxlICE9PSAnJykge1xuICAgICAganNvbi50ZXh0U3R5bGUgPSB0ZXh0U3R5bGU7XG4gICAgfVxuICAgIHJldHVybiBqc29uO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRGb3JtYXQoc2VyaWFsaXplZE5vZGUuZm9ybWF0KS5zZXRJbmRlbnQoc2VyaWFsaXplZE5vZGUuaW5kZW50KS5zZXREaXJlY3Rpb24oc2VyaWFsaXplZE5vZGUuZGlyZWN0aW9uKS5zZXRUZXh0Rm9ybWF0KHNlcmlhbGl6ZWROb2RlLnRleHRGb3JtYXQgfHwgMCkuc2V0VGV4dFN0eWxlKHNlcmlhbGl6ZWROb2RlLnRleHRTdHlsZSB8fCAnJyk7XG4gIH1cbiAgLy8gVGhlc2UgYXJlIGludGVuZGVkIHRvIGJlIGV4dGVuZHMgZm9yIHNwZWNpZmljIGVsZW1lbnQgaGV1cmlzdGljcy5cbiAgaW5zZXJ0TmV3QWZ0ZXIoc2VsZWN0aW9uLCByZXN0b3JlU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qXG4gICAqIFRoaXMgbWV0aG9kIGNvbnRyb2xzIHRoZSBiZWhhdmlvciBvZiB0aGUgbm9kZSBkdXJpbmcgYmFja3dhcmRzXG4gICAqIGRlbGV0aW9uIChpLmUuLCBiYWNrc3BhY2UpIHdoZW4gc2VsZWN0aW9uIGlzIGF0IHRoZSBiZWdpbm5pbmcgb2ZcbiAgICogdGhlIG5vZGUgKG9mZnNldCAwKS4gWW91IG1heSB1c2UgdGhpcyB0byBoYXZlIHRoZSBub2RlIHJlcGxhY2VcbiAgICogaXRzZWxmLCBjaGFuZ2UgaXRzIHN0YXRlLCBvciBkbyBub3RoaW5nLiBXaGVuIHlvdSBkbyBtYWtlIHN1Y2hcbiAgICogYSBjaGFuZ2UsIHlvdSBzaG91bGQgcmV0dXJuIHRydWUuXG4gICAqXG4gICAqIFdoZW4gdHJ1ZSBpcyByZXR1cm5lZCwgdGhlIGNvbGxhcHNlIHBoYXNlIHdpbGwgc3RvcC5cbiAgICogV2hlbiBmYWxzZSBpcyByZXR1cm5lZCwgYW5kIGlzSW5saW5lKCkgaXMgdHJ1ZSwgYW5kIGdldFByZXZpb3VzU2libGluZygpIGlzIG51bGwsXG4gICAqIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbiBpdHMgcGFyZW50LlxuICAgKi9cbiAgY29sbGFwc2VBdFN0YXJ0KHNlbGVjdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleGNsdWRlRnJvbUNvcHkoZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIEBpbnRlcm5hbCAqL1xuICBjYW5SZXBsYWNlV2l0aChyZXBsYWNlbWVudCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBAaW50ZXJuYWwgKi9cbiAgY2FuSW5zZXJ0QWZ0ZXIobm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjYW5JbnNlcnRUZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaXNJbmxpbmUoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEEgc2hhZG93IHJvb3QgaXMgYSBOb2RlIHRoYXQgYmVoYXZlcyBsaWtlIFJvb3ROb2RlLiBUaGUgc2hhZG93IHJvb3QgKGFuZCBSb290Tm9kZSkgbWFyayB0aGVcbiAgLy8gZW5kIG9mIHRoZSBoaWVyYXJjaHksIG1vc3QgaW1wbGVtZW50YXRpb25zIHNob3VsZCB0cmVhdCBpdCBhcyB0aGVyZSdzIG5vdGhpbmcgKHVwd2FyZHMpXG4gIC8vIGJleW9uZCB0aGlzIHBvaW50LiBGb3IgZXhhbXBsZSwgbm9kZS5nZXRUb3BMZXZlbEVsZW1lbnQoKSwgd2hlbiBwZXJmb3JtZWQgaW5zaWRlIGEgVGFibGVDZWxsTm9kZVxuICAvLyB3aWxsIHJldHVybiB0aGUgaW1tZWRpYXRlIGZpcnN0IGNoaWxkIHVuZGVybmVhdGggVGFibGVDZWxsTm9kZSBpbnN0ZWFkIG9mIFJvb3ROb2RlLlxuICBpc1NoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKiBAZGVwcmVjYXRlZCBAaW50ZXJuYWwgKi9cbiAgY2FuTWVyZ2VXaXRoKG5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCwgc2VsZWN0aW9uLCBkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBub2RlLCB3aGVuIGVtcHR5LCBjYW4gbWVyZ2Ugd2l0aCBhIGZpcnN0IGJsb2NrXG4gICAqIG9mIG5vZGVzIGJlaW5nIGluc2VydGVkLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBzcGVjaWZpY2FsbHkgY2FsbGVkIGluIHtAbGluayBSYW5nZVNlbGVjdGlvbi5pbnNlcnROb2Rlc31cbiAgICogdG8gZGV0ZXJtaW5lIG1lcmdpbmcgYmVoYXZpb3IgZHVyaW5nIG5vZGVzIGluc2VydGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gSW4gYSBMaXN0SXRlbU5vZGUgb3IgUXVvdGVOb2RlIGltcGxlbWVudGF0aW9uOlxuICAgKiBjYW5NZXJnZVdoZW5FbXB0eSgpOiB0cnVlIHtcbiAgICogIHJldHVybiB0cnVlO1xuICAgKiB9XG4gICAqL1xuICBjYW5NZXJnZVdoZW5FbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHJlY29uY2lsZU9ic2VydmVkTXV0YXRpb24oZG9tLCBlZGl0b3IpIHtcbiAgICBjb25zdCBzbG90ID0gdGhpcy5nZXRET01TbG90KGRvbSk7XG4gICAgbGV0IGN1cnJlbnRET00gPSBzbG90LmdldEZpcnN0Q2hpbGQoKTtcbiAgICBmb3IgKGxldCBjdXJyZW50Tm9kZSA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpOyBjdXJyZW50Tm9kZTsgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXROZXh0U2libGluZygpKSB7XG4gICAgICBjb25zdCBjb3JyZWN0RE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShjdXJyZW50Tm9kZS5nZXRLZXkoKSk7XG4gICAgICBpZiAoY29ycmVjdERPTSA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50RE9NID09IG51bGwpIHtcbiAgICAgICAgc2xvdC5pbnNlcnRDaGlsZChjb3JyZWN0RE9NKTtcbiAgICAgICAgY3VycmVudERPTSA9IGNvcnJlY3RET007XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnRET00gIT09IGNvcnJlY3RET00pIHtcbiAgICAgICAgc2xvdC5yZXBsYWNlQ2hpbGQoY29ycmVjdERPTSwgY3VycmVudERPTSk7XG4gICAgICB9XG4gICAgICBjdXJyZW50RE9NID0gY3VycmVudERPTS5uZXh0U2libGluZztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRpc0VsZW1lbnROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50Tm9kZTtcbn1cbmZ1bmN0aW9uIGlzUG9pbnRSZW1vdmVkKHBvaW50LCBub2Rlc1RvUmVtb3ZlS2V5U2V0LCBub2Rlc1RvSW5zZXJ0S2V5U2V0KSB7XG4gIGxldCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGNvbnN0IG5vZGVLZXkgPSBub2RlLl9fa2V5O1xuICAgIGlmIChub2Rlc1RvUmVtb3ZlS2V5U2V0Lmhhcyhub2RlS2V5KSAmJiAhbm9kZXNUb0luc2VydEtleVNldC5oYXMobm9kZUtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcblxuLyoqIEBub0luaGVyaXREb2MgKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWRlY2xhcmF0aW9uLW1lcmdpbmdcbmNsYXNzIERlY29yYXRvck5vZGUgZXh0ZW5kcyBMZXhpY2FsTm9kZSB7XG4gIC8qKlxuICAgKiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgYWRkZWQgdG8gdGhlIExleGljYWxFZGl0b3IuX2RlY29yYXRvcnNcbiAgICovXG4gIGRlY29yYXRlKGVkaXRvciwgY29uZmlnKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBkZWNvcmF0ZTogYmFzZSBtZXRob2Qgbm90IGV4dGVuZGVkYCk7XG4gICAgfVxuICB9XG4gIGlzSXNvbGF0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzSW5saW5lKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzS2V5Ym9hcmRTZWxlY3RhYmxlKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBEZWNvcmF0b3JOb2RlO1xufVxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgUm9vdE5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3Jvb3QnO1xuICB9XG4gIHN0YXRpYyBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFJvb3ROb2RlKCk7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ3Jvb3QnKTtcbiAgICB0aGlzLl9fY2FjaGVkVGV4dCA9IG51bGw7XG4gIH1cbiAgZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGdldFRvcExldmVsRWxlbWVudE9yVGhyb3c6IHJvb3Qgbm9kZXMgYXJlIG5vdCB0b3AgbGV2ZWwgZWxlbWVudHNgKTtcbiAgICB9XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgY29uc3QgY2FjaGVkVGV4dCA9IHRoaXMuX19jYWNoZWRUZXh0O1xuICAgIGlmIChpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSgpIHx8IGdldEFjdGl2ZUVkaXRvcigpLl9kaXJ0eVR5cGUgPT09IE5PX0RJUlRZX05PREVTKSB7XG4gICAgICBpZiAoY2FjaGVkVGV4dCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gY2FjaGVkVGV4dDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldFRleHRDb250ZW50KCk7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgcmVtb3ZlOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH1cbiAgcmVwbGFjZShub2RlKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGByZXBsYWNlOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH1cbiAgaW5zZXJ0QmVmb3JlKG5vZGVUb0luc2VydCkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgaW5zZXJ0QmVmb3JlOiBjYW5ub3QgYmUgY2FsbGVkIG9uIHJvb3Qgbm9kZXNgKTtcbiAgICB9XG4gIH1cbiAgaW5zZXJ0QWZ0ZXIobm9kZVRvSW5zZXJ0KSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbnNlcnRBZnRlcjogY2Fubm90IGJlIGNhbGxlZCBvbiByb290IG5vZGVzYCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVmlld1xuXG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gTXV0YXRlXG4gIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIG5vZGVzVG9JbnNlcnQpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXNUb0luc2VydCkge1xuICAgICAgaWYgKCEoJGlzRWxlbWVudE5vZGUobm9kZSkgfHwgJGlzRGVjb3JhdG9yTm9kZShub2RlKSkpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGByb290Tm9kZS5zcGxpY2U6IE9ubHkgZWxlbWVudCBvciBkZWNvcmF0b3Igbm9kZXMgY2FuIGJlIGluc2VydGVkIHRvIHRoZSByb290IG5vZGVgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIG5vZGVzVG9JbnNlcnQpO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgLy8gV2UgZG9uJ3QgY3JlYXRlIGEgcm9vdCwgYW5kIGluc3RlYWQgdXNlIHRoZSBleGlzdGluZyByb290LlxuICAgIHJldHVybiAkZ2V0Um9vdCgpLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKTtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uICRjcmVhdGVSb290Tm9kZSgpIHtcbiAgcmV0dXJuIG5ldyBSb290Tm9kZSgpO1xufVxuZnVuY3Rpb24gJGlzUm9vdE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFJvb3ROb2RlO1xufVxuXG5mdW5jdGlvbiBlZGl0b3JTdGF0ZUhhc0RpcnR5U2VsZWN0aW9uKGVkaXRvclN0YXRlLCBlZGl0b3IpIHtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLl9zZWxlY3Rpb247XG4gIGNvbnN0IHBlbmRpbmdTZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uO1xuXG4gIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gdXBkYXRlIGJlY2F1c2Ugb2YgY2hhbmdlcyBpbiBzZWxlY3Rpb25cbiAgaWYgKHBlbmRpbmdTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbi5kaXJ0eSB8fCAhcGVuZGluZ1NlbGVjdGlvbi5pcyhjdXJyZW50U2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGN1cnJlbnRTZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjbG9uZUVkaXRvclN0YXRlKGN1cnJlbnQpIHtcbiAgcmV0dXJuIG5ldyBFZGl0b3JTdGF0ZShuZXcgTWFwKGN1cnJlbnQuX25vZGVNYXApKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKSB7XG4gIHJldHVybiBuZXcgRWRpdG9yU3RhdGUobmV3IE1hcChbWydyb290JywgJGNyZWF0ZVJvb3ROb2RlKCldXSkpO1xufVxuZnVuY3Rpb24gZXhwb3J0Tm9kZVRvSlNPTihub2RlKSB7XG4gIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gbm9kZS5leHBvcnRKU09OKCk7XG4gIGNvbnN0IG5vZGVDbGFzcyA9IG5vZGUuY29uc3RydWN0b3I7XG4gIGlmIChzZXJpYWxpemVkTm9kZS50eXBlICE9PSBub2RlQ2xhc3MuZ2V0VHlwZSgpKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBMZXhpY2FsTm9kZTogTm9kZSAke25vZGVDbGFzcy5uYW1lfSBkb2VzIG5vdCBtYXRjaCB0aGUgc2VyaWFsaXplZCB0eXBlLiBDaGVjayBpZiAuZXhwb3J0SlNPTigpIGlzIGltcGxlbWVudGVkIGFuZCBpdCBpcyByZXR1cm5pbmcgdGhlIGNvcnJlY3QgdHlwZS5gKTtcbiAgICB9XG4gIH1cbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZENoaWxkcmVuID0gc2VyaWFsaXplZE5vZGUuY2hpbGRyZW47XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNlcmlhbGl6ZWRDaGlsZHJlbikpIHtcbiAgICAgIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBMZXhpY2FsTm9kZTogTm9kZSAke25vZGVDbGFzcy5uYW1lfSBpcyBhbiBlbGVtZW50IGJ1dCAuZXhwb3J0SlNPTigpIGRvZXMgbm90IGhhdmUgYSBjaGlsZHJlbiBhcnJheS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBleHBvcnROb2RlVG9KU09OKGNoaWxkKTtcbiAgICAgIHNlcmlhbGl6ZWRDaGlsZHJlbi5wdXNoKHNlcmlhbGl6ZWRDaGlsZE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgcmV0dXJuIHNlcmlhbGl6ZWROb2RlO1xufVxuY2xhc3MgRWRpdG9yU3RhdGUge1xuICBjb25zdHJ1Y3Rvcihub2RlTWFwLCBzZWxlY3Rpb24pIHtcbiAgICB0aGlzLl9ub2RlTWFwID0gbm9kZU1hcDtcbiAgICB0aGlzLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb24gfHwgbnVsbDtcbiAgICB0aGlzLl9mbHVzaFN5bmMgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkT25seSA9IGZhbHNlO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVNYXAuc2l6ZSA9PT0gMSAmJiB0aGlzLl9zZWxlY3Rpb24gPT09IG51bGw7XG4gIH1cbiAgcmVhZChjYWxsYmFja0ZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHJlYWRFZGl0b3JTdGF0ZShvcHRpb25zICYmIG9wdGlvbnMuZWRpdG9yIHx8IG51bGwsIHRoaXMsIGNhbGxiYWNrRm4pO1xuICB9XG4gIGNsb25lKHNlbGVjdGlvbikge1xuICAgIGNvbnN0IGVkaXRvclN0YXRlID0gbmV3IEVkaXRvclN0YXRlKHRoaXMuX25vZGVNYXAsIHNlbGVjdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5fc2VsZWN0aW9uIDogc2VsZWN0aW9uKTtcbiAgICBlZGl0b3JTdGF0ZS5fcmVhZE9ubHkgPSB0cnVlO1xuICAgIHJldHVybiBlZGl0b3JTdGF0ZTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHJlYWRFZGl0b3JTdGF0ZShudWxsLCB0aGlzLCAoKSA9PiAoe1xuICAgICAgcm9vdDogZXhwb3J0Tm9kZVRvSlNPTigkZ2V0Um9vdCgpKVxuICAgIH0pKTtcbiAgfVxufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogQ29tbW9uIHVwZGF0ZSB0YWdzIHVzZWQgaW4gTGV4aWNhbC4gVGhlc2UgdGFncyBjYW4gYmUgdXNlZCB3aXRoIGVkaXRvci51cGRhdGUoKSBvciAkYWRkVXBkYXRlVGFnKClcbiAqIHRvIGluZGljYXRlIHRoZSB0eXBlL3B1cnBvc2Ugb2YgYW4gdXBkYXRlLiBNdWx0aXBsZSB0YWdzIGNhbiBiZSB1c2VkIGluIGEgc2luZ2xlIHVwZGF0ZS5cbiAqL1xuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSB1cGRhdGUgaXMgcmVsYXRlZCB0byBoaXN0b3J5IG9wZXJhdGlvbnMgKHVuZG8vcmVkbylcbiAqL1xuY29uc3QgSElTVE9SSUNfVEFHID0gJ2hpc3RvcmljJztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBhIG5ldyBoaXN0b3J5IGVudHJ5IHNob3VsZCBiZSBwdXNoZWQgdG8gdGhlIGhpc3Rvcnkgc3RhY2tcbiAqL1xuY29uc3QgSElTVE9SWV9QVVNIX1RBRyA9ICdoaXN0b3J5LXB1c2gnO1xuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50IHVwZGF0ZSBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIHByZXZpb3VzIGhpc3RvcnkgZW50cnlcbiAqL1xuY29uc3QgSElTVE9SWV9NRVJHRV9UQUcgPSAnaGlzdG9yeS1tZXJnZSc7XG5cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgdGhlIHVwZGF0ZSBpcyByZWxhdGVkIHRvIGEgcGFzdGUgb3BlcmF0aW9uXG4gKi9cbmNvbnN0IFBBU1RFX1RBRyA9ICdwYXN0ZSc7XG5cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgdGhlIHVwZGF0ZSBpcyByZWxhdGVkIHRvIGNvbGxhYm9yYXRpdmUgZWRpdGluZ1xuICovXG5jb25zdCBDT0xMQUJPUkFUSU9OX1RBRyA9ICdjb2xsYWJvcmF0aW9uJztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgdXBkYXRlIHNob3VsZCBza2lwIGNvbGxhYm9yYXRpdmUgc3luY1xuICovXG5jb25zdCBTS0lQX0NPTExBQl9UQUcgPSAnc2tpcC1jb2xsYWInO1xuXG4vKipcbiAqIEluZGljYXRlcyB0aGF0IHRoZSB1cGRhdGUgc2hvdWxkIHNraXAgc2Nyb2xsaW5nIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3XG4gKi9cbmNvbnN0IFNLSVBfU0NST0xMX0lOVE9fVklFV19UQUcgPSAnc2tpcC1zY3JvbGwtaW50by12aWV3JztcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGUgdXBkYXRlIHNob3VsZCBza2lwIHVwZGF0aW5nIHRoZSBET00gc2VsZWN0aW9uXG4gKiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIG1ha2UgdXBkYXRlcyB3aXRob3V0IGNoYW5naW5nIHRoZSBzZWxlY3Rpb24gb3IgZm9jdXNcbiAqL1xuY29uc3QgU0tJUF9ET01fU0VMRUNUSU9OX1RBRyA9ICdza2lwLWRvbS1zZWxlY3Rpb24nO1xuXG4vKipcbiAqIFRoZSB1cGRhdGUgd2FzIHRyaWdnZXJlZCBieSBlZGl0b3IuZm9jdXMoKVxuICovXG5jb25zdCBGT0NVU19UQUcgPSAnZm9jdXMnO1xuXG4vKipcbiAqIFRoZSBzZXQgb2Yga25vd24gdXBkYXRlIHRhZ3MgdG8gaGVscCB3aXRoIFR5cGVTY3JpcHQgc3VnZ2VzdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5cbi8vIFRPRE86IENsZWFudXAgQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UgIzU5NjZcbmNsYXNzIEFydGlmaWNpYWxOb2RlX19ET19OT1RfVVNFIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ2FydGlmaWNpYWwnO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICAvLyB0aGlzIGlzbnQgc3VwcG9zZWQgdG8gYmUgdXNlZCBhbmQgaXMgbm90IHVzZWQgYW55d2hlcmUgYnV0IGRlZmluaW5nIGl0IHRvIGFwcGVhc2UgdGhlIEFQSVxuICAgIGNvbnN0IGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldHVybiBkb207XG4gIH1cbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgUGFyYWdyYXBoTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdwYXJhZ3JhcGgnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJhZ3JhcGhOb2RlKG5vZGUuX19rZXkpO1xuICB9XG5cbiAgLy8gVmlld1xuXG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgY29uc3QgY2xhc3NOYW1lcyA9IGdldENhY2hlZENsYXNzTmFtZUFycmF5KGNvbmZpZy50aGVtZSwgJ3BhcmFncmFwaCcpO1xuICAgIGlmIChjbGFzc05hbWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGRvbUNsYXNzTGlzdCA9IGRvbS5jbGFzc0xpc3Q7XG4gICAgICBkb21DbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gZG9tO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFBhcmFncmFwaEVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICBlbGVtZW50LmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZvcm1hdFR5cGUgPSB0aGlzLmdldEZvcm1hdFR5cGUoKTtcbiAgICAgIGlmIChmb3JtYXRUeXBlKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gZm9ybWF0VHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIC8vIFRoZXNlIGFyZSBpbmNsdWRlZCBleHBsaWNpdGx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgdGV4dEZvcm1hdDogdGhpcy5nZXRUZXh0Rm9ybWF0KCksXG4gICAgICB0ZXh0U3R5bGU6IHRoaXMuZ2V0VGV4dFN0eWxlKClcbiAgICB9O1xuICB9XG5cbiAgLy8gTXV0YXRpb25cblxuICBpbnNlcnROZXdBZnRlcihyYW5nZVNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbikge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIG5ld0VsZW1lbnQuc2V0VGV4dEZvcm1hdChyYW5nZVNlbGVjdGlvbi5mb3JtYXQpO1xuICAgIG5ld0VsZW1lbnQuc2V0VGV4dFN0eWxlKHJhbmdlU2VsZWN0aW9uLnN0eWxlKTtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLmdldERpcmVjdGlvbigpO1xuICAgIG5ld0VsZW1lbnQuc2V0RGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgbmV3RWxlbWVudC5zZXRGb3JtYXQodGhpcy5nZXRGb3JtYXRUeXBlKCkpO1xuICAgIG5ld0VsZW1lbnQuc2V0U3R5bGUodGhpcy5nZXRTdHlsZSgpKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG5ld0VsZW1lbnQsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGVtcHR5ICh0cmltbWVkKSBmaXJzdCBwYXJhZ3JhcGggYW5kIHRyeSBhbmQgcmVtb3ZlIGl0LFxuICAgIC8vIGRlbGV0ZSB0aGUgcGFyYWdyYXBoIGFzIGxvbmcgYXMgd2UgaGF2ZSBhbm90aGVyIHNpYmxpbmcgdG8gZ28gdG9cbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8ICRpc1RleHROb2RlKGNoaWxkcmVuWzBdKSAmJiBjaGlsZHJlblswXS5nZXRUZXh0Q29udGVudCgpLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gdGhpcy5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKG5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0TmV4dCgpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgIGlmIChwcmV2U2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0UGFyYWdyYXBoRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IG5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBpZiAoZWxlbWVudC5zdHlsZSkge1xuICAgIG5vZGUuc2V0Rm9ybWF0KGVsZW1lbnQuc3R5bGUudGV4dEFsaWduKTtcbiAgICBzZXROb2RlSW5kZW50RnJvbURPTShlbGVtZW50LCBub2RlKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBQYXJhZ3JhcGhOb2RlKCkpO1xufVxuZnVuY3Rpb24gJGlzUGFyYWdyYXBoTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgUGFyYWdyYXBoTm9kZTtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zODQxXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIEEgTGV4aWNhbE5vZGUgY2xhc3Mgb3IgTGV4aWNhbE5vZGVSZXBsYWNlbWVudCBjb25maWd1cmF0aW9uXG4gKi9cblxuY29uc3QgREVGQVVMVF9TS0lQX0lOSVRJQUxJWkFUSU9OID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIHBheWxvYWQgcGFzc2VkIHRvIGFuIFVwZGF0ZUxpc3RlbmVyXG4gKi9cblxuLyoqXG4gKiBBIGxpc3RlbmVyIHRoYXQgZ2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIGVkaXRvciBpcyB1cGRhdGVkXG4gKi9cblxuY29uc3QgQ09NTUFORF9QUklPUklUWV9FRElUT1IgPSAwO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9MT1cgPSAxO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9OT1JNQUwgPSAyO1xuY29uc3QgQ09NTUFORF9QUklPUklUWV9ISUdIID0gMztcbmNvbnN0IENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwgPSA0O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5cbi8qKlxuICogVHlwZSBoZWxwZXIgZm9yIGV4dHJhY3RpbmcgdGhlIHBheWxvYWQgdHlwZSBmcm9tIGEgY29tbWFuZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IE1ZX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kPFNvbWVUeXBlPigpO1xuICpcbiAqIC8vIC4uLlxuICpcbiAqIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoTVlfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gKiAgIC8vIFR5cGUgb2YgYHBheWxvYWRgIGlzIGluZmVycmVkIGhlcmUuIEJ1dCBsZXRzIHNheSB3ZSB3YW50IHRvIGV4dHJhY3QgYSBmdW5jdGlvbiB0byBkZWxlZ2F0ZSB0b1xuICogICAkaGFuZGxlTXlDb21tYW5kKGVkaXRvciwgcGF5bG9hZCk7XG4gKiAgIHJldHVybiB0cnVlO1xuICogfSk7XG4gKlxuICogZnVuY3Rpb24gJGhhbmRsZU15Q29tbWFuZChlZGl0b3I6IExleGljYWxFZGl0b3IsIHBheWxvYWQ6IENvbW1hbmRQYXlsb2FkVHlwZTx0eXBlb2YgTVlfQ09NTUFORD4pIHtcbiAqICAgLy8gYHBheWxvYWRgIGlzIG9mIHR5cGUgYFNvbWVUeXBlYCwgZXh0cmFjdGVkIGZyb20gdGhlIGNvbW1hbmQuXG4gKiB9XG4gKiBgYGBcbiAqL1xuXG5mdW5jdGlvbiByZXNldEVkaXRvcihlZGl0b3IsIHByZXZSb290RWxlbWVudCwgbmV4dFJvb3RFbGVtZW50LCBwZW5kaW5nRWRpdG9yU3RhdGUpIHtcbiAgY29uc3Qga2V5Tm9kZU1hcCA9IGVkaXRvci5fa2V5VG9ET01NYXA7XG4gIGtleU5vZGVNYXAuY2xlYXIoKTtcbiAgZWRpdG9yLl9lZGl0b3JTdGF0ZSA9IGNyZWF0ZUVtcHR5RWRpdG9yU3RhdGUoKTtcbiAgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBwZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGVkaXRvci5fY29tcG9zaXRpb25LZXkgPSBudWxsO1xuICBlZGl0b3IuX2RpcnR5VHlwZSA9IE5PX0RJUlRZX05PREVTO1xuICBlZGl0b3IuX2Nsb25lTm90TmVlZGVkLmNsZWFyKCk7XG4gIGVkaXRvci5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG4gIGVkaXRvci5fZGlydHlFbGVtZW50cy5jbGVhcigpO1xuICBlZGl0b3IuX25vcm1hbGl6ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgZWRpdG9yLl91cGRhdGVUYWdzID0gbmV3IFNldCgpO1xuICBlZGl0b3IuX3VwZGF0ZXMgPSBbXTtcbiAgZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBudWxsO1xuICBjb25zdCBvYnNlcnZlciA9IGVkaXRvci5fb2JzZXJ2ZXI7XG4gIGlmIChvYnNlcnZlciAhPT0gbnVsbCkge1xuICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICBlZGl0b3IuX29ic2VydmVyID0gbnVsbDtcbiAgfVxuXG4gIC8vIFJlbW92ZSBhbGwgdGhlIERPTSBub2RlcyBmcm9tIHRoZSByb290IGVsZW1lbnRcbiAgaWYgKHByZXZSb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIHByZXZSb290RWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICB9XG4gIGlmIChuZXh0Um9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBuZXh0Um9vdEVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICBrZXlOb2RlTWFwLnNldCgncm9vdCcsIG5leHRSb290RWxlbWVudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGluaXRpYWxpemVDb252ZXJzaW9uQ2FjaGUobm9kZXMsIGFkZGl0aW9uYWxDb252ZXJzaW9ucykge1xuICBjb25zdCBjb252ZXJzaW9uQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGhhbmRsZWRDb252ZXJzaW9ucyA9IG5ldyBTZXQoKTtcbiAgY29uc3QgYWRkQ29udmVyc2lvbnNUb0NhY2hlID0gbWFwID0+IHtcbiAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGxldCBjdXJyZW50Q2FjaGUgPSBjb252ZXJzaW9uQ2FjaGUuZ2V0KGtleSk7XG4gICAgICBpZiAoY3VycmVudENhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudENhY2hlID0gW107XG4gICAgICAgIGNvbnZlcnNpb25DYWNoZS5zZXQoa2V5LCBjdXJyZW50Q2FjaGUpO1xuICAgICAgfVxuICAgICAgY3VycmVudENhY2hlLnB1c2gobWFwW2tleV0pO1xuICAgIH0pO1xuICB9O1xuICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgIGNvbnN0IGltcG9ydERPTSA9IG5vZGUua2xhc3MuaW1wb3J0RE9NO1xuICAgIGlmIChpbXBvcnRET00gPT0gbnVsbCB8fCBoYW5kbGVkQ29udmVyc2lvbnMuaGFzKGltcG9ydERPTSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlZENvbnZlcnNpb25zLmFkZChpbXBvcnRET00pO1xuICAgIGNvbnN0IG1hcCA9IGltcG9ydERPTS5jYWxsKG5vZGUua2xhc3MpO1xuICAgIGlmIChtYXAgIT09IG51bGwpIHtcbiAgICAgIGFkZENvbnZlcnNpb25zVG9DYWNoZShtYXApO1xuICAgIH1cbiAgfSk7XG4gIGlmIChhZGRpdGlvbmFsQ29udmVyc2lvbnMpIHtcbiAgICBhZGRDb252ZXJzaW9uc1RvQ2FjaGUoYWRkaXRpb25hbENvbnZlcnNpb25zKTtcbiAgfVxuICByZXR1cm4gY29udmVyc2lvbkNhY2hlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTGV4aWNhbEVkaXRvciBhdHRhY2hlZCB0byBhIHNpbmdsZSBjb250ZW50RWRpdGFibGUgKHByb3ZpZGVkIGluIHRoZSBjb25maWcpLiBUaGlzIGlzXG4gKiB0aGUgbG93ZXN0LWxldmVsIGluaXRpYWxpemF0aW9uIEFQSSBmb3IgYSBMZXhpY2FsRWRpdG9yLiBJZiB5b3UncmUgdXNpbmcgUmVhY3Qgb3IgYW5vdGhlciBmcmFtZXdvcmssXG4gKiBjb25zaWRlciB1c2luZyB0aGUgYXBwcm9wcmlhdGUgYWJzdHJhY3Rpb25zLCBzdWNoIGFzIExleGljYWxDb21wb3NlclxuICogQHBhcmFtIGVkaXRvckNvbmZpZyAtIHRoZSBlZGl0b3IgY29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm5zIGEgTGV4aWNhbEVkaXRvciBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGl0b3IoZWRpdG9yQ29uZmlnKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGVkaXRvckNvbmZpZyB8fCB7fTtcbiAgY29uc3QgYWN0aXZlRWRpdG9yID0gaW50ZXJuYWxHZXRBY3RpdmVFZGl0b3IoKTtcbiAgY29uc3QgdGhlbWUgPSBjb25maWcudGhlbWUgfHwge307XG4gIGNvbnN0IHBhcmVudEVkaXRvciA9IGVkaXRvckNvbmZpZyA9PT0gdW5kZWZpbmVkID8gYWN0aXZlRWRpdG9yIDogY29uZmlnLnBhcmVudEVkaXRvciB8fCBudWxsO1xuICBjb25zdCBkaXNhYmxlRXZlbnRzID0gY29uZmlnLmRpc2FibGVFdmVudHMgfHwgZmFsc2U7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gY3JlYXRlRW1wdHlFZGl0b3JTdGF0ZSgpO1xuICBjb25zdCBuYW1lc3BhY2UgPSBjb25maWcubmFtZXNwYWNlIHx8IChwYXJlbnRFZGl0b3IgIT09IG51bGwgPyBwYXJlbnRFZGl0b3IuX2NvbmZpZy5uYW1lc3BhY2UgOiBjcmVhdGVVSUQoKSk7XG4gIGNvbnN0IGluaXRpYWxFZGl0b3JTdGF0ZSA9IGNvbmZpZy5lZGl0b3JTdGF0ZTtcbiAgY29uc3Qgbm9kZXMgPSBbUm9vdE5vZGUsIFRleHROb2RlLCBMaW5lQnJlYWtOb2RlLCBUYWJOb2RlLCBQYXJhZ3JhcGhOb2RlLCBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSwgLi4uKGNvbmZpZy5ub2RlcyB8fCBbXSldO1xuICBjb25zdCB7XG4gICAgb25FcnJvcixcbiAgICBodG1sXG4gIH0gPSBjb25maWc7XG4gIGNvbnN0IGlzRWRpdGFibGUgPSBjb25maWcuZWRpdGFibGUgIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5lZGl0YWJsZSA6IHRydWU7XG4gIGxldCByZWdpc3RlcmVkTm9kZXM7XG4gIGlmIChlZGl0b3JDb25maWcgPT09IHVuZGVmaW5lZCAmJiBhY3RpdmVFZGl0b3IgIT09IG51bGwpIHtcbiAgICByZWdpc3RlcmVkTm9kZXMgPSBhY3RpdmVFZGl0b3IuX25vZGVzO1xuICB9IGVsc2Uge1xuICAgIHJlZ2lzdGVyZWROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQga2xhc3MgPSBub2Rlc1tpXTtcbiAgICAgIGxldCByZXBsYWNlID0gbnVsbDtcbiAgICAgIGxldCByZXBsYWNlV2l0aEtsYXNzID0gbnVsbDtcbiAgICAgIGlmICh0eXBlb2Yga2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGtsYXNzO1xuICAgICAgICBrbGFzcyA9IG9wdGlvbnMucmVwbGFjZTtcbiAgICAgICAgcmVwbGFjZSA9IG9wdGlvbnMud2l0aDtcbiAgICAgICAgcmVwbGFjZVdpdGhLbGFzcyA9IG9wdGlvbnMud2l0aEtsYXNzIHx8IG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG93bk5vZGVDb25maWdcbiAgICAgIH0gPSBnZXRTdGF0aWNOb2RlQ29uZmlnKGtsYXNzKTtcbiAgICAgIC8vIEVuc3VyZSBjdXN0b20gbm9kZXMgaW1wbGVtZW50IHJlcXVpcmVkIG1ldGhvZHMgYW5kIHJlcGxhY2VXaXRoS2xhc3MgaXMgaW5zdGFuY2Ugb2YgYmFzZSBrbGFzcy5cbiAgICAgIHtcbiAgICAgICAgLy8gQXJ0aWZpY2lhbE5vZGVfX0RPX05PVF9VU0UgY2FuIGdldCByZW5hbWVkLCBzbyB3ZSB1c2UgdGhlIHR5cGVcbiAgICAgICAgY29uc3QgbmFtZSA9IGtsYXNzLm5hbWU7XG4gICAgICAgIGNvbnN0IG5vZGVUeXBlID0gaGFzT3duU3RhdGljTWV0aG9kKGtsYXNzLCAnZ2V0VHlwZScpICYmIGtsYXNzLmdldFR5cGUoKTtcbiAgICAgICAgaWYgKHJlcGxhY2VXaXRoS2xhc3MpIHtcbiAgICAgICAgICBpZiAoIShyZXBsYWNlV2l0aEtsYXNzLnByb3RvdHlwZSBpbnN0YW5jZW9mIGtsYXNzKSkge1xuICAgICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAke3JlcGxhY2VXaXRoS2xhc3MubmFtZX0gZG9lc24ndCBleHRlbmQgdGhlICR7bmFtZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVwbGFjZSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgT3ZlcnJpZGUgZm9yICR7bmFtZX0gc3BlY2lmaWVzICdyZXBsYWNlJyB3aXRob3V0ICd3aXRoS2xhc3MnLiAnd2l0aEtsYXNzJyB3aWxsIGJlIHJlcXVpcmVkIGluIGEgZnV0dXJlIHZlcnNpb24uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgIT09ICdSb290Tm9kZScgJiYgbm9kZVR5cGUgIT09ICdyb290JyAmJiBub2RlVHlwZSAhPT0gJ2FydGlmaWNpYWwnICYmXG4gICAgICAgIC8vIFRoaXMgaXMgbW9zdGx5IGZvciB0aGUgdW5pdCB0ZXN0IHN1aXRlIHdoaWNoXG4gICAgICAgIC8vIHVzZXMgTGV4aWNhbE5vZGUgaW4gYW4gb3RoZXJ3aXNlIGluY29ycmVjdCB3YXlcbiAgICAgICAgLy8gYnkgbW9ja2luZyBpdHMgc3RhdGljIGdldFR5cGVcbiAgICAgICAga2xhc3MgIT09IExleGljYWxOb2RlKSB7XG4gICAgICAgICAgY29uc3QgcHJvdG8gPSBrbGFzcy5wcm90b3R5cGU7XG4gICAgICAgICAgWydnZXRUeXBlJywgJ2Nsb25lJ10uZm9yRWFjaChtZXRob2QgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25TdGF0aWNNZXRob2Qoa2xhc3MsIG1ldGhvZCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IG11c3QgaW1wbGVtZW50IHN0YXRpYyBcIiR7bWV0aG9kfVwiIG1ldGhvZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghaGFzT3duU3RhdGljTWV0aG9kKGtsYXNzLCAnaW1wb3J0RE9NJykgJiYgaGFzT3duRXhwb3J0RE9NKGtsYXNzKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IHNob3VsZCBpbXBsZW1lbnQgXCJpbXBvcnRET01cIiBpZiB1c2luZyBhIGN1c3RvbSBcImV4cG9ydERPTVwiIG1ldGhvZCB0byBlbnN1cmUgSFRNTCBzZXJpYWxpemF0aW9uIChpbXBvcnRhbnQgZm9yIGNvcHkgJiBwYXN0ZSkgd29ya3MgYXMgZXhwZWN0ZWRgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCRpc0RlY29yYXRvck5vZGUocHJvdG8pKSB7XG4gICAgICAgICAgICBpZiAocHJvdG8uZGVjb3JhdGUgPT09IERlY29yYXRvck5vZGUucHJvdG90eXBlLmRlY29yYXRlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtwcm90by5jb25zdHJ1Y3Rvci5uYW1lfSBtdXN0IGltcGxlbWVudCBcImRlY29yYXRlXCIgbWV0aG9kYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaGFzT3duU3RhdGljTWV0aG9kKGtsYXNzLCAnaW1wb3J0SlNPTicpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gc2hvdWxkIGltcGxlbWVudCBcImltcG9ydEpTT05cIiBtZXRob2QgdG8gZW5zdXJlIEpTT04gYW5kIGRlZmF1bHQgSFRNTCBzZXJpYWxpemF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0ga2xhc3MuZ2V0VHlwZSgpO1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0ga2xhc3MudHJhbnNmb3JtKCk7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1zID0gbmV3IFNldCgpO1xuICAgICAgaWYgKG93bk5vZGVDb25maWcgJiYgb3duTm9kZUNvbmZpZy4kdHJhbnNmb3JtKSB7XG4gICAgICAgIHRyYW5zZm9ybXMuYWRkKG93bk5vZGVDb25maWcuJHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICBpZiAodHJhbnNmb3JtICE9PSBudWxsKSB7XG4gICAgICAgIHRyYW5zZm9ybXMuYWRkKHRyYW5zZm9ybSk7XG4gICAgICB9XG4gICAgICByZWdpc3RlcmVkTm9kZXMuc2V0KHR5cGUsIHtcbiAgICAgICAgZXhwb3J0RE9NOiBodG1sICYmIGh0bWwuZXhwb3J0ID8gaHRtbC5leHBvcnQuZ2V0KGtsYXNzKSA6IHVuZGVmaW5lZCxcbiAgICAgICAga2xhc3MsXG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHJlcGxhY2VXaXRoS2xhc3MsXG4gICAgICAgIHNoYXJlZE5vZGVTdGF0ZTogY3JlYXRlU2hhcmVkTm9kZVN0YXRlKG5vZGVzW2ldKSxcbiAgICAgICAgdHJhbnNmb3Jtc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGVkaXRvciA9IG5ldyBMZXhpY2FsRWRpdG9yKGVkaXRvclN0YXRlLCBwYXJlbnRFZGl0b3IsIHJlZ2lzdGVyZWROb2Rlcywge1xuICAgIGRpc2FibGVFdmVudHMsXG4gICAgbmFtZXNwYWNlLFxuICAgIHRoZW1lXG4gIH0sIG9uRXJyb3IgPyBvbkVycm9yIDogY29uc29sZS5lcnJvciwgaW5pdGlhbGl6ZUNvbnZlcnNpb25DYWNoZShyZWdpc3RlcmVkTm9kZXMsIGh0bWwgPyBodG1sLmltcG9ydCA6IHVuZGVmaW5lZCksIGlzRWRpdGFibGUsIGVkaXRvckNvbmZpZyk7XG4gIGlmIChpbml0aWFsRWRpdG9yU3RhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgIGVkaXRvci5fcGVuZGluZ0VkaXRvclN0YXRlID0gaW5pdGlhbEVkaXRvclN0YXRlO1xuICAgIGVkaXRvci5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gIH1cbiAgcmV0dXJuIGVkaXRvcjtcbn1cbmNsYXNzIExleGljYWxFZGl0b3Ige1xuICAvKiogVGhlIHZlcnNpb24gd2l0aCBidWlsZCBpZGVudGlmaWVycyBmb3IgdGhpcyBlZGl0b3IgKHNpbmNlIDAuMTcuMSkgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gIGNvbnN0cnVjdG9yKGVkaXRvclN0YXRlLCBwYXJlbnRFZGl0b3IsIG5vZGVzLCBjb25maWcsIG9uRXJyb3IsIGh0bWxDb252ZXJzaW9ucywgZWRpdGFibGUsIGNyZWF0ZUVkaXRvckFyZ3MpIHtcbiAgICB0aGlzLl9jcmVhdGVFZGl0b3JBcmdzID0gY3JlYXRlRWRpdG9yQXJncztcbiAgICB0aGlzLl9wYXJlbnRFZGl0b3IgPSBwYXJlbnRFZGl0b3I7XG4gICAgLy8gVGhlIHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBlZGl0b3JcbiAgICB0aGlzLl9yb290RWxlbWVudCA9IG51bGw7XG4gICAgLy8gVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlXG4gICAgdGhpcy5fZWRpdG9yU3RhdGUgPSBlZGl0b3JTdGF0ZTtcbiAgICAvLyBIYW5kbGluZyBvZiBkcmFmdHMgYW5kIHVwZGF0ZXNcbiAgICB0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgPSBudWxsO1xuICAgIC8vIFVzZWQgdG8gaGVscCBjby1vcmRpbmF0ZSBzZWxlY3Rpb24gYW5kIGV2ZW50c1xuICAgIHRoaXMuX2NvbXBvc2l0aW9uS2V5ID0gbnVsbDtcbiAgICB0aGlzLl9kZWZlcnJlZCA9IFtdO1xuICAgIC8vIFVzZWQgZHVyaW5nIHJlY29uY2lsaWF0aW9uXG4gICAgdGhpcy5fa2V5VG9ET01NYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fdXBkYXRlcyA9IFtdO1xuICAgIHRoaXMuX3VwZGF0aW5nID0gZmFsc2U7XG4gICAgLy8gTGlzdGVuZXJzXG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge1xuICAgICAgZGVjb3JhdG9yOiBuZXcgU2V0KCksXG4gICAgICBlZGl0YWJsZTogbmV3IFNldCgpLFxuICAgICAgbXV0YXRpb246IG5ldyBNYXAoKSxcbiAgICAgIHJvb3Q6IG5ldyBTZXQoKSxcbiAgICAgIHRleHRjb250ZW50OiBuZXcgU2V0KCksXG4gICAgICB1cGRhdGU6IG5ldyBTZXQoKVxuICAgIH07XG4gICAgLy8gQ29tbWFuZHNcbiAgICB0aGlzLl9jb21tYW5kcyA9IG5ldyBNYXAoKTtcbiAgICAvLyBFZGl0b3IgY29uZmlndXJhdGlvbiBmb3IgdGhlbWUvY29udGV4dC5cbiAgICB0aGlzLl9jb25maWcgPSBjb25maWc7XG4gICAgLy8gTWFwcGluZyBvZiB0eXBlcyB0byB0aGVpciBub2Rlc1xuICAgIHRoaXMuX25vZGVzID0gbm9kZXM7XG4gICAgLy8gUmVhY3Qgbm9kZSBkZWNvcmF0b3JzIGZvciBwb3J0YWxzXG4gICAgdGhpcy5fZGVjb3JhdG9ycyA9IHt9O1xuICAgIHRoaXMuX3BlbmRpbmdEZWNvcmF0b3JzID0gbnVsbDtcbiAgICAvLyBVc2VkIHRvIG9wdGltaXplIHJlY29uY2lsaWF0aW9uXG4gICAgdGhpcy5fZGlydHlUeXBlID0gTk9fRElSVFlfTk9ERVM7XG4gICAgdGhpcy5fY2xvbmVOb3ROZWVkZWQgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fZGlydHlMZWF2ZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fZGlydHlFbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ub3JtYWxpemVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5fdXBkYXRlVGFncyA9IG5ldyBTZXQoKTtcbiAgICAvLyBIYW5kbGluZyBvZiBET00gbXV0YXRpb25zXG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIC8vIFVzZWQgZm9yIGlkZW50aWZ5aW5nIG93bmluZyBlZGl0b3JzXG4gICAgdGhpcy5fa2V5ID0gY3JlYXRlVUlEKCk7XG4gICAgdGhpcy5fb25FcnJvciA9IG9uRXJyb3I7XG4gICAgdGhpcy5faHRtbENvbnZlcnNpb25zID0gaHRtbENvbnZlcnNpb25zO1xuICAgIHRoaXMuX2VkaXRhYmxlID0gZWRpdGFibGU7XG4gICAgdGhpcy5faGVhZGxlc3MgPSBwYXJlbnRFZGl0b3IgIT09IG51bGwgJiYgcGFyZW50RWRpdG9yLl9oZWFkbGVzcztcbiAgICB0aGlzLl93aW5kb3cgPSBudWxsO1xuICAgIHRoaXMuX2Jsb2NrQ3Vyc29yRWxlbWVudCA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZWRpdG9yIGlzIGN1cnJlbnRseSBpbiBcImNvbXBvc2l0aW9uXCIgbW9kZSBkdWUgdG8gcmVjZWl2aW5nIGlucHV0XG4gICAqIHRocm91Z2ggYW4gSU1FLCBvciAzUCBleHRlbnNpb24sIGZvciBleGFtcGxlLiBSZXR1cm5zIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzQ29tcG9zaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wb3NpdGlvbktleSAhPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciBmb3IgRWRpdG9yIHVwZGF0ZSBldmVudC4gV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFja1xuICAgKiBlYWNoIHRpbWUgdGhlIGVkaXRvciBnb2VzIHRocm91Z2ggYW4gdXBkYXRlICh2aWEge0BsaW5rIExleGljYWxFZGl0b3IudXBkYXRlfSkgdW50aWwgdGhlXG4gICAqIHRlYXJkb3duIGZ1bmN0aW9uIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMudXBkYXRlO1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciBmb3Igd2hlbiB0aGUgZWRpdG9yIGNoYW5nZXMgYmV0d2VlbiBlZGl0YWJsZSBhbmQgbm9uLWVkaXRhYmxlIHN0YXRlcy5cbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICByZWdpc3RlckVkaXRhYmxlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBjb25zdCBsaXN0ZW5lclNldE9yTWFwID0gdGhpcy5fbGlzdGVuZXJzLmVkaXRhYmxlO1xuICAgIGxpc3RlbmVyU2V0T3JNYXAuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbGlzdGVuZXJTZXRPck1hcC5kZWxldGUobGlzdGVuZXIpO1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIGZvciB3aGVuIHRoZSBlZGl0b3IncyBkZWNvcmF0b3Igb2JqZWN0IGNoYW5nZXMuIFRoZSBkZWNvcmF0b3Igb2JqZWN0IGNvbnRhaW5zXG4gICAqIGFsbCBEZWNvcmF0b3JOb2RlIGtleXMgLT4gdGhlaXIgZGVjb3JhdGVkIHZhbHVlLiBUaGlzIGlzIHByaW1hcmlseSB1c2VkIHdpdGggZXh0ZXJuYWwgVUkgZnJhbWV3b3Jrcy5cbiAgICpcbiAgICogV2lsbCB0cmlnZ2VyIHRoZSBwcm92aWRlZCBjYWxsYmFjayBlYWNoIHRpbWUgdGhlIGVkaXRvciB0cmFuc2l0aW9ucyBiZXR3ZWVuIHRoZXNlIHN0YXRlcyB1bnRpbCB0aGVcbiAgICogdGVhcmRvd24gZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICByZWdpc3RlckRlY29yYXRvckxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJTZXRPck1hcCA9IHRoaXMuX2xpc3RlbmVycy5kZWNvcmF0b3I7XG4gICAgbGlzdGVuZXJTZXRPck1hcC5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lclNldE9yTWFwLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIHdoZW4gTGV4aWNhbCBjb21taXRzIGFuIHVwZGF0ZSB0byB0aGUgRE9NIGFuZCB0aGUgdGV4dCBjb250ZW50IG9mXG4gICAqIHRoZSBlZGl0b3IgY2hhbmdlcyBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZSBvZiB0aGUgZWRpdG9yLiBJZiB0aGUgdGV4dCBjb250ZW50IGlzIHRoZVxuICAgKiBzYW1lIGJldHdlZW4gdXBkYXRlcywgbm8gbm90aWZpY2F0aW9ucyB0byB0aGUgbGlzdGVuZXJzIHdpbGwgaGFwcGVuLlxuICAgKlxuICAgKiBXaWxsIHRyaWdnZXIgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGVhY2ggdGltZSB0aGUgZWRpdG9yIHRyYW5zaXRpb25zIGJldHdlZW4gdGhlc2Ugc3RhdGVzIHVudGlsIHRoZVxuICAgKiB0ZWFyZG93biBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlZ2lzdGVyVGV4dENvbnRlbnRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGNvbnN0IGxpc3RlbmVyU2V0T3JNYXAgPSB0aGlzLl9saXN0ZW5lcnMudGV4dGNvbnRlbnQ7XG4gICAgbGlzdGVuZXJTZXRPck1hcC5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lclNldE9yTWFwLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgZm9yIHdoZW4gdGhlIGVkaXRvcidzIHJvb3QgRE9NIGVsZW1lbnQgKHRoZSBjb250ZW50IGVkaXRhYmxlXG4gICAqIExleGljYWwgYXR0YWNoZXMgdG8pIGNoYW5nZXMuIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gYXR0YWNoIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgcm9vdFxuICAgKiAgZWxlbWVudC4gVGhlIHJvb3QgbGlzdGVuZXIgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZGlyZWN0bHkgdXBvbiByZWdpc3RyYXRpb24gYW5kIHRoZW4gb25cbiAgICogYW55IHN1YnNlcXVlbnQgdXBkYXRlLlxuICAgKlxuICAgKiBXaWxsIHRyaWdnZXIgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGVhY2ggdGltZSB0aGUgZWRpdG9yIHRyYW5zaXRpb25zIGJldHdlZW4gdGhlc2Ugc3RhdGVzIHVudGlsIHRoZVxuICAgKiB0ZWFyZG93biBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIGEgdGVhcmRvd24gZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhbnVwIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIHJlZ2lzdGVyUm9vdExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgY29uc3QgbGlzdGVuZXJTZXRPck1hcCA9IHRoaXMuX2xpc3RlbmVycy5yb290O1xuICAgIGxpc3RlbmVyKHRoaXMuX3Jvb3RFbGVtZW50LCBudWxsKTtcbiAgICBsaXN0ZW5lclNldE9yTWFwLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVyKG51bGwsIHRoaXMuX3Jvb3RFbGVtZW50KTtcbiAgICAgIGxpc3RlbmVyU2V0T3JNYXAuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgdHJpZ2dlciBhbnl0aW1lIHRoZSBwcm92aWRlZCBjb21tYW5kXG4gICAqIGlzIGRpc3BhdGNoZWQgd2l0aCB7QGxpbmsgTGV4aWNhbEVkaXRvci5kaXNwYXRjaH0sIHN1YmplY3QgdG8gcHJpb3JpdHkuXG4gICAqIExpc3RlbmVycyB0aGF0IHJ1biBhdCBhIGhpZ2hlciBwcmlvcml0eSBjYW4gXCJpbnRlcmNlcHRcIiBjb21tYW5kcyBhbmRcbiAgICogcHJldmVudCB0aGVtIGZyb20gcHJvcGFnYXRpbmcgdG8gb3RoZXIgaGFuZGxlcnMgYnkgcmV0dXJuaW5nIHRydWUuXG4gICAqXG4gICAqIExpc3RlbmVycyBhcmUgYWx3YXlzIGludm9rZWQgaW4gYW4ge0BsaW5rIExleGljYWxFZGl0b3IudXBkYXRlfSBhbmQgY2FuXG4gICAqIGNhbGwgZG9sbGFyIGZ1bmN0aW9ucy5cbiAgICpcbiAgICogTGlzdGVuZXJzIHJlZ2lzdGVyZWQgYXQgdGhlIHNhbWUgcHJpb3JpdHkgbGV2ZWwgd2lsbCBydW5cbiAgICogZGV0ZXJtaW5pc3RpY2FsbHkgaW4gdGhlIG9yZGVyIG9mIHJlZ2lzdHJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIGNvbW1hbmQgLSB0aGUgY29tbWFuZCB0aGF0IHdpbGwgdHJpZ2dlciB0aGUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIHRoZSBmdW5jdGlvbiB0aGF0IHdpbGwgZXhlY3V0ZSB3aGVuIHRoZSBjb21tYW5kIGlzIGRpc3BhdGNoZWQuXG4gICAqIEBwYXJhbSBwcmlvcml0eSAtIHRoZSByZWxhdGl2ZSBwcmlvcml0eSBvZiB0aGUgbGlzdGVuZXIuIDAgfCAxIHwgMiB8IDMgfCA0XG4gICAqICAgKG9yIHtAbGluayBDT01NQU5EX1BSSU9SSVRZX0VESVRPUn0gfFxuICAgKiAgICAge0BsaW5rIENPTU1BTkRfUFJJT1JJVFlfTE9XfSB8XG4gICAqICAgICB7QGxpbmsgQ09NTUFORF9QUklPUklUWV9OT1JNQUx9IHxcbiAgICogICAgIHtAbGluayBDT01NQU5EX1BSSU9SSVRZX0hJR0h9IHxcbiAgICogICAgIHtAbGluayBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMfSlcbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGxpc3RlbmVyLCBwcmlvcml0eSkge1xuICAgIGlmIChwcmlvcml0eSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTGlzdGVuZXIgZm9yIHR5cGUgXCJjb21tYW5kXCIgcmVxdWlyZXMgYSBcInByaW9yaXR5XCIuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbW1hbmRzTWFwID0gdGhpcy5fY29tbWFuZHM7XG4gICAgaWYgKCFjb21tYW5kc01hcC5oYXMoY29tbWFuZCkpIHtcbiAgICAgIGNvbW1hbmRzTWFwLnNldChjb21tYW5kLCBbbmV3IFNldCgpLCBuZXcgU2V0KCksIG5ldyBTZXQoKSwgbmV3IFNldCgpLCBuZXcgU2V0KCldKTtcbiAgICB9XG4gICAgY29uc3QgbGlzdGVuZXJzSW5Qcmlvcml0eU9yZGVyID0gY29tbWFuZHNNYXAuZ2V0KGNvbW1hbmQpO1xuICAgIGlmIChsaXN0ZW5lcnNJblByaW9yaXR5T3JkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYHJlZ2lzdGVyQ29tbWFuZDogQ29tbWFuZCAke1N0cmluZyhjb21tYW5kKX0gbm90IGZvdW5kIGluIGNvbW1hbmQgbWFwYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IGxpc3RlbmVyc0luUHJpb3JpdHlPcmRlcltwcmlvcml0eV07XG4gICAgbGlzdGVuZXJzLmFkZChsaXN0ZW5lcik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgaWYgKGxpc3RlbmVyc0luUHJpb3JpdHlPcmRlci5ldmVyeShsaXN0ZW5lcnNTZXQgPT4gbGlzdGVuZXJzU2V0LnNpemUgPT09IDApKSB7XG4gICAgICAgIGNvbW1hbmRzTWFwLmRlbGV0ZShjb21tYW5kKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGxpc3RlbmVyIHRoYXQgd2lsbCBydW4gd2hlbiBhIExleGljYWwgbm9kZSBvZiB0aGUgcHJvdmlkZWQgY2xhc3MgaXNcbiAgICogbXV0YXRlZC4gVGhlIGxpc3RlbmVyIHdpbGwgcmVjZWl2ZSBhIGxpc3Qgb2Ygbm9kZXMgYWxvbmcgd2l0aCB0aGUgdHlwZSBvZiBtdXRhdGlvblxuICAgKiB0aGF0IHdhcyBwZXJmb3JtZWQgb24gZWFjaDogY3JlYXRlZCwgZGVzdHJveWVkLCBvciB1cGRhdGVkLlxuICAgKlxuICAgKiBPbmUgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRvIGF0dGFjaCBET00gZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSB1bmRlcmx5aW5nIERPTSBub2RlcyBhcyBMZXhpY2FsIG5vZGVzIGFyZSBjcmVhdGVkLlxuICAgKiB7QGxpbmsgTGV4aWNhbEVkaXRvci5nZXRFbGVtZW50QnlLZXl9IGNhbiBiZSB1c2VkIGZvciB0aGlzLlxuICAgKlxuICAgKiBJZiBhbnkgZXhpc3Rpbmcgbm9kZXMgYXJlIGluIHRoZSBET00sIGFuZCBza2lwSW5pdGlhbGl6YXRpb24gaXMgbm90IHRydWUsIHRoZSBsaXN0ZW5lclxuICAgKiB3aWxsIGJlIGNhbGxlZCBpbW1lZGlhdGVseSB3aXRoIGFuIHVwZGF0ZVRhZyBvZiAncmVnaXN0ZXJNdXRhdGlvbkxpc3RlbmVyJyB3aGVyZSBhbGxcbiAgICogbm9kZXMgaGF2ZSB0aGUgJ2NyZWF0ZWQnIE5vZGVNdXRhdGlvbi4gVGhpcyBjYW4gYmUgY29udHJvbGxlZCB3aXRoIHRoZSBza2lwSW5pdGlhbGl6YXRpb24gb3B0aW9uXG4gICAqICh3aG9zZSBkZWZhdWx0IHdhcyBwcmV2aW91c2x5IHRydWUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggJmx0Oz0wLjE2LjEgYnV0IGhhcyBiZWVuIGNoYW5nZWQgdG8gZmFsc2UgYXMgb2YgMC4yMS4wKS5cbiAgICpcbiAgICogQHBhcmFtIGtsYXNzIC0gVGhlIGNsYXNzIG9mIHRoZSBub2RlIHRoYXQgeW91IHdhbnQgdG8gbGlzdGVuIHRvIG11dGF0aW9ucyBvbi5cbiAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxvZ2ljIHlvdSB3YW50IHRvIHJ1biB3aGVuIHRoZSBub2RlIGlzIG11dGF0ZWQuXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gc2VlIHtAbGluayBNdXRhdGlvbkxpc3RlbmVyT3B0aW9uc31cbiAgICogQHJldHVybnMgYSB0ZWFyZG93biBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNsZWFudXAgdGhlIGxpc3RlbmVyLlxuICAgKi9cbiAgcmVnaXN0ZXJNdXRhdGlvbkxpc3RlbmVyKGtsYXNzLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGtsYXNzVG9NdXRhdGUgPSB0aGlzLnJlc29sdmVSZWdpc3RlcmVkTm9kZUFmdGVyUmVwbGFjZW1lbnRzKHRoaXMuZ2V0UmVnaXN0ZXJlZE5vZGUoa2xhc3MpKS5rbGFzcztcbiAgICBjb25zdCBtdXRhdGlvbnMgPSB0aGlzLl9saXN0ZW5lcnMubXV0YXRpb247XG4gICAgbGV0IGtsYXNzU2V0ID0gbXV0YXRpb25zLmdldChsaXN0ZW5lcik7XG4gICAgaWYgKGtsYXNzU2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGtsYXNzU2V0ID0gbmV3IFNldCgpO1xuICAgICAgbXV0YXRpb25zLnNldChsaXN0ZW5lciwga2xhc3NTZXQpO1xuICAgIH1cbiAgICBrbGFzc1NldC5hZGQoa2xhc3NUb011dGF0ZSk7XG4gICAgY29uc3Qgc2tpcEluaXRpYWxpemF0aW9uID0gb3B0aW9ucyAmJiBvcHRpb25zLnNraXBJbml0aWFsaXphdGlvbjtcbiAgICBpZiAoIShza2lwSW5pdGlhbGl6YXRpb24gPT09IHVuZGVmaW5lZCA/IERFRkFVTFRfU0tJUF9JTklUSUFMSVpBVElPTiA6IHNraXBJbml0aWFsaXphdGlvbikpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZU11dGF0aW9uTGlzdGVuZXIobGlzdGVuZXIsIGtsYXNzVG9NdXRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAga2xhc3NTZXQuZGVsZXRlKGtsYXNzVG9NdXRhdGUpO1xuICAgICAgaWYgKGtsYXNzU2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgbXV0YXRpb25zLmRlbGV0ZShsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0UmVnaXN0ZXJlZE5vZGUoa2xhc3MpIHtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IHRoaXMuX25vZGVzLmdldChrbGFzcy5nZXRUeXBlKCkpO1xuICAgIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTm9kZSAke2tsYXNzLm5hbWV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLiBFbnN1cmUgbm9kZSBoYXMgYmVlbiBwYXNzZWQgdG8gY3JlYXRlRWRpdG9yLmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVnaXN0ZXJlZE5vZGU7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHJlc29sdmVSZWdpc3RlcmVkTm9kZUFmdGVyUmVwbGFjZW1lbnRzKHJlZ2lzdGVyZWROb2RlKSB7XG4gICAgd2hpbGUgKHJlZ2lzdGVyZWROb2RlLnJlcGxhY2VXaXRoS2xhc3MpIHtcbiAgICAgIHJlZ2lzdGVyZWROb2RlID0gdGhpcy5nZXRSZWdpc3RlcmVkTm9kZShyZWdpc3RlcmVkTm9kZS5yZXBsYWNlV2l0aEtsYXNzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lzdGVyZWROb2RlO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBpbml0aWFsaXplTXV0YXRpb25MaXN0ZW5lcihsaXN0ZW5lciwga2xhc3MpIHtcbiAgICBjb25zdCBwcmV2RWRpdG9yU3RhdGUgPSB0aGlzLl9lZGl0b3JTdGF0ZTtcbiAgICBjb25zdCBub2RlTWFwID0gZ2V0Q2FjaGVkVHlwZVRvTm9kZU1hcChwcmV2RWRpdG9yU3RhdGUpLmdldChrbGFzcy5nZXRUeXBlKCkpO1xuICAgIGlmICghbm9kZU1hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlTXV0YXRpb25NYXAgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBrIG9mIG5vZGVNYXAua2V5cygpKSB7XG4gICAgICBub2RlTXV0YXRpb25NYXAuc2V0KGssICdjcmVhdGVkJyk7XG4gICAgfVxuICAgIGlmIChub2RlTXV0YXRpb25NYXAuc2l6ZSA+IDApIHtcbiAgICAgIGxpc3RlbmVyKG5vZGVNdXRhdGlvbk1hcCwge1xuICAgICAgICBkaXJ0eUxlYXZlczogbmV3IFNldCgpLFxuICAgICAgICBwcmV2RWRpdG9yU3RhdGUsXG4gICAgICAgIHVwZGF0ZVRhZ3M6IG5ldyBTZXQoWydyZWdpc3Rlck11dGF0aW9uTGlzdGVuZXInXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcmVnaXN0ZXJOb2RlVHJhbnNmb3JtVG9LbGFzcyhrbGFzcywgbGlzdGVuZXIpIHtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IHRoaXMuZ2V0UmVnaXN0ZXJlZE5vZGUoa2xhc3MpO1xuICAgIHJlZ2lzdGVyZWROb2RlLnRyYW5zZm9ybXMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gcmVnaXN0ZXJlZE5vZGU7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIHJ1biB3aGVuIGEgTGV4aWNhbCBub2RlIG9mIHRoZSBwcm92aWRlZCBjbGFzcyBpc1xuICAgKiBtYXJrZWQgZGlydHkgZHVyaW5nIGFuIHVwZGF0ZS4gVGhlIGxpc3RlbmVyIHdpbGwgY29udGludWUgdG8gcnVuIGFzIGxvbmcgYXMgdGhlIG5vZGVcbiAgICogaXMgbWFya2VkIGRpcnR5LiBUaGVyZSBhcmUgbm8gZ3VhcmFudGVlcyBhcm91bmQgdGhlIG9yZGVyIG9mIHRyYW5zZm9ybSBleGVjdXRpb24hXG4gICAqXG4gICAqIFdhdGNoIG91dCBmb3IgaW5maW5pdGUgbG9vcHMuIFNlZSBbTm9kZSBUcmFuc2Zvcm1zXShodHRwczovL2xleGljYWwuZGV2L2RvY3MvY29uY2VwdHMvdHJhbnNmb3JtcylcbiAgICogQHBhcmFtIGtsYXNzIC0gVGhlIGNsYXNzIG9mIHRoZSBub2RlIHRoYXQgeW91IHdhbnQgdG8gcnVuIHRyYW5zZm9ybXMgb24uXG4gICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBsb2dpYyB5b3Ugd2FudCB0byBydW4gd2hlbiB0aGUgbm9kZSBpcyB1cGRhdGVkLlxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2xlYW51cCB0aGUgbGlzdGVuZXIuXG4gICAqL1xuICByZWdpc3Rlck5vZGVUcmFuc2Zvcm0oa2xhc3MsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSB0aGlzLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybVRvS2xhc3Moa2xhc3MsIGxpc3RlbmVyKTtcbiAgICBjb25zdCByZWdpc3RlcmVkTm9kZXMgPSBbcmVnaXN0ZXJlZE5vZGVdO1xuICAgIGNvbnN0IHJlcGxhY2VXaXRoS2xhc3MgPSByZWdpc3RlcmVkTm9kZS5yZXBsYWNlV2l0aEtsYXNzO1xuICAgIGlmIChyZXBsYWNlV2l0aEtsYXNzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJlZ2lzdGVyZWRSZXBsYWNlV2l0aE5vZGUgPSB0aGlzLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybVRvS2xhc3MocmVwbGFjZVdpdGhLbGFzcywgbGlzdGVuZXIpO1xuICAgICAgcmVnaXN0ZXJlZE5vZGVzLnB1c2gocmVnaXN0ZXJlZFJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfVxuICAgIG1hcmtOb2Rlc1dpdGhUeXBlc0FzRGlydHkodGhpcywgcmVnaXN0ZXJlZE5vZGVzLm1hcChub2RlID0+IG5vZGUua2xhc3MuZ2V0VHlwZSgpKSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJlZ2lzdGVyZWROb2Rlcy5mb3JFYWNoKG5vZGUgPT4gbm9kZS50cmFuc2Zvcm1zLmRlbGV0ZShsaXN0ZW5lcikpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBhc3NlcnQgdGhhdCBhIGNlcnRhaW4gbm9kZSBpcyByZWdpc3RlcmVkLCB1c3VhbGx5IGJ5IHBsdWdpbnMgdG8gZW5zdXJlIG5vZGVzIHRoYXQgdGhleVxuICAgKiBkZXBlbmQgb24gaGF2ZSBiZWVuIHJlZ2lzdGVyZWQuXG4gICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIGVkaXRvciBoYXMgcmVnaXN0ZXJlZCB0aGUgcHJvdmlkZWQgbm9kZSB0eXBlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBoYXNOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXMuaGFzKG5vZGUuZ2V0VHlwZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGFzc2VydCB0aGF0IGNlcnRhaW4gbm9kZXMgYXJlIHJlZ2lzdGVyZWQsIHVzdWFsbHkgYnkgcGx1Z2lucyB0byBlbnN1cmUgbm9kZXMgdGhhdCB0aGV5XG4gICAqIGRlcGVuZCBvbiBoYXZlIGJlZW4gcmVnaXN0ZXJlZC5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZWRpdG9yIGhhcyByZWdpc3RlcmVkIGFsbCBvZiB0aGUgcHJvdmlkZWQgbm9kZSB0eXBlcywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzTm9kZXMobm9kZXMpIHtcbiAgICByZXR1cm4gbm9kZXMuZXZlcnkodGhpcy5oYXNOb2RlLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBjb21tYW5kIG9mIHRoZSBzcGVjaWZpZWQgdHlwZSB3aXRoIHRoZSBzcGVjaWZpZWQgcGF5bG9hZC5cbiAgICogVGhpcyB0cmlnZ2VycyBhbGwgY29tbWFuZCBsaXN0ZW5lcnMgKHNldCBieSB7QGxpbmsgTGV4aWNhbEVkaXRvci5yZWdpc3RlckNvbW1hbmR9KVxuICAgKiBmb3IgdGhpcyB0eXBlLCBwYXNzaW5nIHRoZW0gdGhlIHByb3ZpZGVkIHBheWxvYWQuIFRoZSBjb21tYW5kIGxpc3RlbmVyc1xuICAgKiB3aWxsIGJlIHRyaWdnZXJlZCBpbiBhbiBpbXBsaWNpdCB7QGxpbmsgTGV4aWNhbEVkaXRvci51cGRhdGV9LCB1bmxlc3NcbiAgICogdGhpcyB3YXMgaW52b2tlZCBmcm9tIGluc2lkZSBhbiB1cGRhdGUgaW4gd2hpY2ggY2FzZSB0aGF0IHVwZGF0ZSBjb250ZXh0XG4gICAqIHdpbGwgYmUgcmUtdXNlZCAoYXMgaWYgdGhpcyB3YXMgYSBkb2xsYXIgZnVuY3Rpb24gaXRzZWxmKS5cbiAgICogQHBhcmFtIHR5cGUgLSB0aGUgdHlwZSBvZiBjb21tYW5kIGxpc3RlbmVycyB0byB0cmlnZ2VyLlxuICAgKiBAcGFyYW0gcGF5bG9hZCAtIHRoZSBkYXRhIHRvIHBhc3MgYXMgYW4gYXJndW1lbnQgdG8gdGhlIGNvbW1hbmQgbGlzdGVuZXJzLlxuICAgKi9cbiAgZGlzcGF0Y2hDb21tYW5kKHR5cGUsIHBheWxvYWQpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2hDb21tYW5kKHRoaXMsIHR5cGUsIHBheWxvYWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgYSBtYXAgb2YgYWxsIGRlY29yYXRvcnMgaW4gdGhlIGVkaXRvci5cbiAgICogQHJldHVybnMgQSBtYXBwaW5nIG9mIGNhbGwgZGVjb3JhdG9yIGtleXMgdG8gdGhlaXIgZGVjb3JhdGVkIGNvbnRlbnRcbiAgICovXG4gIGdldERlY29yYXRvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlY29yYXRvcnM7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHJldHVybnMgdGhlIGN1cnJlbnQgcm9vdCBlbGVtZW50IG9mIHRoZSBlZGl0b3IuIElmIHlvdSB3YW50IHRvIHJlZ2lzdGVyXG4gICAqIGFuIGV2ZW50IGxpc3RlbmVyLCBkbyBpdCB2aWEge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJSb290TGlzdGVuZXJ9LCBzaW5jZVxuICAgKiB0aGlzIHJlZmVyZW5jZSBtYXkgbm90IGJlIHN0YWJsZS5cbiAgICovXG4gIGdldFJvb3RFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yb290RWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBrZXkgb2YgdGhlIGVkaXRvclxuICAgKiBAcmV0dXJucyBUaGUgZWRpdG9yIGtleVxuICAgKi9cbiAgZ2V0S2V5KCkge1xuICAgIHJldHVybiB0aGlzLl9rZXk7XG4gIH1cblxuICAvKipcbiAgICogSW1wZXJhdGl2ZWx5IHNldCB0aGUgcm9vdCBjb250ZW50ZWRpdGFibGUgZWxlbWVudCB0aGF0IExleGljYWwgbGlzdGVuc1xuICAgKiBmb3IgZXZlbnRzIG9uLlxuICAgKi9cbiAgc2V0Um9vdEVsZW1lbnQobmV4dFJvb3RFbGVtZW50KSB7XG4gICAgY29uc3QgcHJldlJvb3RFbGVtZW50ID0gdGhpcy5fcm9vdEVsZW1lbnQ7XG4gICAgaWYgKG5leHRSb290RWxlbWVudCAhPT0gcHJldlJvb3RFbGVtZW50KSB7XG4gICAgICBjb25zdCBjbGFzc05hbWVzID0gZ2V0Q2FjaGVkQ2xhc3NOYW1lQXJyYXkodGhpcy5fY29uZmlnLnRoZW1lLCAncm9vdCcpO1xuICAgICAgY29uc3QgcGVuZGluZ0VkaXRvclN0YXRlID0gdGhpcy5fcGVuZGluZ0VkaXRvclN0YXRlIHx8IHRoaXMuX2VkaXRvclN0YXRlO1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBuZXh0Um9vdEVsZW1lbnQ7XG4gICAgICByZXNldEVkaXRvcih0aGlzLCBwcmV2Um9vdEVsZW1lbnQsIG5leHRSb290RWxlbWVudCwgcGVuZGluZ0VkaXRvclN0YXRlKTtcbiAgICAgIGlmIChwcmV2Um9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZmxhZyBvbmNlIHdlIG5vIGxvbmdlciB1c2UgVUV2MiBpbnRlcm5hbGx5XG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLmRpc2FibGVFdmVudHMpIHtcbiAgICAgICAgICByZW1vdmVSb290RWxlbWVudEV2ZW50cyhwcmV2Um9vdEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWVzICE9IG51bGwpIHtcbiAgICAgICAgICBwcmV2Um9vdEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSguLi5jbGFzc05hbWVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5leHRSb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB3aW5kb3dPYmogPSBnZXREZWZhdWx0VmlldyhuZXh0Um9vdEVsZW1lbnQpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IG5leHRSb290RWxlbWVudC5zdHlsZTtcbiAgICAgICAgc3R5bGUudXNlclNlbGVjdCA9ICd0ZXh0JztcbiAgICAgICAgc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gICAgICAgIHN0eWxlLndvcmRCcmVhayA9ICdicmVhay13b3JkJztcbiAgICAgICAgbmV4dFJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLWVkaXRvcicsICd0cnVlJyk7XG4gICAgICAgIHRoaXMuX3dpbmRvdyA9IHdpbmRvd09iajtcbiAgICAgICAgdGhpcy5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgICAgIGluaXRNdXRhdGlvbk9ic2VydmVyKHRoaXMpO1xuICAgICAgICB0aGlzLl91cGRhdGVUYWdzLmFkZChISVNUT1JZX01FUkdFX1RBRyk7XG4gICAgICAgICRjb21taXRQZW5kaW5nVXBkYXRlcyh0aGlzKTtcblxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBmbGFnIG9uY2Ugd2Ugbm8gbG9uZ2VyIHVzZSBVRXYyIGludGVybmFsbHlcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuZGlzYWJsZUV2ZW50cykge1xuICAgICAgICAgIGFkZFJvb3RFbGVtZW50RXZlbnRzKG5leHRSb290RWxlbWVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsYXNzTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICAgIG5leHRSb290RWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBuZXh0Um9vdEVsZW1lbnRQYXJlbnQgPSBuZXh0Um9vdEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICBpZiAobmV4dFJvb3RFbGVtZW50UGFyZW50ICE9IG51bGwgJiYgWydmbGV4JywgJ2lubGluZS1mbGV4J10uaW5jbHVkZXMoZ2V0Q29tcHV0ZWRTdHlsZShuZXh0Um9vdEVsZW1lbnRQYXJlbnQpLmRpc3BsYXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdoZW4gdXNpbmcgXCJkaXNwbGF5OiBmbGV4XCIgb3IgXCJkaXNwbGF5OiBpbmxpbmUtZmxleFwiIG9uIGFuIGVsZW1lbnQgY29udGFpbmluZyBjb250ZW50IGVkaXRhYmxlLCBDaHJvbWUgbWF5IGhhdmUgdW53YW50ZWQgZm9jdXNpbmcgYmVoYXZpb3Igd2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIGl0LiBDb25zaWRlciB3cmFwcGluZyB0aGUgY29udGVudCBlZGl0YWJsZSB3aXRoaW4gYSBub24tZmxleCBlbGVtZW50LmApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgY29udGVudCBlZGl0YWJsZSBpcyB1bm1vdW50ZWQgd2Ugd2lsbCBzdGlsbCB0cmlnZ2VyIGFcbiAgICAgICAgLy8gcmVjb25jaWxpYXRpb24gc28gdGhhdCBhbnkgcGVuZGluZyB1cGRhdGVzIGFyZSBmbHVzaGVkLFxuICAgICAgICAvLyB0byBtYXRjaCB0aGUgcHJldmlvdXMgc3RhdGUgY2hhbmdlIHdoZW5cbiAgICAgICAgLy8gYF9lZGl0b3JTdGF0ZSA9IHBlbmRpbmdFZGl0b3JTdGF0ZWAgd2FzIHVzZWQsIGJ1dCBieVxuICAgICAgICAvLyB1c2luZyBhIGNvbW1pdCB3ZSBwcmVzZXJ2ZSB0aGUgcmVhZE9ubHkgaW52YXJpYW50XG4gICAgICAgIC8vIGZvciBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5cbiAgICAgICAgdGhpcy5fd2luZG93ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdXBkYXRlVGFncy5hZGQoSElTVE9SWV9NRVJHRV9UQUcpO1xuICAgICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXModGhpcyk7XG4gICAgICB9XG4gICAgICB0cmlnZ2VyTGlzdGVuZXJzKCdyb290JywgdGhpcywgZmFsc2UsIG5leHRSb290RWxlbWVudCwgcHJldlJvb3RFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdW5kZXJseWluZyBIVE1MRWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIExleGljYWxOb2RlIGZvciB0aGUgZ2l2ZW4ga2V5LlxuICAgKiBAcmV0dXJucyB0aGUgSFRNTEVsZW1lbnQgcmVuZGVyZWQgYnkgdGhlIExleGljYWxOb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LlxuICAgKiBAcGFyYW0ga2V5IC0gdGhlIGtleSBvZiB0aGUgTGV4aWNhbE5vZGUuXG4gICAqL1xuICBnZXRFbGVtZW50QnlLZXkoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2tleVRvRE9NTWFwLmdldChrZXkpIHx8IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYWN0aXZlIGVkaXRvciBzdGF0ZS5cbiAgICogQHJldHVybnMgVGhlIGVkaXRvciBzdGF0ZVxuICAgKi9cbiAgZ2V0RWRpdG9yU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkaXRvclN0YXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcGVyYXRpdmVseSBzZXQgdGhlIEVkaXRvclN0YXRlLiBUcmlnZ2VycyByZWNvbmNpbGlhdGlvbiBsaWtlIGFuIHVwZGF0ZS5cbiAgICogQHBhcmFtIGVkaXRvclN0YXRlIC0gdGhlIHN0YXRlIHRvIHNldCB0aGUgZWRpdG9yXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gb3B0aW9ucyBmb3IgdGhlIHVwZGF0ZS5cbiAgICovXG4gIHNldEVkaXRvclN0YXRlKGVkaXRvclN0YXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKGVkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgICAge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYHNldEVkaXRvclN0YXRlOiB0aGUgZWRpdG9yIHN0YXRlIGlzIGVtcHR5LiBFbnN1cmUgdGhlIGVkaXRvciBzdGF0ZSdzIHJvb3Qgbm9kZSBuZXZlciBiZWNvbWVzIGVtcHR5LmApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIGhhdmUgYSB3cml0YWJsZSBFZGl0b3JTdGF0ZSBzbyB0aGF0IHRyYW5zZm9ybXMgY2FuIHJ1blxuICAgIC8vIGR1cmluZyBhIGhpc3RvcmljIG9wZXJhdGlvblxuICAgIGxldCB3cml0YWJsZUVkaXRvclN0YXRlID0gZWRpdG9yU3RhdGU7XG4gICAgaWYgKHdyaXRhYmxlRWRpdG9yU3RhdGUuX3JlYWRPbmx5KSB7XG4gICAgICB3cml0YWJsZUVkaXRvclN0YXRlID0gY2xvbmVFZGl0b3JTdGF0ZShlZGl0b3JTdGF0ZSk7XG4gICAgICB3cml0YWJsZUVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBlZGl0b3JTdGF0ZS5fc2VsZWN0aW9uID8gZWRpdG9yU3RhdGUuX3NlbGVjdGlvbi5jbG9uZSgpIDogbnVsbDtcbiAgICB9XG4gICAgZmx1c2hSb290TXV0YXRpb25zKHRoaXMpO1xuICAgIGNvbnN0IHBlbmRpbmdFZGl0b3JTdGF0ZSA9IHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZTtcbiAgICBjb25zdCB0YWdzID0gdGhpcy5fdXBkYXRlVGFncztcbiAgICBjb25zdCB0YWcgPSBvcHRpb25zICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnRhZyA6IG51bGw7XG4gICAgaWYgKHBlbmRpbmdFZGl0b3JTdGF0ZSAhPT0gbnVsbCAmJiAhcGVuZGluZ0VkaXRvclN0YXRlLmlzRW1wdHkoKSkge1xuICAgICAgaWYgKHRhZyAhPSBudWxsKSB7XG4gICAgICAgIHRhZ3MuYWRkKHRhZyk7XG4gICAgICB9XG4gICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXModGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX3BlbmRpbmdFZGl0b3JTdGF0ZSA9IHdyaXRhYmxlRWRpdG9yU3RhdGU7XG4gICAgdGhpcy5fZGlydHlUeXBlID0gRlVMTF9SRUNPTkNJTEU7XG4gICAgdGhpcy5fZGlydHlFbGVtZW50cy5zZXQoJ3Jvb3QnLCBmYWxzZSk7XG4gICAgdGhpcy5fY29tcG9zaXRpb25LZXkgPSBudWxsO1xuICAgIGlmICh0YWcgIT0gbnVsbCkge1xuICAgICAgdGFncy5hZGQodGFnKTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IGNvbW1pdCBwZW5kaW5nIHVwZGF0ZXMgaWYgbm90IGFscmVhZHkgaW4gYW4gZWRpdG9yLnVwZGF0ZVxuICAgIC8vIChlLmcuIGRpc3BhdGNoQ29tbWFuZCkgb3RoZXJ3aXNlIHRoaXMgd2lsbCBjYXVzZSBhIHNlY29uZCBjb21taXRcbiAgICAvLyB3aXRoIGFuIGFscmVhZHkgcmVhZC1vbmx5IHN0YXRlIGFuZCBzZWxlY3Rpb25cbiAgICBpZiAoIXRoaXMuX3VwZGF0aW5nKSB7XG4gICAgICAkY29tbWl0UGVuZGluZ1VwZGF0ZXModGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhIFNlcmlhbGl6ZWRFZGl0b3JTdGF0ZSAodXN1YWxseSBwcm9kdWNlZCBieSB7QGxpbmsgRWRpdG9yU3RhdGUudG9KU09OfSkgYW5kIHJldHVybnNcbiAgICogYW5kIEVkaXRvclN0YXRlIG9iamVjdCB0aGF0IGNhbiBiZSwgZm9yIGV4YW1wbGUsIHBhc3NlZCB0byB7QGxpbmsgTGV4aWNhbEVkaXRvci5zZXRFZGl0b3JTdGF0ZX0uIFR5cGljYWxseSxcbiAgICogZGVzZXJpYWxpemF0aW9uIGZyb20gSlNPTiBzdG9yZWQgaW4gYSBkYXRhYmFzZSB1c2VzIHRoaXMgbWV0aG9kLlxuICAgKiBAcGFyYW0gbWF5YmVTdHJpbmdpZmllZEVkaXRvclN0YXRlXG4gICAqIEBwYXJhbSB1cGRhdGVGblxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcGFyc2VFZGl0b3JTdGF0ZShtYXliZVN0cmluZ2lmaWVkRWRpdG9yU3RhdGUsIHVwZGF0ZUZuKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZEVkaXRvclN0YXRlID0gdHlwZW9mIG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKG1heWJlU3RyaW5naWZpZWRFZGl0b3JTdGF0ZSkgOiBtYXliZVN0cmluZ2lmaWVkRWRpdG9yU3RhdGU7XG4gICAgcmV0dXJuIHBhcnNlRWRpdG9yU3RhdGUoc2VyaWFsaXplZEVkaXRvclN0YXRlLCB0aGlzLCB1cGRhdGVGbik7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSByZWFkIG9mIHRoZSBlZGl0b3IncyBzdGF0ZSwgd2l0aCB0aGVcbiAgICogZWRpdG9yIGNvbnRleHQgYXZhaWxhYmxlICh1c2VmdWwgZm9yIGV4cG9ydGluZyBhbmQgcmVhZC1vbmx5IERPTVxuICAgKiBvcGVyYXRpb25zKS4gTXVjaCBsaWtlIHVwZGF0ZSwgYnV0IHByZXZlbnRzIGFueSBtdXRhdGlvbiBvZiB0aGVcbiAgICogZWRpdG9yJ3Mgc3RhdGUuIEFueSBwZW5kaW5nIHVwZGF0ZXMgd2lsbCBiZSBmbHVzaGVkIGltbWVkaWF0ZWx5IGJlZm9yZVxuICAgKiB0aGUgcmVhZC5cbiAgICogQHBhcmFtIGNhbGxiYWNrRm4gLSBBIGZ1bmN0aW9uIHRoYXQgaGFzIGFjY2VzcyB0byByZWFkLW9ubHkgZWRpdG9yIHN0YXRlLlxuICAgKi9cbiAgcmVhZChjYWxsYmFja0ZuKSB7XG4gICAgJGNvbW1pdFBlbmRpbmdVcGRhdGVzKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmdldEVkaXRvclN0YXRlKCkucmVhZChjYWxsYmFja0ZuLCB7XG4gICAgICBlZGl0b3I6IHRoaXNcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhbiB1cGRhdGUgdG8gdGhlIGVkaXRvciBzdGF0ZS4gVGhlIHVwZGF0ZUZuIGNhbGxiYWNrIGlzIHRoZSBPTkxZIHBsYWNlXG4gICAqIHdoZXJlIExleGljYWwgZWRpdG9yIHN0YXRlIGNhbiBiZSBzYWZlbHkgbXV0YXRlZC5cbiAgICogQHBhcmFtIHVwZGF0ZUZuIC0gQSBmdW5jdGlvbiB0aGF0IGhhcyBhY2Nlc3MgdG8gd3JpdGFibGUgZWRpdG9yIHN0YXRlLlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIEEgYmFnIG9mIG9wdGlvbnMgdG8gY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgdGhlIHVwZGF0ZS5cbiAgICovXG4gIHVwZGF0ZSh1cGRhdGVGbiwgb3B0aW9ucykge1xuICAgIHVwZGF0ZUVkaXRvcih0aGlzLCB1cGRhdGVGbiwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRm9jdXNlcyB0aGUgZWRpdG9yIGJ5IG1hcmtpbmcgdGhlIGV4aXN0aW5nIHNlbGVjdGlvbiBhcyBkaXJ0eSwgb3IgYnlcbiAgICogY3JlYXRpbmcgYSBuZXcgc2VsZWN0aW9uIGF0IGBkZWZhdWx0U2VsZWN0aW9uYCBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeVxuICAgKiBleGlzdC4gSWYgeW91IHdhbnQgdG8gZm9yY2UgYSBzcGVjaWZpYyBzZWxlY3Rpb24sIHlvdSBzaG91bGQgY2FsbFxuICAgKiBgcm9vdC5zZWxlY3RTdGFydCgpYCBvciBgcm9vdC5zZWxlY3RFbmQoKWAgaW4gYW4gdXBkYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2tGbiAtIEEgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBIGJhZyBvZiBvcHRpb25zXG4gICAqL1xuICBmb2N1cyhjYWxsYmFja0ZuLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IHRoaXMuX3Jvb3RFbGVtZW50O1xuICAgIGlmIChyb290RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgaU9TIGRvZXMgbm90IHRyaWdnZXIgY2FwcyBsb2NrIHVwb24gZm9jdXNcbiAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXV0b2NhcGl0YWxpemUnLCAnb2ZmJyk7XG4gICAgICB1cGRhdGVFZGl0b3JTeW5jKHRoaXMsICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIE1hcmtpbmcgdGhlIHNlbGVjdGlvbiBkaXJ0eSB3aWxsIGZvcmNlIHRoZSBzZWxlY3Rpb24gYmFjayB0byBpdFxuICAgICAgICAgIGlmICghc2VsZWN0aW9uLmRpcnR5KSB7XG4gICAgICAgICAgICAkc2V0U2VsZWN0aW9uKHNlbGVjdGlvbi5jbG9uZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocm9vdC5nZXRDaGlsZHJlblNpemUoKSAhPT0gMCkge1xuICAgICAgICAgIGlmIChvcHRpb25zLmRlZmF1bHRTZWxlY3Rpb24gPT09ICdyb290U3RhcnQnKSB7XG4gICAgICAgICAgICByb290LnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3Quc2VsZWN0RW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICRhZGRVcGRhdGVUYWcoRk9DVVNfVEFHKTtcbiAgICAgICAgJG9uVXBkYXRlKCgpID0+IHtcbiAgICAgICAgICByb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2F1dG9jYXBpdGFsaXplJyk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrRm4pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrRm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvLyBJbiB0aGUgY2FzZSB3aGVyZSBvblVwZGF0ZSBkb2Vzbid0IGZpcmUgKGR1ZSB0byB0aGUgZm9jdXMgdXBkYXRlIG5vdFxuICAgICAgLy8gb2NjdXJyaW5nKS5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhdXRvY2FwaXRhbGl6ZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGZvY3VzIGZyb20gdGhlIGVkaXRvci5cbiAgICovXG4gIGJsdXIoKSB7XG4gICAgY29uc3Qgcm9vdEVsZW1lbnQgPSB0aGlzLl9yb290RWxlbWVudDtcbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJvb3RFbGVtZW50LmJsdXIoKTtcbiAgICB9XG4gICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKHRoaXMuX3dpbmRvdyk7XG4gICAgaWYgKGRvbVNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgZWRpdG9yIGlzIGVkaXRhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLl9lZGl0YWJsZTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgZWRpdGFibGUgcHJvcGVydHkgb2YgdGhlIGVkaXRvci4gV2hlbiBmYWxzZSwgdGhlXG4gICAqIGVkaXRvciB3aWxsIG5vdCBsaXN0ZW4gZm9yIHVzZXIgZXZlbnRzIG9uIHRoZSB1bmRlcmxpbmcgY29udGVudGVkaXRhYmxlLlxuICAgKiBAcGFyYW0gZWRpdGFibGUgLSB0aGUgdmFsdWUgdG8gc2V0IHRoZSBlZGl0YWJsZSBtb2RlIHRvLlxuICAgKi9cbiAgc2V0RWRpdGFibGUoZWRpdGFibGUpIHtcbiAgICBpZiAodGhpcy5fZWRpdGFibGUgIT09IGVkaXRhYmxlKSB7XG4gICAgICB0aGlzLl9lZGl0YWJsZSA9IGVkaXRhYmxlO1xuICAgICAgdHJpZ2dlckxpc3RlbmVycygnZWRpdGFibGUnLCB0aGlzLCB0cnVlLCBlZGl0YWJsZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTi1zZXJpYWxpemFibGUgamF2YXNjcmlwdCBvYmplY3QgTk9UIGEgSlNPTiBzdHJpbmcuXG4gICAqIFlvdSBzdGlsbCBtdXN0IGNhbGwgSlNPTi5zdHJpbmdpZnkgKG9yIHNvbWV0aGluZyBlbHNlKSB0byB0dXJuIHRoZVxuICAgKiBzdGF0ZSBpbnRvIGEgc3RyaW5nIHlvdSBjYW4gdHJhbnNmZXIgb3ZlciB0aGUgd2lyZSBhbmQgc3RvcmUgaW4gYSBkYXRhYmFzZS5cbiAgICpcbiAgICogU2VlIHtAbGluayBMZXhpY2FsTm9kZS5leHBvcnRKU09OfVxuICAgKlxuICAgKiBAcmV0dXJucyBBIEpTT04tc2VyaWFsaXphYmxlIGphdmFzY3JpcHQgb2JqZWN0XG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVkaXRvclN0YXRlOiB0aGlzLl9lZGl0b3JTdGF0ZS50b0pTT04oKVxuICAgIH07XG4gIH1cbn1cbkxleGljYWxFZGl0b3IudmVyc2lvbiA9IFwiMC4zNC4wK2Rldi5lc21cIjtcblxubGV0IHBlbmRpbmdOb2RlVG9DbG9uZSA9IG51bGw7XG5mdW5jdGlvbiBzZXRQZW5kaW5nTm9kZVRvQ2xvbmUocGVuZGluZ05vZGUpIHtcbiAgcGVuZGluZ05vZGVUb0Nsb25lID0gcGVuZGluZ05vZGU7XG59XG5mdW5jdGlvbiBnZXRQZW5kaW5nTm9kZVRvQ2xvbmUoKSB7XG4gIGNvbnN0IG5vZGUgPSBwZW5kaW5nTm9kZVRvQ2xvbmU7XG4gIHBlbmRpbmdOb2RlVG9DbG9uZSA9IG51bGw7XG4gIHJldHVybiBub2RlO1xufVxubGV0IGtleUNvdW50ZXIgPSAxO1xuZnVuY3Rpb24gcmVzZXRSYW5kb21LZXkoKSB7XG4gIGtleUNvdW50ZXIgPSAxO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21LZXkoKSB7XG4gIHJldHVybiAnJyArIGtleUNvdW50ZXIrKztcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZE5vZGVPclRocm93KGVkaXRvciwgbm9kZVR5cGUpIHtcbiAgY29uc3QgcmVnaXN0ZXJlZE5vZGUgPSBnZXRSZWdpc3RlcmVkTm9kZShlZGl0b3IsIG5vZGVUeXBlKTtcbiAgaWYgKHJlZ2lzdGVyZWROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYHJlZ2lzdGVyZWROb2RlOiBUeXBlICR7bm9kZVR5cGV9IG5vdCBmb3VuZGApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVnaXN0ZXJlZE5vZGU7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWROb2RlKGVkaXRvciwgbm9kZVR5cGUpIHtcbiAgcmV0dXJuIGVkaXRvci5fbm9kZXMuZ2V0KG5vZGVUeXBlKTtcbn1cbmNvbnN0IHNjaGVkdWxlTWljcm9UYXNrID0gdHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nID8gcXVldWVNaWNyb3Rhc2sgOiBmbiA9PiB7XG4gIC8vIE5vIHdpbmRvdyBwcmVmaXggaW50ZW5kZWQgKCMxNDAwKVxuICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKTtcbn07XG5mdW5jdGlvbiAkaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9yKG5vZGUpIHtcbiAgcmV0dXJuICRpc0RlY29yYXRvck5vZGUoJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUobm9kZSkpO1xufVxuZnVuY3Rpb24gaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQoYW5jaG9yRE9NKSB7XG4gIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoYWN0aXZlRWxlbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgbm9kZU5hbWUgPSBhY3RpdmVFbGVtZW50Lm5vZGVOYW1lO1xuICByZXR1cm4gJGlzRGVjb3JhdG9yTm9kZSgkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhbmNob3JET00pKSAmJiAobm9kZU5hbWUgPT09ICdJTlBVVCcgfHwgbm9kZU5hbWUgPT09ICdURVhUQVJFQScgfHwgYWN0aXZlRWxlbWVudC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyAmJiBnZXRFZGl0b3JQcm9wZXJ0eUZyb21ET01Ob2RlKGFjdGl2ZUVsZW1lbnQpID09IG51bGwpO1xufVxuZnVuY3Rpb24gaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IoZWRpdG9yLCBhbmNob3JET00sIGZvY3VzRE9NKSB7XG4gIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJvb3RFbGVtZW50ICE9PSBudWxsICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKGFuY2hvckRPTSkgJiYgcm9vdEVsZW1lbnQuY29udGFpbnMoZm9jdXNET00pICYmXG4gICAgLy8gSWdub3JlIGlmIHNlbGVjdGlvbiBpcyB3aXRoaW4gbmVzdGVkIGVkaXRvclxuICAgIGFuY2hvckRPTSAhPT0gbnVsbCAmJiAhaXNTZWxlY3Rpb25DYXB0dXJlZEluRGVjb3JhdG9ySW5wdXQoYW5jaG9yRE9NKSAmJiBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUoYW5jaG9yRE9NKSA9PT0gZWRpdG9yO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIGFyZ3VtZW50IGlzIGEgTGV4aWNhbEVkaXRvciBpbnN0YW5jZSBmcm9tIHRoaXMgYnVpbGQgb2YgTGV4aWNhbFxuICovXG5mdW5jdGlvbiBpc0xleGljYWxFZGl0b3IoZWRpdG9yKSB7XG4gIC8vIENoZWNrIGluc3RhbmNlb2YgdG8gcHJldmVudCBpc3N1ZXMgd2l0aCBtdWx0aXBsZSBlbWJlZGRlZCBMZXhpY2FsIGluc3RhbGxhdGlvbnNcbiAgcmV0dXJuIGVkaXRvciBpbnN0YW5jZW9mIExleGljYWxFZGl0b3I7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUobm9kZSkge1xuICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICB3aGlsZSAoY3VycmVudE5vZGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IGVkaXRvciA9IGdldEVkaXRvclByb3BlcnR5RnJvbURPTU5vZGUoY3VycmVudE5vZGUpO1xuICAgIGlmIChpc0xleGljYWxFZGl0b3IoZWRpdG9yKSkge1xuICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBnZXRQYXJlbnRFbGVtZW50KGN1cnJlbnROb2RlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZ2V0RWRpdG9yUHJvcGVydHlGcm9tRE9NTm9kZShub2RlKSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gIHJldHVybiBub2RlID8gbm9kZS5fX2xleGljYWxFZGl0b3IgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGV4dERpcmVjdGlvbih0ZXh0KSB7XG4gIGlmIChSVExfUkVHRVgudGVzdCh0ZXh0KSkge1xuICAgIHJldHVybiAncnRsJztcbiAgfVxuICBpZiAoTFRSX1JFR0VYLnRlc3QodGV4dCkpIHtcbiAgICByZXR1cm4gJ2x0cic7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIFRleHROb2RlIGlzIGEgVGFiTm9kZSBvciBpcyBpbiB0b2tlbiBtb2RlLlxuICovXG5mdW5jdGlvbiAkaXNUb2tlbk9yVGFiKG5vZGUpIHtcbiAgcmV0dXJuICRpc1RhYk5vZGUobm9kZSkgfHwgbm9kZS5pc1Rva2VuKCk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIFRleHROb2RlIGlzIGEgVGFiTm9kZSwgb3IgaXMgaW4gdG9rZW4gb3Igc2VnbWVudGVkIG1vZGUuXG4gKi9cbmZ1bmN0aW9uICRpc1Rva2VuT3JTZWdtZW50ZWQobm9kZSkge1xuICByZXR1cm4gJGlzVG9rZW5PclRhYihub2RlKSB8fCBub2RlLmlzU2VnbWVudGVkKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIG5vZGUgLSBUaGUgZWxlbWVudCBiZWluZyB0ZXN0ZWRcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGFuIERPTSBUZXh0IG5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNET01UZXh0Tm9kZShub2RlKSB7XG4gIHJldHVybiBpc0RPTU5vZGUobm9kZSkgJiYgbm9kZS5ub2RlVHlwZSA9PT0gRE9NX1RFWFRfVFlQRTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gbm9kZSAtIFRoZSBlbGVtZW50IGJlaW5nIHRlc3RlZFxuICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIG5vZGUgaXMgYW4gRE9NIERvY3VtZW50IG5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNET01Eb2N1bWVudE5vZGUobm9kZSkge1xuICByZXR1cm4gaXNET01Ob2RlKG5vZGUpICYmIG5vZGUubm9kZVR5cGUgPT09IERPTV9ET0NVTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gZ2V0RE9NVGV4dE5vZGUoZWxlbWVudCkge1xuICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBpZiAoaXNET01UZXh0Tm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB0b2dnbGVUZXh0Rm9ybWF0VHlwZShmb3JtYXQsIHR5cGUsIGFsaWduV2l0aEZvcm1hdCkge1xuICBjb25zdCBhY3RpdmVGb3JtYXQgPSBURVhUX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICBpZiAoYWxpZ25XaXRoRm9ybWF0ICE9PSBudWxsICYmIChmb3JtYXQgJiBhY3RpdmVGb3JtYXQpID09PSAoYWxpZ25XaXRoRm9ybWF0ICYgYWN0aXZlRm9ybWF0KSkge1xuICAgIHJldHVybiBmb3JtYXQ7XG4gIH1cbiAgbGV0IG5ld0Zvcm1hdCA9IGZvcm1hdCBeIGFjdGl2ZUZvcm1hdDtcbiAgaWYgKHR5cGUgPT09ICdzdWJzY3JpcHQnKSB7XG4gICAgbmV3Rm9ybWF0ICY9IH5URVhUX1RZUEVfVE9fRk9STUFULnN1cGVyc2NyaXB0O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdXBlcnNjcmlwdCcpIHtcbiAgICBuZXdGb3JtYXQgJj0gflRFWFRfVFlQRV9UT19GT1JNQVQuc3Vic2NyaXB0O1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdsb3dlcmNhc2UnKSB7XG4gICAgbmV3Rm9ybWF0ICY9IH5URVhUX1RZUEVfVE9fRk9STUFULnVwcGVyY2FzZTtcbiAgICBuZXdGb3JtYXQgJj0gflRFWFRfVFlQRV9UT19GT1JNQVQuY2FwaXRhbGl6ZTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAndXBwZXJjYXNlJykge1xuICAgIG5ld0Zvcm1hdCAmPSB+VEVYVF9UWVBFX1RPX0ZPUk1BVC5sb3dlcmNhc2U7XG4gICAgbmV3Rm9ybWF0ICY9IH5URVhUX1RZUEVfVE9fRk9STUFULmNhcGl0YWxpemU7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NhcGl0YWxpemUnKSB7XG4gICAgbmV3Rm9ybWF0ICY9IH5URVhUX1RZUEVfVE9fRk9STUFULmxvd2VyY2FzZTtcbiAgICBuZXdGb3JtYXQgJj0gflRFWFRfVFlQRV9UT19GT1JNQVQudXBwZXJjYXNlO1xuICB9XG4gIHJldHVybiBuZXdGb3JtYXQ7XG59XG5mdW5jdGlvbiAkaXNMZWFmTm9kZShub2RlKSB7XG4gIHJldHVybiAkaXNUZXh0Tm9kZShub2RlKSB8fCAkaXNMaW5lQnJlYWtOb2RlKG5vZGUpIHx8ICRpc0RlY29yYXRvck5vZGUobm9kZSk7XG59XG5mdW5jdGlvbiAkc2V0Tm9kZUtleShub2RlLCBleGlzdGluZ0tleSkge1xuICBjb25zdCBwZW5kaW5nTm9kZSA9IGdldFBlbmRpbmdOb2RlVG9DbG9uZSgpO1xuICBleGlzdGluZ0tleSA9IGV4aXN0aW5nS2V5IHx8IHBlbmRpbmdOb2RlICYmIHBlbmRpbmdOb2RlLl9fa2V5O1xuICBpZiAoZXhpc3RpbmdLZXkgIT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yT25Ob2RlS2V5Q29uc3RydWN0b3JNaXNtYXRjaChub2RlLCBleGlzdGluZ0tleSwgcGVuZGluZ05vZGUpO1xuICAgIH1cbiAgICBub2RlLl9fa2V5ID0gZXhpc3RpbmdLZXk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBlcnJvck9uSW5maW5pdGVUcmFuc2Zvcm1zKCk7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IGtleSA9IGdlbmVyYXRlUmFuZG9tS2V5KCk7XG4gIGVkaXRvclN0YXRlLl9ub2RlTWFwLnNldChrZXksIG5vZGUpO1xuICAvLyBUT0RPIFNwbGl0IHRoaXMgZnVuY3Rpb24gaW50byBsZWFmL2VsZW1lbnRcbiAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZWRpdG9yLl9kaXJ0eUVsZW1lbnRzLnNldChrZXksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMuYWRkKGtleSk7XG4gIH1cbiAgZWRpdG9yLl9jbG9uZU5vdE5lZWRlZC5hZGQoa2V5KTtcbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBIQVNfRElSVFlfTk9ERVM7XG4gIG5vZGUuX19rZXkgPSBrZXk7XG59XG5mdW5jdGlvbiBlcnJvck9uTm9kZUtleUNvbnN0cnVjdG9yTWlzbWF0Y2gobm9kZSwgZXhpc3RpbmdLZXksIHBlbmRpbmdOb2RlKSB7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gaW50ZXJuYWxHZXRBY3RpdmVFZGl0b3JTdGF0ZSgpO1xuICBpZiAoIWVkaXRvclN0YXRlKSB7XG4gICAgLy8gdGVzdHMgZXhwZWN0IHRvIGJlIGFibGUgdG8gZG8gdGhpcyBraW5kIG9mIGNsb25lIHdpdGhvdXQgYW4gYWN0aXZlIGVkaXRvciBzdGF0ZVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBleGlzdGluZ05vZGUgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoZXhpc3RpbmdLZXkpO1xuICBpZiAocGVuZGluZ05vZGUpIHtcbiAgICBpZiAoIShleGlzdGluZ0tleSA9PT0gcGVuZGluZ05vZGUuX19rZXkpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYExleGljYWwgbm9kZSB3aXRoIGNvbnN0cnVjdG9yICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSAodHlwZSAke25vZGUuZ2V0VHlwZSgpfSkgaGFzIGFuIGluY29ycmVjdCBjbG9uZSBpbXBsZW1lbnRhdGlvbiwgZ290ICR7U3RyaW5nKGV4aXN0aW5nS2V5KX0gZm9yIG5vZGVLZXkgd2hlbiBleHBlY3RpbmcgJHtwZW5kaW5nTm9kZS5fX2tleX1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4aXN0aW5nTm9kZSAmJiBleGlzdGluZ05vZGUuY29uc3RydWN0b3IgIT09IG5vZGUuY29uc3RydWN0b3IpIHtcbiAgICAvLyBMaWZ0ZWQgY29uZGl0aW9uIHRvIGlmIHN0YXRlbWVudCBiZWNhdXNlIHRoZSBpbnZlcnRlZCBsb2dpYyBpcyBhIGJpdCBjb25mdXNpbmdcbiAgICBpZiAobm9kZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSBleGlzdGluZ05vZGUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYExleGljYWwgbm9kZSB3aXRoIGNvbnN0cnVjdG9yICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSBhdHRlbXB0ZWQgdG8gcmUtdXNlIGtleSBmcm9tIG5vZGUgaW4gYWN0aXZlIGVkaXRvciBzdGF0ZSB3aXRoIGNvbnN0cnVjdG9yICR7ZXhpc3RpbmdOb2RlLmNvbnN0cnVjdG9yLm5hbWV9LiBLZXlzIG11c3Qgbm90IGJlIHJlLXVzZWQgd2hlbiB0aGUgdHlwZSBpcyBjaGFuZ2VkLmApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTGV4aWNhbCBub2RlIHdpdGggY29uc3RydWN0b3IgJHtub2RlLmNvbnN0cnVjdG9yLm5hbWV9IGF0dGVtcHRlZCB0byByZS11c2Uga2V5IGZyb20gbm9kZSBpbiBhY3RpdmUgZWRpdG9yIHN0YXRlIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9yIHdpdGggdGhlIHNhbWUgbmFtZSAocG9zc2libHkgZHVlIHRvIGludmFsaWQgSG90IE1vZHVsZSBSZXBsYWNlbWVudCkuIEtleXMgbXVzdCBub3QgYmUgcmUtdXNlZCB3aGVuIHRoZSB0eXBlIGlzIGNoYW5nZWQuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBpbnRlcm5hbE1hcmtQYXJlbnRFbGVtZW50c0FzRGlydHkocGFyZW50S2V5LCBub2RlTWFwLCBkaXJ0eUVsZW1lbnRzKSB7XG4gIGxldCBuZXh0UGFyZW50S2V5ID0gcGFyZW50S2V5O1xuICB3aGlsZSAobmV4dFBhcmVudEtleSAhPT0gbnVsbCkge1xuICAgIGlmIChkaXJ0eUVsZW1lbnRzLmhhcyhuZXh0UGFyZW50S2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gbm9kZU1hcC5nZXQobmV4dFBhcmVudEtleSk7XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRpcnR5RWxlbWVudHMuc2V0KG5leHRQYXJlbnRLZXksIGZhbHNlKTtcbiAgICBuZXh0UGFyZW50S2V5ID0gbm9kZS5fX3BhcmVudDtcbiAgfVxufVxuXG4vLyBUT0RPICM2MDMxIHRoaXMgZnVuY3Rpb24gb3IgdGhlaXIgY2FsbGVycyBoYXZlIHRvIGFkanVzdCBzZWxlY3Rpb24gKGkuZS4gaW5zZXJ0QmVmb3JlKVxuLyoqXG4gKiBSZW1vdmVzIGEgbm9kZSBmcm9tIGl0cyBwYXJlbnQsIHVwZGF0aW5nIGFsbCBuZWNlc3NhcnkgcG9pbnRlcnMgYW5kIGxpbmtzLlxuICogQGludGVybmFsXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBmb3IgaW50ZXJuYWwgdXNlIG9mIHRoZSBsaWJyYXJ5LlxuICogUGxlYXNlIGRvIG5vdCB1c2UgaXQgYXMgaXQgbWF5IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICovXG5mdW5jdGlvbiByZW1vdmVGcm9tUGFyZW50KG5vZGUpIHtcbiAgY29uc3Qgb2xkUGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IHdyaXRhYmxlTm9kZSA9IG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICBjb25zdCB3cml0YWJsZVBhcmVudCA9IG9sZFBhcmVudC5nZXRXcml0YWJsZSgpO1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcblxuICAgIC8vIFN0b3JlIHNpYmxpbmcga2V5c1xuICAgIGNvbnN0IG5leHRTaWJsaW5nS2V5ID0gbmV4dFNpYmxpbmcgIT09IG51bGwgPyBuZXh0U2libGluZy5fX2tleSA6IG51bGw7XG4gICAgY29uc3QgcHJldlNpYmxpbmdLZXkgPSBwcmV2U2libGluZyAhPT0gbnVsbCA/IHByZXZTaWJsaW5nLl9fa2V5IDogbnVsbDtcblxuICAgIC8vIEdldCB3cml0YWJsZSBzaWJsaW5ncyBvbmNlXG4gICAgY29uc3Qgd3JpdGFibGVQcmV2U2libGluZyA9IHByZXZTaWJsaW5nICE9PSBudWxsID8gcHJldlNpYmxpbmcuZ2V0V3JpdGFibGUoKSA6IG51bGw7XG4gICAgY29uc3Qgd3JpdGFibGVOZXh0U2libGluZyA9IG5leHRTaWJsaW5nICE9PSBudWxsID8gbmV4dFNpYmxpbmcuZ2V0V3JpdGFibGUoKSA6IG51bGw7XG5cbiAgICAvLyBVcGRhdGUgcGFyZW50J3MgZmlyc3QvbGFzdCBwb2ludGVyc1xuICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgd3JpdGFibGVQYXJlbnQuX19maXJzdCA9IG5leHRTaWJsaW5nS2V5O1xuICAgIH1cbiAgICBpZiAobmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUGFyZW50Ll9fbGFzdCA9IHByZXZTaWJsaW5nS2V5O1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzaWJsaW5nIGxpbmtzXG4gICAgaWYgKHdyaXRhYmxlUHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHdyaXRhYmxlUHJldlNpYmxpbmcuX19uZXh0ID0gbmV4dFNpYmxpbmdLZXk7XG4gICAgfVxuICAgIGlmICh3cml0YWJsZU5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICB3cml0YWJsZU5leHRTaWJsaW5nLl9fcHJldiA9IHByZXZTaWJsaW5nS2V5O1xuICAgIH1cblxuICAgIC8vIENsZWFyIG5vZGUncyBsaW5rc1xuICAgIHdyaXRhYmxlTm9kZS5fX3ByZXYgPSBudWxsO1xuICAgIHdyaXRhYmxlTm9kZS5fX25leHQgPSBudWxsO1xuICAgIHdyaXRhYmxlTm9kZS5fX3BhcmVudCA9IG51bGw7XG5cbiAgICAvLyBVcGRhdGUgcGFyZW50IHNpemVcbiAgICB3cml0YWJsZVBhcmVudC5fX3NpemUtLTtcbiAgfVxufVxuXG4vLyBOZXZlciB1c2UgdGhpcyBmdW5jdGlvbiBkaXJlY3RseSEgSXQgd2lsbCBicmVha1xuLy8gdGhlIGNsb25pbmcgaGV1cmlzdGljLiBJbnN0ZWFkIHVzZSBub2RlLmdldFdyaXRhYmxlKCkuXG5mdW5jdGlvbiBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShub2RlKSB7XG4gIGVycm9yT25JbmZpbml0ZVRyYW5zZm9ybXMoKTtcbiAgY29uc3QgbGF0ZXN0ID0gbm9kZS5nZXRMYXRlc3QoKTtcbiAgY29uc3QgcGFyZW50ID0gbGF0ZXN0Ll9fcGFyZW50O1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBub2RlTWFwID0gZWRpdG9yU3RhdGUuX25vZGVNYXA7XG4gIGNvbnN0IGRpcnR5RWxlbWVudHMgPSBlZGl0b3IuX2RpcnR5RWxlbWVudHM7XG4gIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICBpbnRlcm5hbE1hcmtQYXJlbnRFbGVtZW50c0FzRGlydHkocGFyZW50LCBub2RlTWFwLCBkaXJ0eUVsZW1lbnRzKTtcbiAgfVxuICBjb25zdCBrZXkgPSBsYXRlc3QuX19rZXk7XG4gIGVkaXRvci5fZGlydHlUeXBlID0gSEFTX0RJUlRZX05PREVTO1xuICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICBkaXJ0eUVsZW1lbnRzLnNldChrZXksIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIGVkaXRvci5fZGlydHlMZWF2ZXMuYWRkKGtleSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVybmFsTWFya1NpYmxpbmdzQXNEaXJ0eShub2RlKSB7XG4gIGNvbnN0IHByZXZpb3VzTm9kZSA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIGNvbnN0IG5leHROb2RlID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICBpZiAocHJldmlvdXNOb2RlICE9PSBudWxsKSB7XG4gICAgaW50ZXJuYWxNYXJrTm9kZUFzRGlydHkocHJldmlvdXNOb2RlKTtcbiAgfVxuICBpZiAobmV4dE5vZGUgIT09IG51bGwpIHtcbiAgICBpbnRlcm5hbE1hcmtOb2RlQXNEaXJ0eShuZXh0Tm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRzZXRDb21wb3NpdGlvbktleShjb21wb3NpdGlvbktleSkge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGNvbnN0IHByZXZpb3VzQ29tcG9zaXRpb25LZXkgPSBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5O1xuICBpZiAoY29tcG9zaXRpb25LZXkgIT09IHByZXZpb3VzQ29tcG9zaXRpb25LZXkpIHtcbiAgICBlZGl0b3IuX2NvbXBvc2l0aW9uS2V5ID0gY29tcG9zaXRpb25LZXk7XG4gICAgaWYgKHByZXZpb3VzQ29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHByZXZpb3VzQ29tcG9zaXRpb25LZXkpO1xuICAgICAgaWYgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5nZXRXcml0YWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9zaXRpb25LZXkgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KGNvbXBvc2l0aW9uS2V5KTtcbiAgICAgIGlmIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuZ2V0V3JpdGFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRDb21wb3NpdGlvbktleSgpIHtcbiAgaWYgKGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fY29tcG9zaXRpb25LZXk7XG59XG5mdW5jdGlvbiAkZ2V0Tm9kZUJ5S2V5KGtleSwgX2VkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGVkaXRvclN0YXRlID0gX2VkaXRvclN0YXRlIHx8IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGNvbnN0IG5vZGUgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoa2V5KTtcbiAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gJGdldE5vZGVGcm9tRE9NTm9kZShkb20sIGVkaXRvclN0YXRlKSB7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBrZXkgPSBnZXROb2RlS2V5RnJvbURPTU5vZGUoZG9tLCBlZGl0b3IpO1xuICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJGdldE5vZGVCeUtleShrZXksIGVkaXRvclN0YXRlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNldE5vZGVLZXlPbkRPTU5vZGUoZG9tLCBlZGl0b3IsIGtleSkge1xuICBjb25zdCBwcm9wID0gYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWA7XG4gIGRvbVtwcm9wXSA9IGtleTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVLZXlGcm9tRE9NTm9kZShkb20sIGVkaXRvcikge1xuICBjb25zdCBwcm9wID0gYF9fbGV4aWNhbEtleV8ke2VkaXRvci5fa2V5fWA7XG4gIHJldHVybiBkb21bcHJvcF07XG59XG5mdW5jdGlvbiAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShzdGFydGluZ0RPTSwgZWRpdG9yU3RhdGUpIHtcbiAgbGV0IGRvbSA9IHN0YXJ0aW5nRE9NO1xuICB3aGlsZSAoZG9tICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlID0gJGdldE5vZGVGcm9tRE9NTm9kZShkb20sIGVkaXRvclN0YXRlKTtcbiAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGRvbSA9IGdldFBhcmVudEVsZW1lbnQoZG9tKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNsb25lRGVjb3JhdG9ycyhlZGl0b3IpIHtcbiAgY29uc3QgY3VycmVudERlY29yYXRvcnMgPSBlZGl0b3IuX2RlY29yYXRvcnM7XG4gIGNvbnN0IHBlbmRpbmdEZWNvcmF0b3JzID0gT2JqZWN0LmFzc2lnbih7fSwgY3VycmVudERlY29yYXRvcnMpO1xuICBlZGl0b3IuX3BlbmRpbmdEZWNvcmF0b3JzID0gcGVuZGluZ0RlY29yYXRvcnM7XG4gIHJldHVybiBwZW5kaW5nRGVjb3JhdG9ycztcbn1cbmZ1bmN0aW9uIGdldEVkaXRvclN0YXRlVGV4dENvbnRlbnQoZWRpdG9yU3RhdGUpIHtcbiAgcmV0dXJuIGVkaXRvclN0YXRlLnJlYWQoKCkgPT4gJGdldFJvb3QoKS5nZXRUZXh0Q29udGVudCgpKTtcbn1cbmZ1bmN0aW9uIG1hcmtOb2Rlc1dpdGhUeXBlc0FzRGlydHkoZWRpdG9yLCB0eXBlcykge1xuICAvLyBXZSBvbmx5IG5lZWQgdG8gbWFyayBub2RlcyBkaXJ0eSBpZiB0aGV5IHdlcmUgaW4gdGhlIHByZXZpb3VzIHN0YXRlLlxuICAvLyBJZiB0aGV5IGFyZW4ndCwgdGhlbiB0aGV5IGFyZSBieSBkZWZpbml0aW9uIGRpcnR5IGFscmVhZHkuXG4gIGNvbnN0IGNhY2hlZE1hcCA9IGdldENhY2hlZFR5cGVUb05vZGVNYXAoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkpO1xuICBjb25zdCBkaXJ0eU5vZGVNYXBzID0gW107XG4gIGZvciAoY29uc3QgdHlwZSBvZiB0eXBlcykge1xuICAgIGNvbnN0IG5vZGVNYXAgPSBjYWNoZWRNYXAuZ2V0KHR5cGUpO1xuICAgIGlmIChub2RlTWFwKSB7XG4gICAgICAvLyBCeSBjb25zdHJ1Y3Rpb24gdGhlc2UgYXJlIG5vbi1lbXB0eVxuICAgICAgZGlydHlOb2RlTWFwcy5wdXNoKG5vZGVNYXApO1xuICAgIH1cbiAgfVxuICAvLyBOb3RoaW5nIHRvIG1hcmsgZGlydHksIG5vIHVwZGF0ZSBuZWNlc3NhcnlcbiAgaWYgKGRpcnR5Tm9kZU1hcHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgIGZvciAoY29uc3Qgbm9kZU1hcCBvZiBkaXJ0eU5vZGVNYXBzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGVLZXkgb2Ygbm9kZU1hcC5rZXlzKCkpIHtcbiAgICAgICAgLy8gV2UgYXJlIG9ubHkgY29uY2VybmVkIHdpdGggbm9kZXMgdGhhdCBhcmUgc3RpbGwgaW4gdGhlIGxhdGVzdCBOb2RlTWFwLFxuICAgICAgICAvLyBpZiB0aGV5IG5vIGxvbmdlciBleGlzdCB0aGVuIG1hcmtEaXJ0eSB3b3VsZCByYWlzZSBhbiBleGNlcHRpb25cbiAgICAgICAgY29uc3QgbGF0ZXN0ID0gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbiAgICAgICAgaWYgKGxhdGVzdCkge1xuICAgICAgICAgIGxhdGVzdC5tYXJrRGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGUgPT09IG51bGwgPyB7XG4gICAgdGFnOiBISVNUT1JZX01FUkdFX1RBR1xuICB9IDogdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uICRnZXRSb290KCkge1xuICByZXR1cm4gaW50ZXJuYWxHZXRSb290KGdldEFjdGl2ZUVkaXRvclN0YXRlKCkpO1xufVxuZnVuY3Rpb24gaW50ZXJuYWxHZXRSb290KGVkaXRvclN0YXRlKSB7XG4gIHJldHVybiBlZGl0b3JTdGF0ZS5fbm9kZU1hcC5nZXQoJ3Jvb3QnKTtcbn1cbmZ1bmN0aW9uICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmlzRnJvemVuKHNlbGVjdGlvbikpIHtcbiAgICAgICAge1xuICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJHNldFNlbGVjdGlvbiBjYWxsZWQgb24gZnJvemVuIHNlbGVjdGlvbiBvYmplY3QuIEVuc3VyZSBzZWxlY3Rpb24gaXMgY2xvbmVkIGJlZm9yZSBwYXNzaW5nIGluLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgc2VsZWN0aW9uLnNldENhY2hlZE5vZGVzKG51bGwpO1xuICB9XG4gIGVkaXRvclN0YXRlLl9zZWxlY3Rpb24gPSBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkZmx1c2hNdXRhdGlvbnMoKSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgZmx1c2hSb290TXV0YXRpb25zKGVkaXRvcik7XG59XG5mdW5jdGlvbiAkZ2V0Tm9kZUZyb21ET00oZG9tKSB7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBub2RlS2V5ID0gZ2V0Tm9kZUtleUZyb21ET01UcmVlKGRvbSwgZWRpdG9yKTtcbiAgaWYgKG5vZGVLZXkgPT09IG51bGwpIHtcbiAgICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgIGlmIChkb20gPT09IHJvb3RFbGVtZW50KSB7XG4gICAgICByZXR1cm4gJGdldE5vZGVCeUtleSgncm9vdCcpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gJGdldE5vZGVCeUtleShub2RlS2V5KTtcbn1cbmZ1bmN0aW9uIGdldE5vZGVLZXlGcm9tRE9NVHJlZShcbi8vIE5vdGUgdGhhdCBub2RlIGhlcmUgcmVmZXJzIHRvIGEgRE9NIE5vZGUsIG5vdCBhbiBMZXhpY2FsIE5vZGVcbmRvbSwgZWRpdG9yKSB7XG4gIGxldCBub2RlID0gZG9tO1xuICB3aGlsZSAobm9kZSAhPSBudWxsKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0Tm9kZUtleUZyb21ET01Ob2RlKG5vZGUsIGVkaXRvcik7XG4gICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICBub2RlID0gZ2V0UGFyZW50RWxlbWVudChub2RlKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBgc3RyYCBjb250YWlucyBhbnkgdmFsaWQgc3Vycm9nYXRlIHBhaXIuXG4gKlxuICogU2VlIGFsc28gJHVwZGF0ZUNhcmV0U2VsZWN0aW9uRm9yVW5pY29kZUNoYXJhY3RlciBmb3JcbiAqIGEgZGlzY3Vzc2lvbiBvbiB3aGVuIGFuZCB3aHkgdGhpcyBpcyB1c2VmdWwuXG4gKi9cbmZ1bmN0aW9uIGRvZXNDb250YWluU3Vycm9nYXRlUGFpcihzdHIpIHtcbiAgcmV0dXJuIC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2cudGVzdChzdHIpO1xufVxuZnVuY3Rpb24gZ2V0RWRpdG9yc1RvUHJvcGFnYXRlKGVkaXRvcikge1xuICBjb25zdCBlZGl0b3JzVG9Qcm9wYWdhdGUgPSBbXTtcbiAgbGV0IGN1cnJlbnRFZGl0b3IgPSBlZGl0b3I7XG4gIHdoaWxlIChjdXJyZW50RWRpdG9yICE9PSBudWxsKSB7XG4gICAgZWRpdG9yc1RvUHJvcGFnYXRlLnB1c2goY3VycmVudEVkaXRvcik7XG4gICAgY3VycmVudEVkaXRvciA9IGN1cnJlbnRFZGl0b3IuX3BhcmVudEVkaXRvcjtcbiAgfVxuICByZXR1cm4gZWRpdG9yc1RvUHJvcGFnYXRlO1xufVxuZnVuY3Rpb24gY3JlYXRlVUlEKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikucmVwbGFjZSgvW15hLXpdKy9nLCAnJykuc3Vic3RyaW5nKDAsIDUpO1xufVxuZnVuY3Rpb24gZ2V0QW5jaG9yVGV4dEZyb21ET00oYW5jaG9yTm9kZSkge1xuICByZXR1cm4gaXNET01UZXh0Tm9kZShhbmNob3JOb2RlKSA/IGFuY2hvck5vZGUubm9kZVZhbHVlIDogbnVsbDtcbn1cbmZ1bmN0aW9uICR1cGRhdGVTZWxlY3RlZFRleHRGcm9tRE9NKGlzQ29tcG9zaXRpb25FbmQsIGVkaXRvciwgZGF0YSkge1xuICAvLyBVcGRhdGUgdGhlIHRleHQgY29udGVudCB3aXRoIHRoZSBsYXRlc3QgY29tcG9zaXRpb24gdGV4dFxuICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24oZ2V0V2luZG93KGVkaXRvcikpO1xuICBpZiAoZG9tU2VsZWN0aW9uID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgbGV0IHtcbiAgICBhbmNob3JPZmZzZXQsXG4gICAgZm9jdXNPZmZzZXRcbiAgfSA9IGRvbVNlbGVjdGlvbjtcbiAgaWYgKGFuY2hvck5vZGUgIT09IG51bGwpIHtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSBnZXRBbmNob3JUZXh0RnJvbURPTShhbmNob3JOb2RlKTtcbiAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoYW5jaG9yTm9kZSk7XG4gICAgaWYgKHRleHRDb250ZW50ICE9PSBudWxsICYmICRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAvLyBEYXRhIGlzIGludGVudGlvbmFsbHkgdHJ1dGh5LCBhcyB3ZSBjaGVjayBmb3IgYm9vbGVhbiwgbnVsbCBhbmQgZW1wdHkgc3RyaW5nLlxuICAgICAgaWYgKHRleHRDb250ZW50ID09PSBDT01QT1NJVElPTl9TVUZGSVggJiYgZGF0YSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGV4dENvbnRlbnQgPSBkYXRhO1xuICAgICAgICBhbmNob3JPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHRleHRDb250ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KG5vZGUsIHRleHRDb250ZW50LCBhbmNob3JPZmZzZXQsIGZvY3VzT2Zmc2V0LCBpc0NvbXBvc2l0aW9uRW5kKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICR1cGRhdGVUZXh0Tm9kZUZyb21ET01Db250ZW50KHRleHROb2RlLCB0ZXh0Q29udGVudCwgYW5jaG9yT2Zmc2V0LCBmb2N1c09mZnNldCwgY29tcG9zaXRpb25FbmQpIHtcbiAgbGV0IG5vZGUgPSB0ZXh0Tm9kZTtcbiAgaWYgKG5vZGUuaXNBdHRhY2hlZCgpICYmIChjb21wb3NpdGlvbkVuZCB8fCAhbm9kZS5pc0RpcnR5KCkpKSB7XG4gICAgY29uc3QgaXNDb21wb3NpbmcgPSBub2RlLmlzQ29tcG9zaW5nKCk7XG4gICAgbGV0IG5vcm1hbGl6ZWRUZXh0Q29udGVudCA9IHRleHRDb250ZW50O1xuICAgIGlmICgoaXNDb21wb3NpbmcgfHwgY29tcG9zaXRpb25FbmQpICYmIHRleHRDb250ZW50W3RleHRDb250ZW50Lmxlbmd0aCAtIDFdID09PSBDT01QT1NJVElPTl9TVUZGSVgpIHtcbiAgICAgIG5vcm1hbGl6ZWRUZXh0Q29udGVudCA9IHRleHRDb250ZW50LnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgY29uc3QgcHJldlRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGlmIChjb21wb3NpdGlvbkVuZCB8fCBub3JtYWxpemVkVGV4dENvbnRlbnQgIT09IHByZXZUZXh0Q29udGVudCkge1xuICAgICAgaWYgKG5vcm1hbGl6ZWRUZXh0Q29udGVudCA9PT0gJycpIHtcbiAgICAgICAgJHNldENvbXBvc2l0aW9uS2V5KG51bGwpO1xuICAgICAgICBpZiAoIUlTX1NBRkFSSSAmJiAhSVNfSU9TICYmICFJU19BUFBMRV9XRUJLSVQpIHtcbiAgICAgICAgICAvLyBGb3IgY29tcG9zaXRpb24gKG1haW5seSBBbmRyb2lkKSwgd2UgaGF2ZSB0byByZW1vdmUgdGhlIG5vZGUgb24gYSBsYXRlciB1cGRhdGVcbiAgICAgICAgICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICBpZiAobm9kZS5pc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAyMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgY29uc3QgcHJldlNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgICAgY29uc3QgcHJldlRleHRDb250ZW50U2l6ZSA9IG5vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCk7XG4gICAgICBjb25zdCBjb21wb3NpdGlvbktleSA9ICRnZXRDb21wb3NpdGlvbktleSgpO1xuICAgICAgY29uc3Qgbm9kZUtleSA9IG5vZGUuZ2V0S2V5KCk7XG4gICAgICBpZiAobm9kZS5pc1Rva2VuKCkgfHwgY29tcG9zaXRpb25LZXkgIT09IG51bGwgJiYgbm9kZUtleSA9PT0gY29tcG9zaXRpb25LZXkgJiYgIWlzQ29tcG9zaW5nIHx8XG4gICAgICAvLyBDaGVjayBpZiBjaGFyYWN0ZXIgd2FzIGFkZGVkIGF0IHRoZSBzdGFydCBvciBib3VuZGFyaWVzIHdoZW4gbm90IGluc2VydGFibGUsIGFuZCB3ZSBuZWVkXG4gICAgICAvLyB0byBjbGVhciB0aGlzIGlucHV0IGZyb20gb2NjdXJyaW5nIGFzIHRoYXQgYWN0aW9uIHdhc24ndCBwZXJtaXR0ZWQuXG4gICAgICAkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiAocGFyZW50ICE9PSBudWxsICYmICFwYXJlbnQuY2FuSW5zZXJ0VGV4dEJlZm9yZSgpICYmIHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCB8fCBwcmV2U2VsZWN0aW9uLmFuY2hvci5rZXkgPT09IHRleHROb2RlLl9fa2V5ICYmIHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCA9PT0gMCAmJiAhbm9kZS5jYW5JbnNlcnRUZXh0QmVmb3JlKCkgJiYgIWlzQ29tcG9zaW5nIHx8IHByZXZTZWxlY3Rpb24uZm9jdXMua2V5ID09PSB0ZXh0Tm9kZS5fX2tleSAmJiBwcmV2U2VsZWN0aW9uLmZvY3VzLm9mZnNldCA9PT0gcHJldlRleHRDb250ZW50U2l6ZSAmJiAhbm9kZS5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSAmJiAhaXNDb21wb3NpbmcpKSB7XG4gICAgICAgIG5vZGUubWFya0RpcnR5KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCBhbmNob3JPZmZzZXQgPT09IG51bGwgfHwgZm9jdXNPZmZzZXQgPT09IG51bGwpIHtcbiAgICAgICAgJHNldFRleHRDb250ZW50V2l0aFNlbGVjdGlvbihub2RlLCBub3JtYWxpemVkVGV4dENvbnRlbnQsIHNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNlbGVjdGlvbi5zZXRUZXh0Tm9kZVJhbmdlKG5vZGUsIGFuY2hvck9mZnNldCwgbm9kZSwgZm9jdXNPZmZzZXQpO1xuICAgICAgaWYgKG5vZGUuaXNTZWdtZW50ZWQoKSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFRleHRDb250ZW50ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9ICRjcmVhdGVUZXh0Tm9kZShvcmlnaW5hbFRleHRDb250ZW50KTtcbiAgICAgICAgbm9kZS5yZXBsYWNlKHJlcGxhY2VtZW50KTtcbiAgICAgICAgbm9kZSA9IHJlcGxhY2VtZW50O1xuICAgICAgfVxuICAgICAgJHNldFRleHRDb250ZW50V2l0aFNlbGVjdGlvbihub2RlLCBub3JtYWxpemVkVGV4dENvbnRlbnQsIHNlbGVjdGlvbik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkc2V0VGV4dENvbnRlbnRXaXRoU2VsZWN0aW9uKG5vZGUsIHRleHRDb250ZW50LCBzZWxlY3Rpb24pIHtcbiAgbm9kZS5zZXRUZXh0Q29udGVudCh0ZXh0Q29udGVudCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3Qga2V5ID0gbm9kZS5nZXRLZXkoKTtcbiAgICBmb3IgKGNvbnN0IGsgb2YgWydhbmNob3InLCAnZm9jdXMnXSkge1xuICAgICAgY29uc3QgcHQgPSBzZWxlY3Rpb25ba107XG4gICAgICBpZiAocHQudHlwZSA9PT0gJ3RleHQnICYmIHB0LmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHB0Lm9mZnNldCA9ICRnZXRUZXh0Tm9kZU9mZnNldChub2RlLCBwdC5vZmZzZXQsICdjbGFtcCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHByZXZpb3VzU2libGluZ0RvZXNOb3RBY2NlcHRUZXh0KG5vZGUpIHtcbiAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgcmV0dXJuICgkaXNUZXh0Tm9kZShwcmV2aW91c1NpYmxpbmcpIHx8ICRpc0VsZW1lbnROb2RlKHByZXZpb3VzU2libGluZykgJiYgcHJldmlvdXNTaWJsaW5nLmlzSW5saW5lKCkpICYmICFwcmV2aW91c1NpYmxpbmcuY2FuSW5zZXJ0VGV4dEFmdGVyKCk7XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgY29ubmVjdGVkIHRvICRzaG91bGRQcmV2ZW50RGVmYXVsdEFuZEluc2VydFRleHQgYW5kIGRldGVybWluZXMgd2hldGhlciB0aGVcbi8vIFRleHROb2RlIGJvdW5kYXJpZXMgYXJlIHdyaXRhYmxlIG9yIHdlIHNob3VsZCB1c2UgdGhlIHByZXZpb3VzL25leHQgc2libGluZyBpbnN0ZWFkLiBGb3IgZXhhbXBsZSxcbi8vIGluIHRoZSBjYXNlIG9mIGEgTGlua05vZGUsIGJvdW5kYXJpZXMgYXJlIG5vdCB3cml0YWJsZS5cbmZ1bmN0aW9uICRzaG91bGRJbnNlcnRUZXh0QWZ0ZXJPckJlZm9yZVRleHROb2RlKHNlbGVjdGlvbiwgbm9kZSkge1xuICBpZiAobm9kZS5pc1NlZ21lbnRlZCgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBvZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgY29uc3QgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIGNvbnN0IGlzVG9rZW4gPSAkaXNUb2tlbk9yVGFiKG5vZGUpO1xuICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgcmV0dXJuICFub2RlLmNhbkluc2VydFRleHRCZWZvcmUoKSB8fCAhcGFyZW50LmNhbkluc2VydFRleHRCZWZvcmUoKSAmJiAhbm9kZS5pc0NvbXBvc2luZygpIHx8IGlzVG9rZW4gfHwgJHByZXZpb3VzU2libGluZ0RvZXNOb3RBY2NlcHRUZXh0KG5vZGUpO1xuICB9IGVsc2UgaWYgKG9mZnNldCA9PT0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSkge1xuICAgIHJldHVybiAhbm9kZS5jYW5JbnNlcnRUZXh0QWZ0ZXIoKSB8fCAhcGFyZW50LmNhbkluc2VydFRleHRBZnRlcigpICYmICFub2RlLmlzQ29tcG9zaW5nKCkgfHwgaXNUb2tlbjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBBIEtleWJvYXJkRXZlbnQgb3Igc3RydWN0dXJhbGx5IHNpbWlsYXIgb2JqZWN0IHdpdGggYSBzdHJpbmcgYGtleWAgYXMgd2VsbFxuICogYXMgYGFsdEtleWAsIGBjdHJsS2V5YCwgYG1ldGFLZXlgLCBhbmQgYHNoaWZ0S2V5YCBib29sZWFuIHByb3BlcnRpZXMuXG4gKi9cblxuLyoqXG4gKiBBIHJlY29yZCBvZiBrZXlib2FyZCBtb2RpZmllcnMgdGhhdCBtdXN0IGJlIGVuYWJsZWQuXG4gKiBJZiB0aGUgdmFsdWUgaXMgYCdhbnknYCB0aGVuIHRoZSBtb2RpZmllciBrZXkncyBzdGF0ZSBpcyBpZ25vcmVkLlxuICogSWYgdGhlIHZhbHVlIGlzIGB0cnVlYCB0aGVuIHRoZSBtb2RpZmllciBrZXkgbXVzdCBiZSBwcmVzc2VkLlxuICogSWYgdGhlIHZhbHVlIGlzIGBmYWxzZWAgb3IgdGhlIHByb3BlcnR5IGlzIG9taXR0ZWQgdGhlbiB0aGUgbW9kaWZpZXIga2V5IG11c3RcbiAqIG5vdCBiZSBwcmVzc2VkLlxuICovXG5cbmZ1bmN0aW9uIG1hdGNoTW9kaWZpZXIoZXZlbnQsIG1hc2ssIHByb3ApIHtcbiAgY29uc3QgZXhwZWN0ZWQgPSBtYXNrW3Byb3BdIHx8IGZhbHNlO1xuICByZXR1cm4gZXhwZWN0ZWQgPT09ICdhbnknIHx8IGV4cGVjdGVkID09PSBldmVudFtwcm9wXTtcbn1cblxuLyoqXG4gKiBNYXRjaCBhIEtleWJvYXJkRXZlbnQgd2l0aCBpdHMgZXhwZWN0ZWQgbW9kaWZpZXIgc3RhdGVcbiAqXG4gKiBAcGFyYW0gZXZlbnQgQSBLZXlib2FyZEV2ZW50LCBvciBzdHJ1Y3R1cmFsbHkgc2ltaWxhciBvYmplY3RcbiAqIEBwYXJhbSBtYXNrIEFuIG9iamVjdCBzcGVjaWZ5aW5nIHRoZSBleHBlY3RlZCBzdGF0ZSBvZiB0aGUgbW9kaWZpZXJzXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBldmVudCBtYXRjaGVzXG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJNYXRjaChldmVudCwgbWFzaykge1xuICByZXR1cm4gbWF0Y2hNb2RpZmllcihldmVudCwgbWFzaywgJ2FsdEtleScpICYmIG1hdGNoTW9kaWZpZXIoZXZlbnQsIG1hc2ssICdjdHJsS2V5JykgJiYgbWF0Y2hNb2RpZmllcihldmVudCwgbWFzaywgJ3NoaWZ0S2V5JykgJiYgbWF0Y2hNb2RpZmllcihldmVudCwgbWFzaywgJ21ldGFLZXknKTtcbn1cblxuLyoqXG4gKiBNYXRjaCBhIEtleWJvYXJkRXZlbnQgd2l0aCBpdHMgZXhwZWN0ZWQgc3RhdGVcbiAqXG4gKiBAcGFyYW0gZXZlbnQgQSBLZXlib2FyZEV2ZW50LCBvciBzdHJ1Y3R1cmFsbHkgc2ltaWxhciBvYmplY3RcbiAqIEBwYXJhbSBleHBlY3RlZEtleSBUaGUgc3RyaW5nIHRvIGNvbXBhcmUgd2l0aCBldmVudC5rZXkgKGNhc2UgaW5zZW5zaXRpdmUpXG4gKiBAcGFyYW0gbWFzayBBbiBvYmplY3Qgc3BlY2lmeWluZyB0aGUgZXhwZWN0ZWQgc3RhdGUgb2YgdGhlIG1vZGlmaWVyc1xuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZXZlbnQgbWF0Y2hlc1xuICovXG5mdW5jdGlvbiBpc0V4YWN0U2hvcnRjdXRNYXRjaChldmVudCwgZXhwZWN0ZWRLZXksIG1hc2spIHtcbiAgcmV0dXJuIGlzTW9kaWZpZXJNYXRjaChldmVudCwgbWFzaykgJiYgZXZlbnQua2V5LnRvTG93ZXJDYXNlKCkgPT09IGV4cGVjdGVkS2V5LnRvTG93ZXJDYXNlKCk7XG59XG5jb25zdCBDT05UUk9MX09SX01FVEEgPSB7XG4gIGN0cmxLZXk6ICFJU19BUFBMRSxcbiAgbWV0YUtleTogSVNfQVBQTEVcbn07XG5jb25zdCBDT05UUk9MX09SX0FMVCA9IHtcbiAgYWx0S2V5OiBJU19BUFBMRSxcbiAgY3RybEtleTogIUlTX0FQUExFXG59O1xuZnVuY3Rpb24gaXNUYWIoZXZlbnQpIHtcbiAgcmV0dXJuIGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAnVGFiJywge1xuICAgIHNoaWZ0S2V5OiAnYW55J1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzQm9sZChldmVudCkge1xuICByZXR1cm4gaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICdiJywgQ09OVFJPTF9PUl9NRVRBKTtcbn1cbmZ1bmN0aW9uIGlzSXRhbGljKGV2ZW50KSB7XG4gIHJldHVybiBpc0V4YWN0U2hvcnRjdXRNYXRjaChldmVudCwgJ2knLCBDT05UUk9MX09SX01FVEEpO1xufVxuZnVuY3Rpb24gaXNVbmRlcmxpbmUoZXZlbnQpIHtcbiAgcmV0dXJuIGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAndScsIENPTlRST0xfT1JfTUVUQSk7XG59XG5mdW5jdGlvbiBpc1BhcmFncmFwaChldmVudCkge1xuICByZXR1cm4gaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICdFbnRlcicsIHtcbiAgICBhbHRLZXk6ICdhbnknLFxuICAgIGN0cmxLZXk6ICdhbnknLFxuICAgIG1ldGFLZXk6ICdhbnknXG4gIH0pO1xufVxuZnVuY3Rpb24gaXNMaW5lQnJlYWsoZXZlbnQpIHtcbiAgcmV0dXJuIGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAnRW50ZXInLCB7XG4gICAgYWx0S2V5OiAnYW55JyxcbiAgICBjdHJsS2V5OiAnYW55JyxcbiAgICBtZXRhS2V5OiAnYW55JyxcbiAgICBzaGlmdEtleTogdHJ1ZVxuICB9KTtcbn1cblxuLy8gSW5zZXJ0cyBhIG5ldyBsaW5lIGFmdGVyIHRoZSBzZWxlY3Rpb25cblxuZnVuY3Rpb24gaXNPcGVuTGluZUJyZWFrKGV2ZW50KSB7XG4gIC8vIDc5ID0gS2V5T1xuICByZXR1cm4gSVNfQVBQTEUgJiYgaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICdvJywge1xuICAgIGN0cmxLZXk6IHRydWVcbiAgfSk7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZVdvcmRCYWNrd2FyZChldmVudCkge1xuICByZXR1cm4gaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICdCYWNrc3BhY2UnLCBDT05UUk9MX09SX0FMVCk7XG59XG5mdW5jdGlvbiBpc0RlbGV0ZVdvcmRGb3J3YXJkKGV2ZW50KSB7XG4gIHJldHVybiBpc0V4YWN0U2hvcnRjdXRNYXRjaChldmVudCwgJ0RlbGV0ZScsIENPTlRST0xfT1JfQUxUKTtcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlTGluZUJhY2t3YXJkKGV2ZW50KSB7XG4gIHJldHVybiBJU19BUFBMRSAmJiBpc0V4YWN0U2hvcnRjdXRNYXRjaChldmVudCwgJ0JhY2tzcGFjZScsIHtcbiAgICBtZXRhS2V5OiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gaXNEZWxldGVMaW5lRm9yd2FyZChldmVudCkge1xuICByZXR1cm4gSVNfQVBQTEUgJiYgKGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAnRGVsZXRlJywge1xuICAgIG1ldGFLZXk6IHRydWVcbiAgfSkgfHwgaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICdrJywge1xuICAgIGN0cmxLZXk6IHRydWVcbiAgfSkpO1xufVxuZnVuY3Rpb24gaXNEZWxldGVCYWNrd2FyZChldmVudCkge1xuICByZXR1cm4gaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICdCYWNrc3BhY2UnLCB7XG4gICAgc2hpZnRLZXk6ICdhbnknXG4gIH0pIHx8IElTX0FQUExFICYmIGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAnaCcsIHtcbiAgICBjdHJsS2V5OiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gaXNEZWxldGVGb3J3YXJkKGV2ZW50KSB7XG4gIHJldHVybiBpc0V4YWN0U2hvcnRjdXRNYXRjaChldmVudCwgJ0RlbGV0ZScsIHt9KSB8fCBJU19BUFBMRSAmJiBpc0V4YWN0U2hvcnRjdXRNYXRjaChldmVudCwgJ2QnLCB7XG4gICAgY3RybEtleTogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzVW5kbyhldmVudCkge1xuICByZXR1cm4gaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICd6JywgQ09OVFJPTF9PUl9NRVRBKTtcbn1cbmZ1bmN0aW9uIGlzUmVkbyhldmVudCkge1xuICBpZiAoSVNfQVBQTEUpIHtcbiAgICByZXR1cm4gaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICd6Jywge1xuICAgICAgbWV0YUtleTogdHJ1ZSxcbiAgICAgIHNoaWZ0S2V5OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAneScsIHtcbiAgICBjdHJsS2V5OiB0cnVlXG4gIH0pIHx8IGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAneicsIHtcbiAgICBjdHJsS2V5OiB0cnVlLFxuICAgIHNoaWZ0S2V5OiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gaXNDb3B5KGV2ZW50KSB7XG4gIHJldHVybiBpc0V4YWN0U2hvcnRjdXRNYXRjaChldmVudCwgJ2MnLCBDT05UUk9MX09SX01FVEEpO1xufVxuZnVuY3Rpb24gaXNDdXQoZXZlbnQpIHtcbiAgcmV0dXJuIGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAneCcsIENPTlRST0xfT1JfTUVUQSk7XG59XG5mdW5jdGlvbiBpc01vdmVCYWNrd2FyZChldmVudCkge1xuICByZXR1cm4gaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICdBcnJvd0xlZnQnLCB7XG4gICAgc2hpZnRLZXk6ICdhbnknXG4gIH0pO1xufVxuZnVuY3Rpb24gaXNNb3ZlVG9TdGFydChldmVudCkge1xuICByZXR1cm4gaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICdBcnJvd0xlZnQnLCBDT05UUk9MX09SX01FVEEpO1xufVxuZnVuY3Rpb24gaXNNb3ZlRm9yd2FyZChldmVudCkge1xuICByZXR1cm4gaXNFeGFjdFNob3J0Y3V0TWF0Y2goZXZlbnQsICdBcnJvd1JpZ2h0Jywge1xuICAgIHNoaWZ0S2V5OiAnYW55J1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTW92ZVRvRW5kKGV2ZW50KSB7XG4gIHJldHVybiBpc0V4YWN0U2hvcnRjdXRNYXRjaChldmVudCwgJ0Fycm93UmlnaHQnLCBDT05UUk9MX09SX01FVEEpO1xufVxuZnVuY3Rpb24gaXNNb3ZlVXAoZXZlbnQpIHtcbiAgcmV0dXJuIGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAnQXJyb3dVcCcsIHtcbiAgICBhbHRLZXk6ICdhbnknLFxuICAgIHNoaWZ0S2V5OiAnYW55J1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTW92ZURvd24oZXZlbnQpIHtcbiAgcmV0dXJuIGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAnQXJyb3dEb3duJywge1xuICAgIGFsdEtleTogJ2FueScsXG4gICAgc2hpZnRLZXk6ICdhbnknXG4gIH0pO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllcihldmVudCkge1xuICByZXR1cm4gZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleTtcbn1cbmZ1bmN0aW9uIGlzU3BhY2UoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmtleSA9PT0gJyAnO1xufVxuZnVuY3Rpb24gaXNCYWNrc3BhY2UoZXZlbnQpIHtcbiAgcmV0dXJuIGV2ZW50LmtleSA9PT0gJ0JhY2tzcGFjZSc7XG59XG5mdW5jdGlvbiBpc0VzY2FwZShldmVudCkge1xuICByZXR1cm4gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbn1cbmZ1bmN0aW9uIGlzRGVsZXRlKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5rZXkgPT09ICdEZWxldGUnO1xufVxuZnVuY3Rpb24gaXNTZWxlY3RBbGwoZXZlbnQpIHtcbiAgcmV0dXJuIGlzRXhhY3RTaG9ydGN1dE1hdGNoKGV2ZW50LCAnYScsIENPTlRST0xfT1JfTUVUQSk7XG59XG5mdW5jdGlvbiAkc2VsZWN0QWxsKHNlbGVjdGlvbikge1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IHRvcFBhcmVudCA9IGFuY2hvck5vZGUuZ2V0VG9wTGV2ZWxFbGVtZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IHJvb3ROb2RlID0gdG9wUGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBhbmNob3Iuc2V0KHJvb3ROb2RlLmdldEtleSgpLCAwLCAnZWxlbWVudCcpO1xuICAgIGZvY3VzLnNldChyb290Tm9kZS5nZXRLZXkoKSwgcm9vdE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgJG5vcm1hbGl6ZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH0gZWxzZSB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IFJhbmdlU2VsZWN0aW9uXG4gICAgY29uc3QgbmV3U2VsZWN0aW9uID0gcm9vdC5zZWxlY3QoMCwgcm9vdC5nZXRDaGlsZHJlblNpemUoKSk7XG4gICAgJHNldFNlbGVjdGlvbigkbm9ybWFsaXplU2VsZWN0aW9uKG5ld1NlbGVjdGlvbikpO1xuICAgIHJldHVybiBuZXdTZWxlY3Rpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENhY2hlZENsYXNzTmFtZUFycmF5KGNsYXNzTmFtZXNUaGVtZSwgY2xhc3NOYW1lVGhlbWVUeXBlKSB7XG4gIGlmIChjbGFzc05hbWVzVGhlbWUuX19sZXhpY2FsQ2xhc3NOYW1lQ2FjaGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsYXNzTmFtZXNUaGVtZS5fX2xleGljYWxDbGFzc05hbWVDYWNoZSA9IHt9O1xuICB9XG4gIGNvbnN0IGNsYXNzTmFtZXNDYWNoZSA9IGNsYXNzTmFtZXNUaGVtZS5fX2xleGljYWxDbGFzc05hbWVDYWNoZTtcbiAgY29uc3QgY2FjaGVkQ2xhc3NOYW1lcyA9IGNsYXNzTmFtZXNDYWNoZVtjbGFzc05hbWVUaGVtZVR5cGVdO1xuICBpZiAoY2FjaGVkQ2xhc3NOYW1lcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNhY2hlZENsYXNzTmFtZXM7XG4gIH1cbiAgY29uc3QgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXNUaGVtZVtjbGFzc05hbWVUaGVtZVR5cGVdO1xuICAvLyBBcyB3ZSdyZSB1c2luZyBjbGFzc0xpc3QsIHdlIG5lZWRcbiAgLy8gdG8gaGFuZGxlIGNsYXNzTmFtZSB0b2tlbnMgdGhhdCBoYXZlIHNwYWNlcy5cbiAgLy8gVGhlIGVhc2llc3Qgd2F5IHRvIGRvIHRoaXMgdG8gY29udmVydCB0aGVcbiAgLy8gY2xhc3NOYW1lIHRva2VucyB0byBhbiBhcnJheSB0aGF0IGNhbiBiZVxuICAvLyBhcHBsaWVkIHRvIGNsYXNzTGlzdC5hZGQoKS9yZW1vdmUoKS5cbiAgaWYgKHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGNsYXNzTmFtZXNBcnIgPSBub3JtYWxpemVDbGFzc05hbWVzKGNsYXNzTmFtZXMpO1xuICAgIGNsYXNzTmFtZXNDYWNoZVtjbGFzc05hbWVUaGVtZVR5cGVdID0gY2xhc3NOYW1lc0FycjtcbiAgICByZXR1cm4gY2xhc3NOYW1lc0FycjtcbiAgfVxuICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIHNldE11dGF0ZWROb2RlKG11dGF0ZWROb2RlcywgcmVnaXN0ZXJlZE5vZGVzLCBtdXRhdGlvbkxpc3RlbmVycywgbm9kZSwgbXV0YXRpb24pIHtcbiAgaWYgKG11dGF0aW9uTGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgbm9kZVR5cGUgPSBub2RlLl9fdHlwZTtcbiAgY29uc3Qgbm9kZUtleSA9IG5vZGUuX19rZXk7XG4gIGNvbnN0IHJlZ2lzdGVyZWROb2RlID0gcmVnaXN0ZXJlZE5vZGVzLmdldChub2RlVHlwZSk7XG4gIGlmIChyZWdpc3RlcmVkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUeXBlICR7bm9kZVR5cGV9IG5vdCBpbiByZWdpc3RlcmVkTm9kZXNgKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qga2xhc3MgPSByZWdpc3RlcmVkTm9kZS5rbGFzcztcbiAgbGV0IG11dGF0ZWROb2Rlc0J5VHlwZSA9IG11dGF0ZWROb2Rlcy5nZXQoa2xhc3MpO1xuICBpZiAobXV0YXRlZE5vZGVzQnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBtdXRhdGVkTm9kZXNCeVR5cGUgPSBuZXcgTWFwKCk7XG4gICAgbXV0YXRlZE5vZGVzLnNldChrbGFzcywgbXV0YXRlZE5vZGVzQnlUeXBlKTtcbiAgfVxuICBjb25zdCBwcmV2TXV0YXRpb24gPSBtdXRhdGVkTm9kZXNCeVR5cGUuZ2V0KG5vZGVLZXkpO1xuICAvLyBJZiB0aGUgbm9kZSBoYXMgYWxyZWFkeSBiZWVuIFwiZGVzdHJveWVkXCIsIHlldCB3ZSBhcmVcbiAgLy8gcmUtbWFraW5nIGl0LCB0aGVuIHRoaXMgbWVhbnMgYSBtb3ZlIGxpa2VseSBoYXBwZW5lZC5cbiAgLy8gV2Ugc2hvdWxkIGNoYW5nZSB0aGUgbXV0YXRpb24gdG8gYmUgdGhhdCBvZiBcInVwZGF0ZWRcIlxuICAvLyBpbnN0ZWFkLlxuICBjb25zdCBpc01vdmUgPSBwcmV2TXV0YXRpb24gPT09ICdkZXN0cm95ZWQnICYmIG11dGF0aW9uID09PSAnY3JlYXRlZCc7XG4gIGlmIChwcmV2TXV0YXRpb24gPT09IHVuZGVmaW5lZCB8fCBpc01vdmUpIHtcbiAgICBtdXRhdGVkTm9kZXNCeVR5cGUuc2V0KG5vZGVLZXksIGlzTW92ZSA/ICd1cGRhdGVkJyA6IG11dGF0aW9uKTtcbiAgfVxufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIExleGljYWxFZGl0b3IucmVnaXN0ZXJNdXRhdGlvbkxpc3RlbmVyfSB3aXRoIGBza2lwSW5pdGlhbGl6YXRpb246IGZhbHNlYCBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiAkbm9kZXNPZlR5cGUoa2xhc3MpIHtcbiAgY29uc3Qga2xhc3NUeXBlID0ga2xhc3MuZ2V0VHlwZSgpO1xuICBjb25zdCBlZGl0b3JTdGF0ZSA9IGdldEFjdGl2ZUVkaXRvclN0YXRlKCk7XG4gIGlmIChlZGl0b3JTdGF0ZS5fcmVhZE9ubHkpIHtcbiAgICBjb25zdCBub2RlcyA9IGdldENhY2hlZFR5cGVUb05vZGVNYXAoZWRpdG9yU3RhdGUpLmdldChrbGFzc1R5cGUpO1xuICAgIHJldHVybiBub2RlcyA/IEFycmF5LmZyb20obm9kZXMudmFsdWVzKCkpIDogW107XG4gIH1cbiAgY29uc3Qgbm9kZXMgPSBlZGl0b3JTdGF0ZS5fbm9kZU1hcDtcbiAgY29uc3Qgbm9kZXNPZlR5cGUgPSBbXTtcbiAgZm9yIChjb25zdCBbLCBub2RlXSBvZiBub2Rlcykge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2Yga2xhc3MgJiYgbm9kZS5fX3R5cGUgPT09IGtsYXNzVHlwZSAmJiBub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgbm9kZXNPZlR5cGUucHVzaChub2RlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGVzT2ZUeXBlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUVsZW1lbnQoZWxlbWVudCwgaXNCYWNrd2FyZCwgZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5nZXRQYXJlbnQoKTtcbiAgbGV0IG9mZnNldCA9IGZvY3VzT2Zmc2V0O1xuICBsZXQgYmxvY2sgPSBlbGVtZW50O1xuICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzQmFja3dhcmQgJiYgZm9jdXNPZmZzZXQgPT09IDApIHtcbiAgICAgIG9mZnNldCA9IGJsb2NrLmdldEluZGV4V2l0aGluUGFyZW50KCk7XG4gICAgICBibG9jayA9IHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKCFpc0JhY2t3YXJkICYmIGZvY3VzT2Zmc2V0ID09PSBibG9jay5nZXRDaGlsZHJlblNpemUoKSkge1xuICAgICAgb2Zmc2V0ID0gYmxvY2suZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIDE7XG4gICAgICBibG9jayA9IHBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJsb2NrLmdldENoaWxkQXRJbmRleChpc0JhY2t3YXJkID8gb2Zmc2V0IC0gMSA6IG9mZnNldCk7XG59XG5mdW5jdGlvbiAkZ2V0QWRqYWNlbnROb2RlKGZvY3VzLCBpc0JhY2t3YXJkKSB7XG4gIGNvbnN0IGZvY3VzT2Zmc2V0ID0gZm9jdXMub2Zmc2V0O1xuICBpZiAoZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgY29uc3QgYmxvY2sgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVFbGVtZW50KGJsb2NrLCBpc0JhY2t3YXJkLCBmb2N1c09mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmIChpc0JhY2t3YXJkICYmIGZvY3VzT2Zmc2V0ID09PSAwIHx8ICFpc0JhY2t3YXJkICYmIGZvY3VzT2Zmc2V0ID09PSBmb2N1c05vZGUuZ2V0VGV4dENvbnRlbnRTaXplKCkpIHtcbiAgICAgIGNvbnN0IHBvc3NpYmxlTm9kZSA9IGlzQmFja3dhcmQgPyBmb2N1c05vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgOiBmb2N1c05vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmIChwb3NzaWJsZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVFbGVtZW50KGZvY3VzTm9kZS5nZXRQYXJlbnRPclRocm93KCksIGlzQmFja3dhcmQsIGZvY3VzTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpICsgKGlzQmFja3dhcmQgPyAwIDogMSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvc3NpYmxlTm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc0ZpcmVmb3hDbGlwYm9hcmRFdmVudHMoZWRpdG9yKSB7XG4gIGNvbnN0IGV2ZW50ID0gZ2V0V2luZG93KGVkaXRvcikuZXZlbnQ7XG4gIGNvbnN0IGlucHV0VHlwZSA9IGV2ZW50ICYmIGV2ZW50LmlucHV0VHlwZTtcbiAgcmV0dXJuIGlucHV0VHlwZSA9PT0gJ2luc2VydEZyb21QYXN0ZScgfHwgaW5wdXRUeXBlID09PSAnaW5zZXJ0RnJvbVBhc3RlQXNRdW90YXRpb24nO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2hDb21tYW5kKGVkaXRvciwgY29tbWFuZCwgcGF5bG9hZCkge1xuICByZXR1cm4gdHJpZ2dlckNvbW1hbmRMaXN0ZW5lcnMoZWRpdG9yLCBjb21tYW5kLCBwYXlsb2FkKTtcbn1cbmZ1bmN0aW9uICR0ZXh0Q29udGVudFJlcXVpcmVzRG91YmxlTGluZWJyZWFrQXRFbmQobm9kZSkge1xuICByZXR1cm4gISRpc1Jvb3ROb2RlKG5vZGUpICYmICFub2RlLmlzTGFzdENoaWxkKCkgJiYgIW5vZGUuaXNJbmxpbmUoKTtcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRCeUtleU9yVGhyb3coZWRpdG9yLCBrZXkpIHtcbiAgY29uc3QgZWxlbWVudCA9IGVkaXRvci5fa2V5VG9ET01NYXAuZ2V0KGtleSk7XG4gIGlmIChlbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFJlY29uY2lsaWF0aW9uOiBjb3VsZCBub3QgZmluZCBET00gZWxlbWVudCBmb3Igbm9kZSBrZXkgJHtrZXl9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50RWxlbWVudChub2RlKSB7XG4gIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudEVsZW1lbnQ7XG4gIHJldHVybiBpc0RvY3VtZW50RnJhZ21lbnQocGFyZW50RWxlbWVudCkgPyBwYXJlbnRFbGVtZW50Lmhvc3QgOiBwYXJlbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0RE9NT3duZXJEb2N1bWVudCh0YXJnZXQpIHtcbiAgcmV0dXJuIGlzRE9NRG9jdW1lbnROb2RlKHRhcmdldCkgPyB0YXJnZXQgOiBpc0hUTUxFbGVtZW50KHRhcmdldCkgPyB0YXJnZXQub3duZXJEb2N1bWVudCA6IG51bGw7XG59XG5mdW5jdGlvbiBzY3JvbGxJbnRvVmlld0lmTmVlZGVkKGVkaXRvciwgc2VsZWN0aW9uUmVjdCwgcm9vdEVsZW1lbnQpIHtcbiAgY29uc3QgZG9jID0gZ2V0RE9NT3duZXJEb2N1bWVudChyb290RWxlbWVudCk7XG4gIGNvbnN0IGRlZmF1bHRWaWV3ID0gZ2V0RGVmYXVsdFZpZXcoZG9jKTtcbiAgaWYgKGRvYyA9PT0gbnVsbCB8fCBkZWZhdWx0VmlldyA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQge1xuICAgIHRvcDogY3VycmVudFRvcCxcbiAgICBib3R0b206IGN1cnJlbnRCb3R0b21cbiAgfSA9IHNlbGVjdGlvblJlY3Q7XG4gIGxldCB0YXJnZXRUb3AgPSAwO1xuICBsZXQgdGFyZ2V0Qm90dG9tID0gMDtcbiAgbGV0IGVsZW1lbnQgPSByb290RWxlbWVudDtcbiAgd2hpbGUgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICBjb25zdCBpc0JvZHlFbGVtZW50ID0gZWxlbWVudCA9PT0gZG9jLmJvZHk7XG4gICAgaWYgKGlzQm9keUVsZW1lbnQpIHtcbiAgICAgIHRhcmdldFRvcCA9IDA7XG4gICAgICB0YXJnZXRCb3R0b20gPSBnZXRXaW5kb3coZWRpdG9yKS5pbm5lckhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0YXJnZXRUb3AgPSB0YXJnZXRSZWN0LnRvcDtcbiAgICAgIHRhcmdldEJvdHRvbSA9IHRhcmdldFJlY3QuYm90dG9tO1xuICAgIH1cbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgaWYgKGN1cnJlbnRUb3AgPCB0YXJnZXRUb3ApIHtcbiAgICAgIGRpZmYgPSAtKHRhcmdldFRvcCAtIGN1cnJlbnRUb3ApO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudEJvdHRvbSA+IHRhcmdldEJvdHRvbSkge1xuICAgICAgZGlmZiA9IGN1cnJlbnRCb3R0b20gLSB0YXJnZXRCb3R0b207XG4gICAgfVxuICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICBpZiAoaXNCb2R5RWxlbWVudCkge1xuICAgICAgICAvLyBPbmx5IGhhbmRsZXMgc2Nyb2xsaW5nIG9mIFkgYXhpc1xuICAgICAgICBkZWZhdWx0Vmlldy5zY3JvbGxCeSgwLCBkaWZmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCArPSBkaWZmO1xuICAgICAgICBjb25zdCB5T2Zmc2V0ID0gZWxlbWVudC5zY3JvbGxUb3AgLSBzY3JvbGxUb3A7XG4gICAgICAgIGN1cnJlbnRUb3AgLT0geU9mZnNldDtcbiAgICAgICAgY3VycmVudEJvdHRvbSAtPSB5T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNCb2R5RWxlbWVudCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGVsZW1lbnQgPSBnZXRQYXJlbnRFbGVtZW50KGVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiAkaGFzVXBkYXRlVGFnKHRhZykge1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgcmV0dXJuIGVkaXRvci5fdXBkYXRlVGFncy5oYXModGFnKTtcbn1cbmZ1bmN0aW9uICRhZGRVcGRhdGVUYWcodGFnKSB7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCBlZGl0b3IgPSBnZXRBY3RpdmVFZGl0b3IoKTtcbiAgZWRpdG9yLl91cGRhdGVUYWdzLmFkZCh0YWcpO1xufVxuXG4vKipcbiAqIEFkZCBhIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCB1cGRhdGUuIFRoaXMgd2lsbCBydW4gYWZ0ZXIgYW55XG4gKiBgb25VcGRhdGVgIGZ1bmN0aW9uIGFscmVhZHkgc3VwcGxpZWQgdG8gYGVkaXRvci51cGRhdGUoKWAsIGFzIHdlbGwgYXMgYW55XG4gKiBmdW5jdGlvbnMgYWRkZWQgd2l0aCBwcmV2aW91cyBjYWxscyB0byBgJG9uVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gdXBkYXRlRm4gVGhlIGZ1bmN0aW9uIHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCB1cGRhdGUuXG4gKi9cbmZ1bmN0aW9uICRvblVwZGF0ZSh1cGRhdGVGbikge1xuICBlcnJvck9uUmVhZE9ubHkoKTtcbiAgY29uc3QgZWRpdG9yID0gZ2V0QWN0aXZlRWRpdG9yKCk7XG4gIGVkaXRvci5fZGVmZXJyZWQucHVzaCh1cGRhdGVGbik7XG59XG5mdW5jdGlvbiAkbWF5YmVNb3ZlQ2hpbGRyZW5TZWxlY3Rpb25Ub1BhcmVudChwYXJlbnROb2RlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNFbGVtZW50Tm9kZShwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBzZWxlY3Rpb247XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gZm9jdXMuZ2V0Tm9kZSgpO1xuICBpZiAoJGhhc0FuY2VzdG9yKGFuY2hvck5vZGUsIHBhcmVudE5vZGUpKSB7XG4gICAgYW5jaG9yLnNldChwYXJlbnROb2RlLl9fa2V5LCAwLCAnZWxlbWVudCcpO1xuICB9XG4gIGlmICgkaGFzQW5jZXN0b3IoZm9jdXNOb2RlLCBwYXJlbnROb2RlKSkge1xuICAgIGZvY3VzLnNldChwYXJlbnROb2RlLl9fa2V5LCAwLCAnZWxlbWVudCcpO1xuICB9XG4gIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiAkaGFzQW5jZXN0b3IoY2hpbGQsIHRhcmdldE5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IGNoaWxkLmdldFBhcmVudCgpO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKHBhcmVudC5pcyh0YXJnZXROb2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Vmlldyhkb21FbGVtKSB7XG4gIGNvbnN0IG93bmVyRG9jID0gZ2V0RE9NT3duZXJEb2N1bWVudChkb21FbGVtKTtcbiAgcmV0dXJuIG93bmVyRG9jID8gb3duZXJEb2MuZGVmYXVsdFZpZXcgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KGVkaXRvcikge1xuICBjb25zdCB3aW5kb3dPYmogPSBlZGl0b3IuX3dpbmRvdztcbiAgaWYgKHdpbmRvd09iaiA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgd2luZG93IG9iamVjdCBub3QgZm91bmRgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHdpbmRvd09iajtcbn1cbmZ1bmN0aW9uICRpc0lubGluZUVsZW1lbnRPckRlY29yYXRvck5vZGUobm9kZSkge1xuICByZXR1cm4gJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpIHx8ICRpc0RlY29yYXRvck5vZGUobm9kZSkgJiYgbm9kZS5pc0lubGluZSgpO1xufVxuZnVuY3Rpb24gJGdldE5lYXJlc3RSb290T3JTaGFkb3dSb290KG5vZGUpIHtcbiAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICByZXR1cm4gcGFyZW50O1xufVxuZnVuY3Rpb24gJGlzUm9vdE9yU2hhZG93Um9vdChub2RlKSB7XG4gIHJldHVybiAkaXNSb290Tm9kZShub2RlKSB8fCAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmlzU2hhZG93Um9vdCgpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzaGFsbG93IGNsb25lIG9mIG5vZGUgd2l0aCBhIG5ldyBrZXkuIEFsbCBwcm9wZXJ0aWVzIG9mIHRoZSBub2RlXG4gKiB3aWxsIGJlIGNvcGllZCB0byB0aGUgbmV3IG5vZGUgKGJ5IGBjbG9uZWAgYW5kIHRoZW4gYGFmdGVyQ2xvbmVGcm9tYCksXG4gKiBleGNlcHQgdGhvc2UgcmVsYXRlZCB0byBwYXJlbnQvc2libGluZy9jaGlsZFxuICogcmVsYXRpb25zaGlwcyBpbiB0aGUgYEVkaXRvclN0YXRlYC4gVGhpcyBtZWFucyB0aGF0IHRoZSBjb3B5IG11c3QgYmVcbiAqIHNlcGFyYXRlbHkgYWRkZWQgdG8gdGhlIGRvY3VtZW50LCBhbmQgaXQgd2lsbCBub3QgaGF2ZSBhbnkgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjb3BpZWQuXG4gKiBAcmV0dXJucyBUaGUgY29weSBvZiB0aGUgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGNvcHlOb2RlKG5vZGUpIHtcbiAgY29uc3QgY29weSA9IG5vZGUuY29uc3RydWN0b3IuY2xvbmUobm9kZSk7XG4gICRzZXROb2RlS2V5KGNvcHksIG51bGwpO1xuICBjb3B5LmFmdGVyQ2xvbmVGcm9tKG5vZGUpO1xuICByZXR1cm4gY29weTtcbn1cbmZ1bmN0aW9uICRhcHBseU5vZGVSZXBsYWNlbWVudChub2RlKSB7XG4gIGNvbnN0IGVkaXRvciA9IGdldEFjdGl2ZUVkaXRvcigpO1xuICBjb25zdCBub2RlVHlwZSA9IG5vZGUuZ2V0VHlwZSgpO1xuICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IGdldFJlZ2lzdGVyZWROb2RlKGVkaXRvciwgbm9kZVR5cGUpO1xuICBpZiAoIShyZWdpc3RlcmVkTm9kZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGFwcGx5Tm9kZVJlcGxhY2VtZW50IG5vZGUgJHtub2RlLmNvbnN0cnVjdG9yLm5hbWV9IHdpdGggdHlwZSAke25vZGVUeXBlfSBtdXN0IGJlIHJlZ2lzdGVyZWQgdG8gdGhlIGVkaXRvci4gWW91IGNhbiBkbyB0aGlzIGJ5IHBhc3NpbmcgdGhlIG5vZGUgY2xhc3MgdmlhIHRoZSBcIm5vZGVzXCIgYXJyYXkgaW4gdGhlIGVkaXRvciBjb25maWcuYCk7XG4gIH1cbiAgY29uc3Qge1xuICAgIHJlcGxhY2UsXG4gICAgcmVwbGFjZVdpdGhLbGFzc1xuICB9ID0gcmVnaXN0ZXJlZE5vZGU7XG4gIGlmIChyZXBsYWNlICE9PSBudWxsKSB7XG4gICAgY29uc3QgcmVwbGFjZW1lbnROb2RlID0gcmVwbGFjZShub2RlKTtcbiAgICBjb25zdCByZXBsYWNlbWVudE5vZGVLbGFzcyA9IHJlcGxhY2VtZW50Tm9kZS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAocmVwbGFjZVdpdGhLbGFzcyAhPT0gbnVsbCkge1xuICAgICAgaWYgKCEocmVwbGFjZW1lbnROb2RlIGluc3RhbmNlb2YgcmVwbGFjZVdpdGhLbGFzcykpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkYXBwbHlOb2RlUmVwbGFjZW1lbnQgZmFpbGVkLiBFeHBlY3RlZCByZXBsYWNlbWVudCBub2RlIHRvIGJlIGFuIGluc3RhbmNlIG9mICR7cmVwbGFjZVdpdGhLbGFzcy5uYW1lfSB3aXRoIHR5cGUgJHtyZXBsYWNlV2l0aEtsYXNzLmdldFR5cGUoKX0gYnV0IHJldHVybmVkICR7cmVwbGFjZW1lbnROb2RlS2xhc3MubmFtZX0gd2l0aCB0eXBlICR7cmVwbGFjZW1lbnROb2RlS2xhc3MuZ2V0VHlwZSgpfSBmcm9tIG9yaWdpbmFsIG5vZGUgJHtub2RlLmNvbnN0cnVjdG9yLm5hbWV9IHdpdGggdHlwZSAke25vZGVUeXBlfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIShyZXBsYWNlbWVudE5vZGUgaW5zdGFuY2VvZiBub2RlLmNvbnN0cnVjdG9yICYmIHJlcGxhY2VtZW50Tm9kZUtsYXNzICE9PSBub2RlLmNvbnN0cnVjdG9yKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRhcHBseU5vZGVSZXBsYWNlbWVudCBmYWlsZWQuIEVuc3VyZSByZXBsYWNlbWVudCBub2RlICR7cmVwbGFjZW1lbnROb2RlS2xhc3MubmFtZX0gd2l0aCB0eXBlICR7cmVwbGFjZW1lbnROb2RlS2xhc3MuZ2V0VHlwZSgpfSBpcyBhIHN1YmNsYXNzIG9mIHRoZSBvcmlnaW5hbCBub2RlICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSB3aXRoIHR5cGUgJHtub2RlVHlwZX0uYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghKHJlcGxhY2VtZW50Tm9kZS5fX2tleSAhPT0gbm9kZS5fX2tleSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGFwcGx5Tm9kZVJlcGxhY2VtZW50IGZhaWxlZC4gRW5zdXJlIHRoYXQgdGhlIGtleSBhcmd1bWVudCBpcyAqbm90KiB1c2VkIGluIHlvdXIgcmVwbGFjZSBmdW5jdGlvbiAoZnJvbSBub2RlICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSB3aXRoIHR5cGUgJHtub2RlVHlwZX0gdG8gbm9kZSAke3JlcGxhY2VtZW50Tm9kZUtsYXNzLm5hbWV9IHdpdGggdHlwZSAke3JlcGxhY2VtZW50Tm9kZUtsYXNzLmdldFR5cGUoKX0pLCBOb2RlIGtleXMgbXVzdCBuZXZlciBiZSByZS11c2VkIGV4Y2VwdCBieSB0aGUgc3RhdGljIGNsb25lIG1ldGhvZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxhY2VtZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGVycm9yT25JbnNlcnRUZXh0Tm9kZU9uUm9vdChub2RlLCBpbnNlcnROb2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlLmdldFBhcmVudCgpO1xuICBpZiAoJGlzUm9vdE5vZGUocGFyZW50Tm9kZSkgJiYgISRpc0VsZW1lbnROb2RlKGluc2VydE5vZGUpICYmICEkaXNEZWNvcmF0b3JOb2RlKGluc2VydE5vZGUpKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBPbmx5IGVsZW1lbnQgb3IgZGVjb3JhdG9yIG5vZGVzIGNhbiBiZSBpbnNlcnRlZCBpbiB0byB0aGUgcm9vdCBub2RlYCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkZ2V0Tm9kZUJ5S2V5T3JUaHJvdyhrZXkpIHtcbiAgY29uc3Qgbm9kZSA9ICRnZXROb2RlQnlLZXkoa2V5KTtcbiAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgd2l0aCBrZXkgJHtrZXl9IHRvIGV4aXN0IGJ1dCBpdCdzIG5vdCBpbiB0aGUgbm9kZU1hcC5gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBjcmVhdGVCbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yQ29uZmlnKSB7XG4gIGNvbnN0IHRoZW1lID0gZWRpdG9yQ29uZmlnLnRoZW1lO1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsZW1lbnQuY29udGVudEVkaXRhYmxlID0gJ2ZhbHNlJztcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1jdXJzb3InLCAndHJ1ZScpO1xuICBsZXQgYmxvY2tDdXJzb3JUaGVtZSA9IHRoZW1lLmJsb2NrQ3Vyc29yO1xuICBpZiAoYmxvY2tDdXJzb3JUaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBibG9ja0N1cnNvclRoZW1lID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgY2xhc3NOYW1lc0FyciA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMoYmxvY2tDdXJzb3JUaGVtZSk7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlbnRpb25hbFxuICAgICAgYmxvY2tDdXJzb3JUaGVtZSA9IHRoZW1lLmJsb2NrQ3Vyc29yID0gY2xhc3NOYW1lc0FycjtcbiAgICB9XG4gICAgaWYgKGJsb2NrQ3Vyc29yVGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmJsb2NrQ3Vyc29yVGhlbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cbmZ1bmN0aW9uIG5lZWRzQmxvY2tDdXJzb3Iobm9kZSkge1xuICByZXR1cm4gKCRpc0RlY29yYXRvck5vZGUobm9kZSkgfHwgJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuY2FuQmVFbXB0eSgpKSAmJiAhbm9kZS5pc0lubGluZSgpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRE9NQmxvY2tDdXJzb3JFbGVtZW50KGJsb2NrQ3Vyc29yRWxlbWVudCwgZWRpdG9yLCByb290RWxlbWVudCkge1xuICByb290RWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY2FyZXQtY29sb3InKTtcbiAgZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBudWxsO1xuICBjb25zdCBwYXJlbnRFbGVtZW50ID0gYmxvY2tDdXJzb3JFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIGlmIChwYXJlbnRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChibG9ja0N1cnNvckVsZW1lbnQpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVET01CbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLCByb290RWxlbWVudCwgbmV4dFNlbGVjdGlvbikge1xuICBsZXQgYmxvY2tDdXJzb3JFbGVtZW50ID0gZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQ7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihuZXh0U2VsZWN0aW9uKSAmJiBuZXh0U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgbmV4dFNlbGVjdGlvbi5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgY29uc3QgYW5jaG9yID0gbmV4dFNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZWxlbWVudE5vZGUgPSBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IG9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgY29uc3QgZWxlbWVudE5vZGVTaXplID0gZWxlbWVudE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgbGV0IGlzQmxvY2tDdXJzb3IgPSBmYWxzZTtcbiAgICBsZXQgaW5zZXJ0QmVmb3JlRWxlbWVudCA9IG51bGw7XG4gICAgaWYgKG9mZnNldCA9PT0gZWxlbWVudE5vZGVTaXplKSB7XG4gICAgICBjb25zdCBjaGlsZCA9IGVsZW1lbnROb2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQgLSAxKTtcbiAgICAgIGlmIChuZWVkc0Jsb2NrQ3Vyc29yKGNoaWxkKSkge1xuICAgICAgICBpc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBlbGVtZW50Tm9kZS5nZXRDaGlsZEF0SW5kZXgob2Zmc2V0KTtcbiAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCAmJiBuZWVkc0Jsb2NrQ3Vyc29yKGNoaWxkKSkge1xuICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgIGlmIChzaWJsaW5nID09PSBudWxsIHx8IG5lZWRzQmxvY2tDdXJzb3Ioc2libGluZykpIHtcbiAgICAgICAgICBpc0Jsb2NrQ3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgICBpbnNlcnRCZWZvcmVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShjaGlsZC5fX2tleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQmxvY2tDdXJzb3IpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGVsZW1lbnROb2RlLl9fa2V5KTtcbiAgICAgIGlmIChibG9ja0N1cnNvckVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgZWRpdG9yLl9ibG9ja0N1cnNvckVsZW1lbnQgPSBibG9ja0N1cnNvckVsZW1lbnQgPSBjcmVhdGVCbG9ja0N1cnNvckVsZW1lbnQoZWRpdG9yLl9jb25maWcpO1xuICAgICAgfVxuICAgICAgcm9vdEVsZW1lbnQuc3R5bGUuY2FyZXRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgICBpZiAoaW5zZXJ0QmVmb3JlRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICBlbGVtZW50RE9NLmFwcGVuZENoaWxkKGJsb2NrQ3Vyc29yRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50RE9NLmluc2VydEJlZm9yZShibG9ja0N1cnNvckVsZW1lbnQsIGluc2VydEJlZm9yZUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvLyBSZW1vdmUgY3Vyc29yXG4gIGlmIChibG9ja0N1cnNvckVsZW1lbnQgIT09IG51bGwpIHtcbiAgICByZW1vdmVET01CbG9ja0N1cnNvckVsZW1lbnQoYmxvY2tDdXJzb3JFbGVtZW50LCBlZGl0b3IsIHJvb3RFbGVtZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlbGVjdGlvbiBmb3IgdGhlIGdpdmVuIHdpbmRvdywgb3IgdGhlIGdsb2JhbCB3aW5kb3cgaWYgbnVsbC5cbiAqIFdpbGwgcmV0dXJuIG51bGwgaWYge0BsaW5rIENBTl9VU0VfRE9NfSBpcyBmYWxzZS5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0V2luZG93IFRoZSB3aW5kb3cgdG8gZ2V0IHRoZSBzZWxlY3Rpb24gZnJvbVxuICogQHJldHVybnMgYSBTZWxlY3Rpb24gb3IgbnVsbFxuICovXG5mdW5jdGlvbiBnZXRET01TZWxlY3Rpb24odGFyZ2V0V2luZG93KSB7XG4gIHJldHVybiAhQ0FOX1VTRV9ET00gPyBudWxsIDogKHRhcmdldFdpbmRvdyB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNlbGVjdGlvbiBmb3IgdGhlIGRlZmF1bHRWaWV3IG9mIHRoZSBvd25lckRvY3VtZW50IG9mIGdpdmVuIEV2ZW50VGFyZ2V0LlxuICpcbiAqIEBwYXJhbSBldmVudFRhcmdldCBUaGUgbm9kZSB0byBnZXQgdGhlIHNlbGVjdGlvbiBmcm9tXG4gKiBAcmV0dXJucyBhIFNlbGVjdGlvbiBvciBudWxsXG4gKi9cbmZ1bmN0aW9uIGdldERPTVNlbGVjdGlvbkZyb21UYXJnZXQoZXZlbnRUYXJnZXQpIHtcbiAgY29uc3QgZGVmYXVsdFZpZXcgPSBnZXREZWZhdWx0VmlldyhldmVudFRhcmdldCk7XG4gIHJldHVybiBkZWZhdWx0VmlldyA/IGRlZmF1bHRWaWV3LmdldFNlbGVjdGlvbigpIDogbnVsbDtcbn1cbmZ1bmN0aW9uICRzcGxpdE5vZGUobm9kZSwgb2Zmc2V0KSB7XG4gIGxldCBzdGFydE5vZGUgPSBub2RlLmdldENoaWxkQXRJbmRleChvZmZzZXQpO1xuICBpZiAoc3RhcnROb2RlID09IG51bGwpIHtcbiAgICBzdGFydE5vZGUgPSBub2RlO1xuICB9XG4gIGlmICghISRpc1Jvb3RPclNoYWRvd1Jvb3Qobm9kZSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYENhbiBub3QgY2FsbCAkc3BsaXROb2RlKCkgb24gcm9vdCBlbGVtZW50YCk7XG4gIH1cbiAgY29uc3QgcmVjdXJzZSA9IGN1cnJlbnROb2RlID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gICAgY29uc3QgaXNQYXJlbnRSb290ID0gJGlzUm9vdE9yU2hhZG93Um9vdChwYXJlbnQpO1xuICAgIC8vIFRoZSBub2RlIHdlIHN0YXJ0IHNwbGl0IGZyb20gKGxlYWYpIGlzIG1vdmVkLCBidXQgaXRzIHJlY3Vyc2l2ZVxuICAgIC8vIHBhcmVudHMgYXJlIGNvcGllZCB0byBjcmVhdGUgc2VwYXJhdGUgdHJlZVxuICAgIGNvbnN0IG5vZGVUb01vdmUgPSBjdXJyZW50Tm9kZSA9PT0gc3RhcnROb2RlICYmICFpc1BhcmVudFJvb3QgPyBjdXJyZW50Tm9kZSA6ICRjb3B5Tm9kZShjdXJyZW50Tm9kZSk7XG4gICAgaWYgKGlzUGFyZW50Um9vdCkge1xuICAgICAgaWYgKCEoJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpICYmICRpc0VsZW1lbnROb2RlKG5vZGVUb01vdmUpKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYENoaWxkcmVuIG9mIGEgcm9vdCBtdXN0IGJlIEVsZW1lbnROb2RlYCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50Tm9kZS5pbnNlcnRBZnRlcihub2RlVG9Nb3ZlKTtcbiAgICAgIHJldHVybiBbY3VycmVudE5vZGUsIG5vZGVUb01vdmUsIG5vZGVUb01vdmVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbGVmdFRyZWUsIHJpZ2h0VHJlZSwgbmV3UGFyZW50XSA9IHJlY3Vyc2UocGFyZW50KTtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5ncyA9IGN1cnJlbnROb2RlLmdldE5leHRTaWJsaW5ncygpO1xuICAgICAgbmV3UGFyZW50LmFwcGVuZChub2RlVG9Nb3ZlLCAuLi5uZXh0U2libGluZ3MpO1xuICAgICAgcmV0dXJuIFtsZWZ0VHJlZSwgcmlnaHRUcmVlLCBub2RlVG9Nb3ZlXTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IFtsZWZ0VHJlZSwgcmlnaHRUcmVlXSA9IHJlY3Vyc2Uoc3RhcnROb2RlKTtcbiAgcmV0dXJuIFtsZWZ0VHJlZSwgcmlnaHRUcmVlXTtcbn1cbmZ1bmN0aW9uICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBmaW5kRm4pIHtcbiAgbGV0IGN1cnIgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChjdXJyICE9PSAkZ2V0Um9vdCgpICYmIGN1cnIgIT0gbnVsbCkge1xuICAgIGlmIChmaW5kRm4oY3VycikpIHtcbiAgICAgIHJldHVybiBjdXJyO1xuICAgIH1cbiAgICBjdXJyID0gY3Vyci5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geCAtIFRoZSBlbGVtZW50IGJlaW5nIHRlc3RlZFxuICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIHggaXMgYW4gSFRNTCBhbmNob3IgdGFnLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuZnVuY3Rpb24gaXNIVE1MQW5jaG9yRWxlbWVudCh4KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KHgpICYmIHgudGFnTmFtZSA9PT0gJ0EnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB4IC0gVGhlIGVsZW1lbnQgYmVpbmcgdGVzdGVkXG4gKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgeCBpcyBhbiBIVE1MIGVsZW1lbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNIVE1MRWxlbWVudCh4KSB7XG4gIHJldHVybiBpc0RPTU5vZGUoeCkgJiYgeC5ub2RlVHlwZSA9PT0gRE9NX0VMRU1FTlRfVFlQRTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geCAtIFRoZSBlbGVtZW50IGJlaW5nIHRlc3RlZFxuICogQHJldHVybnMgUmV0dXJucyB0cnVlIGlmIHggaXMgYSBET00gTm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0RPTU5vZGUoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwgJiYgJ25vZGVUeXBlJyBpbiB4ICYmIHR5cGVvZiB4Lm5vZGVUeXBlID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBAcGFyYW0geCAtIFRoZSBlbGVtZW50IGJlaW5nIHRlc3RpbmdcbiAqIEByZXR1cm5zIFJldHVybnMgdHJ1ZSBpZiB4IGlzIGEgZG9jdW1lbnQgZnJhZ21lbnQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNEb2N1bWVudEZyYWdtZW50KHgpIHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh4KSAmJiB4Lm5vZGVUeXBlID09PSBET01fRE9DVU1FTlRfRlJBR01FTlRfVFlQRTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIG5vZGUgLSB0aGUgRG9tIE5vZGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIGlmIHRoZSBEb20gTm9kZSBpcyBhbiBpbmxpbmUgbm9kZVxuICovXG5mdW5jdGlvbiBpc0lubGluZURvbU5vZGUobm9kZSkge1xuICBjb25zdCBpbmxpbmVOb2RlcyA9IG5ldyBSZWdFeHAoL14oYXxhYmJyfGFjcm9ueW18YnxjaXRlfGNvZGV8ZGVsfGVtfGl8aW5zfGtiZHxsYWJlbHxtYXJrfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNwYW58c3Ryb25nfHN1YnxzdXB8dGltZXx1fHR0fHZhcnwjdGV4dCkkLywgJ2knKTtcbiAgcmV0dXJuIG5vZGUubm9kZU5hbWUubWF0Y2goaW5saW5lTm9kZXMpICE9PSBudWxsO1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gbm9kZSAtIHRoZSBEb20gTm9kZSB0byBjaGVja1xuICogQHJldHVybnMgaWYgdGhlIERvbSBOb2RlIGlzIGEgYmxvY2sgbm9kZVxuICovXG5mdW5jdGlvbiBpc0Jsb2NrRG9tTm9kZShub2RlKSB7XG4gIGNvbnN0IGJsb2NrTm9kZXMgPSBuZXcgUmVnRXhwKC9eKGFkZHJlc3N8YXJ0aWNsZXxhc2lkZXxibG9ja3F1b3RlfGNhbnZhc3xkZHxkaXZ8ZGx8ZHR8ZmllbGRzZXR8ZmlnY2FwdGlvbnxmaWd1cmV8Zm9vdGVyfGZvcm18aDF8aDJ8aDN8aDR8aDV8aDZ8aGVhZGVyfGhyfGxpfG1haW58bmF2fG5vc2NyaXB0fG9sfHB8cHJlfHNlY3Rpb258dGFibGV8dGR8dGZvb3R8dWx8dmlkZW8pJC8sICdpJyk7XG4gIHJldHVybiBub2RlLm5vZGVOYW1lLm1hdGNoKGJsb2NrTm9kZXMpICE9PSBudWxsO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgZm9yIGludGVybmFsIHVzZSBvZiB0aGUgbGlicmFyeS5cbiAqIFBsZWFzZSBkbyBub3QgdXNlIGl0IGFzIGl0IG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBmb3IgYSBEZWNvcmF0b3JOb2RlIHRoYXQgaXMgbm90IGlubGluZSBPUlxuICogYW4gRWxlbWVudE5vZGUgdGhhdCBpczpcbiAqIC0gbm90IGEgcm9vdCBvciBzaGFkb3cgcm9vdFxuICogLSBub3QgaW5saW5lXG4gKiAtIGNhbid0IGJlIGVtcHR5XG4gKiAtIGhhcyBubyBjaGlsZHJlbiBvciBhbiBpbmxpbmUgZmlyc3QgY2hpbGRcbiAqL1xuZnVuY3Rpb24gSU5URVJOQUxfJGlzQmxvY2sobm9kZSkge1xuICBpZiAoJGlzRGVjb3JhdG9yTm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSB8fCAkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSBub2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgY29uc3QgaXNMZWFmRWxlbWVudCA9IGZpcnN0Q2hpbGQgPT09IG51bGwgfHwgJGlzTGluZUJyZWFrTm9kZShmaXJzdENoaWxkKSB8fCAkaXNUZXh0Tm9kZShmaXJzdENoaWxkKSB8fCBmaXJzdENoaWxkLmlzSW5saW5lKCk7XG4gIHJldHVybiAhbm9kZS5pc0lubGluZSgpICYmIG5vZGUuY2FuQmVFbXB0eSgpICE9PSBmYWxzZSAmJiBpc0xlYWZFbGVtZW50O1xufVxuZnVuY3Rpb24gJGdldEFuY2VzdG9yKG5vZGUsIHByZWRpY2F0ZSkge1xuICBsZXQgcGFyZW50ID0gbm9kZTtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuZ2V0UGFyZW50KCkgIT09IG51bGwgJiYgIXByZWRpY2F0ZShwYXJlbnQpKSB7XG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKTtcbiAgfVxuICByZXR1cm4gcHJlZGljYXRlKHBhcmVudCkgPyBwYXJlbnQgOiBudWxsO1xufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGFjY2Vzc2luZyBjdXJyZW50IGFjdGl2ZSBlZGl0b3IgaW5zdGFuY2UuXG4gKiBAcmV0dXJucyBDdXJyZW50IGFjdGl2ZSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gJGdldEVkaXRvcigpIHtcbiAgcmV0dXJuIGdldEFjdGl2ZUVkaXRvcigpO1xufVxuXG4vKiogQGludGVybmFsICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBDb21wdXRlIGEgY2FjaGVkIE1hcCBvZiBub2RlIHR5cGUgdG8gbm9kZXMgZm9yIGEgZnJvemVuIEVkaXRvclN0YXRlXG4gKi9cbmNvbnN0IGNhY2hlZE5vZGVNYXBzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IEVNUFRZX1RZUEVfVE9fTk9ERV9NQVAgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXRDYWNoZWRUeXBlVG9Ob2RlTWFwKGVkaXRvclN0YXRlKSB7XG4gIC8vIElmIHRoaXMgaXMgYSBuZXcgRWRpdG9yIGl0IG1heSBoYXZlIGEgd3JpdGFibGUgdGhpcy5fZWRpdG9yU3RhdGVcbiAgLy8gd2l0aCBvbmx5IGEgJ3Jvb3QnIGVudHJ5LlxuICBpZiAoIWVkaXRvclN0YXRlLl9yZWFkT25seSAmJiBlZGl0b3JTdGF0ZS5pc0VtcHR5KCkpIHtcbiAgICByZXR1cm4gRU1QVFlfVFlQRV9UT19OT0RFX01BUDtcbiAgfVxuICBpZiAoIWVkaXRvclN0YXRlLl9yZWFkT25seSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0Q2FjaGVkVHlwZVRvTm9kZU1hcCBjYWxsZWQgd2l0aCBhIHdyaXRhYmxlIEVkaXRvclN0YXRlYCk7XG4gIH1cbiAgbGV0IHR5cGVUb05vZGVNYXAgPSBjYWNoZWROb2RlTWFwcy5nZXQoZWRpdG9yU3RhdGUpO1xuICBpZiAoIXR5cGVUb05vZGVNYXApIHtcbiAgICB0eXBlVG9Ob2RlTWFwID0gY29tcHV0ZVR5cGVUb05vZGVNYXAoZWRpdG9yU3RhdGUpO1xuICAgIGNhY2hlZE5vZGVNYXBzLnNldChlZGl0b3JTdGF0ZSwgdHlwZVRvTm9kZU1hcCk7XG4gIH1cbiAgcmV0dXJuIHR5cGVUb05vZGVNYXA7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKiBDb21wdXRlIGEgTWFwIG9mIG5vZGUgdHlwZSB0byBub2RlcyBmb3IgYW4gRWRpdG9yU3RhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVR5cGVUb05vZGVNYXAoZWRpdG9yU3RhdGUpIHtcbiAgY29uc3QgdHlwZVRvTm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBbbm9kZUtleSwgbm9kZV0gb2YgZWRpdG9yU3RhdGUuX25vZGVNYXApIHtcbiAgICBjb25zdCBub2RlVHlwZSA9IG5vZGUuX190eXBlO1xuICAgIGxldCBub2RlTWFwID0gdHlwZVRvTm9kZU1hcC5nZXQobm9kZVR5cGUpO1xuICAgIGlmICghbm9kZU1hcCkge1xuICAgICAgbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIHR5cGVUb05vZGVNYXAuc2V0KG5vZGVUeXBlLCBub2RlTWFwKTtcbiAgICB9XG4gICAgbm9kZU1hcC5zZXQobm9kZUtleSwgbm9kZSk7XG4gIH1cbiAgcmV0dXJuIHR5cGVUb05vZGVNYXA7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGNsb25lIG9mIGEgbm9kZSB1c2luZyBgbm9kZS5jb25zdHJ1Y3Rvci5jbG9uZSgpYCBmb2xsb3dlZCBieVxuICogYGNsb25lLmFmdGVyQ2xvbmVGcm9tKG5vZGUpYC4gVGhlIHJlc3VsdGluZyBjbG9uZSBtdXN0IGhhdmUgdGhlIHNhbWUga2V5LFxuICogcGFyZW50L25leHQvcHJldiBwb2ludGVycywgYW5kIG90aGVyIHByb3BlcnRpZXMgdGhhdCBhcmUgbm90IHNldCBieVxuICogYG5vZGUuY29uc3RydWN0b3IuY2xvbmVgIChmb3JtYXQsIHN0eWxlLCBldGMuKS4gVGhpcyBpcyBwcmltYXJpbHkgdXNlZCBieVxuICoge0BsaW5rIExleGljYWxOb2RlLmdldFdyaXRhYmxlfSB0byBjcmVhdGUgYSB3cml0YWJsZSB2ZXJzaW9uIG9mIGFuXG4gKiBleGlzdGluZyBub2RlLiBUaGUgY2xvbmUgaXMgdGhlIHNhbWUgbG9naWNhbCBub2RlIGFzIHRoZSBvcmlnaW5hbCBub2RlLFxuICogZG8gbm90IHRyeSBhbmQgdXNlIHRoaXMgZnVuY3Rpb24gdG8gZHVwbGljYXRlIG9yIGNvcHkgYW4gZXhpc3Rpbmcgbm9kZS5cbiAqXG4gKiBEb2VzIG5vdCBtdXRhdGUgdGhlIEVkaXRvclN0YXRlLlxuICogQHBhcmFtIGxhdGVzdE5vZGUgLSBUaGUgbm9kZSB0byBiZSBjbG9uZWQuXG4gKiBAcmV0dXJucyBUaGUgY2xvbmUgb2YgdGhlIG5vZGUuXG4gKi9cbmZ1bmN0aW9uICRjbG9uZVdpdGhQcm9wZXJ0aWVzKGxhdGVzdE5vZGUpIHtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBsYXRlc3ROb2RlLmNvbnN0cnVjdG9yO1xuICBjb25zdCBtdXRhYmxlTm9kZSA9IGNvbnN0cnVjdG9yLmNsb25lKGxhdGVzdE5vZGUpO1xuICBtdXRhYmxlTm9kZS5hZnRlckNsb25lRnJvbShsYXRlc3ROb2RlKTtcbiAge1xuICAgIGlmICghKG11dGFibGVOb2RlLl9fa2V5ID09PSBsYXRlc3ROb2RlLl9fa2V5KSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkY2xvbmVXaXRoUHJvcGVydGllczogJHtjb25zdHJ1Y3Rvci5uYW1lfS5jbG9uZShub2RlKSAod2l0aCB0eXBlICcke2NvbnN0cnVjdG9yLmdldFR5cGUoKX0nKSBkaWQgbm90IHJldHVybiBhIG5vZGUgd2l0aCB0aGUgc2FtZSBrZXksIG1ha2Ugc3VyZSB0byBzcGVjaWZ5IG5vZGUuX19rZXkgYXMgdGhlIGxhc3QgYXJndW1lbnQgdG8gdGhlIGNvbnN0cnVjdG9yYCk7XG4gICAgfVxuICAgIGlmICghKG11dGFibGVOb2RlLl9fcGFyZW50ID09PSBsYXRlc3ROb2RlLl9fcGFyZW50ICYmIG11dGFibGVOb2RlLl9fbmV4dCA9PT0gbGF0ZXN0Tm9kZS5fX25leHQgJiYgbXV0YWJsZU5vZGUuX19wcmV2ID09PSBsYXRlc3ROb2RlLl9fcHJldikpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGNsb25lV2l0aFByb3BlcnRpZXM6ICR7Y29uc3RydWN0b3IubmFtZX0uY2xvbmUobm9kZSkgKHdpdGggdHlwZSAnJHtjb25zdHJ1Y3Rvci5nZXRUeXBlKCl9Jykgb3ZlcnJvZGUgYWZ0ZXJDbG9uZUZyb20gYnV0IGRpZCBub3QgY2FsbCBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSlgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG11dGFibGVOb2RlO1xufVxuZnVuY3Rpb24gc2V0Tm9kZUluZGVudEZyb21ET00oZWxlbWVudERvbSwgZWxlbWVudE5vZGUpIHtcbiAgY29uc3QgaW5kZW50U2l6ZSA9IHBhcnNlSW50KGVsZW1lbnREb20uc3R5bGUucGFkZGluZ0lubGluZVN0YXJ0LCAxMCkgfHwgMDtcbiAgY29uc3QgaW5kZW50ID0gTWF0aC5yb3VuZChpbmRlbnRTaXplIC8gNDApO1xuICBlbGVtZW50Tm9kZS5zZXRJbmRlbnQoaW5kZW50KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBNYXJrIHRoaXMgbm9kZSBhcyB1bm1hbmFnZWQgYnkgbGV4aWNhbCdzIG11dGF0aW9uIG9ic2VydmVyIGxpa2VcbiAqIGRlY29yYXRvciBub2Rlc1xuICovXG5mdW5jdGlvbiBzZXRET01Vbm1hbmFnZWQoZWxlbWVudERvbSkge1xuICBjb25zdCBlbCA9IGVsZW1lbnREb207XG4gIGVsLl9fbGV4aWNhbFVubWFuYWdlZCA9IHRydWU7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKlxuICogVHJ1ZSBpZiB0aGlzIERPTSBub2RlIHdhcyBtYXJrZWQgd2l0aCB7QGxpbmsgc2V0RE9NVW5tYW5hZ2VkfVxuICovXG5mdW5jdGlvbiBpc0RPTVVubWFuYWdlZChlbGVtZW50RG9tKSB7XG4gIGNvbnN0IGVsID0gZWxlbWVudERvbTtcbiAgcmV0dXJuIGVsLl9fbGV4aWNhbFVubWFuYWdlZCA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBPYmplY3QuaGFzT3duIHBvbnlmaWxsXG4gKi9cbmZ1bmN0aW9uIGhhc093bihvLCBrKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgayk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc093blN0YXRpY01ldGhvZChrbGFzcywgaykge1xuICByZXR1cm4gaGFzT3duKGtsYXNzLCBrKSAmJiBrbGFzc1trXSAhPT0gTGV4aWNhbE5vZGVba107XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc093bkV4cG9ydERPTShrbGFzcykge1xuICByZXR1cm4gaGFzT3duKGtsYXNzLnByb3RvdHlwZSwgJ2V4cG9ydERPTScpO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBpc0Fic3RyYWN0Tm9kZUNsYXNzKGtsYXNzKSB7XG4gIHJldHVybiBrbGFzcyA9PT0gRGVjb3JhdG9yTm9kZSB8fCBrbGFzcyA9PT0gRWxlbWVudE5vZGUgfHwga2xhc3MgPT09IExleGljYWxOb2RlO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBnZXRTdGF0aWNOb2RlQ29uZmlnKGtsYXNzKSB7XG4gIGNvbnN0IG5vZGVDb25maWdSZWNvcmQgPSBQUk9UT1RZUEVfQ09ORklHX01FVEhPRCBpbiBrbGFzcy5wcm90b3R5cGUgPyBrbGFzcy5wcm90b3R5cGVbUFJPVE9UWVBFX0NPTkZJR19NRVRIT0RdKCkgOiB1bmRlZmluZWQ7XG4gIGNvbnN0IGlzQWJzdHJhY3QgPSBpc0Fic3RyYWN0Tm9kZUNsYXNzKGtsYXNzKTtcbiAgY29uc3Qgbm9kZVR5cGUgPSAhaXNBYnN0cmFjdCAmJiBoYXNPd25TdGF0aWNNZXRob2Qoa2xhc3MsICdnZXRUeXBlJykgPyBrbGFzcy5nZXRUeXBlKCkgOiB1bmRlZmluZWQ7XG4gIGxldCBvd25Ob2RlQ29uZmlnO1xuICBsZXQgb3duTm9kZVR5cGUgPSBub2RlVHlwZTtcbiAgaWYgKG5vZGVDb25maWdSZWNvcmQpIHtcbiAgICBpZiAobm9kZVR5cGUpIHtcbiAgICAgIG93bk5vZGVDb25maWcgPSBub2RlQ29uZmlnUmVjb3JkW25vZGVUeXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMobm9kZUNvbmZpZ1JlY29yZCkpIHtcbiAgICAgICAgb3duTm9kZVR5cGUgPSBrO1xuICAgICAgICBvd25Ob2RlQ29uZmlnID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc0Fic3RyYWN0ICYmIG93bk5vZGVUeXBlKSB7XG4gICAgaWYgKCFoYXNPd25TdGF0aWNNZXRob2Qoa2xhc3MsICdnZXRUeXBlJykpIHtcbiAgICAgIGtsYXNzLmdldFR5cGUgPSAoKSA9PiBvd25Ob2RlVHlwZTtcbiAgICB9XG4gICAgaWYgKCFoYXNPd25TdGF0aWNNZXRob2Qoa2xhc3MsICdjbG9uZScpKSB7XG4gICAgICAvLyBUZXh0Tm9kZS5sZW5ndGggPiAwIHdpbGwgb25seSBiZSB0cnVlIGlmIHRoZSBjb21waWxlciBvdXRwdXRcbiAgICAgIC8vIGlzIG5vdCBFUzYgY29tcGxpYW50LCBpbiB3aGljaCBjYXNlIHdlIGNhbiBub3QgcHJvdmlkZSB0aGlzXG4gICAgICAvLyB3YXJuaW5nXG4gICAgICBpZiAoVGV4dE5vZGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICghKGtsYXNzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCR7a2xhc3MubmFtZX0gKHR5cGUgJHtvd25Ob2RlVHlwZX0pIG11c3QgaW1wbGVtZW50IGEgc3RhdGljIGNsb25lIG1ldGhvZCBzaW5jZSBpdHMgY29uc3RydWN0b3IgaGFzICR7U3RyaW5nKGtsYXNzLmxlbmd0aCl9IHJlcXVpcmVkIGFyZ3VtZW50cyAoZXhwZWN0aW5nIDApLiBVc2UgYW4gZXhwbGljaXQgZGVmYXVsdCBpbiB0aGUgZmlyc3QgYXJndW1lbnQgb2YgeW91ciBjb25zdHJ1Y3Rvcihwcm9wOiBUPVgsIG5vZGVLZXk/OiBOb2RlS2V5KS5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAga2xhc3MuY2xvbmUgPSBwcmV2Tm9kZSA9PiB7XG4gICAgICAgIHNldFBlbmRpbmdOb2RlVG9DbG9uZShwcmV2Tm9kZSk7XG4gICAgICAgIHJldHVybiBuZXcga2xhc3MoKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghaGFzT3duU3RhdGljTWV0aG9kKGtsYXNzLCAnaW1wb3J0SlNPTicpKSB7XG4gICAgICBpZiAoVGV4dE5vZGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmICghKGtsYXNzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCR7a2xhc3MubmFtZX0gKHR5cGUgJHtvd25Ob2RlVHlwZX0pIG11c3QgaW1wbGVtZW50IGEgc3RhdGljIGltcG9ydEpTT04gbWV0aG9kIHNpbmNlIGl0cyBjb25zdHJ1Y3RvciBoYXMgJHtTdHJpbmcoa2xhc3MubGVuZ3RoKX0gcmVxdWlyZWQgYXJndW1lbnRzIChleHBlY3RpbmcgMCkuIFVzZSBhbiBleHBsaWNpdCBkZWZhdWx0IGluIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB5b3VyIGNvbnN0cnVjdG9yKHByb3A6IFQ9WCwgbm9kZUtleT86IE5vZGVLZXkpLmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrbGFzcy5pbXBvcnRKU09OID0gb3duTm9kZUNvbmZpZyAmJiBvd25Ob2RlQ29uZmlnLiRpbXBvcnRKU09OIHx8IChzZXJpYWxpemVkTm9kZSA9PiBuZXcga2xhc3MoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkpO1xuICAgIH1cbiAgICBpZiAoIWhhc093blN0YXRpY01ldGhvZChrbGFzcywgJ2ltcG9ydERPTScpICYmIG93bk5vZGVDb25maWcpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW1wb3J0RE9NXG4gICAgICB9ID0gb3duTm9kZUNvbmZpZztcbiAgICAgIGlmIChpbXBvcnRET00pIHtcbiAgICAgICAga2xhc3MuaW1wb3J0RE9NID0gKCkgPT4gaW1wb3J0RE9NO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG93bk5vZGVDb25maWcsXG4gICAgb3duTm9kZVR5cGVcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gbm9kZSBmcm9tIGl0cyBjbGFzcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyB3aWxsIGRpcmVjdGx5IGNvbnN0cnVjdCB0aGUgZmluYWwgYHdpdGhLbGFzc2Agbm9kZSB0eXBlLFxuICogYW5kIHdpbGwgaWdub3JlIHRoZSBkZXByZWNhdGVkIGB3aXRoYCBmdW5jdGlvbnMuIFRoaXMgYWxsb3dzIGAkY3JlYXRlYCB0b1xuICogc2tpcCBhbnkgaW50ZXJtZWRpYXRlIHN0ZXBzIHdoZXJlIHRoZSByZXBsYWNlZCBub2RlIHdvdWxkIGJlIGNyZWF0ZWQgYW5kXG4gKiB0aGVuIGltbWVkaWF0ZWx5IGRpc2NhcmRlZCAob25jZSBwZXIgY29uZmlndXJlZCByZXBsYWNlbWVudCBvZiB0aGF0IG5vZGUpLlxuICpcbiAqIFRoaXMgZG9lcyBub3Qgc3VwcG9ydCBhbnkgYXJndW1lbnRzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIFNldHRlcnMgY2FuIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZSB5b3VyIG5vZGUsIGFuZCB0aGV5IGNhblxuICogYmUgY2hhaW5lZC4gWW91IGNhbiBvZiBjb3Vyc2Ugd3JpdGUgeW91ciBvd24gbXV0bGlwbGUtYXJndW1lbnQgZnVuY3Rpb25zXG4gKiB0byB3cmFwIHRoYXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBmdW5jdGlvbiAkY3JlYXRlVG9rZW5UZXh0KHRleHQ6IHN0cmluZyk6IFRleHROb2RlIHtcbiAqICAgcmV0dXJuICRjcmVhdGUoVGV4dE5vZGUpLnNldFRleHRDb250ZW50KHRleHQpLnNldE1vZGUoJ3Rva2VuJyk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gJGNyZWF0ZShrbGFzcykge1xuICBjb25zdCBlZGl0b3IgPSAkZ2V0RWRpdG9yKCk7XG4gIGVycm9yT25SZWFkT25seSgpO1xuICBjb25zdCByZWdpc3RlcmVkTm9kZSA9IGVkaXRvci5yZXNvbHZlUmVnaXN0ZXJlZE5vZGVBZnRlclJlcGxhY2VtZW50cyhlZGl0b3IuZ2V0UmVnaXN0ZXJlZE5vZGUoa2xhc3MpKTtcbiAgcmV0dXJuIG5ldyByZWdpc3RlcmVkTm9kZS5rbGFzcygpO1xufVxuXG4vKipcbiAqIFRoZSBkaXJlY3Rpb24gb2YgYSBjYXJldCwgJ25leHQnIHBvaW50cyB0b3dhcmRzIHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50XG4gKiBhbmQgJ3ByZXZpb3VzJyBwb2ludHMgdG93YXJkcyB0aGUgYmVnaW5uaW5nXG4gKi9cblxuLyoqXG4gKiBBIHR5cGUgdXRpbGl0eSB0byBmbGlwIG5leHQgYW5kIHByZXZpb3VzXG4gKi9cblxuLyoqXG4gKiBBIHNpYmxpbmcgY2FyZXQgdHlwZSBwb2ludHMgZnJvbSBhIExleGljYWxOb2RlIG9yaWdpbiB0byBpdHMgbmV4dCBvciBwcmV2aW91cyBzaWJsaW5nLFxuICogYW5kIGEgY2hpbGQgY2FyZXQgdHlwZSBwb2ludHMgZnJvbSBhbiBFbGVtZW50Tm9kZSBvcmlnaW4gdG8gaXRzIGZpcnN0IG9yIGxhc3QgY2hpbGQuXG4gKi9cblxuLyoqXG4gKiBUaGUgUm9vdE1vZGUgaXMgc3BlY2lmaWVkIGluIGFsbCBjYXJldCB0cmF2ZXJzYWxzIHdoZXJlIHRoZSB0cmF2ZXJzYWwgY2FuIGdvIHVwXG4gKiB0b3dhcmRzIHRoZSByb290LiAncm9vdCcgbWVhbnMgdGhhdCBpdCB3aWxsIHN0b3AgYXQgdGhlIGRvY3VtZW50IHJvb3QsXG4gKiBhbmQgJ3NoYWRvd1Jvb3QnIHdpbGwgc3RvcCBhdCB0aGUgZG9jdW1lbnQgcm9vdCBvciBhbnkgc2hhZG93IHJvb3RcbiAqIChwZXIge0BsaW5rICRpc1Jvb3RPclNoYWRvd1Jvb3R9KS5cbiAqL1xuXG5jb25zdCBGTElQX0RJUkVDVElPTiA9IHtcbiAgbmV4dDogJ3ByZXZpb3VzJyxcbiAgcHJldmlvdXM6ICduZXh0J1xufTtcblxuLyoqIEBub0luaGVyaXREb2MgKi9cblxuLyoqXG4gKiBBIFJhbmdlU2VsZWN0aW9uIGV4cHJlc3NlZCBhcyBhIHBhaXIgb2YgQ2FyZXRzXG4gKi9cblxuLyoqXG4gKiBBIE5vZGVDYXJldCBpcyB0aGUgY29tYmluYXRpb24gb2YgYW4gb3JpZ2luIG5vZGUgYW5kIGEgZGlyZWN0aW9uXG4gKiB0aGF0IHBvaW50cyB0b3dhcmRzIHdoZXJlIGEgY29ubmVjdGVkIG5vZGUgd2lsbCBiZSBmZXRjaGVkLCBpbnNlcnRlZCxcbiAqIG9yIHJlcGxhY2VkLiBBIFNpYmxpbmdDYXJldCBwb2ludHMgZnJvbSBhIG5vZGUgdG8gaXRzIG5leHQgb3IgcHJldmlvdXNcbiAqIHNpYmxpbmcsIGFuZCBhIENoaWxkQ2FyZXQgcG9pbnRzIHRvIGl0cyBmaXJzdCBvciBsYXN0IGNoaWxkXG4gKiAodXNpbmcgbmV4dCBvciBwcmV2aW91cyBhcyBkaXJlY3Rpb24sIGZvciBzeW1tZXRyeSB3aXRoIFNpYmxpbmdDYXJldCkuXG4gKlxuICogVGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gTm9kZUNhcmV0IGFuZCBQb2ludFR5cGUgYXJlOlxuICogLSBOb2RlQ2FyZXQgY2FuIG9ubHkgYmUgdXNlZCB0byByZWZlciB0byBhbiBlbnRpcmUgbm9kZSAoUG9pbnRDYXJldCBpcyB1c2VkIHdoZW4gYSBmdWxsIGFuYWxvZyBpcyBuZWVkZWQpLiBBIFBvaW50VHlwZSBvZiB0ZXh0IHR5cGUgY2FuIGJlIHVzZWQgdG8gcmVmZXIgdG8gYSBzcGVjaWZpYyBsb2NhdGlvbiBpbnNpZGUgb2YgYSBUZXh0Tm9kZS5cbiAqIC0gTm9kZUNhcmV0IHN0b3JlcyBhbiBvcmlnaW4gbm9kZSwgdHlwZSAoc2libGluZyBvciBjaGlsZCksIGFuZCBkaXJlY3Rpb24gKG5leHQgb3IgcHJldmlvdXMpLiBBIFBvaW50VHlwZSBzdG9yZXMgYSB0eXBlICh0ZXh0IG9yIGVsZW1lbnQpLCB0aGUga2V5IG9mIGEgbm9kZSwgYW5kIGEgdGV4dCBvciBjaGlsZCBvZmZzZXQgd2l0aGluIHRoYXQgbm9kZS5cbiAqIC0gTm9kZUNhcmV0IGlzIGRpcmVjdGlvbmFsIGFuZCBhbHdheXMgcmVmZXJzIHRvIGEgdmVyeSBzcGVjaWZpYyBub2RlLCBlbGltaW5hdGluZyBhbGwgYW1iaWd1aXR5LiBQb2ludFR5cGUgY2FuIHJlZmVyIHRvIHRoZSBsb2NhdGlvbiBiZWZvcmUgb3IgYXQgYSBub2RlIGRlcGVuZGluZyBvbiBjb250ZXh0LlxuICogLSBOb2RlQ2FyZXQgaXMgbW9yZSByb2J1c3QgdG8gbmVhcmJ5IG11dGF0aW9ucywgYXMgaXQgcmVsaWVzIG9ubHkgb24gYSBub2RlJ3MgZGlyZWN0IGNvbm5lY3Rpb25zLiBBbiBlbGVtZW50IEFueSBjaGFuZ2UgdG8gdGhlIGNvdW50IG9mIHByZXZpb3VzIHNpYmxpbmdzIGluIGFuIGVsZW1lbnQgUG9pbnRUeXBlIHdpbGwgaW52YWxpZGF0ZSBpdC5cbiAqIC0gTm9kZUNhcmV0IGlzIGRlc2lnbmVkIHRvIHdvcmsgbW9yZSBkaXJlY3RseSB3aXRoIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZG9jdW1lbnQgdHJlZSwgbWFraW5nIGl0IHN1aXRhYmxlIGZvciB1c2UgaW4gdHJhdmVyc2FscyB3aXRob3V0IHBlcmZvcm1pbmcgYW55IHJlZHVuZGFudCB3b3JrLlxuICpcbiAqIFRoZSBjYXJldCBkb2VzICpub3QqIHVwZGF0ZSBpbiByZXNwb25zZSB0byBhbnkgbXV0YXRpb25zLCB5b3Ugc2hvdWxkXG4gKiBub3QgcGVyc2lzdCBpdCBhY3Jvc3MgZWRpdG9yIHVwZGF0ZXMsIGFuZCB1c2luZyBhIGNhcmV0IGFmdGVyIGl0cyBvcmlnaW5cbiAqIG5vZGUgaGFzIGJlZW4gcmVtb3ZlZCBvciByZXBsYWNlZCBtYXkgcmVzdWx0IGluIHJ1bnRpbWUgZXJyb3JzLlxuICovXG5cbi8qKlxuICogQSBQb2ludENhcmV0IGlzIGEgTm9kZUNhcmV0IHRoYXQgYWxzbyBpbmNsdWRlcyBhXG4gKiBUZXh0UG9pbnRDYXJldCB0eXBlIHdoaWNoIHJlZmVycyB0byBhIHNwZWNpZmljIG9mZnNldCBvZiBhIFRleHROb2RlLlxuICogVGhpcyB0eXBlIGlzIHNlcGFyYXRlIGJlY2F1c2UgaXQgaXMgbm90IHJlbGV2YW50IHRvIGdlbmVyYWwgbm9kZSB0cmF2ZXJzYWxcbiAqIHNvIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBoYXZlIGl0IHNob3cgdXAgZXhjZXB0IHdoZW4gZGVmaW5pbmdcbiAqIGEgQ2FyZXRSYW5nZSBhbmQgaW4gdGhvc2UgY2FzZXMgdGhlcmUgd2lsbCBiZSBhdCBtb3N0IHR3byBvZiB0aGVtIG9ubHlcbiAqIGF0IHRoZSBib3VuZGFyaWVzLlxuICpcbiAqIFRoZSBhZGRpdGlvbiBvZiBUZXh0UG9pbnRDYXJldCBhbGxvd3MgdGhpcyB0eXBlIHRvIHJlcHJlc2VudCBhbnkgbG9jYXRpb25cbiAqIHRoYXQgaXMgcmVwcmVzZW50YWJsZSBieSBQb2ludFR5cGUsIGFzIHRoZSBUZXh0UG9pbnRDYXJldCByZWZlcnMgdG8gYVxuICogc3BlY2lmaWMgb2Zmc2V0IHdpdGhpbiBhIFRleHROb2RlLlxuICovXG5cbi8qKlxuICogQSBTaWJsaW5nQ2FyZXQgcG9pbnRzIGZyb20gYW4gb3JpZ2luIExleGljYWxOb2RlIHRvd2FyZHMgaXRzIG5leHQgb3IgcHJldmlvdXMgc2libGluZy5cbiAqL1xuXG4vKipcbiAqIEEgQ2hpbGRDYXJldCBwb2ludHMgZnJvbSBhbiBvcmlnaW4gRWxlbWVudE5vZGUgdG93YXJkcyBpdHMgZmlyc3Qgb3IgbGFzdCBjaGlsZC5cbiAqL1xuXG4vKipcbiAqIEEgVGV4dFBvaW50Q2FyZXQgaXMgYSBzcGVjaWFsIGNhc2Ugb2YgYSBTaWJsaW5nQ2FyZXQgdGhhdCBhbHNvIGNhcnJpZXNcbiAqIGFuIG9mZnNldCB1c2VkIGZvciByZXByZXNlbnRpbmcgcGFydGlhbGx5IHNlbGVjdGVkIFRleHROb2RlIGF0IHRoZSBlZGdlc1xuICogb2YgYSBDYXJldFJhbmdlLlxuICpcbiAqIFRoZSBkaXJlY3Rpb24gZGV0ZXJtaW5lcyB3aGljaCBwYXJ0IG9mIHRoZSB0ZXh0IGlzIGFkamFjZW50IHRvIHRoZSBjYXJldCxcbiAqIGlmIG5leHQgaXQncyBhbGwgb2YgdGhlIHRleHQgYWZ0ZXIgb2Zmc2V0LiBJZiBwcmV2aW91cywgaXQncyBhbGwgb2YgdGhlXG4gKiB0ZXh0IGJlZm9yZSBvZmZzZXQuXG4gKlxuICogV2hpbGUgdGhpcyBjYW4gYmUgdXNlZCBpbiBwbGFjZSBvZiBhbnkgU2libGluZ0NhcmV0IG9mIGEgVGV4dE5vZGUsXG4gKiB0aGUgb2Zmc2V0IGludG8gdGhlIHRleHQgd2lsbCBiZSBpZ25vcmVkIGV4Y2VwdCBpbiBjb250ZXh0cyB0aGF0XG4gKiBzcGVjaWZpY2FsbHkgdXNlIHRoZSBUZXh0UG9pbnRDYXJldCBvciBQb2ludENhcmV0IHR5cGVzLlxuICovXG5cbi8qKlxuICogQSBUZXh0UG9pbnRDYXJldFNsaWNlIGlzIGEgd3JhcHBlciBmb3IgYSBUZXh0UG9pbnRDYXJldCB0aGF0IGNhcnJpZXMgYSBzaWduZWRcbiAqIGRpc3RhbmNlIHJlcHJlc2VudGluZyB0aGUgZGlyZWN0aW9uIGFuZCBhbW91bnQgb2YgdGV4dCBzZWxlY3RlZCBmcm9tIHRoZSBnaXZlblxuICogY2FyZXQuIEEgbmVnYXRpdmUgZGlzdGFuY2UgbWVhbnMgdGhhdCB0ZXh0IGJlZm9yZSBvZmZzZXQgaXMgc2VsZWN0ZWQsIGFcbiAqIHBvc2l0aXZlIGRpc3RhbmNlIG1lYW5zIHRoYXQgdGV4dCBhZnRlciBvZmZzZXQgaXMgc2VsZWN0ZWQuIFRoZSBvZmZzZXQrZGlzdGFuY2VcbiAqIHBhaXIgaXMgbm90IGFmZmVjdGVkIGluIGFueSB3YXkgYnkgdGhlIGRpcmVjdGlvbiBvZiB0aGUgY2FyZXQuXG4gKi9cblxuLyoqXG4gKiBBIHV0aWxpdHkgdHlwZSB0byBzcGVjaWZ5IHRoYXQgYSBDYXJldFJhbmdlIG1heSBoYXZlIHplcm8sXG4gKiBvbmUsIG9yIHR3byBhc3NvY2lhdGVkIFRleHRQb2ludENhcmV0U2xpY2UuIElmIHRoZSBhbmNob3JcbiAqIGFuZCBmb2N1cyBhcmUgb24gdGhlIHNhbWUgbm9kZSwgdGhlIGFuY2hvclNsaWNlIHdpbGwgY29udGFpblxuICogdGhlIHNsaWNlIGFuZCBmb2N1c1NsaWUgd2lsbCBiZSBudWxsLlxuICovXG5cbmNsYXNzIEFic3RyYWN0Q2FyZXQge1xuICBjb25zdHJ1Y3RvcihvcmlnaW4pIHtcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gbWFrZVN0ZXB3aXNlSXRlcmF0b3Ioe1xuICAgICAgaGFzTmV4dDogJGlzU2libGluZ0NhcmV0LFxuICAgICAgaW5pdGlhbDogdGhpcy5nZXRBZGphY2VudENhcmV0KCksXG4gICAgICBtYXA6IGNhcmV0ID0+IGNhcmV0LFxuICAgICAgc3RlcDogY2FyZXQgPT4gY2FyZXQuZ2V0QWRqYWNlbnRDYXJldCgpXG4gICAgfSk7XG4gIH1cbiAgZ2V0QWRqYWNlbnRDYXJldCgpIHtcbiAgICByZXR1cm4gJGdldFNpYmxpbmdDYXJldCh0aGlzLmdldE5vZGVBdENhcmV0KCksIHRoaXMuZGlyZWN0aW9uKTtcbiAgfVxuICBnZXRTaWJsaW5nQ2FyZXQoKSB7XG4gICAgcmV0dXJuICRnZXRTaWJsaW5nQ2FyZXQodGhpcy5vcmlnaW4sIHRoaXMuZGlyZWN0aW9uKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Tm9kZUF0Q2FyZXQoKTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmVwbGFjZU9ySW5zZXJ0KG5vZGUsIGluY2x1ZGVDaGlsZHJlbikge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuZ2V0Tm9kZUF0Q2FyZXQoKTtcbiAgICBpZiAobm9kZS5pcyh0aGlzLm9yaWdpbikgfHwgbm9kZS5pcyh0YXJnZXQpKSA7IGVsc2UgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5pbnNlcnQobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5yZXBsYWNlKG5vZGUsIGluY2x1ZGVDaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNwbGljZShkZWxldGVDb3VudCwgbm9kZXMsIG5vZGVzRGlyZWN0aW9uID0gJ25leHQnKSB7XG4gICAgY29uc3Qgbm9kZUl0ZXIgPSBub2Rlc0RpcmVjdGlvbiA9PT0gdGhpcy5kaXJlY3Rpb24gPyBub2RlcyA6IEFycmF5LmZyb20obm9kZXMpLnJldmVyc2UoKTtcbiAgICBsZXQgY2FyZXQgPSB0aGlzO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50QXRDYXJldCgpO1xuICAgIGNvbnN0IG5vZGVzVG9SZW1vdmUgPSBuZXcgTWFwKCk7XG4gICAgLy8gRmluZCBhbGwgb2YgdGhlIG5vZGVzIHdlIGV4cGVjdCB0byByZW1vdmUgZmlyc3QsIHNvXG4gICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byB3b3JyeSBhYm91dCB0aGUgY2FzZXMgd2hlcmUgdGhlcmUgaXNcbiAgICAvLyBvdmVybGFwIGJldHdlZW4gdGhlIG5vZGVzIHRvIGluc2VydCBhbmQgdGhlIG5vZGVzIHRvXG4gICAgLy8gcmVtb3ZlXG4gICAgZm9yIChsZXQgcmVtb3ZlQ2FyZXQgPSBjYXJldC5nZXRBZGphY2VudENhcmV0KCk7IHJlbW92ZUNhcmV0ICE9PSBudWxsICYmIG5vZGVzVG9SZW1vdmUuc2l6ZSA8IGRlbGV0ZUNvdW50OyByZW1vdmVDYXJldCA9IHJlbW92ZUNhcmV0LmdldEFkamFjZW50Q2FyZXQoKSkge1xuICAgICAgY29uc3Qgd3JpdGFibGVOb2RlID0gcmVtb3ZlQ2FyZXQub3JpZ2luLmdldFdyaXRhYmxlKCk7XG4gICAgICBub2Rlc1RvUmVtb3ZlLnNldCh3cml0YWJsZU5vZGUuZ2V0S2V5KCksIHdyaXRhYmxlTm9kZSk7XG4gICAgfVxuICAgIC8vIFRPRE86IE9wdGltaXplIHRoaXMgdG8gd29yayBkaXJlY3RseSB3aXRoIG5vZGUgaW50ZXJuYWxzXG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVJdGVyKSB7XG4gICAgICBpZiAobm9kZXNUb1JlbW92ZS5zaXplID4gMCkge1xuICAgICAgICAvLyBGb3Igc29tZSByZWFzb24gYG5wbSBydW4gdHNjLWV4dGVuc2lvbmAgbmVlZHMgdGhpcyBhbm5vdGF0aW9uP1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBjYXJldC5nZXROb2RlQXRDYXJldCgpO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgbm9kZXNUb1JlbW92ZS5kZWxldGUodGFyZ2V0LmdldEtleSgpKTtcbiAgICAgICAgICBub2Rlc1RvUmVtb3ZlLmRlbGV0ZShub2RlLmdldEtleSgpKTtcbiAgICAgICAgICBpZiAodGFyZ2V0LmlzKG5vZGUpIHx8IGNhcmV0Lm9yaWdpbi5pcyhub2RlKSkgOyBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVQYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICAgICAgaWYgKG5vZGVQYXJlbnQgJiYgbm9kZVBhcmVudC5pcyhwYXJlbnQpKSB7XG4gICAgICAgICAgICAgIC8vIEl0J3MgYSBzaWJsaW5nIHNvbWV3aGVyZSBlbHNlIGluIHRoaXMgbm9kZSwgc28gdW5wYXJlbnQgaXQgZmlyc3RcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5yZXBsYWNlKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoISh0YXJnZXQgIT09IG51bGwpKSB7XG4gICAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYE5vZGVDYXJldC5zcGxpY2U6IFVuZGVyZmxvdyBvZiBleHBlY3RlZCBub2Rlc1RvUmVtb3ZlIGR1cmluZyBzcGxpY2UgKGtleXM6ICR7QXJyYXkuZnJvbShub2Rlc1RvUmVtb3ZlKS5qb2luKCcgJyl9KWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FyZXQuaW5zZXJ0KG5vZGUpO1xuICAgICAgfVxuICAgICAgY2FyZXQgPSAkZ2V0U2libGluZ0NhcmV0KG5vZGUsIHRoaXMuZGlyZWN0aW9uKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzVG9SZW1vdmUudmFsdWVzKCkpIHtcbiAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jbGFzcyBBYnN0cmFjdENoaWxkQ2FyZXQgZXh0ZW5kcyBBYnN0cmFjdENhcmV0IHtcbiAgdHlwZSA9ICdjaGlsZCc7XG4gIGdldExhdGVzdCgpIHtcbiAgICBjb25zdCBvcmlnaW4gPSB0aGlzLm9yaWdpbi5nZXRMYXRlc3QoKTtcbiAgICByZXR1cm4gb3JpZ2luID09PSB0aGlzLm9yaWdpbiA/IHRoaXMgOiAkZ2V0Q2hpbGRDYXJldChvcmlnaW4sIHRoaXMuZGlyZWN0aW9uKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBTaWJsaW5nQ2FyZXQgZnJvbSB0aGlzIG9yaWdpbiBpbiB0aGUgc2FtZSBkaXJlY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSBtb2RlICdyb290JyB0byByZXR1cm4gbnVsbCBhdCB0aGUgcm9vdCwgJ3NoYWRvd1Jvb3QnIHRvIHJldHVybiBudWxsIGF0IHRoZSByb290IG9yIGFueSBzaGFkb3cgcm9vdFxuICAgKiBAcmV0dXJucyBBIFNpYmxpbmdDYXJldCB3aXRoIHRoaXMgb3JpZ2luLCBvciBudWxsIGlmIG9yaWdpbiBpcyBhIHJvb3QgYWNjb3JkaW5nIHRvIG1vZGUuXG4gICAqL1xuICBnZXRQYXJlbnRDYXJldChtb2RlID0gJ3Jvb3QnKSB7XG4gICAgcmV0dXJuICRnZXRTaWJsaW5nQ2FyZXQoJGZpbHRlckJ5TW9kZSh0aGlzLmdldFBhcmVudEF0Q2FyZXQoKSwgbW9kZSksIHRoaXMuZGlyZWN0aW9uKTtcbiAgfVxuICBnZXRGbGlwcGVkKCkge1xuICAgIGNvbnN0IGRpciA9IGZsaXBEaXJlY3Rpb24odGhpcy5kaXJlY3Rpb24pO1xuICAgIHJldHVybiAkZ2V0U2libGluZ0NhcmV0KHRoaXMuZ2V0Tm9kZUF0Q2FyZXQoKSwgZGlyKSB8fCAkZ2V0Q2hpbGRDYXJldCh0aGlzLm9yaWdpbiwgZGlyKTtcbiAgfVxuICBnZXRQYXJlbnRBdENhcmV0KCkge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbjtcbiAgfVxuICBnZXRDaGlsZENhcmV0KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGlzU2FtZU5vZGVDYXJldChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEFic3RyYWN0Q2hpbGRDYXJldCAmJiB0aGlzLmRpcmVjdGlvbiA9PT0gb3RoZXIuZGlyZWN0aW9uICYmIHRoaXMub3JpZ2luLmlzKG90aGVyLm9yaWdpbik7XG4gIH1cbiAgaXNTYW1lUG9pbnRDYXJldChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmlzU2FtZU5vZGVDYXJldChvdGhlcik7XG4gIH1cbn1cbmNsYXNzIENoaWxkQ2FyZXRGaXJzdCBleHRlbmRzIEFic3RyYWN0Q2hpbGRDYXJldCB7XG4gIGRpcmVjdGlvbiA9ICduZXh0JztcbiAgZ2V0Tm9kZUF0Q2FyZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luLmdldEZpcnN0Q2hpbGQoKTtcbiAgfVxuICBpbnNlcnQobm9kZSkge1xuICAgIHRoaXMub3JpZ2luLnNwbGljZSgwLCAwLCBbbm9kZV0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jbGFzcyBDaGlsZENhcmV0TGFzdCBleHRlbmRzIEFic3RyYWN0Q2hpbGRDYXJldCB7XG4gIGRpcmVjdGlvbiA9ICdwcmV2aW91cyc7XG4gIGdldE5vZGVBdENhcmV0KCkge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbi5nZXRMYXN0Q2hpbGQoKTtcbiAgfVxuICBpbnNlcnQobm9kZSkge1xuICAgIHRoaXMub3JpZ2luLnNwbGljZSh0aGlzLm9yaWdpbi5nZXRDaGlsZHJlblNpemUoKSwgMCwgW25vZGVdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuY29uc3QgTU9ERV9QUkVESUNBVEUgPSB7XG4gIHJvb3Q6ICRpc1Jvb3ROb2RlLFxuICBzaGFkb3dSb290OiAkaXNSb290T3JTaGFkb3dSb290XG59O1xuXG4vKipcbiAqIEZsaXAgYSBkaXJlY3Rpb24gKCduZXh0JyAtPiAncHJldmlvdXMnOyAncHJldmlvdXMnIC0+ICduZXh0JykuXG4gKlxuICogTm90ZSB0aGF0IFR5cGVTY3JpcHQgY2FuJ3QgcHJvdmUgdGhhdCBGbGlwRGlyZWN0aW9uIGlzIGl0cyBvd25cbiAqIGludmVyc2UgKGJ1dCBpZiB5b3UgaGF2ZSBhIGNvbmNyZXRlICduZXh0JyBvciAncHJldmlvdXMnIGl0IHdpbGxcbiAqIHNpbXBsaWZ5IGFjY29yZGluZ2x5KS5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyBUaGUgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZsaXBEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gIHJldHVybiBGTElQX0RJUkVDVElPTltkaXJlY3Rpb25dO1xufVxuZnVuY3Rpb24gJGZpbHRlckJ5TW9kZShub2RlLCBtb2RlID0gJ3Jvb3QnKSB7XG4gIHJldHVybiBNT0RFX1BSRURJQ0FURVttb2RlXShub2RlKSA/IG51bGwgOiBub2RlO1xufVxuY2xhc3MgQWJzdHJhY3RTaWJsaW5nQ2FyZXQgZXh0ZW5kcyBBYnN0cmFjdENhcmV0IHtcbiAgdHlwZSA9ICdzaWJsaW5nJztcbiAgZ2V0TGF0ZXN0KCkge1xuICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMub3JpZ2luLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBvcmlnaW4gPT09IHRoaXMub3JpZ2luID8gdGhpcyA6ICRnZXRTaWJsaW5nQ2FyZXQob3JpZ2luLCB0aGlzLmRpcmVjdGlvbik7XG4gIH1cbiAgZ2V0U2libGluZ0NhcmV0KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdldFBhcmVudEF0Q2FyZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luLmdldFBhcmVudCgpO1xuICB9XG4gIGdldENoaWxkQ2FyZXQoKSB7XG4gICAgcmV0dXJuICRpc0VsZW1lbnROb2RlKHRoaXMub3JpZ2luKSA/ICRnZXRDaGlsZENhcmV0KHRoaXMub3JpZ2luLCB0aGlzLmRpcmVjdGlvbikgOiBudWxsO1xuICB9XG4gIGdldFBhcmVudENhcmV0KG1vZGUgPSAncm9vdCcpIHtcbiAgICByZXR1cm4gJGdldFNpYmxpbmdDYXJldCgkZmlsdGVyQnlNb2RlKHRoaXMuZ2V0UGFyZW50QXRDYXJldCgpLCBtb2RlKSwgdGhpcy5kaXJlY3Rpb24pO1xuICB9XG4gIGdldEZsaXBwZWQoKSB7XG4gICAgY29uc3QgZGlyID0gZmxpcERpcmVjdGlvbih0aGlzLmRpcmVjdGlvbik7XG4gICAgcmV0dXJuICRnZXRTaWJsaW5nQ2FyZXQodGhpcy5nZXROb2RlQXRDYXJldCgpLCBkaXIpIHx8ICRnZXRDaGlsZENhcmV0KHRoaXMub3JpZ2luLmdldFBhcmVudE9yVGhyb3coKSwgZGlyKTtcbiAgfVxuICBpc1NhbWVQb2ludENhcmV0KG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgQWJzdHJhY3RTaWJsaW5nQ2FyZXQgJiYgdGhpcy5kaXJlY3Rpb24gPT09IG90aGVyLmRpcmVjdGlvbiAmJiB0aGlzLm9yaWdpbi5pcyhvdGhlci5vcmlnaW4pO1xuICB9XG4gIGlzU2FtZU5vZGVDYXJldChvdGhlcikge1xuICAgIHJldHVybiAob3RoZXIgaW5zdGFuY2VvZiBBYnN0cmFjdFNpYmxpbmdDYXJldCB8fCBvdGhlciBpbnN0YW5jZW9mIEFic3RyYWN0VGV4dFBvaW50Q2FyZXQpICYmIHRoaXMuZGlyZWN0aW9uID09PSBvdGhlci5kaXJlY3Rpb24gJiYgdGhpcy5vcmlnaW4uaXMob3RoZXIub3JpZ2luKTtcbiAgfVxufVxuY2xhc3MgQWJzdHJhY3RUZXh0UG9pbnRDYXJldCBleHRlbmRzIEFic3RyYWN0Q2FyZXQge1xuICB0eXBlID0gJ3RleHQnO1xuICBjb25zdHJ1Y3RvcihvcmlnaW4sIG9mZnNldCkge1xuICAgIHN1cGVyKG9yaWdpbik7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH1cbiAgZ2V0TGF0ZXN0KCkge1xuICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMub3JpZ2luLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBvcmlnaW4gPT09IHRoaXMub3JpZ2luID8gdGhpcyA6ICRnZXRUZXh0UG9pbnRDYXJldChvcmlnaW4sIHRoaXMuZGlyZWN0aW9uLCB0aGlzLm9mZnNldCk7XG4gIH1cbiAgZ2V0UGFyZW50QXRDYXJldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW4uZ2V0UGFyZW50KCk7XG4gIH1cbiAgZ2V0Q2hpbGRDYXJldCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXRQYXJlbnRDYXJldChtb2RlID0gJ3Jvb3QnKSB7XG4gICAgcmV0dXJuICRnZXRTaWJsaW5nQ2FyZXQoJGZpbHRlckJ5TW9kZSh0aGlzLmdldFBhcmVudEF0Q2FyZXQoKSwgbW9kZSksIHRoaXMuZGlyZWN0aW9uKTtcbiAgfVxuICBnZXRGbGlwcGVkKCkge1xuICAgIHJldHVybiAkZ2V0VGV4dFBvaW50Q2FyZXQodGhpcy5vcmlnaW4sIGZsaXBEaXJlY3Rpb24odGhpcy5kaXJlY3Rpb24pLCB0aGlzLm9mZnNldCk7XG4gIH1cbiAgaXNTYW1lUG9pbnRDYXJldChvdGhlcikge1xuICAgIHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEFic3RyYWN0VGV4dFBvaW50Q2FyZXQgJiYgdGhpcy5kaXJlY3Rpb24gPT09IG90aGVyLmRpcmVjdGlvbiAmJiB0aGlzLm9yaWdpbi5pcyhvdGhlci5vcmlnaW4pICYmIHRoaXMub2Zmc2V0ID09PSBvdGhlci5vZmZzZXQ7XG4gIH1cbiAgaXNTYW1lTm9kZUNhcmV0KG90aGVyKSB7XG4gICAgcmV0dXJuIChvdGhlciBpbnN0YW5jZW9mIEFic3RyYWN0U2libGluZ0NhcmV0IHx8IG90aGVyIGluc3RhbmNlb2YgQWJzdHJhY3RUZXh0UG9pbnRDYXJldCkgJiYgdGhpcy5kaXJlY3Rpb24gPT09IG90aGVyLmRpcmVjdGlvbiAmJiB0aGlzLm9yaWdpbi5pcyhvdGhlci5vcmlnaW4pO1xuICB9XG4gIGdldFNpYmxpbmdDYXJldCgpIHtcbiAgICByZXR1cm4gJGdldFNpYmxpbmdDYXJldCh0aGlzLm9yaWdpbiwgdGhpcy5kaXJlY3Rpb24pO1xuICB9XG59XG4vKipcbiAqIEd1YXJkIHRvIGNoZWNrIGlmIHRoZSBnaXZlbiBjYXJldCBpcyBzcGVjaWZpY2FsbHkgYSBUZXh0UG9pbnRDYXJldFxuICpcbiAqIEBwYXJhbSBjYXJldCBBbnkgY2FyZXRcbiAqIEByZXR1cm5zIHRydWUgaWYgaXQgaXMgYSBUZXh0UG9pbnRDYXJldFxuICovXG5mdW5jdGlvbiAkaXNUZXh0UG9pbnRDYXJldChjYXJldCkge1xuICByZXR1cm4gY2FyZXQgaW5zdGFuY2VvZiBBYnN0cmFjdFRleHRQb2ludENhcmV0O1xufVxuXG4vKipcbiAqIEd1YXJkIHRvIGNoZWNrIGlmIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBhbnkgdHlwZSBvZiBjYXJldFxuICpcbiAqIEBwYXJhbSBjYXJldFxuICogQHJldHVybnMgdHJ1ZSBpZiBjYXJldCBpcyBhbnkgdHlwZSBvZiBjYXJldFxuICovXG5mdW5jdGlvbiAkaXNOb2RlQ2FyZXQoY2FyZXQpIHtcbiAgcmV0dXJuIGNhcmV0IGluc3RhbmNlb2YgQWJzdHJhY3RDYXJldDtcbn1cblxuLyoqXG4gKiBHdWFyZCB0byBjaGVjayBpZiB0aGUgZ2l2ZW4gYXJndW1lbnQgaXMgc3BlY2lmaWNhbGx5IGEgU2libGluZ0NhcmV0IChvciBUZXh0UG9pbnRDYXJldClcbiAqXG4gKiBAcGFyYW0gY2FyZXRcbiAqIEByZXR1cm5zIHRydWUgaWYgY2FyZXQgaXMgYSBTaWJsaW5nQ2FyZXRcbiAqL1xuZnVuY3Rpb24gJGlzU2libGluZ0NhcmV0KGNhcmV0KSB7XG4gIHJldHVybiBjYXJldCBpbnN0YW5jZW9mIEFic3RyYWN0U2libGluZ0NhcmV0O1xufVxuXG4vKipcbiAqIEd1YXJkIHRvIGNoZWNrIGlmIHRoZSBnaXZlbiBhcmd1bWVudCBpcyBzcGVjaWZpY2FsbHkgYSBDaGlsZENhcmV0XG5cbiAqIEBwYXJhbSBjYXJldCBcbiAqIEByZXR1cm5zIHRydWUgaWYgY2FyZXQgaXMgYSBDaGlsZENhcmV0XG4gKi9cbmZ1bmN0aW9uICRpc0NoaWxkQ2FyZXQoY2FyZXQpIHtcbiAgcmV0dXJuIGNhcmV0IGluc3RhbmNlb2YgQWJzdHJhY3RDaGlsZENhcmV0O1xufVxuY2xhc3MgU2libGluZ0NhcmV0TmV4dCBleHRlbmRzIEFic3RyYWN0U2libGluZ0NhcmV0IHtcbiAgZGlyZWN0aW9uID0gJ25leHQnO1xuICBnZXROb2RlQXRDYXJldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW4uZ2V0TmV4dFNpYmxpbmcoKTtcbiAgfVxuICBpbnNlcnQobm9kZSkge1xuICAgIHRoaXMub3JpZ2luLmluc2VydEFmdGVyKG5vZGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jbGFzcyBTaWJsaW5nQ2FyZXRQcmV2aW91cyBleHRlbmRzIEFic3RyYWN0U2libGluZ0NhcmV0IHtcbiAgZGlyZWN0aW9uID0gJ3ByZXZpb3VzJztcbiAgZ2V0Tm9kZUF0Q2FyZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3JpZ2luLmdldFByZXZpb3VzU2libGluZygpO1xuICB9XG4gIGluc2VydChub2RlKSB7XG4gICAgdGhpcy5vcmlnaW4uaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jbGFzcyBUZXh0UG9pbnRDYXJldE5leHQgZXh0ZW5kcyBBYnN0cmFjdFRleHRQb2ludENhcmV0IHtcbiAgZGlyZWN0aW9uID0gJ25leHQnO1xuICBnZXROb2RlQXRDYXJldCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW4uZ2V0TmV4dFNpYmxpbmcoKTtcbiAgfVxuICBpbnNlcnQobm9kZSkge1xuICAgIHRoaXMub3JpZ2luLmluc2VydEFmdGVyKG5vZGUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5jbGFzcyBUZXh0UG9pbnRDYXJldFByZXZpb3VzIGV4dGVuZHMgQWJzdHJhY3RUZXh0UG9pbnRDYXJldCB7XG4gIGRpcmVjdGlvbiA9ICdwcmV2aW91cyc7XG4gIGdldE5vZGVBdENhcmV0KCkge1xuICAgIHJldHVybiB0aGlzLm9yaWdpbi5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgfVxuICBpbnNlcnQobm9kZSkge1xuICAgIHRoaXMub3JpZ2luLmluc2VydEJlZm9yZShub2RlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuY29uc3QgVEVYVF9DVE9SID0ge1xuICBuZXh0OiBUZXh0UG9pbnRDYXJldE5leHQsXG4gIHByZXZpb3VzOiBUZXh0UG9pbnRDYXJldFByZXZpb3VzXG59O1xuY29uc3QgU0lCTElOR19DVE9SID0ge1xuICBuZXh0OiBTaWJsaW5nQ2FyZXROZXh0LFxuICBwcmV2aW91czogU2libGluZ0NhcmV0UHJldmlvdXNcbn07XG5jb25zdCBDSElMRF9DVE9SID0ge1xuICBuZXh0OiBDaGlsZENhcmV0Rmlyc3QsXG4gIHByZXZpb3VzOiBDaGlsZENhcmV0TGFzdFxufTtcblxuLyoqXG4gKiBHZXQgYSBjYXJldCB0aGF0IHBvaW50cyBhdCB0aGUgbmV4dCBvciBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBnaXZlbiBvcmlnaW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0gb3JpZ2luIFRoZSBvcmlnaW4gbm9kZVxuICogQHBhcmFtIGRpcmVjdGlvbiAnbmV4dCcgb3IgJ3ByZXZpb3VzJ1xuICogQHJldHVybnMgbnVsbCBpZiBvcmlnaW4gaXMgbnVsbCwgb3RoZXJ3aXNlIGEgU2libGluZ0NhcmV0IGZvciB0aGlzIG9yaWdpbiBhbmQgZGlyZWN0aW9uXG4gKi9cblxuZnVuY3Rpb24gJGdldFNpYmxpbmdDYXJldChvcmlnaW4sIGRpcmVjdGlvbikge1xuICByZXR1cm4gb3JpZ2luID8gbmV3IFNJQkxJTkdfQ1RPUltkaXJlY3Rpb25dKG9yaWdpbikgOiBudWxsO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIFRleHRQb2ludENhcmV0XG4gKlxuICogQHBhcmFtIG9yaWdpbiBUaGUgVGV4dE5vZGVcbiAqIEBwYXJhbSBkaXJlY3Rpb24gVGhlIGRpcmVjdGlvbiAobmV4dCBwb2ludHMgdG8gdGhlIGVuZCBvZiB0aGUgdGV4dCwgcHJldmlvdXMgcG9pbnRzIHRvIHRoZSBiZWdpbm5pbmcpXG4gKiBAcGFyYW0gb2Zmc2V0IFRoZSBvZmZzZXQgaW50byB0aGUgdGV4dCBpbiBhYnNvbHV0ZSBwb3NpdGl2ZSBzdHJpbmcgY29vcmRpbmF0ZXMgKDAgaXMgdGhlIHN0YXJ0KVxuICogQHJldHVybnMgYSBUZXh0UG9pbnRDYXJldFxuICovXG5cbmZ1bmN0aW9uICRnZXRUZXh0UG9pbnRDYXJldChvcmlnaW4sIGRpcmVjdGlvbiwgb2Zmc2V0KSB7XG4gIHJldHVybiBvcmlnaW4gPyBuZXcgVEVYVF9DVE9SW2RpcmVjdGlvbl0ob3JpZ2luLCAkZ2V0VGV4dE5vZGVPZmZzZXQob3JpZ2luLCBvZmZzZXQpKSA6IG51bGw7XG59XG5cbi8qKlxuICogR2V0IGEgbm9ybWFsaXplZCBvZmZzZXQgaW50byBhIFRleHROb2RlIGdpdmVuIGEgbnVtZXJpYyBvZmZzZXQgb3IgYVxuICogZGlyZWN0aW9uIGZvciB3aGljaCBlbmQgb2YgdGhlIHN0cmluZyB0byB1c2UuIFRocm93cyBpbiBkZXYgaWYgdGhlIG9mZnNldFxuICogaXMgbm90IGluIHRoZSBib3VuZHMgb2YgdGhlIHRleHQgY29udGVudCBzaXplLlxuICpcbiAqIEBwYXJhbSBvcmlnaW4gYSBUZXh0Tm9kZVxuICogQHBhcmFtIG9mZnNldCBBbiBhYnNvbHV0ZSBvZmZzZXQgaW50byB0aGUgVGV4dE5vZGUgc3RyaW5nLCBvciBhIGRpcmVjdGlvbiBmb3Igd2hpY2ggZW5kIHRvIHVzZSBhcyB0aGUgb2Zmc2V0XG4gKiBAcGFyYW0gbW9kZSBJZiAnZXJyb3InICh0aGUgZGVmYXVsdCkgb3V0IG9mIGJvdW5kcyBvZmZzZXRzIHdpbGwgYmUgYW4gZXJyb3IgaW4gZGV2LiBPdGhlcndpc2UgaXQgd2lsbCBjbGFtcCB0byBhIHZhbGlkIG9mZnNldC5cbiAqIEByZXR1cm5zIEFuIGFic29sdXRlIG9mZnNldCBpbnRvIHRoZSBUZXh0Tm9kZSBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gJGdldFRleHROb2RlT2Zmc2V0KG9yaWdpbiwgb2Zmc2V0LCBtb2RlID0gJ2Vycm9yJykge1xuICBjb25zdCBzaXplID0gb3JpZ2luLmdldFRleHRDb250ZW50U2l6ZSgpO1xuICBsZXQgbnVtZXJpY09mZnNldCA9IG9mZnNldCA9PT0gJ25leHQnID8gc2l6ZSA6IG9mZnNldCA9PT0gJ3ByZXZpb3VzJyA/IDAgOiBvZmZzZXQ7XG4gIGlmIChudW1lcmljT2Zmc2V0IDwgMCB8fCBudW1lcmljT2Zmc2V0ID4gc2l6ZSkge1xuICAgIGlmICghKG1vZGUgPT09ICdjbGFtcCcpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRnZXRUZXh0Tm9kZU9mZnNldDogaW52YWxpZCBvZmZzZXQgJHtTdHJpbmcob2Zmc2V0KX0gZm9yIHNpemUgJHtTdHJpbmcoc2l6ZSl9IGF0IGtleSAke29yaWdpbi5nZXRLZXkoKX1gKTtcbiAgICB9IC8vIENsYW1wIGludmFsaWQgb2Zmc2V0cyBpbiBwcm9kXG4gICAgbnVtZXJpY09mZnNldCA9IG51bWVyaWNPZmZzZXQgPCAwID8gMCA6IHNpemU7XG4gIH1cbiAgcmV0dXJuIG51bWVyaWNPZmZzZXQ7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgVGV4dFBvaW50Q2FyZXRTbGljZSBnaXZlbiBhIFRleHRQb2ludENhcmV0IGFuZCBhIHNpZ25lZCBkaXN0YW5jZS4gVGhlXG4gKiBkaXN0YW5jZSBzaG91bGQgYmUgbmVnYXRpdmUgdG8gc2xpY2UgdGV4dCBiZWZvcmUgdGhlIGNhcmV0J3Mgb2Zmc2V0LCBhbmQgcG9zaXRpdmVcbiAqIHRvIHNsaWNlIHRleHQgYWZ0ZXIgdGhlIG9mZnNldC4gVGhlIGRpcmVjdGlvbiBvZiB0aGUgY2FyZXQgaXRzZWxmIGlzIG5vdFxuICogcmVsZXZhbnQgdG8gdGhlIHN0cmluZyBjb29yZGluYXRlcyB3aGVuIHdvcmtpbmcgd2l0aCBhIFRleHRQb2ludENhcmV0U2xpY2VcbiAqIGJ1dCBtdXRhdGlvbiBvcGVyYXRpb25zIHdpbGwgcHJlc2VydmUgdGhlIGRpcmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gY2FyZXRcbiAqIEBwYXJhbSBkaXN0YW5jZVxuICogQHJldHVybnMgVGV4dFBvaW50Q2FyZXRTbGljZVxuICovXG5mdW5jdGlvbiAkZ2V0VGV4dFBvaW50Q2FyZXRTbGljZShjYXJldCwgZGlzdGFuY2UpIHtcbiAgcmV0dXJuIG5ldyBUZXh0UG9pbnRDYXJldFNsaWNlSW1wbChjYXJldCwgZGlzdGFuY2UpO1xufVxuXG4vKipcbiAqIEdldCBhIGNhcmV0IHRoYXQgcG9pbnRzIGF0IHRoZSBmaXJzdCBvciBsYXN0IGNoaWxkIG9mIHRoZSBnaXZlbiBvcmlnaW4gbm9kZSxcbiAqIHdoaWNoIG11c3QgYmUgYW4gRWxlbWVudE5vZGUuXG4gKlxuICogQHBhcmFtIG9yaWdpbiBUaGUgb3JpZ2luIEVsZW1lbnROb2RlXG4gKiBAcGFyYW0gZGlyZWN0aW9uICduZXh0JyBmb3IgZmlyc3QgY2hpbGQgb3IgJ3ByZXZpb3VzJyBmb3IgbGFzdCBjaGlsZFxuICogQHJldHVybnMgbnVsbCBpZiBvcmlnaW4gaXMgbnVsbCBvciBub3QgYW4gRWxlbWVudE5vZGUsIG90aGVyd2lzZSBhIENoaWxkQ2FyZXQgZm9yIHRoaXMgb3JpZ2luIGFuZCBkaXJlY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiAkZ2V0Q2hpbGRDYXJldChvcmlnaW4sIGRpcmVjdGlvbikge1xuICByZXR1cm4gJGlzRWxlbWVudE5vZGUob3JpZ2luKSA/IG5ldyBDSElMRF9DVE9SW2RpcmVjdGlvbl0ob3JpZ2luKSA6IG51bGw7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgQ2hpbGRDYXJldCBpZiBvbmUgaXMgcG9zc2libGUgYXQgdGhpcyBjYXJldCBvcmlnaW4sIG90aGVyd2lzZSByZXR1cm4gdGhlIGNhcmV0XG4gKi9cbmZ1bmN0aW9uICRnZXRDaGlsZENhcmV0T3JTZWxmKGNhcmV0KSB7XG4gIHJldHVybiBjYXJldCAmJiBjYXJldC5nZXRDaGlsZENhcmV0KCkgfHwgY2FyZXQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYWRqYWNlbnQgY2FyZXQsIGlmIG5vdC1udWxsIGFuZCBpZiB0aGUgb3JpZ2luIG9mIHRoZSBhZGphY2VudCBjYXJldCBpcyBhbiBFbGVtZW50Tm9kZSwgdGhlbiByZXR1cm5cbiAqIHRoZSBDaGlsZENhcmV0LiBUaGlzIGNhbiBiZSB1c2VkIGFsb25nIHdpdGggdGhlIGdldFBhcmVudEFkamFjZW50Q2FyZXQgbWV0aG9kIHRvIHBlcmZvcm0gYSBmdWxsIERGU1xuICogc3R5bGUgdHJhdmVyc2FsIG9mIHRoZSB0cmVlLlxuICpcbiAqIEBwYXJhbSBjYXJldCBUaGUgY2FyZXQgdG8gc3RhcnQgYXRcbiAqL1xuZnVuY3Rpb24gJGdldEFkamFjZW50Q2hpbGRDYXJldChjYXJldCkge1xuICByZXR1cm4gY2FyZXQgJiYgJGdldENoaWxkQ2FyZXRPclNlbGYoY2FyZXQuZ2V0QWRqYWNlbnRDYXJldCgpKTtcbn1cbmNsYXNzIENhcmV0UmFuZ2VJbXBsIHtcbiAgdHlwZSA9ICdub2RlLWNhcmV0LXJhbmdlJztcbiAgY29uc3RydWN0b3IoYW5jaG9yLCBmb2N1cywgZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgdGhpcy5mb2N1cyA9IGZvY3VzO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICB9XG4gIGdldExhdGVzdCgpIHtcbiAgICBjb25zdCBhbmNob3IgPSB0aGlzLmFuY2hvci5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBmb2N1cyA9IHRoaXMuZm9jdXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIGFuY2hvciA9PT0gdGhpcy5hbmNob3IgJiYgZm9jdXMgPT09IHRoaXMuZm9jdXMgPyB0aGlzIDogbmV3IENhcmV0UmFuZ2VJbXBsKGFuY2hvciwgZm9jdXMsIHRoaXMuZGlyZWN0aW9uKTtcbiAgfVxuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmNob3IuaXNTYW1lUG9pbnRDYXJldCh0aGlzLmZvY3VzKTtcbiAgfVxuICBnZXRUZXh0U2xpY2VzKCkge1xuICAgIGNvbnN0IGdldFNsaWNlID0gayA9PiB7XG4gICAgICBjb25zdCBjYXJldCA9IHRoaXNba10uZ2V0TGF0ZXN0KCk7XG4gICAgICByZXR1cm4gJGlzVGV4dFBvaW50Q2FyZXQoY2FyZXQpID8gJGdldFNsaWNlRnJvbVRleHRQb2ludENhcmV0KGNhcmV0LCBrKSA6IG51bGw7XG4gICAgfTtcbiAgICBjb25zdCBhbmNob3JTbGljZSA9IGdldFNsaWNlKCdhbmNob3InKTtcbiAgICBjb25zdCBmb2N1c1NsaWNlID0gZ2V0U2xpY2UoJ2ZvY3VzJyk7XG4gICAgaWYgKGFuY2hvclNsaWNlICYmIGZvY3VzU2xpY2UpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2FyZXQ6IGFuY2hvckNhcmV0XG4gICAgICB9ID0gYW5jaG9yU2xpY2U7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNhcmV0OiBmb2N1c0NhcmV0XG4gICAgICB9ID0gZm9jdXNTbGljZTtcbiAgICAgIGlmIChhbmNob3JDYXJldC5pc1NhbWVOb2RlQ2FyZXQoZm9jdXNDYXJldCkpIHtcbiAgICAgICAgcmV0dXJuIFskZ2V0VGV4dFBvaW50Q2FyZXRTbGljZShhbmNob3JDYXJldCwgZm9jdXNDYXJldC5vZmZzZXQgLSBhbmNob3JDYXJldC5vZmZzZXQpLCBudWxsXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFthbmNob3JTbGljZSwgZm9jdXNTbGljZV07XG4gIH1cbiAgaXRlck5vZGVDYXJldHMocm9vdE1vZGUgPSAncm9vdCcpIHtcbiAgICBjb25zdCBhbmNob3IgPSAkaXNUZXh0UG9pbnRDYXJldCh0aGlzLmFuY2hvcikgPyB0aGlzLmFuY2hvci5nZXRTaWJsaW5nQ2FyZXQoKSA6IHRoaXMuYW5jaG9yLmdldExhdGVzdCgpO1xuICAgIGNvbnN0IGZvY3VzID0gdGhpcy5mb2N1cy5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBpc1RleHRGb2N1cyA9ICRpc1RleHRQb2ludENhcmV0KGZvY3VzKTtcbiAgICBjb25zdCBzdGVwID0gc3RhdGUgPT4gc3RhdGUuaXNTYW1lTm9kZUNhcmV0KGZvY3VzKSA/IG51bGwgOiAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0KHN0YXRlKSB8fCBzdGF0ZS5nZXRQYXJlbnRDYXJldChyb290TW9kZSk7XG4gICAgcmV0dXJuIG1ha2VTdGVwd2lzZUl0ZXJhdG9yKHtcbiAgICAgIGhhc05leHQ6IHN0YXRlID0+IHN0YXRlICE9PSBudWxsICYmICEoaXNUZXh0Rm9jdXMgJiYgZm9jdXMuaXNTYW1lTm9kZUNhcmV0KHN0YXRlKSksXG4gICAgICBpbml0aWFsOiBhbmNob3IuaXNTYW1lTm9kZUNhcmV0KGZvY3VzKSA/IG51bGwgOiBzdGVwKGFuY2hvciksXG4gICAgICBtYXA6IHN0YXRlID0+IHN0YXRlLFxuICAgICAgc3RlcFxuICAgIH0pO1xuICB9XG4gIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgIHJldHVybiB0aGlzLml0ZXJOb2RlQ2FyZXRzKCdyb290Jyk7XG4gIH1cbn1cbmNsYXNzIFRleHRQb2ludENhcmV0U2xpY2VJbXBsIHtcbiAgdHlwZSA9ICdzbGljZSc7XG4gIGNvbnN0cnVjdG9yKGNhcmV0LCBkaXN0YW5jZSkge1xuICAgIHRoaXMuY2FyZXQgPSBjYXJldDtcbiAgICB0aGlzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG4gIH1cbiAgZ2V0U2xpY2VJbmRpY2VzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgY2FyZXQ6IHtcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0QiA9IG9mZnNldCArIGRpc3RhbmNlO1xuICAgIHJldHVybiBvZmZzZXRCIDwgb2Zmc2V0ID8gW29mZnNldEIsIG9mZnNldF0gOiBbb2Zmc2V0LCBvZmZzZXRCXTtcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBbc3RhcnRJbmRleCwgZW5kSW5kZXhdID0gdGhpcy5nZXRTbGljZUluZGljZXMoKTtcbiAgICByZXR1cm4gdGhpcy5jYXJldC5vcmlnaW4uZ2V0VGV4dENvbnRlbnQoKS5zbGljZShzdGFydEluZGV4LCBlbmRJbmRleCk7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnRTaXplKCkge1xuICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmRpc3RhbmNlKTtcbiAgfVxuICByZW1vdmVUZXh0U2xpY2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2FyZXQ6IHtcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBkaXJlY3Rpb25cbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBbaW5kZXhTdGFydCwgaW5kZXhFbmRdID0gdGhpcy5nZXRTbGljZUluZGljZXMoKTtcbiAgICBjb25zdCB0ZXh0ID0gb3JpZ2luLmdldFRleHRDb250ZW50KCk7XG4gICAgcmV0dXJuICRnZXRUZXh0UG9pbnRDYXJldChvcmlnaW4uc2V0VGV4dENvbnRlbnQodGV4dC5zbGljZSgwLCBpbmRleFN0YXJ0KSArIHRleHQuc2xpY2UoaW5kZXhFbmQpKSwgZGlyZWN0aW9uLCBpbmRleFN0YXJ0KTtcbiAgfVxufVxuZnVuY3Rpb24gJGdldFNsaWNlRnJvbVRleHRQb2ludENhcmV0KGNhcmV0LCBhbmNob3JPckZvY3VzKSB7XG4gIGNvbnN0IHtcbiAgICBkaXJlY3Rpb24sXG4gICAgb3JpZ2luXG4gIH0gPSBjYXJldDtcbiAgY29uc3Qgb2Zmc2V0QiA9ICRnZXRUZXh0Tm9kZU9mZnNldChvcmlnaW4sIGFuY2hvck9yRm9jdXMgPT09ICdmb2N1cycgPyBmbGlwRGlyZWN0aW9uKGRpcmVjdGlvbikgOiBkaXJlY3Rpb24pO1xuICByZXR1cm4gJGdldFRleHRQb2ludENhcmV0U2xpY2UoY2FyZXQsIG9mZnNldEIgLSBjYXJldC5vZmZzZXQpO1xufVxuXG4vKipcbiAqIEd1YXJkIHRvIGNoZWNrIGZvciBhIFRleHRQb2ludENhcmV0U2xpY2VcbiAqXG4gKiBAcGFyYW0gY2FyZXRPclNsaWNlIEEgY2FyZXQgb3Igc2xpY2VcbiAqIEByZXR1cm5zIHRydWUgaWYgY2FyZXRPclNsaWNlIGlzIGEgVGV4dFBvaW50Q2FyZXRTbGljZVxuICovXG5mdW5jdGlvbiAkaXNUZXh0UG9pbnRDYXJldFNsaWNlKGNhcmV0T3JTbGljZSkge1xuICByZXR1cm4gY2FyZXRPclNsaWNlIGluc3RhbmNlb2YgVGV4dFBvaW50Q2FyZXRTbGljZUltcGw7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgQ2FyZXRSYW5nZSB0aGF0IHN0YXJ0cyBhdCBhbmNob3IgYW5kIGdvZXMgdG8gdGhlIGVuZCBvZiB0aGVcbiAqIGRvY3VtZW50IGluIHRoZSBhbmNob3IgY2FyZXQncyBkaXJlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uICRleHRlbmRDYXJldFRvUmFuZ2UoYW5jaG9yKSB7XG4gIHJldHVybiAkZ2V0Q2FyZXRSYW5nZShhbmNob3IsICRnZXRTaWJsaW5nQ2FyZXQoJGdldFJvb3QoKSwgYW5jaG9yLmRpcmVjdGlvbikpO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdCBhIGNvbGxhcHNlZCBDYXJldFJhbmdlIHRoYXQgc3RhcnRzIGFuZCBlbmRzIGF0IGFuY2hvci5cbiAqL1xuZnVuY3Rpb24gJGdldENvbGxhcHNlZENhcmV0UmFuZ2UoYW5jaG9yKSB7XG4gIHJldHVybiAkZ2V0Q2FyZXRSYW5nZShhbmNob3IsIGFuY2hvcik7XG59XG5cbi8qKlxuICogQ29uc3RydWN0IGEgQ2FyZXRSYW5nZSBmcm9tIGFuY2hvciBhbmQgZm9jdXMgY2FyZXRzIHBvaW50aW5nIGluIHRoZVxuICogc2FtZSBkaXJlY3Rpb24uIEluIG9yZGVyIHRvIGdldCB0aGUgZXhwZWN0ZWQgYmVoYXZpb3IsXG4gKiB0aGUgYW5jaG9yIG11c3QgcG9pbnQgdG93YXJkcyB0aGUgZm9jdXMgb3IgYmUgdGhlIHNhbWUgcG9pbnQuXG4gKlxuICogSW4gdGhlICduZXh0JyBkaXJlY3Rpb24gdGhlIGFuY2hvciBzaG91bGQgYmUgYXQgb3IgYmVmb3JlIHRoZVxuICogZm9jdXMgaW4gdGhlIGRvY3VtZW50LiBJbiB0aGUgJ3ByZXZpb3VzJyBkaXJlY3Rpb24gdGhlIGFuY2hvclxuICogc2hvdWxkIGJlIGF0IG9yIGFmdGVyIHRoZSBmb2N1cyBpbiB0aGUgZG9jdW1lbnRcbiAqIChzaW1pbGFyIHRvIGEgYmFja3dhcmRzIFJhbmdlU2VsZWN0aW9uKS5cbiAqXG4gKiBAcGFyYW0gYW5jaG9yXG4gKiBAcGFyYW0gZm9jdXNcbiAqIEByZXR1cm5zIGEgQ2FyZXRSYW5nZVxuICovXG5mdW5jdGlvbiAkZ2V0Q2FyZXRSYW5nZShhbmNob3IsIGZvY3VzKSB7XG4gIGlmICghKGFuY2hvci5kaXJlY3Rpb24gPT09IGZvY3VzLmRpcmVjdGlvbikpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRnZXRDYXJldFJhbmdlOiBhbmNob3IgYW5kIGZvY3VzIG11c3QgYmUgaW4gdGhlIHNhbWUgZGlyZWN0aW9uYCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBDYXJldFJhbmdlSW1wbChhbmNob3IsIGZvY3VzLCBhbmNob3IuZGlyZWN0aW9uKTtcbn1cblxuLyoqXG4gKiBBIGdlbmVyYWxpemVkIHV0aWxpdHkgZm9yIGNyZWF0aW5nIGEgc3RlcHdpc2UgaXRlcmF0b3JcbiAqIGJhc2VkIG9uOlxuICpcbiAqIC0gYW4gaW5pdGlhbCBzdGF0ZVxuICogLSBhIHN0b3AgZ3VhcmQgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGl0ZXJhdGlvbiBpcyBvdmVyLCB0aGlzXG4gKiAgIGlzIHR5cGljYWxseSB1c2VkIHRvIGRldGVjdCBhIHNlbnRpbmVsIHZhbHVlIHN1Y2ggYXMgbnVsbCBvclxuICogICB1bmRlZmluZWQgZnJvbSB0aGUgc3RhdGUgYnV0IG1heSByZXR1cm4gdHJ1ZSBmb3Igb3RoZXIgY29uZGl0aW9uc1xuICogICBhcyB3ZWxsXG4gKiAtIGEgc3RlcCBmdW5jdGlvbiB0aGF0IGFkdmFuY2VzIHRoZSBzdGF0ZSAodGhpcyB3aWxsIGJlIGNhbGxlZFxuICogICBhZnRlciBtYXAgZWFjaCB0aW1lIG5leHQoKSBpcyBjYWxsZWQgdG8gcHJlcGFyZSB0aGUgbmV4dCBzdGF0ZSlcbiAqIC0gYSBtYXAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB0aGF0IG1heSB0cmFuc2Zvcm0gdGhlIHN0YXRlXG4gKiAgIGJlZm9yZSByZXR1cm5pbmcgaXQuIEl0IHdpbGwgb25seSBiZSBjYWxsZWQgb25jZSBmb3IgZWFjaCBuZXh0KClcbiAqICAgY2FsbCB3aGVuIHN0b3Aoc3RhdGUpID09PSBmYWxzZVxuICpcbiAqIEBwYXJhbSBjb25maWdcbiAqIEByZXR1cm5zIEFuIEl0ZXJhYmxlSXRlcmF0b3JcbiAqL1xuZnVuY3Rpb24gbWFrZVN0ZXB3aXNlSXRlcmF0b3IoY29uZmlnKSB7XG4gIGNvbnN0IHtcbiAgICBpbml0aWFsLFxuICAgIGhhc05leHQsXG4gICAgc3RlcCxcbiAgICBtYXBcbiAgfSA9IGNvbmZpZztcbiAgbGV0IHN0YXRlID0gaW5pdGlhbDtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIGlmICghaGFzTmV4dChzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJ2YWwgPSB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogbWFwKHN0YXRlKVxuICAgICAgfTtcbiAgICAgIHN0YXRlID0gc3RlcChzdGF0ZSk7XG4gICAgICByZXR1cm4gcnZhbDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjb21wYXJlTnVtYmVyKGEsIGIpIHtcbiAgcmV0dXJuIE1hdGguc2lnbihhIC0gYik7XG59XG5cbi8qKlxuICogQSB0b3RhbCBvcmRlcmluZyBmb3IgYFBvaW50Q2FyZXQ8J25leHQnPmAsIGJhc2VkIG9uXG4gKiB0aGUgc2FtZSBvcmRlciB0aGF0IGEge0BsaW5rIENhcmV0UmFuZ2V9IHdvdWxkIGl0ZXJhdGVcbiAqIHRoZW0uXG4gKlxuICogRm9yIGEgZ2l2ZW4gb3JpZ2luIG5vZGU6XG4gKiAtIENoaWxkQ2FyZXQgY29tZXMgYmVmb3JlIFNpYmxpbmdDYXJldFxuICogLSBUZXh0UG9pbnRDYXJldCBjb21lcyBiZWZvcmUgU2libGluZ0NhcmV0XG4gKlxuICogQW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGVuIGEgYW5kIGIgZG8gbm90IGhhdmUgYW55XG4gKiBjb21tb24gYW5jZXN0b3IuXG4gKlxuICogVGhpcyBvcmRlcmluZyBpcyBhIHNvcnQgb2YgbWl4IG9mIHByZS1vcmRlciBhbmQgcG9zdC1vcmRlclxuICogYmVjYXVzZSBlYWNoIEVsZW1lbnROb2RlIHdpbGwgc2hvdyB1cCBhcyBhIENoaWxkQ2FyZXRcbiAqIG9uICdlbnRlcicgKHByZS1vcmRlcikgYW5kIGEgU2libGluZ0NhcmV0IG9uICdsZWF2ZScgKHBvc3Qtb3JkZXIpLlxuICpcbiAqIEBwYXJhbSBhXG4gKiBAcGFyYW0gYlxuICogQHJldHVybnMgLTEgaWYgYSBjb21lcyBiZWZvcmUgYiwgMCBpZiBhIGFuZCBiIGFyZSB0aGUgc2FtZSwgb3IgMSBpZiBhIGNvbWVzIGFmdGVyIGJcbiAqL1xuZnVuY3Rpb24gJGNvbXBhcmVQb2ludENhcmV0TmV4dChhLCBiKSB7XG4gIGNvbnN0IGNvbXBhcmUgPSAkZ2V0Q29tbW9uQW5jZXN0b3IoYS5vcmlnaW4sIGIub3JpZ2luKTtcbiAgaWYgKCEoY29tcGFyZSAhPT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRjb21wYXJlUG9pbnRDYXJldE5leHQ6IGEgKGtleSAke2Eub3JpZ2luLmdldEtleSgpfSkgYW5kIGIgKGtleSAke2Iub3JpZ2luLmdldEtleSgpfSkgZG8gbm90IGhhdmUgYSBjb21tb24gYW5jZXN0b3JgKTtcbiAgfVxuICBzd2l0Y2ggKGNvbXBhcmUudHlwZSkge1xuICAgIGNhc2UgJ3NhbWUnOlxuICAgICAge1xuICAgICAgICBjb25zdCBhSXNUZXh0ID0gYS50eXBlID09PSAndGV4dCc7XG4gICAgICAgIGNvbnN0IGJJc1RleHQgPSBiLnR5cGUgPT09ICd0ZXh0JztcbiAgICAgICAgcmV0dXJuIGFJc1RleHQgJiYgYklzVGV4dCA/IGNvbXBhcmVOdW1iZXIoYS5vZmZzZXQsIGIub2Zmc2V0KSA6IGEudHlwZSA9PT0gYi50eXBlID8gMCA6IGFJc1RleHQgPyAtMSA6IGJJc1RleHQgPyAxIDogYS50eXBlID09PSAnY2hpbGQnID8gLTEgOiAxO1xuICAgICAgfVxuICAgIGNhc2UgJ2FuY2VzdG9yJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGEudHlwZSA9PT0gJ2NoaWxkJyA/IC0xIDogMTtcbiAgICAgIH1cbiAgICBjYXNlICdkZXNjZW5kYW50JzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGIudHlwZSA9PT0gJ2NoaWxkJyA/IDEgOiAtMTtcbiAgICAgIH1cbiAgICBjYXNlICdicmFuY2gnOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJGdldENvbW1vbkFuY2VzdG9yUmVzdWx0QnJhbmNoT3JkZXIoY29tcGFyZSk7XG4gICAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIG9yZGVyaW5nIG9mIHNpYmxpbmdzIGluIGEgQ29tbW9uQW5jZXN0b3JSZXN1bHRCcmFuY2hcbiAqIEBwYXJhbSBicmFuY2ggUmV0dXJucyAtMSBpZiBhIHByZWNlZGVzIGIsIDEgb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uICRnZXRDb21tb25BbmNlc3RvclJlc3VsdEJyYW5jaE9yZGVyKGNvbXBhcmUpIHtcbiAgY29uc3Qge1xuICAgIGEsXG4gICAgYlxuICB9ID0gY29tcGFyZTtcbiAgY29uc3QgYUtleSA9IGEuX19rZXk7XG4gIGNvbnN0IGJLZXkgPSBiLl9fa2V5O1xuICBsZXQgbmEgPSBhO1xuICBsZXQgbmIgPSBiO1xuICBmb3IgKDsgbmEgJiYgbmI7IG5hID0gbmEuZ2V0TmV4dFNpYmxpbmcoKSwgbmIgPSBuYi5nZXROZXh0U2libGluZygpKSB7XG4gICAgaWYgKG5hLl9fa2V5ID09PSBiS2V5KSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSBlbHNlIGlmIChuYi5fX2tleSA9PT0gYUtleSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBuYSA9PT0gbnVsbCA/IDEgOiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgdHdvIGNvbXBhcmVkIG5vZGVzIGFyZSB0aGUgc2FtZVxuICovXG5cbi8qKlxuICogTm9kZSBhIHdhcyBhIGRlc2NlbmRhbnQgb2Ygbm9kZSBiLCBhbmQgbm90IHRoZSBzYW1lIG5vZGVcbiAqL1xuXG4vKipcbiAqIE5vZGUgYSBpcyBhbiBhbmNlc3RvciBvZiBub2RlIGIsIGFuZCBub3QgdGhlIHNhbWUgbm9kZVxuICovXG5cbi8qKlxuICogTm9kZSBhIGFuZCBub2RlIGIgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvciBidXQgYXJlIG9uIGRpZmZlcmVudCBicmFuY2hlcyxcbiAqIHRoZSBgYWAgYW5kIGBiYCBwcm9wZXJ0aWVzIG9mIHRoaXMgcmVzdWx0IGFyZSB0aGUgYW5jZXN0b3JzIG9mIGEgYW5kIGJcbiAqIHRoYXQgYXJlIGNoaWxkcmVuIG9mIHRoZSBjb21tb25BbmNlc3Rvci4gU2luY2UgdGhleSBhcmUgc2libGluZ3MsIHRoZWlyXG4gKiBwb3NpdGlvbnMgYXJlIGNvbXBhcmFibGUgdG8gZGV0ZXJtaW5lIG9yZGVyIGluIHRoZSBkb2N1bWVudC5cbiAqL1xuXG4vKipcbiAqIFRoZSByZXN1bHQgb2YgY29tcGFyaW5nIHR3byBub2RlcyB0aGF0IHNoYXJlIHNvbWUgY29tbW9uIGFuY2VzdG9yXG4gKi9cblxuZnVuY3Rpb24gJGlzU2FtZU5vZGUocmVmZXJlbmNlLCBvdGhlcikge1xuICByZXR1cm4gb3RoZXIuaXMocmVmZXJlbmNlKTtcbn1cbmZ1bmN0aW9uICRpbml0aWFsRWxlbWVudFR1cGxlKG5vZGUpIHtcbiAgcmV0dXJuICRpc0VsZW1lbnROb2RlKG5vZGUpID8gW25vZGUuZ2V0TGF0ZXN0KCksIG51bGxdIDogW25vZGUuZ2V0UGFyZW50KCksIG5vZGUuZ2V0TGF0ZXN0KCldO1xufVxuXG4vKipcbiAqIEZpbmQgYSBjb21tb24gYW5jZXN0b3Igb2YgYSBhbmQgYiBhbmQgcmV0dXJuIGEgZGV0YWlsZWQgcmVzdWx0IG9iamVjdCxcbiAqIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gY29tbW9uIGFuY2VzdG9yIGJldHdlZW4gdGhlIHR3byBub2Rlcy5cbiAqXG4gKiBUaGUgcmVzdWx0IG9iamVjdCB3aWxsIGhhdmUgYSBjb21tb25BbmNlc3RvciBwcm9wZXJ0eSwgYW5kIHRoZSBvdGhlclxuICogcHJvcGVydGllcyBjYW4gYmUgdXNlZCB0byBxdWlja2x5IGNvbXBhcmUgdGhlc2UgcG9zaXRpb25zIGluIHRoZSB0cmVlLlxuICpcbiAqIEBwYXJhbSBhIEEgTGV4aWNhbE5vZGVcbiAqIEBwYXJhbSBiIEEgTGV4aWNhbE5vZGVcbiAqIEByZXR1cm5zIEEgY29tcGFyaXNvbiByZXN1bHQgYmV0d2VlbiB0aGUgdHdvIG5vZGVzIG9yIG51bGwgaWYgdGhleSBoYXZlIG5vIGNvbW1vbiBhbmNlc3RvclxuICovXG5mdW5jdGlvbiAkZ2V0Q29tbW9uQW5jZXN0b3IoYSwgYikge1xuICBpZiAoYS5pcyhiKSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21tb25BbmNlc3RvcjogYSxcbiAgICAgIHR5cGU6ICdzYW1lJ1xuICAgIH07XG4gIH1cbiAgLy8gTWFwIG9mIHBhcmVudCAtPiBjaGlsZCBlbnRyaWVzIGJhc2VkIG9uIGEgYW5kIGl0cyBhbmNlc3RvcnNcbiAgY29uc3QgYU1hcCA9IG5ldyBNYXAoKTtcbiAgZm9yIChsZXQgW3BhcmVudCwgY2hpbGRdID0gJGluaXRpYWxFbGVtZW50VHVwbGUoYSk7IHBhcmVudDsgY2hpbGQgPSBwYXJlbnQsIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKSkge1xuICAgIGFNYXAuc2V0KHBhcmVudCwgY2hpbGQpO1xuICB9XG4gIGZvciAobGV0IFtwYXJlbnQsIGNoaWxkXSA9ICRpbml0aWFsRWxlbWVudFR1cGxlKGIpOyBwYXJlbnQ7IGNoaWxkID0gcGFyZW50LCBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50KCkpIHtcbiAgICBjb25zdCBhQ2hpbGQgPSBhTWFwLmdldChwYXJlbnQpO1xuICAgIGlmIChhQ2hpbGQgPT09IHVuZGVmaW5lZCkgOyBlbHNlIGlmIChhQ2hpbGQgPT09IG51bGwpIHtcbiAgICAgIC8vIGEgaXMgdGhlIGFuY2VzdG9yXG4gICAgICBpZiAoISRpc1NhbWVOb2RlKGEsIHBhcmVudCkpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkb3JpZ2luQ29tcGFyaXNvbjogYW5jZXN0b3IgbG9naWMgZXJyb3JgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1vbkFuY2VzdG9yOiBwYXJlbnQsXG4gICAgICAgIHR5cGU6ICdhbmNlc3RvcidcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgLy8gYiBpcyB0aGUgYW5jZXN0b3JcbiAgICAgIGlmICghJGlzU2FtZU5vZGUoYiwgcGFyZW50KSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRvcmlnaW5Db21wYXJpc29uOiBkZXNjZW5kYW50IGxvZ2ljIGVycm9yYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21tb25BbmNlc3RvcjogcGFyZW50LFxuICAgICAgICB0eXBlOiAnZGVzY2VuZGFudCdcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKCgkaXNFbGVtZW50Tm9kZShhQ2hpbGQpIHx8ICRpc1NhbWVOb2RlKGEsIGFDaGlsZCkpICYmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkgfHwgJGlzU2FtZU5vZGUoYiwgY2hpbGQpKSAmJiBwYXJlbnQuaXMoYUNoaWxkLmdldFBhcmVudCgpKSAmJiBwYXJlbnQuaXMoY2hpbGQuZ2V0UGFyZW50KCkpKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRvcmlnaW5Db21wYXJpc29uOiBicmFuY2ggbG9naWMgZXJyb3JgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGE6IGFDaGlsZCxcbiAgICAgICAgYjogY2hpbGQsXG4gICAgICAgIGNvbW1vbkFuY2VzdG9yOiBwYXJlbnQsXG4gICAgICAgIHR5cGU6ICdicmFuY2gnXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0gcG9pbnRcbiAqIEByZXR1cm5zIGEgUG9pbnRDYXJldCBmb3IgdGhlIHBvaW50XG4gKi9cbmZ1bmN0aW9uICRjYXJldEZyb21Qb2ludChwb2ludCwgZGlyZWN0aW9uKSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlLFxuICAgIGtleSxcbiAgICBvZmZzZXRcbiAgfSA9IHBvaW50O1xuICBjb25zdCBub2RlID0gJGdldE5vZGVCeUtleU9yVGhyb3cocG9pbnQua2V5KTtcbiAgaWYgKHR5cGUgPT09ICd0ZXh0Jykge1xuICAgIGlmICghJGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGNhcmV0RnJvbVBvaW50OiBOb2RlIHdpdGggdHlwZSAke25vZGUuZ2V0VHlwZSgpfSBhbmQga2V5ICR7a2V5fSB0aGF0IGRvZXMgbm90IGluaGVyaXQgZnJvbSBUZXh0Tm9kZSBlbmNvdW50ZXJlZCBmb3IgdGV4dCBwb2ludGApO1xuICAgIH1cbiAgICByZXR1cm4gJGdldFRleHRQb2ludENhcmV0KG5vZGUsIGRpcmVjdGlvbiwgb2Zmc2V0KTtcbiAgfVxuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkY2FyZXRGcm9tUG9pbnQ6IE5vZGUgd2l0aCB0eXBlICR7bm9kZS5nZXRUeXBlKCl9IGFuZCBrZXkgJHtrZXl9IHRoYXQgZG9lcyBub3QgaW5oZXJpdCBmcm9tIEVsZW1lbnROb2RlIGVuY291bnRlcmVkIGZvciBlbGVtZW50IHBvaW50YCk7XG4gIH1cbiAgcmV0dXJuICRnZXRDaGlsZENhcmV0QXRJbmRleChub2RlLCBwb2ludC5vZmZzZXQsIGRpcmVjdGlvbik7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSBnaXZlbiBwb2ludCBpbi1wbGFjZSBmcm9tIHRoZSBQb2ludENhcmV0XG4gKlxuICogQHBhcmFtIHBvaW50IHRoZSBwb2ludCB0byBzZXRcbiAqIEBwYXJhbSBjYXJldCB0aGUgY2FyZXQgdG8gc2V0IHRoZSBwb2ludCBmcm9tXG4gKi9cbmZ1bmN0aW9uICRzZXRQb2ludEZyb21DYXJldChwb2ludCwgY2FyZXQpIHtcbiAgY29uc3Qge1xuICAgIG9yaWdpbixcbiAgICBkaXJlY3Rpb25cbiAgfSA9IGNhcmV0O1xuICBjb25zdCBpc05leHQgPSBkaXJlY3Rpb24gPT09ICduZXh0JztcbiAgaWYgKCRpc1RleHRQb2ludENhcmV0KGNhcmV0KSkge1xuICAgIHBvaW50LnNldChvcmlnaW4uZ2V0S2V5KCksIGNhcmV0Lm9mZnNldCwgJ3RleHQnKTtcbiAgfSBlbHNlIGlmICgkaXNTaWJsaW5nQ2FyZXQoY2FyZXQpKSB7XG4gICAgaWYgKCRpc1RleHROb2RlKG9yaWdpbikpIHtcbiAgICAgIHBvaW50LnNldChvcmlnaW4uZ2V0S2V5KCksICRnZXRUZXh0Tm9kZU9mZnNldChvcmlnaW4sIGRpcmVjdGlvbiksICd0ZXh0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50LnNldChvcmlnaW4uZ2V0UGFyZW50T3JUaHJvdygpLmdldEtleSgpLCBvcmlnaW4uZ2V0SW5kZXhXaXRoaW5QYXJlbnQoKSArIChpc05leHQgPyAxIDogMCksICdlbGVtZW50Jyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghKCRpc0NoaWxkQ2FyZXQoY2FyZXQpICYmICRpc0VsZW1lbnROb2RlKG9yaWdpbikpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRzZXRQb2ludEZyb21DYXJldDogZXhoYXVzdGl2ZW5lc3MgY2hlY2tgKTtcbiAgICB9XG4gICAgcG9pbnQuc2V0KG9yaWdpbi5nZXRLZXkoKSwgaXNOZXh0ID8gMCA6IG9yaWdpbi5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldCBhIFJhbmdlU2VsZWN0aW9uIG9uIHRoZSBlZGl0b3IgZnJvbSB0aGUgZ2l2ZW4gQ2FyZXRSYW5nZVxuICpcbiAqIEByZXR1cm5zIFRoZSBuZXcgUmFuZ2VTZWxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gJHNldFNlbGVjdGlvbkZyb21DYXJldFJhbmdlKGNhcmV0UmFuZ2UpIHtcbiAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGlzUmFuZ2VTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbikgPyBjdXJyZW50U2VsZWN0aW9uIDogJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICR1cGRhdGVSYW5nZVNlbGVjdGlvbkZyb21DYXJldFJhbmdlKHNlbGVjdGlvbiwgY2FyZXRSYW5nZSk7XG4gICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIHBvaW50cyBvZiBhIFJhbmdlU2VsZWN0aW9uIGJhc2VkIG9uIHRoZSBnaXZlbiBQb2ludENhcmV0LlxuICovXG5mdW5jdGlvbiAkdXBkYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tQ2FyZXRSYW5nZShzZWxlY3Rpb24sIGNhcmV0UmFuZ2UpIHtcbiAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5hbmNob3IsIGNhcmV0UmFuZ2UuYW5jaG9yKTtcbiAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5mb2N1cywgY2FyZXRSYW5nZS5mb2N1cyk7XG59XG5cbi8qKlxuICogR2V0IGEgcGFpciBvZiBjYXJldHMgZm9yIGEgUmFuZ2VTZWxlY3Rpb24uXG4gKlxuICogSWYgdGhlIGZvY3VzIGlzIGJlZm9yZSB0aGUgYW5jaG9yLCB0aGVuIHRoZSBkaXJlY3Rpb24gd2lsbCBiZVxuICogJ3ByZXZpb3VzJywgb3RoZXJ3aXNlIHRoZSBkaXJlY3Rpb24gd2lsbCBiZSAnbmV4dCcuXG4gKi9cbmZ1bmN0aW9uICRjYXJldFJhbmdlRnJvbVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgY29uc3Qge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9ID0gc2VsZWN0aW9uO1xuICBjb25zdCBhbmNob3JDYXJldCA9ICRjYXJldEZyb21Qb2ludChhbmNob3IsICduZXh0Jyk7XG4gIGNvbnN0IGZvY3VzQ2FyZXQgPSAkY2FyZXRGcm9tUG9pbnQoZm9jdXMsICduZXh0Jyk7XG4gIGNvbnN0IGRpcmVjdGlvbiA9ICRjb21wYXJlUG9pbnRDYXJldE5leHQoYW5jaG9yQ2FyZXQsIGZvY3VzQ2FyZXQpIDw9IDAgPyAnbmV4dCcgOiAncHJldmlvdXMnO1xuICByZXR1cm4gJGdldENhcmV0UmFuZ2UoJGdldENhcmV0SW5EaXJlY3Rpb24oYW5jaG9yQ2FyZXQsIGRpcmVjdGlvbiksICRnZXRDYXJldEluRGlyZWN0aW9uKGZvY3VzQ2FyZXQsIGRpcmVjdGlvbikpO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgU2libGluZ0NhcmV0IHdlIGNhbiBhbHdheXMgY29tcHV0ZSBhIGNhcmV0IHRoYXQgcG9pbnRzIHRvIHRoZVxuICogb3JpZ2luIG9mIHRoYXQgY2FyZXQgaW4gdGhlIHNhbWUgZGlyZWN0aW9uLiBUaGUgYWRqYWNlbnQgY2FyZXQgb2YgdGhlXG4gKiByZXR1cm5lZCBjYXJldCB3aWxsIGJlIGVxdWl2YWxlbnQgdG8gdGhlIGdpdmVuIGNhcmV0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogc2libGluZ0NhcmV0LmlzKCRyZXdpbmRTaWJsaW5nQ2FyZXQoc2libGluZ0NhcmV0KS5nZXRBZGphY2VudENhcmV0KCkpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gY2FyZXQgVGhlIGNhcmV0IHRvIFwicmV3aW5kXCJcbiAqIEByZXR1cm5zIEEgbmV3IGNhcmV0IChDaGlsZENhcmV0IG9yIFNpYmxpbmdDYXJldCkgd2l0aCB0aGUgc2FtZSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gJHJld2luZFNpYmxpbmdDYXJldChjYXJldCkge1xuICBjb25zdCB7XG4gICAgZGlyZWN0aW9uLFxuICAgIG9yaWdpblxuICB9ID0gY2FyZXQ7XG4gIC8vIFJvdGF0ZSB0aGUgZGlyZWN0aW9uIGFyb3VuZCB0aGUgb3JpZ2luIGFuZCBnZXQgdGhlIGFkamFjZW50IG5vZGVcbiAgY29uc3QgcmV3aW5kT3JpZ2luID0gJGdldFNpYmxpbmdDYXJldChvcmlnaW4sIGZsaXBEaXJlY3Rpb24oZGlyZWN0aW9uKSkuZ2V0Tm9kZUF0Q2FyZXQoKTtcbiAgcmV0dXJuIHJld2luZE9yaWdpbiA/ICRnZXRTaWJsaW5nQ2FyZXQocmV3aW5kT3JpZ2luLCBkaXJlY3Rpb24pIDogJGdldENoaWxkQ2FyZXQob3JpZ2luLmdldFBhcmVudE9yVGhyb3coKSwgZGlyZWN0aW9uKTtcbn1cbmZ1bmN0aW9uICRnZXRBbmNob3JDYW5kaWRhdGVzKGFuY2hvciwgcm9vdE1vZGUgPSAncm9vdCcpIHtcbiAgLy8gVGhlc2UgY2FuZGlkYXRlcyB3aWxsIGJlIHRoZSBhbmNob3IgaXRzZWxmLCB0aGUgcG9pbnRlciB0byB0aGUgYW5jaG9yIChpZiBkaWZmZXJlbnQpLCBhbmQgdGhlbiBhbnkgcGFyZW50cyBvZiB0aGF0XG4gIGNvbnN0IGNhcmV0cyA9IFthbmNob3JdO1xuICBmb3IgKGxldCBwYXJlbnQgPSAkaXNDaGlsZENhcmV0KGFuY2hvcikgPyBhbmNob3IuZ2V0UGFyZW50Q2FyZXQocm9vdE1vZGUpIDogYW5jaG9yLmdldFNpYmxpbmdDYXJldCgpOyBwYXJlbnQgIT09IG51bGw7IHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnRDYXJldChyb290TW9kZSkpIHtcbiAgICBjYXJldHMucHVzaCgkcmV3aW5kU2libGluZ0NhcmV0KHBhcmVudCkpO1xuICB9XG4gIHJldHVybiBjYXJldHM7XG59XG5mdW5jdGlvbiAkaXNDYXJldEF0dGFjaGVkKGNhcmV0KSB7XG4gIHJldHVybiAhIWNhcmV0ICYmIGNhcmV0Lm9yaWdpbi5pc0F0dGFjaGVkKCk7XG59XG5cbi8qKlxuICogUmVtb3ZlIGFsbCB0ZXh0IGFuZCBub2RlcyBpbiB0aGUgZ2l2ZW4gcmFuZ2UuIElmIHRoZSByYW5nZSBzcGFucyBtdWx0aXBsZVxuICogYmxvY2tzIHRoZW4gdGhlIHJlbWFpbmluZyBjb250ZW50cyBvZiB0aGUgbGF0ZXIgYmxvY2sgd2lsbCBiZSBtZXJnZWQgd2l0aFxuICogdGhlIGVhcmxpZXIgYmxvY2suXG4gKlxuICogQHBhcmFtIGluaXRpYWxSYW5nZSBUaGUgcmFuZ2UgdG8gcmVtb3ZlIHRleHQgYW5kIG5vZGVzIGZyb21cbiAqIEBwYXJhbSBzbGljZU1vZGUgSWYgJ3ByZXNlcnZlRW1wdHlUZXh0UG9pbnRDYXJldCcgaXQgd2lsbCBsZWF2ZSBhbiBlbXB0eSBUZXh0UG9pbnRDYXJldCBhdCB0aGUgYW5jaG9yIGZvciBpbnNlcnQgaWYgb25lIGV4aXN0cywgb3RoZXJ3aXNlIGVtcHR5IHNsaWNlcyB3aWxsIGJlIHJlbW92ZWRcbiAqIEByZXR1cm5zIFRoZSBuZXcgY29sbGFwc2VkIHJhbmdlIChiaWFzZWQgdG93YXJkcyB0aGUgZWFybGllciBub2RlKVxuICovXG5mdW5jdGlvbiAkcmVtb3ZlVGV4dEZyb21DYXJldFJhbmdlKGluaXRpYWxSYW5nZSwgc2xpY2VNb2RlID0gJ3JlbW92ZUVtcHR5U2xpY2VzJykge1xuICBpZiAoaW5pdGlhbFJhbmdlLmlzQ29sbGFwc2VkKCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbFJhbmdlO1xuICB9XG4gIC8vIEFsd2F5cyBwcm9jZXNzIHJlbW92YWxzIGluIGRvY3VtZW50IG9yZGVyXG4gIGNvbnN0IHJvb3RNb2RlID0gJ3Jvb3QnO1xuICBjb25zdCBuZXh0RGlyZWN0aW9uID0gJ25leHQnO1xuICBsZXQgc2xpY2VTdGF0ZSA9IHNsaWNlTW9kZTtcbiAgY29uc3QgcmFuZ2UgPSAkZ2V0Q2FyZXRSYW5nZUluRGlyZWN0aW9uKGluaXRpYWxSYW5nZSwgbmV4dERpcmVjdGlvbik7XG4gIGNvbnN0IGFuY2hvckNhbmRpZGF0ZXMgPSAkZ2V0QW5jaG9yQ2FuZGlkYXRlcyhyYW5nZS5hbmNob3IsIHJvb3RNb2RlKTtcbiAgY29uc3QgZm9jdXNDYW5kaWRhdGVzID0gJGdldEFuY2hvckNhbmRpZGF0ZXMocmFuZ2UuZm9jdXMuZ2V0RmxpcHBlZCgpLCByb290TW9kZSk7XG5cbiAgLy8gTWFyayB0aGUgc3RhcnQgb2YgZWFjaCBFbGVtZW50Tm9kZVxuICBjb25zdCBzZWVuU3RhcnQgPSBuZXcgU2V0KCk7XG4gIC8vIFF1ZXVlIHJlbW92YWxzIHNpbmNlIHJlbW92aW5nIHRoZSBvbmx5IGNoaWxkIGNhbiBjYXNjYWRlIHRvIGhhdmluZ1xuICAvLyBhIHBhcmVudCByZW1vdmUgaXRzZWxmIHdoaWNoIHdpbGwgYWZmZWN0IGl0ZXJhdGlvblxuICBjb25zdCByZW1vdmVkTm9kZXMgPSBbXTtcbiAgZm9yIChjb25zdCBjYXJldCBvZiByYW5nZS5pdGVyTm9kZUNhcmV0cyhyb290TW9kZSkpIHtcbiAgICBpZiAoJGlzQ2hpbGRDYXJldChjYXJldCkpIHtcbiAgICAgIHNlZW5TdGFydC5hZGQoY2FyZXQub3JpZ2luLmdldEtleSgpKTtcbiAgICB9IGVsc2UgaWYgKCRpc1NpYmxpbmdDYXJldChjYXJldCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3JpZ2luXG4gICAgICB9ID0gY2FyZXQ7XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKG9yaWdpbikgfHwgc2VlblN0YXJ0LmhhcyhvcmlnaW4uZ2V0S2V5KCkpKSB7XG4gICAgICAgIHJlbW92ZWROb2Rlcy5wdXNoKG9yaWdpbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgbm9kZSBvZiByZW1vdmVkTm9kZXMpIHtcbiAgICBub2RlLnJlbW92ZSgpO1xuICB9XG5cbiAgLy8gU3BsaWNlIHRleHQgYXQgdGhlIGFuY2hvciBhbmQvb3Igb3JpZ2luLlxuICAvLyBJZiB0aGUgdGV4dCBpcyBlbnRpcmVseSBzZWxlY3RlZCB0aGVuIGl0IGlzIHJlbW92ZWQgKHVubGVzcyBpdCBpcyB0aGUgZmlyc3Qgc2xpY2UgYW5kIHNsaWNlTW9kZSBpcyBwcmVzZXJ2ZUVtcHR5VGV4dFNsaWNlQ2FyZXQpLlxuICAvLyBJZiBpdCdzIGEgdG9rZW4gd2l0aCBhIG5vbi1lbXB0eSBzZWxlY3Rpb24gdGhlbiBpdCBpcyByZW1vdmVkLlxuICAvLyBTZWdtZW50ZWQgbm9kZXMgd2lsbCBiZSBjb3BpZWQgdG8gYSBwbGFpbiB0ZXh0IG5vZGUgd2l0aCB0aGUgc2FtZSBmb3JtYXRcbiAgLy8gYW5kIHN0eWxlIGFuZCBzZXQgdG8gbm9ybWFsIG1vZGUuXG4gIGZvciAoY29uc3Qgc2xpY2Ugb2YgcmFuZ2UuZ2V0VGV4dFNsaWNlcygpKSB7XG4gICAgaWYgKCFzbGljZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG9yaWdpblxuICAgIH0gPSBzbGljZS5jYXJldDtcbiAgICBjb25zdCBjb250ZW50U2l6ZSA9IG9yaWdpbi5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICBjb25zdCBjYXJldEJlZm9yZSA9ICRyZXdpbmRTaWJsaW5nQ2FyZXQoJGdldFNpYmxpbmdDYXJldChvcmlnaW4sIG5leHREaXJlY3Rpb24pKTtcbiAgICBjb25zdCBtb2RlID0gb3JpZ2luLmdldE1vZGUoKTtcbiAgICBpZiAoTWF0aC5hYnMoc2xpY2UuZGlzdGFuY2UpID09PSBjb250ZW50U2l6ZSAmJiBzbGljZVN0YXRlID09PSAncmVtb3ZlRW1wdHlTbGljZXMnIHx8IG1vZGUgPT09ICd0b2tlbicgJiYgc2xpY2UuZGlzdGFuY2UgIT09IDApIHtcbiAgICAgIC8vIGFuY2hvckNhbmRpZGF0ZXNbMV0gc2hvdWxkIHN0aWxsIGJlIHZhbGlkLCBpdCBpcyBjYXJldEJlZm9yZVxuICAgICAgY2FyZXRCZWZvcmUucmVtb3ZlKCk7XG4gICAgfSBlbHNlIGlmIChzbGljZS5kaXN0YW5jZSAhPT0gMCkge1xuICAgICAgc2xpY2VTdGF0ZSA9ICdyZW1vdmVFbXB0eVNsaWNlcyc7XG4gICAgICBsZXQgbmV4dENhcmV0ID0gc2xpY2UucmVtb3ZlVGV4dFNsaWNlKCk7XG4gICAgICBjb25zdCBzbGljZU9yaWdpbiA9IHNsaWNlLmNhcmV0Lm9yaWdpbjtcbiAgICAgIGlmIChtb2RlID09PSAnc2VnbWVudGVkJykge1xuICAgICAgICBjb25zdCBzcmMgPSBuZXh0Q2FyZXQub3JpZ2luO1xuICAgICAgICBjb25zdCBwbGFpblRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHNyYy5nZXRUZXh0Q29udGVudCgpKS5zZXRTdHlsZShzcmMuZ2V0U3R5bGUoKSkuc2V0Rm9ybWF0KHNyYy5nZXRGb3JtYXQoKSk7XG4gICAgICAgIGNhcmV0QmVmb3JlLnJlcGxhY2VPckluc2VydChwbGFpblRleHROb2RlKTtcbiAgICAgICAgbmV4dENhcmV0ID0gJGdldFRleHRQb2ludENhcmV0KHBsYWluVGV4dE5vZGUsIG5leHREaXJlY3Rpb24sIG5leHRDYXJldC5vZmZzZXQpO1xuICAgICAgfVxuICAgICAgaWYgKHNsaWNlT3JpZ2luLmlzKGFuY2hvckNhbmRpZGF0ZXNbMF0ub3JpZ2luKSkge1xuICAgICAgICBhbmNob3JDYW5kaWRhdGVzWzBdID0gbmV4dENhcmV0O1xuICAgICAgfVxuICAgICAgaWYgKHNsaWNlT3JpZ2luLmlzKGZvY3VzQ2FuZGlkYXRlc1swXS5vcmlnaW4pKSB7XG4gICAgICAgIGZvY3VzQ2FuZGlkYXRlc1swXSA9IG5leHRDYXJldC5nZXRGbGlwcGVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgZGVlcGVzdCBhbmNob3IgYW5kIGZvY3VzIGNhbmRpZGF0ZXMgdGhhdCBhcmVcbiAgLy8gc3RpbGwgYXR0YWNoZWRcbiAgbGV0IGFuY2hvckNhbmRpZGF0ZTtcbiAgbGV0IGZvY3VzQ2FuZGlkYXRlO1xuICBmb3IgKGNvbnN0IGNhbmRpZGF0ZSBvZiBhbmNob3JDYW5kaWRhdGVzKSB7XG4gICAgaWYgKCRpc0NhcmV0QXR0YWNoZWQoY2FuZGlkYXRlKSkge1xuICAgICAgYW5jaG9yQ2FuZGlkYXRlID0gJG5vcm1hbGl6ZUNhcmV0KGNhbmRpZGF0ZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgZm9jdXNDYW5kaWRhdGVzKSB7XG4gICAgaWYgKCRpc0NhcmV0QXR0YWNoZWQoY2FuZGlkYXRlKSkge1xuICAgICAgZm9jdXNDYW5kaWRhdGUgPSAkbm9ybWFsaXplQ2FyZXQoY2FuZGlkYXRlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIE1lcmdlIGJsb2NrcyBpZiBuZWNlc3NhcnlcbiAgY29uc3QgbWVyZ2VUYXJnZXRzID0gJGdldEJsb2NrTWVyZ2VUYXJnZXRzKGFuY2hvckNhbmRpZGF0ZSwgZm9jdXNDYW5kaWRhdGUsIHNlZW5TdGFydCk7XG4gIGlmIChtZXJnZVRhcmdldHMpIHtcbiAgICBjb25zdCBbYW5jaG9yQmxvY2ssIGZvY3VzQmxvY2tdID0gbWVyZ2VUYXJnZXRzO1xuICAgIC8vIGFsd2F5cyBtZXJnZSBibG9ja3MgbGF0ZXIgaW4gdGhlIGRvY3VtZW50IHdpdGhcbiAgICAvLyBibG9ja3MgZWFybGllciBpbiB0aGUgZG9jdW1lbnRcbiAgICAkZ2V0Q2hpbGRDYXJldChhbmNob3JCbG9jaywgJ3ByZXZpb3VzJykuc3BsaWNlKDAsIGZvY3VzQmxvY2suZ2V0Q2hpbGRyZW4oKSk7XG4gICAgZm9jdXNCbG9jay5yZW1vdmUoKTtcbiAgfVxuXG4gIC8vIG5vdGUgdGhpcyBjYXJldCBjYW4gYmUgaW4gZWl0aGVyIGRpcmVjdGlvblxuICBjb25zdCBiZXN0Q2FuZGlkYXRlID0gW2FuY2hvckNhbmRpZGF0ZSwgZm9jdXNDYW5kaWRhdGUsIC4uLmFuY2hvckNhbmRpZGF0ZXMsIC4uLmZvY3VzQ2FuZGlkYXRlc10uZmluZCgkaXNDYXJldEF0dGFjaGVkKTtcbiAgaWYgKGJlc3RDYW5kaWRhdGUpIHtcbiAgICBjb25zdCBhbmNob3IgPSAkZ2V0Q2FyZXRJbkRpcmVjdGlvbigkbm9ybWFsaXplQ2FyZXQoYmVzdENhbmRpZGF0ZSksIGluaXRpYWxSYW5nZS5kaXJlY3Rpb24pO1xuICAgIHJldHVybiAkZ2V0Q29sbGFwc2VkQ2FyZXRSYW5nZShhbmNob3IpO1xuICB9XG4gIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRyZW1vdmVUZXh0RnJvbUNhcmV0UmFuZ2U6IHNlbGVjdGlvbiB3YXMgbG9zdCwgY291bGQgbm90IGZpbmQgYSBuZXcgYW5jaG9yIGdpdmVuIGNhbmRpZGF0ZXMgd2l0aCBrZXlzOiAke0pTT04uc3RyaW5naWZ5KGFuY2hvckNhbmRpZGF0ZXMubWFwKG4gPT4gbi5vcmlnaW4uX19rZXkpKX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgdHdvIGNhcmV0IG9yaWdpbnMgYXJlIGluIGRpc3RpbmN0IGJsb2NrcyB0aGF0XG4gKiBzaG91bGQgYmUgbWVyZ2VkLlxuICpcbiAqIFRoZSByZXR1cm5lZCBibG9jayBwYWlyIHdpbGwgYmUgdGhlIGNsb3Nlc3QgYmxvY2tzIHRvIHRoZWlyXG4gKiBjb21tb24gYW5jZXN0b3IsIGFuZCBtdXN0IGJlIG5vIHNoYWRvdyByb290cyBiZXR3ZWVuXG4gKiB0aGUgYmxvY2tzIGFuZCB0aGVpciByZXNwZWN0aXZlIGNhcmV0cy4gSWYgdHdvIGRpc3RpbmN0XG4gKiBibG9ja3MgbWF0Y2hpbmcgdGhpcyBjcml0ZXJpYSBhcmUgbm90IGZvdW5kLCB0aGlzIHdpbGwgcmV0dXJuXG4gKiBudWxsLlxuICovXG5mdW5jdGlvbiAkZ2V0QmxvY2tNZXJnZVRhcmdldHMoYW5jaG9yLCBmb2N1cywgc2VlblN0YXJ0KSB7XG4gIGlmICghYW5jaG9yIHx8ICFmb2N1cykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFuY2hvclBhcmVudCA9IGFuY2hvci5nZXRQYXJlbnRBdENhcmV0KCk7XG4gIGNvbnN0IGZvY3VzUGFyZW50ID0gZm9jdXMuZ2V0UGFyZW50QXRDYXJldCgpO1xuICBpZiAoIWFuY2hvclBhcmVudCB8fCAhZm9jdXNQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBUT0RPIHJlZmFjdG9yIHdoZW4gd2UgaGF2ZSBhIGJldHRlciBwcmltaXRpdmUgZm9yIGNvbW1vbiBhbmNlc3RvclxuICBjb25zdCBhbmNob3JFbGVtZW50cyA9IGFuY2hvclBhcmVudC5nZXRQYXJlbnRzKCkucmV2ZXJzZSgpO1xuICBhbmNob3JFbGVtZW50cy5wdXNoKGFuY2hvclBhcmVudCk7XG4gIGNvbnN0IGZvY3VzRWxlbWVudHMgPSBmb2N1c1BhcmVudC5nZXRQYXJlbnRzKCkucmV2ZXJzZSgpO1xuICBmb2N1c0VsZW1lbnRzLnB1c2goZm9jdXNQYXJlbnQpO1xuICBjb25zdCBtYXhMZW4gPSBNYXRoLm1pbihhbmNob3JFbGVtZW50cy5sZW5ndGgsIGZvY3VzRWxlbWVudHMubGVuZ3RoKTtcbiAgbGV0IGNvbW1vbkFuY2VzdG9yQ291bnQ7XG4gIGZvciAoY29tbW9uQW5jZXN0b3JDb3VudCA9IDA7IGNvbW1vbkFuY2VzdG9yQ291bnQgPCBtYXhMZW4gJiYgYW5jaG9yRWxlbWVudHNbY29tbW9uQW5jZXN0b3JDb3VudF0gPT09IGZvY3VzRWxlbWVudHNbY29tbW9uQW5jZXN0b3JDb3VudF07IGNvbW1vbkFuY2VzdG9yQ291bnQrKykge1xuICAgIC8vIGp1c3QgdHJhdmVyc2UgdGhlIGFuY2VzdG9yc1xuICB9XG4gIGNvbnN0ICRnZXRCbG9jayA9IChhcnIsIHByZWRpY2F0ZSkgPT4ge1xuICAgIGxldCBibG9jaztcbiAgICBmb3IgKGxldCBpID0gY29tbW9uQW5jZXN0b3JDb3VudDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYW5jZXN0b3IgPSBhcnJbaV07XG4gICAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChhbmNlc3RvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghYmxvY2sgJiYgcHJlZGljYXRlKGFuY2VzdG9yKSkge1xuICAgICAgICBibG9jayA9IGFuY2VzdG9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmxvY2s7XG4gIH07XG4gIGNvbnN0IGFuY2hvckJsb2NrID0gJGdldEJsb2NrKGFuY2hvckVsZW1lbnRzLCBJTlRFUk5BTF8kaXNCbG9jayk7XG4gIGNvbnN0IGZvY3VzQmxvY2sgPSBhbmNob3JCbG9jayAmJiAkZ2V0QmxvY2soZm9jdXNFbGVtZW50cywgbm9kZSA9PiBzZWVuU3RhcnQuaGFzKG5vZGUuZ2V0S2V5KCkpICYmIElOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpKTtcbiAgcmV0dXJuIGFuY2hvckJsb2NrICYmIGZvY3VzQmxvY2sgPyBbYW5jaG9yQmxvY2ssIGZvY3VzQmxvY2tdIDogbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRlZXBlc3QgQ2hpbGRDYXJldCB0aGF0IGhhcyBpbml0aWFsQ2FyZXQncyBvcmlnaW5cbiAqIGFzIGFuIGFuY2VzdG9yLCBvciBpbml0aWFsQ2FyZXQgaWYgdGhlIG9yaWdpbiBpcyBub3QgYW4gRWxlbWVudE5vZGVcbiAqIG9yIGlzIGFscmVhZHkgdGhlIGRlZXBlc3QgQ2hpbGRDYXJldC5cbiAqXG4gKiBUaGlzIGlzIGdlbmVyYWxseSB1c2VkIHdoZW4gbm9ybWFsaXppbmcgYmVjYXVzZSB0aGVyZSBpc1xuICogXCJ6ZXJvIGRpc3RhbmNlXCIgYmV0d2VlbiB0aGVzZSBsb2NhdGlvbnMuXG4gKlxuICogQHBhcmFtIGluaXRpYWxDYXJldFxuICogQHJldHVybnMgRWl0aGVyIGEgZGVlcGVyIENoaWxkQ2FyZXQgb3IgdGhlIGdpdmVuIGluaXRpYWxDYXJldFxuICovXG5mdW5jdGlvbiAkZ2V0RGVlcGVzdENoaWxkT3JTZWxmKGluaXRpYWxDYXJldCkge1xuICBsZXQgY2FyZXQgPSBpbml0aWFsQ2FyZXQ7XG4gIHdoaWxlICgkaXNDaGlsZENhcmV0KGNhcmV0KSkge1xuICAgIGNvbnN0IGFkamFjZW50ID0gJGdldEFkamFjZW50Q2hpbGRDYXJldChjYXJldCk7XG4gICAgaWYgKCEkaXNDaGlsZENhcmV0KGFkamFjZW50KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhcmV0ID0gYWRqYWNlbnQ7XG4gIH1cbiAgcmV0dXJuIGNhcmV0O1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIGNhcmV0IHRvIHRoZSBkZWVwZXN0IGVxdWl2YWxlbnQgUG9pbnRDYXJldC5cbiAqIFRoaXMgd2lsbCByZXR1cm4gYSBUZXh0UG9pbnRDYXJldCB3aXRoIHRoZSBvZmZzZXQgc2V0IGFjY29yZGluZ1xuICogdG8gdGhlIGRpcmVjdGlvbiBpZiBnaXZlbiBhIGNhcmV0IHdpdGggYSBUZXh0Tm9kZSBvcmlnaW5cbiAqIG9yIGEgY2FyZXQgd2l0aCBhbiBFbGVtZW50Tm9kZSBvcmlnaW4gd2l0aCB0aGUgZGVlcGVzdCBDaGlsZENhcmV0XG4gKiBoYXZpbmcgYW4gYWRqYWNlbnQgVGV4dE5vZGUuXG4gKlxuICogSWYgZ2l2ZW4gYSBUZXh0UG9pbnRDYXJldCwgaXQgd2lsbCBiZSByZXR1cm5lZCwgYXMgbm8gbm9ybWFsaXphdGlvblxuICogaXMgcmVxdWlyZWQgd2hlbiBhbiBvZmZzZXQgaXMgYWxyZWFkeSBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSBpbml0aWFsQ2FyZXRcbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIFBvaW50Q2FyZXRcbiAqL1xuZnVuY3Rpb24gJG5vcm1hbGl6ZUNhcmV0KGluaXRpYWxDYXJldCkge1xuICBjb25zdCBjYXJldCA9ICRnZXREZWVwZXN0Q2hpbGRPclNlbGYoaW5pdGlhbENhcmV0LmdldExhdGVzdCgpKTtcbiAgY29uc3Qge1xuICAgIGRpcmVjdGlvblxuICB9ID0gY2FyZXQ7XG4gIGlmICgkaXNUZXh0Tm9kZShjYXJldC5vcmlnaW4pKSB7XG4gICAgcmV0dXJuICRpc1RleHRQb2ludENhcmV0KGNhcmV0KSA/IGNhcmV0IDogJGdldFRleHRQb2ludENhcmV0KGNhcmV0Lm9yaWdpbiwgZGlyZWN0aW9uLCBkaXJlY3Rpb24pO1xuICB9XG4gIGNvbnN0IGFkaiA9IGNhcmV0LmdldEFkamFjZW50Q2FyZXQoKTtcbiAgcmV0dXJuICRpc1NpYmxpbmdDYXJldChhZGopICYmICRpc1RleHROb2RlKGFkai5vcmlnaW4pID8gJGdldFRleHRQb2ludENhcmV0KGFkai5vcmlnaW4sIGRpcmVjdGlvbiwgZmxpcERpcmVjdGlvbihkaXJlY3Rpb24pKSA6IGNhcmV0O1xufVxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgVGV4dFBvaW50Q2FyZXQncyBvZmZzZXQgY2FuIGJlIGV4dGVuZGVkIGZ1cnRoZXIgd2l0aG91dCBsZWF2aW5nIHRoZSBUZXh0Tm9kZS5cbiAqIFJldHVybnMgZmFsc2UgaWYgdGhlIGdpdmVuIGNhcmV0IGlzIG5vdCBhIFRleHRQb2ludENhcmV0IG9yIHRoZSBvZmZzZXQgY2FuIG5vdCBiZSBtb3ZlZCBmdXJ0aGVyIGluXG4gKiBkaXJlY3Rpb24uXG4gKlxuICogQHBhcmFtIGNhcmV0IEEgUG9pbnRDYXJldFxuICogQHJldHVybnMgdHJ1ZSBpZiBjYXJldCBpcyBhIFRleHRQb2ludENhcmV0IHdpdGggYW4gb2Zmc2V0IHRoYXQgaXMgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHRleHQgZ2l2ZW4gdGhlIGRpcmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gJGlzRXh0ZW5kYWJsZVRleHRQb2ludENhcmV0KGNhcmV0KSB7XG4gIHJldHVybiAkaXNUZXh0UG9pbnRDYXJldChjYXJldCkgJiYgY2FyZXQub2Zmc2V0ICE9PSAkZ2V0VGV4dE5vZGVPZmZzZXQoY2FyZXQub3JpZ2luLCBjYXJldC5kaXJlY3Rpb24pO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgY2FyZXQgaWYgaXQncyBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLCBvdGhlcndpc2UgcmV0dXJuXG4gKiBjYXJldC5nZXRGbGlwcGVkKCkuXG4gKlxuICogQHBhcmFtIGNhcmV0IEFueSBQb2ludENhcmV0XG4gKiBAcGFyYW0gZGlyZWN0aW9uIFRoZSBkZXNpcmVkIGRpcmVjdGlvblxuICogQHJldHVybnMgQSBQb2ludENhcmV0IGluIGRpcmVjdGlvblxuICovXG5mdW5jdGlvbiAkZ2V0Q2FyZXRJbkRpcmVjdGlvbihjYXJldCwgZGlyZWN0aW9uKSB7XG4gIHJldHVybiBjYXJldC5kaXJlY3Rpb24gPT09IGRpcmVjdGlvbiA/IGNhcmV0IDogY2FyZXQuZ2V0RmxpcHBlZCgpO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgcmFuZ2UgaWYgaXQncyBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLCBvdGhlcndpc2VcbiAqIGNvbnN0cnVjdCBhIG5ldyByYW5nZSB1c2luZyBhIGZsaXBwZWQgZm9jdXMgYXMgdGhlIGFuY2hvclxuICogYW5kIGEgZmxpcHBlZCBhbmNob3IgYXMgdGhlIGZvY3VzLiBUaGlzIHRyYW5zZm9ybWF0aW9uXG4gKiBwcmVzZXJ2ZXMgdGhlIHNlY3Rpb24gb2YgdGhlIGRvY3VtZW50IHRoYXQgaXQncyB3b3JraW5nXG4gKiB3aXRoLCBidXQgcmV2ZXJzZXMgdGhlIG9yZGVyIG9mIGl0ZXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0gcmFuZ2UgQW55IENhcmV0UmFuZ2VcbiAqIEBwYXJhbSBkaXJlY3Rpb24gVGhlIGRlc2lyZWQgZGlyZWN0aW9uXG4gKiBAcmV0dXJucyBBIENhcmV0UmFuZ2UgaW4gZGlyZWN0aW9uXG4gKi9cbmZ1bmN0aW9uICRnZXRDYXJldFJhbmdlSW5EaXJlY3Rpb24ocmFuZ2UsIGRpcmVjdGlvbikge1xuICBpZiAocmFuZ2UuZGlyZWN0aW9uID09PSBkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgcmV0dXJuICRnZXRDYXJldFJhbmdlKFxuICAvLyBmb2N1cyBhbmQgYW5jaG9yIGdldCBmbGlwcGVkIGhlcmVcbiAgJGdldENhcmV0SW5EaXJlY3Rpb24ocmFuZ2UuZm9jdXMsIGRpcmVjdGlvbiksICRnZXRDYXJldEluRGlyZWN0aW9uKHJhbmdlLmFuY2hvciwgZGlyZWN0aW9uKSk7XG59XG5cbi8qKlxuICogR2V0IGEgY2FyZXQgcG9pbnRpbmcgYXQgdGhlIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCwgb3IgdGhlIGxhc3RcbiAqIGNhcmV0IGluIHRoYXQgbm9kZSBpZiBvdXQgb2YgYm91bmRzLlxuICpcbiAqIEBwYXJhbSBwYXJlbnQgQW4gRWxlbWVudE5vZGVcbiAqIEBwYXJhbSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIG9yaWdpbiBmb3IgdGhlIGNhcmV0XG4gKiBAcmV0dXJucyBBIGNhcmV0IHBvaW50aW5nIHRvd2FyZHMgdGhlIG5vZGUgYXQgdGhhdCBpbmRleFxuICovXG5mdW5jdGlvbiAkZ2V0Q2hpbGRDYXJldEF0SW5kZXgocGFyZW50LCBpbmRleCwgZGlyZWN0aW9uKSB7XG4gIGxldCBjYXJldCA9ICRnZXRDaGlsZENhcmV0KHBhcmVudCwgJ25leHQnKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XG4gICAgY29uc3QgbmV4dENhcmV0ID0gY2FyZXQuZ2V0QWRqYWNlbnRDYXJldCgpO1xuICAgIGlmIChuZXh0Q2FyZXQgPT09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXJldCA9IG5leHRDYXJldDtcbiAgfVxuICByZXR1cm4gJGdldENhcmV0SW5EaXJlY3Rpb24oY2FyZXQsIGRpcmVjdGlvbik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgTm9kZSBzaWJsaW5nIHdoZW4gdGhpcyBleGlzdHMsIG90aGVyd2lzZSB0aGUgY2xvc2VzdCBwYXJlbnQgc2libGluZy4gRm9yIGV4YW1wbGVcbiAqIFIgLT4gUCAtPiBUMSwgVDJcbiAqICAgLT4gUDJcbiAqIHJldHVybnMgVDIgZm9yIG5vZGUgVDEsIFAyIGZvciBub2RlIFQyLCBhbmQgbnVsbCBmb3Igbm9kZSBQMi5cbiAqIEBwYXJhbSBzdGFydENhcmV0IFRoZSBpbml0aWFsIGNhcmV0XG4gKiBAcGFyYW0gcm9vdE1vZGUgVGhlIHJvb3QgbW9kZSwgJ3Jvb3QnICgnZGVmYXVsdCcpIG9yICdzaGFkb3dSb290J1xuICogQHJldHVybnMgQW4gYXJyYXkgKHR1cGxlKSBjb250YWluaW5nIHRoZSBmb3VuZCBjYXJldCBhbmQgdGhlIGRlcHRoIGRpZmZlcmVuY2UsIG9yIG51bGwsIGlmIHRoaXMgbm9kZSBkb2Vzbid0IGV4aXN0LlxuICovXG5mdW5jdGlvbiAkZ2V0QWRqYWNlbnRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nQ2FyZXQoc3RhcnRDYXJldCwgcm9vdE1vZGUgPSAncm9vdCcpIHtcbiAgbGV0IGRlcHRoRGlmZiA9IDA7XG4gIGxldCBjYXJldCA9IHN0YXJ0Q2FyZXQ7XG4gIGxldCBuZXh0Q2FyZXQgPSAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0KGNhcmV0KTtcbiAgd2hpbGUgKG5leHRDYXJldCA9PT0gbnVsbCkge1xuICAgIGRlcHRoRGlmZi0tO1xuICAgIG5leHRDYXJldCA9IGNhcmV0LmdldFBhcmVudENhcmV0KHJvb3RNb2RlKTtcbiAgICBpZiAoIW5leHRDYXJldCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNhcmV0ID0gbmV4dENhcmV0O1xuICAgIG5leHRDYXJldCA9ICRnZXRBZGphY2VudENoaWxkQ2FyZXQoY2FyZXQpO1xuICB9XG4gIHJldHVybiBuZXh0Q2FyZXQgJiYgW25leHRDYXJldCwgZGVwdGhEaWZmXTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFkamFjZW50IG5vZGVzIHRvIGluaXRpYWxDYXJldCBpbiB0aGUgZ2l2ZW4gZGlyZWN0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogZXhwZWN0KCRnZXRBZGphY2VudE5vZGVzKCRnZXRDaGlsZENhcmV0KHBhcmVudCwgJ25leHQnKSkpLnRvRXF1YWwocGFyZW50LmdldENoaWxkcmVuKCkpO1xuICogZXhwZWN0KCRnZXRBZGphY2VudE5vZGVzKCRnZXRDaGlsZENhcmV0KHBhcmVudCwgJ3ByZXZpb3VzJykpKS50b0VxdWFsKHBhcmVudC5nZXRDaGlsZHJlbigpLnJldmVyc2UoKSk7XG4gKiBleHBlY3QoJGdldEFkamFjZW50Tm9kZXMoJGdldFNpYmxpbmdDYXJldChub2RlLCAnbmV4dCcpKSkudG9FcXVhbChub2RlLmdldE5leHRTaWJsaW5ncygpKTtcbiAqIGV4cGVjdCgkZ2V0QWRqYWNlbnROb2RlcygkZ2V0U2libGluZ0NhcmV0KG5vZGUsICdwcmV2aW91cycpKSkudG9FcXVhbChub2RlLmdldFByZXZpb3VzU2libGluZ3MoKS5yZXZlcnNlKCkpO1xuICogYGBgXG4gKlxuICogQHBhcmFtIGluaXRpYWxDYXJldCBUaGUgY2FyZXQgdG8gc3RhcnQgYXQgKHRoZSBvcmlnaW4gd2lsbCBub3QgYmUgaW5jbHVkZWQpXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBzaWJsaW5ncy5cbiAqL1xuZnVuY3Rpb24gJGdldEFkamFjZW50Tm9kZXMoaW5pdGlhbENhcmV0KSB7XG4gIGNvbnN0IHNpYmxpbmdzID0gW107XG4gIGZvciAobGV0IGNhcmV0ID0gaW5pdGlhbENhcmV0LmdldEFkamFjZW50Q2FyZXQoKTsgY2FyZXQ7IGNhcmV0ID0gY2FyZXQuZ2V0QWRqYWNlbnRDYXJldCgpKSB7XG4gICAgc2libGluZ3MucHVzaChjYXJldC5vcmlnaW4pO1xuICB9XG4gIHJldHVybiBzaWJsaW5ncztcbn1cbmZ1bmN0aW9uICRzcGxpdFRleHRQb2ludENhcmV0KHRleHRQb2ludENhcmV0KSB7XG4gIGNvbnN0IHtcbiAgICBvcmlnaW4sXG4gICAgb2Zmc2V0LFxuICAgIGRpcmVjdGlvblxuICB9ID0gdGV4dFBvaW50Q2FyZXQ7XG4gIGlmIChvZmZzZXQgPT09ICRnZXRUZXh0Tm9kZU9mZnNldChvcmlnaW4sIGRpcmVjdGlvbikpIHtcbiAgICByZXR1cm4gdGV4dFBvaW50Q2FyZXQuZ2V0U2libGluZ0NhcmV0KCk7XG4gIH0gZWxzZSBpZiAob2Zmc2V0ID09PSAkZ2V0VGV4dE5vZGVPZmZzZXQob3JpZ2luLCBmbGlwRGlyZWN0aW9uKGRpcmVjdGlvbikpKSB7XG4gICAgcmV0dXJuICRyZXdpbmRTaWJsaW5nQ2FyZXQodGV4dFBvaW50Q2FyZXQuZ2V0U2libGluZ0NhcmV0KCkpO1xuICB9XG4gIGNvbnN0IFt0ZXh0Tm9kZV0gPSBvcmlnaW4uc3BsaXRUZXh0KG9mZnNldCk7XG4gIGlmICghJGlzVGV4dE5vZGUodGV4dE5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkc3BsaXRUZXh0UG9pbnRDYXJldDogc3BsaXRUZXh0IG11c3QgcmV0dXJuIGF0IGxlYXN0IG9uZSBUZXh0Tm9kZWApO1xuICB9XG4gIHJldHVybiAkZ2V0Q2FyZXRJbkRpcmVjdGlvbigkZ2V0U2libGluZ0NhcmV0KHRleHROb2RlLCAnbmV4dCcpLCBkaXJlY3Rpb24pO1xufVxuZnVuY3Rpb24gJGFsd2F5c1NwbGl0KF9ub2RlLCBfZWRnZSkge1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBTcGxpdCBhIG5vZGUgYXQgYSBQb2ludENhcmV0IGFuZCByZXR1cm4gYSBOb2RlQ2FyZXQgYXQgdGhhdCBwb2ludCwgb3IgbnVsbCBpZiB0aGVcbiAqIG5vZGUgY2FuJ3QgYmUgc3BsaXQuIFRoaXMgaXMgbm9uLXJlY3Vyc2l2ZSBhbmQgd2lsbCBvbmx5IHBlcmZvcm0gYXQgbW9zdCBvbmUgc3BsaXQuXG4gKlxuICogQHJldHVybnMgVGhlIE5vZGVDYXJldCBwb2ludGluZyB0byB0aGUgbG9jYXRpb24gb2YgdGhlIHNwbGl0IChvciBudWxsIGlmIGEgc3BsaXQgaXMgbm90IHBvc3NpYmxlKVxuICovXG5mdW5jdGlvbiAkc3BsaXRBdFBvaW50Q2FyZXROZXh0KHBvaW50Q2FyZXQsIHtcbiAgJGNvcHlFbGVtZW50Tm9kZSA9ICRjb3B5Tm9kZSxcbiAgJHNwbGl0VGV4dFBvaW50Q2FyZXROZXh0ID0gJHNwbGl0VGV4dFBvaW50Q2FyZXQsXG4gIHJvb3RNb2RlID0gJ3NoYWRvd1Jvb3QnLFxuICAkc2hvdWxkU3BsaXQgPSAkYWx3YXlzU3BsaXRcbn0gPSB7fSkge1xuICBpZiAoJGlzVGV4dFBvaW50Q2FyZXQocG9pbnRDYXJldCkpIHtcbiAgICByZXR1cm4gJHNwbGl0VGV4dFBvaW50Q2FyZXROZXh0KHBvaW50Q2FyZXQpO1xuICB9XG4gIGNvbnN0IHBhcmVudENhcmV0ID0gcG9pbnRDYXJldC5nZXRQYXJlbnRDYXJldChyb290TW9kZSk7XG4gIGlmIChwYXJlbnRDYXJldCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG9yaWdpblxuICAgIH0gPSBwYXJlbnRDYXJldDtcbiAgICBpZiAoJGlzQ2hpbGRDYXJldChwb2ludENhcmV0KSAmJiAhKG9yaWdpbi5jYW5CZUVtcHR5KCkgJiYgJHNob3VsZFNwbGl0KG9yaWdpbiwgJ2ZpcnN0JykpKSB7XG4gICAgICAvLyBObyBzcGxpdCBuZWNlc3NhcnksIHRoZSBsZWZ0IHNpZGUgd291bGQgYmUgZW1wdHlcbiAgICAgIHJldHVybiAkcmV3aW5kU2libGluZ0NhcmV0KHBhcmVudENhcmV0KTtcbiAgICB9XG4gICAgY29uc3Qgc2libGluZ3MgPSAkZ2V0QWRqYWNlbnROb2Rlcyhwb2ludENhcmV0KTtcbiAgICBpZiAoc2libGluZ3MubGVuZ3RoID4gMCB8fCBvcmlnaW4uY2FuQmVFbXB0eSgpICYmICRzaG91bGRTcGxpdChvcmlnaW4sICdsYXN0JykpIHtcbiAgICAgIC8vIFNwbGl0IGFuZCBpbnNlcnQgdGhlIHNpYmxpbmdzIGludG8gdGhlIG5ldyB0cmVlXG4gICAgICBwYXJlbnRDYXJldC5pbnNlcnQoJGNvcHlFbGVtZW50Tm9kZShvcmlnaW4pLnNwbGljZSgwLCAwLCBzaWJsaW5ncykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyZW50Q2FyZXQ7XG59XG5cbmV4cG9ydCB7ICRhZGRVcGRhdGVUYWcsICRhcHBseU5vZGVSZXBsYWNlbWVudCwgJGNhcmV0RnJvbVBvaW50LCAkY2FyZXRSYW5nZUZyb21TZWxlY3Rpb24sICRjbG9uZVdpdGhQcm9wZXJ0aWVzLCAkY29tcGFyZVBvaW50Q2FyZXROZXh0LCAkY29weU5vZGUsICRjcmVhdGUsICRjcmVhdGVMaW5lQnJlYWtOb2RlLCAkY3JlYXRlTm9kZVNlbGVjdGlvbiwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRjcmVhdGVQb2ludCwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uLCAkY3JlYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tRG9tLCAkY3JlYXRlVGFiTm9kZSwgJGNyZWF0ZVRleHROb2RlLCAkZXh0ZW5kQ2FyZXRUb1JhbmdlLCAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0LCAkZ2V0QWRqYWNlbnROb2RlLCAkZ2V0QWRqYWNlbnRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nQ2FyZXQsICRnZXRDYXJldEluRGlyZWN0aW9uLCAkZ2V0Q2FyZXRSYW5nZSwgJGdldENhcmV0UmFuZ2VJbkRpcmVjdGlvbiwgJGdldENoYXJhY3Rlck9mZnNldHMsICRnZXRDaGlsZENhcmV0LCAkZ2V0Q2hpbGRDYXJldEF0SW5kZXgsICRnZXRDaGlsZENhcmV0T3JTZWxmLCAkZ2V0Q29sbGFwc2VkQ2FyZXRSYW5nZSwgJGdldENvbW1vbkFuY2VzdG9yLCAkZ2V0Q29tbW9uQW5jZXN0b3JSZXN1bHRCcmFuY2hPcmRlciwgJGdldEVkaXRvciwgJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUsICRnZXROZWFyZXN0Um9vdE9yU2hhZG93Um9vdCwgJGdldE5vZGVCeUtleSwgJGdldE5vZGVCeUtleU9yVGhyb3csICRnZXRQcmV2aW91c1NlbGVjdGlvbiwgJGdldFJvb3QsICRnZXRTZWxlY3Rpb24sICRnZXRTaWJsaW5nQ2FyZXQsICRnZXRTdGF0ZSwgJGdldFN0YXRlQ2hhbmdlLCAkZ2V0VGV4dENvbnRlbnQsICRnZXRUZXh0Tm9kZU9mZnNldCwgJGdldFRleHRQb2ludENhcmV0LCAkZ2V0VGV4dFBvaW50Q2FyZXRTbGljZSwgJGdldFdyaXRhYmxlTm9kZVN0YXRlLCAkaGFzQW5jZXN0b3IsICRoYXNVcGRhdGVUYWcsICRpbnNlcnROb2RlcywgJGlzQmxvY2tFbGVtZW50Tm9kZSwgJGlzQ2hpbGRDYXJldCwgJGlzRGVjb3JhdG9yTm9kZSwgJGlzRWxlbWVudE5vZGUsICRpc0V4dGVuZGFibGVUZXh0UG9pbnRDYXJldCwgJGlzSW5saW5lRWxlbWVudE9yRGVjb3JhdG9yTm9kZSwgJGlzTGVhZk5vZGUsICRpc0xpbmVCcmVha05vZGUsICRpc05vZGVDYXJldCwgJGlzTm9kZVNlbGVjdGlvbiwgJGlzUGFyYWdyYXBoTm9kZSwgJGlzUmFuZ2VTZWxlY3Rpb24sICRpc1Jvb3ROb2RlLCAkaXNSb290T3JTaGFkb3dSb290LCAkaXNTaWJsaW5nQ2FyZXQsICRpc1RhYk5vZGUsICRpc1RleHROb2RlLCAkaXNUZXh0UG9pbnRDYXJldCwgJGlzVGV4dFBvaW50Q2FyZXRTbGljZSwgJGlzVG9rZW5PclNlZ21lbnRlZCwgJGlzVG9rZW5PclRhYiwgJG5vZGVzT2ZUeXBlLCAkbm9ybWFsaXplQ2FyZXQsICRub3JtYWxpemVTZWxlY3Rpb24gYXMgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCAkb25VcGRhdGUsICRwYXJzZVNlcmlhbGl6ZWROb2RlLCAkcmVtb3ZlVGV4dEZyb21DYXJldFJhbmdlLCAkcmV3aW5kU2libGluZ0NhcmV0LCAkc2VsZWN0QWxsLCAkc2V0Q29tcG9zaXRpb25LZXksICRzZXRQb2ludEZyb21DYXJldCwgJHNldFNlbGVjdGlvbiwgJHNldFNlbGVjdGlvbkZyb21DYXJldFJhbmdlLCAkc2V0U3RhdGUsICRzcGxpdEF0UG9pbnRDYXJldE5leHQsICRzcGxpdE5vZGUsICR1cGRhdGVSYW5nZVNlbGVjdGlvbkZyb21DYXJldFJhbmdlLCBBcnRpZmljaWFsTm9kZV9fRE9fTk9UX1VTRSwgQkxVUl9DT01NQU5ELCBDQU5fUkVET19DT01NQU5ELCBDQU5fVU5ET19DT01NQU5ELCBDTEVBUl9FRElUT1JfQ09NTUFORCwgQ0xFQVJfSElTVE9SWV9DT01NQU5ELCBDTElDS19DT01NQU5ELCBDT0xMQUJPUkFUSU9OX1RBRywgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCwgQ09NTUFORF9QUklPUklUWV9FRElUT1IsIENPTU1BTkRfUFJJT1JJVFlfSElHSCwgQ09NTUFORF9QUklPUklUWV9MT1csIENPTU1BTkRfUFJJT1JJVFlfTk9STUFMLCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIENPUFlfQ09NTUFORCwgQ1VUX0NPTU1BTkQsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgREVMRVRFX0xJTkVfQ09NTUFORCwgREVMRVRFX1dPUkRfQ09NTUFORCwgRFJBR0VORF9DT01NQU5ELCBEUkFHT1ZFUl9DT01NQU5ELCBEUkFHU1RBUlRfQ09NTUFORCwgRFJPUF9DT01NQU5ELCBEZWNvcmF0b3JOb2RlLCBFbGVtZW50Tm9kZSwgRk9DVVNfQ09NTUFORCwgRk9STUFUX0VMRU1FTlRfQ09NTUFORCwgRk9STUFUX1RFWFRfQ09NTUFORCwgSElTVE9SSUNfVEFHLCBISVNUT1JZX01FUkdFX1RBRywgSElTVE9SWV9QVVNIX1RBRywgSU5ERU5UX0NPTlRFTlRfQ09NTUFORCwgSU5TRVJUX0xJTkVfQlJFQUtfQ09NTUFORCwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCBJTlNFUlRfVEFCX0NPTU1BTkQsIElOVEVSTkFMXyRpc0Jsb2NrLCBJU19BTExfRk9STUFUVElORywgSVNfQk9MRCwgSVNfQ09ERSwgSVNfSElHSExJR0hULCBJU19JVEFMSUMsIElTX1NUUklLRVRIUk9VR0gsIElTX1NVQlNDUklQVCwgSVNfU1VQRVJTQ1JJUFQsIElTX1VOREVSTElORSwgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIEtFWV9BUlJPV19VUF9DT01NQU5ELCBLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIEtFWV9ERUxFVEVfQ09NTUFORCwgS0VZX0RPV05fQ09NTUFORCwgS0VZX0VOVEVSX0NPTU1BTkQsIEtFWV9FU0NBUEVfQ09NTUFORCwgS0VZX01PRElGSUVSX0NPTU1BTkQsIEtFWV9TUEFDRV9DT01NQU5ELCBLRVlfVEFCX0NPTU1BTkQsIExpbmVCcmVha05vZGUsIE1PVkVfVE9fRU5ELCBNT1ZFX1RPX1NUQVJULCBOT0RFX1NUQVRFX0tFWSwgT1VUREVOVF9DT05URU5UX0NPTU1BTkQsIFBBU1RFX0NPTU1BTkQsIFBBU1RFX1RBRywgUGFyYWdyYXBoTm9kZSwgUkVET19DT01NQU5ELCBSRU1PVkVfVEVYVF9DT01NQU5ELCBSb290Tm9kZSwgU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCBTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCBTRUxFQ1RfQUxMX0NPTU1BTkQsIFNLSVBfQ09MTEFCX1RBRywgU0tJUF9ET01fU0VMRUNUSU9OX1RBRywgU0tJUF9TQ1JPTExfSU5UT19WSUVXX1RBRywgVEVYVF9UWVBFX1RPX0ZPUk1BVCwgVGFiTm9kZSwgVGV4dE5vZGUsIFVORE9fQ09NTUFORCwgYnVpbGRJbXBvcnRNYXAsIGNyZWF0ZUNvbW1hbmQsIGNyZWF0ZUVkaXRvciwgY3JlYXRlU2hhcmVkTm9kZVN0YXRlLCBjcmVhdGVTdGF0ZSwgZmxpcERpcmVjdGlvbiwgZ2V0RE9NT3duZXJEb2N1bWVudCwgZ2V0RE9NU2VsZWN0aW9uLCBnZXRET01TZWxlY3Rpb25Gcm9tVGFyZ2V0LCBnZXRET01UZXh0Tm9kZSwgZ2V0RWRpdG9yUHJvcGVydHlGcm9tRE9NTm9kZSwgZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlLCBnZXRSZWdpc3RlcmVkTm9kZSwgZ2V0UmVnaXN0ZXJlZE5vZGVPclRocm93LCBpc0Jsb2NrRG9tTm9kZSwgaXNDdXJyZW50bHlSZWFkT25seU1vZGUsIGlzRE9NRG9jdW1lbnROb2RlLCBpc0RPTU5vZGUsIGlzRE9NVGV4dE5vZGUsIGlzRE9NVW5tYW5hZ2VkLCBpc0RvY3VtZW50RnJhZ21lbnQsIGlzRXhhY3RTaG9ydGN1dE1hdGNoLCBpc0hUTUxBbmNob3JFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc0lubGluZURvbU5vZGUsIGlzTGV4aWNhbEVkaXRvciwgaXNNb2RpZmllck1hdGNoLCBpc1NlbGVjdGlvbkNhcHR1cmVkSW5EZWNvcmF0b3JJbnB1dCwgaXNTZWxlY3Rpb25XaXRoaW5FZGl0b3IsIG1ha2VTdGVwd2lzZUl0ZXJhdG9yLCByZW1vdmVGcm9tUGFyZW50LCByZXNldFJhbmRvbUtleSwgc2V0RE9NVW5tYW5hZ2VkLCBzZXROb2RlSW5kZW50RnJvbURPTSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/lexical/Lexical.dev.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Fnick%2Fprojects%2Fportfolio%2Fsrc%2Fpages%2Findex.tsx&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);